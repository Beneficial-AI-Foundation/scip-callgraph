{
  "nodes": [
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub_new().",
      "display_name": "sub_new",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub_new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn sub_new(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n        requires\n            limbs_bounded(a),\n            limbs_bounded(b),\n            -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order(),\n        ensures\n            to_nat(&s.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int),\n    {\n        assume(false);  // TODO: complete the proof\n        let mut difference = Scalar52::ZERO;\n        let mask = (1u64 << 52) - 1;\n\n        // a - b\n        let mut borrow: u64 = 0;\n        for i in 0..5 {\n            assume(false);\n            borrow = a.limbs[i].wrapping_sub(b.limbs[i] + (borrow >> 63));\n            difference[i] = borrow & mask;\n        }\n\n        // conditionally add l if the difference is negative\n        difference.conditional_add_l(Choice::from((borrow >> 63) as u8));\n        difference\n    }",
      "start_line": 555,
      "end_line": 19,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_extended_coord_when_z_is_one().",
      "display_name": "lemma_extended_coord_when_z_is_one",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_extended_coord_when_z_is_one().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_extended_coord_when_z_is_one(x: nat, y: nat, t: nat)\n    requires\n        t == math_field_mul(x, y),\n    ensures\n        math_field_mul(t, 1) == math_field_mul(x, y),  // T·Z = X·Y when Z = 1\n{\n    // Goal: t * 1 ≡ x * y (mod p)\n    // Strategy: t * 1 = t (since t < p), and t = x*y from precondition\n    \n    pow255_gt_19();\n    \n    assert(math_field_mul(t, 1) == t) by {\n        // t < p (since t = (x*y) % p)\n        assert(t < p()) by { lemma_mod_bound((x * y) as int, p() as int); };\n        \n        // t % p = t\n    lemma_small_mod(t, p());\n    };\n    \n    // Conclusion: t * 1 = t = x * y\n}",
      "start_line": 147,
      "end_line": 48,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_limbs().",
      "display_name": "from_limbs",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_limbs().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    pub(crate) const fn from_limbs(limbs: [u64; 5]) -> (result: FieldElement51)\n        ensures\n            (result == FieldElement51 { limbs }),\n    {\n        FieldElement51 { limbs }\n    }",
      "start_line": 766,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_nonzero().",
      "display_name": "lemma_sqrt_m1_nonzero",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_nonzero().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/unused_sqrt_ratio_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/unused_sqrt_ratio_lemmas.rs",
      "file_name": "unused_sqrt_ratio_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_sqrt_m1_nonzero()\n    ensures spec_sqrt_m1() % p() != 0,\n{\n    // 0² = 0 ≠ -1, so sqrt(-1) ≠ 0\n    assume(spec_sqrt_m1() % p() != 0);\n}",
      "start_line": 57,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#expect().",
      "display_name": "expect",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#expect().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "curve25519-dalek/src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_y_squared_neq_one_implies_x_nonzero().",
      "display_name": "lemma_y_squared_neq_one_implies_x_nonzero",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_y_squared_neq_one_implies_x_nonzero().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_y_squared_neq_one_implies_x_nonzero(x: nat, y: nat)\n    requires\n        math_on_edwards_curve(x, y),\n        math_field_square(y) != 1,\n    ensures\n        x % p() != 0,\n{\n    // Proof by contradiction using contrapositive\n    // If x % p == 0, then by lemma_x_zero_implies_y_squared_one, y² == 1\n    // But we're given y² != 1, so x % p != 0\n    if x % p() == 0 {\n        lemma_x_zero_implies_y_squared_one(x, y);\n        assert(math_field_square(y) == 1);  // Contradiction with requires\n        assert(false);\n    }\n}",
      "start_line": 692,
      "end_line": 55,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_loop2_invariant().",
      "display_name": "lemma_sub_loop2_invariant",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_loop2_invariant().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub(crate) proof fn lemma_sub_loop2_invariant(\n    difference: Scalar52,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    mask: u64,\n    difference_after_loop1: Scalar52,\n    difference_loop2_start: Scalar52,\n    carry: u64,\n    old_carry: u64,\n    addend: u64,\n    borrow: u64,\n)\n    requires\n        0 <= i < 5,\n        mask == (1u64 << 52) - 1,\n        forall|j: int| 0 <= j < 5 ==> difference_loop2_start.limbs[j] < (1u64 << 52),\n        forall|j: int|\n            i <= j < 5 ==> difference_loop2_start.limbs[j] == difference_after_loop1.limbs[j],\n        forall|j: int|\n            (0 <= j < 5 && j != i) ==> difference_loop2_start.limbs[j] == difference.limbs[j],\n        mask == (1u64 << 52) - 1,\n        i == 0 ==> old_carry == 0,\n        i >= 1 ==> (old_carry >> 52) < 2,\n        (i >= 1 && borrow >> 63 == 0) ==> old_carry == difference_loop2_start.limbs[i - 1],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference_loop2_start,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int))\n            + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) == seq_u64_to_nat(\n            difference_loop2_start.limbs@.subrange(0, i as int),\n        ) + (old_carry >> 52) * pow2(52 * i as nat),\n        difference.limbs[i as int] == carry & mask,\n        difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(\n            0,\n            i as int,\n        ),\n        borrow >> 63 == 0 ==> addend == 0,\n        borrow >> 63 == 1 ==> addend == constants::L.limbs[i as int],\n        carry == (old_carry >> 52) + difference_loop2_start.limbs[i as int] + addend,\n    ensures\n        (i + 1 >= 1 && borrow >> 63 == 0) ==> carry == difference.limbs[i as int],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(\n            difference_after_loop1.limbs@.subrange(0, i + 1 as int),\n        ) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i + 1 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, i + 1 as int),\n        ) + (carry >> 52) * pow2(52 * (i + 1) as nat),\n{\n    if borrow >> 63 == 0 {\n        assert(old_carry >> 52 == 0) by (bit_vector)\n            requires\n                old_carry < 1u64 << 52,\n        ;\n        assert(addend == 0);\n        assert(carry == difference_loop2_start.limbs[i as int]);\n        assert(carry & mask == carry) by (bit_vector)\n            requires\n                carry < 1u64 << 52,\n                mask == (1u64 << 52) - 1,\n        ;\n        assert(difference_after_loop1.limbs[i as int] == difference.limbs[i as int]);\n        assert(forall|j: int|\n            0 <= j < 5 ==> difference_after_loop1.limbs[j] == difference.limbs[j]);\n        assert(difference_after_loop1.limbs == difference.limbs);\n    }\n    if borrow >> 63 == 1 {\n        // When underflow, addend = L.limbs[i]\n        assert(addend == constants::L.limbs[i as int]);\n        // carry = (old_carry >> 52) + difference_after_loop1.limbs[i] + L.limbs[i]\n        // difference.limbs[i] = carry & mask\n        calc! {\n            (==)\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(\n                constants::L.limbs@.subrange(0, i + 1),\n            ); {\n                lemma_seq_u64_to_nat_subrange_extend(difference_after_loop1.limbs@, i as int);\n                lemma_seq_u64_to_nat_subrange_extend(constants::L.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int))\n                + difference_after_loop1.limbs[i as int] as nat * pow2(52 * i as nat)\n                + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int))\n                + constants::L.limbs[i as int] as nat * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n                constants::L.limbs@.subrange(0, i as int),\n            ) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                // Use invariant\n            }\n            seq_u64_to_nat(difference_loop2_start.limbs@.subrange(0, i as int)) + (old_carry\n                >> 52) as nat * pow2(52 * i as nat) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(difference_loop2_start.limbs@.subrange(0, i as int)\n                    == difference.limbs@.subrange(0, i as int));\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat\n                * pow2(52 * i as nat) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((old_carry >> 52) as nat\n                + difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(carry == (old_carry >> 52) + difference_after_loop1.limbs[i as int]\n                    + constants::L.limbs[i as int]);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + carry as nat * pow2(\n                52 * i as nat,\n            ); {\n                assert(carry == (carry >> 52) * (1u64 << 52) + (carry & mask)) by (bit_vector)\n                    requires\n                        mask == (1u64 << 52) - 1,\n                ;\n                assert(carry == (carry >> 52) * pow2(52) + difference.limbs[i as int]) by {\n                    lemma2_to64_rest();\n                    assert(0x10000000000000 == 1u64 << 52) by (compute_only);\n                };\n                assert(difference.limbs[i as int] == carry & mask);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((carry >> 52) as nat * pow2(\n                52,\n            ) + difference.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n                52,\n            ) * pow2(52 * i as nat) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                    broadcast use lemma_pow2_adds;\n\n                };\n                assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat\n                    * pow2(52 * (i + 1) as nat)) by {\n                    assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                    lemma_mul_is_associative(\n                        (carry >> 52) as int,\n                        pow2(52) as int,\n                        pow2(52 * i as nat) as int,\n                    );\n                };\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n                52 * (i + 1) as nat,\n            ) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (carry >> 52) as nat * pow2(\n                52 * (i + 1) as nat,\n            );\n        }\n    }\n}",
      "start_line": 1252,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "display_name": "neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        /* <ORIGINAL CODE>\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        proof {\n            // Preconditions for mul_internal and sub\n            assume(limbs_bounded(&constants::R));\n            assume(limbs_bounded(&UnpackedScalar::ZERO));\n            // Also prove that to_nat(R) < group order\n        }\n\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n\n        proof {\n            assume(limbs_bounded(&self_mod_l));\n            // sub requires: -group_order() <= 0 - to_nat(&self_mod_l.limbs) < group_order()\n            // Hence we need to know that to_nat(self_mod_l) < group_order.\n            // From the spec of montgomery_reduce, that only happens if self_R can be written\n            // as the product of something bounded and something canonical. R is canonical,\n            // so we need self.unpack() to be bounded, which unpack's postcondition gives us\n            assume(-group_order() <= to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(\n                &self_mod_l.limbs,\n            ));\n            assume(to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(&self_mod_l.limbs) < group_order());\n        }\n\n        let result = UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack();\n        proof {\n            // TODO: Prove that -self + self == 0 (mod group_order)\n            assume((scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0);\n        }\n\n        /* </MODIFIED CODE> */\n        result\n    }",
      "start_line": 827,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn identity() -> (result: EdwardsPoint)\n        ensures\n            is_identity_edwards_point(result),\n            is_well_formed_edwards_point(result),\n    {\n        let result = EdwardsPoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T: FieldElement::ZERO,\n        };\n        proof {\n            // ZERO has limbs [0,0,0,0,0] → spec_field_element = 0\n            // ONE has limbs [1,0,0,0,0] → spec_field_element = 1\n            assume(spec_field_element(&FieldElement::ZERO) == 0);\n            assume(spec_field_element(&FieldElement::ONE) == 1);\n            // is_identity_edwards_point requires: z != 0, x == 0, y == z\n            // With X=ZERO, Y=ONE, Z=ONE: z=1≠0, x=0, y=z=1 ✓\n\n            // is_well_formed_edwards_point requires:\n            // - is_valid_edwards_point (identity is on curve)\n            // - edwards_point_limbs_bounded (all limbs < 2^54)\n            // - edwards_point_sum_bounded (Y + X doesn't overflow)\n            // ZERO/ONE have limbs [0/1, 0, 0, 0, 0] which are trivially bounded\n            assume(is_well_formed_edwards_point(result));\n        }\n        result\n    }",
      "start_line": 826,
      "end_line": 16,
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_is_zero_when_divisible().",
      "display_name": "lemma_mod_is_zero_when_divisible",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_is_zero_when_divisible().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "proof fn lemma_mod_is_zero_when_divisible(n: nat, d: nat)\n    requires\n        d > 0,\n        n % d == 0,\n    ensures\n        d <= n || n == 0,\n{\n    if n > 0 {\n        lemma_fundamental_div_mod(n as int, d as int);\n        // n == (n / d) * d + n % d == (n / d) * d + 0 == (n / d) * d\n        assert(n as int == (n as int / d as int) * d as int + n as int % d as int);\n        assert(n as int % d as int == 0);\n        assert(n as int == (n as int / d as int) * d as int);\n        // Since n > 0 and d > 0, we need n / d >= 1\n        if n as int / d as int <= 0 {\n            // If n / d <= 0, then n == (n/d) * d <= 0, contradicting n > 0\n            assert(n as int <= 0int);\n            assert(false);\n        }\n        // Now n / d >= 1, so (n/d) * d >= d, meaning n >= d\n\n        lemma_mul_inequality(1int, (n / d) as int, d as int);\n        lemma_mul_is_commutative((n / d) as int, d as int);\n    }\n}",
      "start_line": 191,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "display_name": "square2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    pub fn square2(&self) -> (r: FieldElement51)\n        requires\n    // The precondition in pow2k loop propagates to here\n\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54,\n        ensures\n            u64_5_as_nat(r.limbs) % p() == (2 * pow(u64_5_as_nat(self.limbs) as int, 2)) as nat\n                % p(),\n    {\n        let mut square = self.pow2k(1);\n\n        // Since square is mut, we save the initial value\n        let ghost old_limbs = square.limbs;\n\n        proof {\n            // forall |i: int| 0 <= i < 5 ==> 2 * old_limbs[i] <= u64::MAX\n            // pow2k now ensures 52-bit output\n            assert forall|i: int| 0 <= i < 5 implies 2 * square.limbs[i] <= u64::MAX by {\n                // if LHS < RHS, then 2 * LHS < 2 * RHS\n                lemma_mul_left_inequality(2, square.limbs[i] as int, (1u64 << 52) as int);\n                assert(2 * (1u64 << 52) <= u64::MAX) by (compute);\n            }\n\n            let ka = [\n                (2 * square.limbs[0]) as u64,\n                (2 * square.limbs[1]) as u64,\n                (2 * square.limbs[2]) as u64,\n                (2 * square.limbs[3]) as u64,\n                (2 * square.limbs[4]) as u64,\n            ];\n\n            // u64_5_as_nat(ka) == 2 * u64_5_as_nat(square.limbs)\n            // and\n            // u64_5_as_nat(ka) % p() == (2 * u64_5_as_nat(square.limbs)) % p()\n            lemma_u64_5_as_nat_k(square.limbs, 2);\n\n            // By pow2k ensures:\n            // u64_5_as_nat(square.limbs) % p() == pow(u64_5_as_nat(self.limbs) as int, pow2(1)) as nat % p()\n            // We just need pow2(1) == 2\n            lemma2_to64();\n\n            // p > 0\n            pow255_gt_19();\n\n            assert(u64_5_as_nat(ka) % p() == ((2nat % p()) * (u64_5_as_nat(square.limbs) % p()))\n                % p() == ((2nat % p()) * (pow(u64_5_as_nat(self.limbs) as int, 2) as nat % p()))\n                % p()) by {\n                lemma_mul_mod_noop(2, u64_5_as_nat(square.limbs) as int, p() as int);\n            }\n\n            // u64_5_as_nat(self.limbs)^2 >= 0\n            assert(pow(u64_5_as_nat(self.limbs) as int, 2) >= 0) by {\n                lemma_pow_nat_is_nat(u64_5_as_nat(self.limbs), 1);\n            }\n\n            assert(((2nat % p()) * (pow(u64_5_as_nat(self.limbs) as int, 2) as nat % p())) % p()\n                == (2 * (pow(u64_5_as_nat(self.limbs) as int, 2))) as nat % p()) by {\n                lemma_mul_mod_noop(2, pow(u64_5_as_nat(self.limbs) as int, 2) as int, p() as int);\n            }\n\n            assert(u64_5_as_nat(ka) % p() == (2 * (pow(u64_5_as_nat(self.limbs) as int, 2))) as nat\n                % p());\n        }\n\n        for i in 0..5\n            invariant\n        // pow2k now ensures 52-bit output\n\n                forall|j: int| 0 <= j < 5 ==> old_limbs[j] < (1u64 << 52),\n                forall|j: int| 0 <= j < i ==> #[trigger] square.limbs[j] == 2 * old_limbs[j],\n                forall|j: int| i <= j < 5 ==> #[trigger] square.limbs[j] == old_limbs[j],\n        {\n            proof {\n                assert(2 * (1u64 << 52) <= u64::MAX) by (compute);\n                lemma_mul_strict_inequality(square.limbs[i as int] as int, (1u64 << 52) as int, 2);\n            }\n            square.limbs[i] *= 2;\n        }\n\n        square\n    }",
      "start_line": 1320,
      "end_line": 19,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strict_inequality().",
      "display_name": "lemma_mul_strict_inequality",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strict_inequality().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_nine_limbs_two_bounded().",
      "display_name": "arb_nine_limbs_two_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_nine_limbs_two_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn arb_nine_limbs_two_bounded() -> impl Strategy<Value = [u128; 9]> {\n        (arb_bounded_scalar52(), arb_bounded_scalar52())\n            .prop_map(|(a, b)| Scalar52::mul_internal(&a, &b))\n    }",
      "start_line": 1431,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/first().",
      "display_name": "first",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/first().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Hash#hash().",
      "display_name": "hash",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Hash#hash().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn hash<H: Hasher>(&self, state: &mut H)\n        ensures/*  VERIFICATION NOTE:\n             (1) The actual postcondition is: *state == spec_state_after_hash_montgomery(initial_state, self)\n                 where initial_state is the value of *state before this call.\n                 However, Verus doesn't support old() on &mut types in ensures clauses.\n                 The property is for now established via assumes in the function body (lines 192-194).\n            (2) The spec is completed by lemma_hash_is_canonical: equal field elements hash identically. */\n\n            true,\n    {\n        // Do a round trip through a `FieldElement`. `as_bytes` is guaranteed to give a canonical\n        // 32-byte encoding\n        let canonical_bytes = FieldElement::from_bytes(&self.0).as_bytes();\n\n        /* GHOST: track the initial state for reasoning about state transformation */\n        let ghost initial_state = *state;\n\n        // Hash the canonical bytes\n        canonical_bytes.hash(state);\n\n        proof {\n            assume(canonical_bytes@ == spec_fe51_to_bytes(&spec_fe51_from_bytes(&self.0)));\n            assume(*state == spec_state_after_hash(initial_state, &canonical_bytes));\n            assume(*state == spec_state_after_hash_montgomery(initial_state, self));\n        }\n    }",
      "start_line": 177,
      "end_line": 12,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_5_bytes_reconstruct().",
      "display_name": "lemma_5_bytes_reconstruct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_5_bytes_reconstruct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_5_bytes_reconstruct(\n    value: nat,\n    byte0: u8,\n    byte1: u8,\n    byte2: u8,\n    byte3: u8,\n    byte4: u8,\n)\n    requires\n        byte0 as nat == (value / pow2(0)) % 256,\n        byte1 as nat == (value / pow2(8)) % 256,\n        byte2 as nat == (value / pow2(16)) % 256,\n        byte3 as nat == (value / pow2(24)) % 256,\n        byte4 as nat == (value / pow2(32)) % 256,\n        value < pow2(40),  // 5 bytes = 40 bits\n\n    ensures\n        byte0 as nat * pow2(0) + byte1 as nat * pow2(8) + byte2 as nat * pow2(16) + byte3 as nat\n            * pow2(24) + byte4 as nat * pow2(32) == value,\n{\n    lemma2_to64();\n\n    assert(byte0 == (value % pow2(1 * 8)) && byte1 == (value % pow2(1 * 8 + 8)) / pow2(1 * 8)\n        && byte2 == (value % pow2(2 * 8 + 8)) / pow2(2 * 8) && byte3 == (value % pow2(3 * 8 + 8))\n        / pow2(3 * 8) && byte4 == (value % pow2(4 * 8 + 8)) / pow2(4 * 8)) by {\n        lemma_pow2_div_mod(value, 0, 8);\n        lemma_pow2_div_mod(value, 8, 8);\n        lemma_pow2_div_mod(value, 16, 8);\n        lemma_pow2_div_mod(value, 24, 8);\n        lemma_pow2_div_mod(value, 32, 8);\n\n        assert(byte0 == value % pow2(1 * 8)) by {\n            lemma_div_basics_2((value % pow2(1 * 8)) as int);\n        }\n    }\n\n    assert forall|i: nat| 1 <= i <= 4 implies #[trigger] (value % pow2(i * 8)) + ((value % pow2(\n        i * 8 + 8,\n    )) / pow2(i * 8)) * pow2(i * 8) == value % pow2(i * 8 + 8) by {\n        let v = value % pow2(i * 8 + 8);\n        let d = pow2(i * 8);\n\n        assert(v == (v / d) * d + v % d) by {\n            lemma_fundamental_div_mod(v as int, d as int);\n        }\n\n        assert(pow2(i * 8 + 8) == pow2(i * 8) * pow2(8)) by {\n            lemma_pow2_adds(i * 8, 8);\n        }\n\n        assert(v % d == value % d) by {\n            lemma_pow2_pos(i * 8);\n            lemma_pow2_pos(8);\n            assert((value % (d * pow2(8))) % d == value % d) by {\n                lemma_mod_mod(value as int, d as int, pow2(8) as int);\n            }\n        }\n    }\n\n    assert(value % pow2(4 * 8 + 8) == value) by {\n        lemma_small_mod(value, pow2(40));\n    }\n}",
      "start_line": 413,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "display_name": "sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            spec_field_element(&output) == math_field_sub(\n                spec_field_element(self),\n                spec_field_element(_rhs),\n            ),\n            fe51_limbs_bounded(&output, 54),\n    {\n        assert(fe51_limbs_bounded(self, 54) && fe51_limbs_bounded(_rhs, 54));\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        let ghost c0 = 36028797018963664u64;  // 16 * (2^51 - 19)\n        let ghost c = 36028797018963952u64;  // 16 * (2^51 -  1)\n\n        proof {\n            lemma_field_add_16p_no_overflow(self, _rhs);\n        }\n\n        // Precompute the constants we add to each limb prior to subtraction.\n        let ghost const_vec = [c0, c, c, c, c];\n\n        // Translate both operands into the safe range before subtracting.\n        let ghost s0 = self.limbs[0] + c0;\n        let ghost s1 = self.limbs[1] + c;\n        let ghost s2 = self.limbs[2] + c;\n        let ghost s3 = self.limbs[3] + c;\n        let ghost s4 = self.limbs[4] + c;\n        // Capture the widened limbs so we can reason about them element-wise.\n        let ghost augmented: [u64; 5] = [s0 as u64, s1 as u64, s2 as u64, s3 as u64, s4 as u64];\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n\n        proof {\n            assert(1u64 << 52 < 1u64 << 54) by (compute);\n            assert(fe51_limbs_bounded(&output, 54));\n\n            // Glue the raw subtraction back to the spec subtraction using reduction lemmas.\n            lemma_u64_5_as_nat_add(self.limbs, const_vec);\n            lemma_u64_5_as_nat_sub(augmented, _rhs.limbs);\n\n            assert(u64_5_as_nat(augmented) == u64_5_as_nat(self.limbs) + u64_5_as_nat(const_vec));\n            lemma_sub_constants_equal_16p();\n            assert(u64_5_as_nat(augmented) == u64_5_as_nat(self.limbs) + (16 as nat) * p());\n\n            let x = u64_5_as_nat(self.limbs) as int;\n            let y = u64_5_as_nat(_rhs.limbs) as int;\n            let modulus = p() as int;\n\n            lemma_mod_sum_factor(16 as int, x - y, modulus);\n\n            let x_mod = x % modulus;\n            let y_mod = y % modulus;\n            assert(spec_field_element(self) == x_mod as nat);\n            assert(spec_field_element(_rhs) == y_mod as nat);\n            assert(spec_field_element(self) % p() == spec_field_element(self)) by {\n                lemma_mod_twice(x, modulus);\n            }\n            assert(spec_field_element(_rhs) % p() == spec_field_element(_rhs)) by {\n                lemma_mod_twice(y, modulus);\n            }\n\n            assert(math_field_sub(spec_field_element(self), spec_field_element(_rhs)) == (((x_mod\n                + modulus) - y_mod) % modulus) as nat) by {\n                assert(spec_field_element(self) % p() == spec_field_element(self));\n                assert(spec_field_element(_rhs) % p() == spec_field_element(_rhs));\n            }\n\n            lemma_mod_sum_factor(1 as int, x_mod - y_mod, modulus);\n            lemma_sub_mod_noop(x, y, modulus);\n            assert(((x_mod + modulus) - y_mod) % modulus == (x - y) % modulus);\n\n            assert(spec_field_element(&output) == math_field_sub(\n                spec_field_element(self),\n                spec_field_element(_rhs),\n            ));\n        }\n\n        output\n    }",
      "start_line": 339,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_quotient_of_squares().",
      "display_name": "lemma_quotient_of_squares",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_quotient_of_squares().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "file_name": "field_algebra_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_quotient_of_squares(a: nat, b: nat)\n    requires\n        b % p() != 0,\n    ensures\n        math_field_mul(math_field_square(a), math_field_inv(math_field_square(b))) \n            == math_field_square(math_field_mul(a, math_field_inv(b))),\n{\n    let p = p();\n    p_gt_2();\n    \n    let a2 = math_field_square(a);\n    let b2 = math_field_square(b);\n    let inv_b = math_field_inv(b);\n    let inv_b2 = math_field_inv(b2);\n    let a_div_b = math_field_mul(a, inv_b);\n    \n    // Step 1: inv(b²) = inv(b)²\n    lemma_inv_of_square(b);\n    assert(inv_b2 == math_field_square(inv_b));\n    \n    // Step 2: a² · inv(b)² = (a · inv(b))²\n    // This is the product-of-squares property: x²·y² = (x·y)²\n    lemma_product_of_squares_eq_square_of_product(a, inv_b);\n    \n    // a² · inv(b²) = a² · inv(b)² = (a · inv(b))²\n    assert(math_field_mul(a2, inv_b2) == math_field_mul(a2, math_field_square(inv_b)));\n    assert(math_field_mul(a2, math_field_square(inv_b)) == math_field_square(a_div_b));\n}",
      "start_line": 342,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "display_name": "square",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn square(&self) -> (result: Scalar52)\n        requires\n            limbs_bounded(self),\n        ensures\n            to_nat(&result.limbs) == (to_nat(&self.limbs) * to_nat(&self.limbs)) % group_order(),\n    {\n        proof {\n            lemma_rr_limbs_bounded();\n        }\n\n        // We only know limbs_bounded, so this triggers the weaker part of the\n        // montgomery_reduce spec\n        let aa = Scalar52::montgomery_reduce(&Scalar52::square_internal(self));\n\n        assert((to_nat(&aa.limbs) * montgomery_radix()) % group_order() == (to_nat(&self.limbs)\n            * to_nat(&self.limbs)) % group_order());\n\n        // square_internal ensures\n        // ensures\n        //     slice128_to_nat(&z) == to_nat(&a.limbs) * to_nat(&a.limbs),\n\n        // We know RR < group_order, so this triggers the stronger part of the\n        // montgomery_reduce spec, which is what this function's postcondition wants\n        let result = Scalar52::montgomery_reduce(&Scalar52::mul_internal(&aa, &constants::RR));\n\n        assert((to_nat(&result.limbs) * montgomery_radix()) % group_order() == (to_nat(&aa.limbs)\n            * to_nat(&constants::RR.limbs)) % group_order());\n\n        proof {\n            // 1. prove (to_nat(&constants::RR.limbs) % group_order() == (montgomery_radix()*montgomery_radix()) % group_order()\n            lemma_rr_equals_spec(constants::RR);\n\n            // 2. Reduce to (to_nat(&result.limbs)) % group_order() == (to_nat(&self.limbs) * to_nat(&self.limbs)) % group_order()\n            lemma_cancel_mul_montgomery_mod(\n                to_nat(&result.limbs),\n                to_nat(&aa.limbs),\n                to_nat(&constants::RR.limbs),\n            );\n\n            // 3. allows us to assert (to_nat(&result.limbs)) % group_order() == (to_nat(&result.limbs))\n            //  true from montgomery_reduce postcondition\n            lemma_small_mod((to_nat(&result.limbs)), group_order())\n        }\n\n        assert((to_nat(&result.limbs)) % group_order() == (to_nat(&aa.limbs) * montgomery_radix())\n            % group_order());\n\n        result\n    }",
      "start_line": 1069,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "display_name": "lemma_pow2k_loop_boundary",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_pow2k_loop_boundary(a: [u64; 5])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < 1u64 << 54,\n    ensures\n        pow2k_loop_boundary_spec(a),\n{\n    let bound = 1u64 << 54;\n    let bound19 = (19 * bound) as u64;\n    let bound_sq = 1u128 << 108;\n\n    // // u64 to u128 conversion forces extra assert\n    assert(bound * bound == bound_sq) by {\n        assert(((1u64 << 54) as u128) * ((1u64 << 54) as u128) == (1u128 << 108)) by (bit_vector);\n    }\n\n    assert(bound * bound19 == 19 * bound_sq) by {\n        assert((1u64 << 54) * ((19 * (1u64 << 54)) as u64) == 19 * (1u128 << 108)) by (bit_vector);\n    }\n\n    assert(19 * bound <= u64::MAX) by {\n        assert(19 * (1u64 << 54) <= u64::MAX) by (compute);\n    }\n\n    assert(term_product_bounds_spec(a, bound)) by {\n        // If a[i] < 2^54 then a[i] * a[j] < 2^108 and a[i] * (19 * a[j]) < 19 * 2^108\n        lemma_term_product_bounds(a, bound);\n    }\n\n    assert(ci_0_val_boundaries(a, bound)) by {\n        // ci_0 < 77 * (1u128 << 108)\n        lemma_c_i_0_bounded(a, bound);\n    }\n\n    // precond for lemma_c_i_shift_bounded\n    assert(77 * bound_sq + u64::MAX <= ((u64::MAX as u128) << 51)) by {\n        assert(77 * (1u128 << 108) + u64::MAX <= ((u64::MAX as u128) << 51)) by (compute);\n    }\n\n    // ci >> 51 <= u64::MAX\n    assert(ci_val_boundaries(a)) by {\n        lemma_c_i_shift_bounded(a, bound);\n    }\n\n    assert(ai_val_boundaries(a)) by {\n        // a0_0 < (1u64 << 51)\n        assert(a0_0_val(a) < 1u64 << 51 && a1_0_val(a) < 1u64 << 51 && a2_0_val(a) < 1u64 << 51\n            && a3_0_val(a) < 1u64 << 51 && a4_0_val(a) < 1u64 << 51) by {\n            lemma_masked_lt_51(c0_val(a) as u64);\n            lemma_masked_lt_51(c1_val(a) as u64);\n            lemma_masked_lt_51(c2_val(a) as u64);\n            lemma_masked_lt_51(c3_val(a) as u64);\n            lemma_masked_lt_51(c4_val(a) as u64);\n        }\n\n        // ceil(2^59.33)\n        let pow2_5933 = 724618875532318195u64;\n        assert(carry_val(a) < pow2_5933) by {\n            // From the comments in pow2k:\n            // c4 < 2^110.33  so that carry < 2^59.33\n            // and\n            // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n            assert(c4_val(a) >> 51 <= (5 * bound_sq + (u64::MAX as u128)) as u128 >> 51) by {\n                lemma_shr_51_le(c4_val(a), (5 * bound_sq + (u64::MAX as u128)) as u128);\n            }\n\n            assert((5 * (1u128 << 108) + (u64::MAX as u128)) as u128 >> 51 < (\n            724618875532318195u64 as u128)) by (compute);\n        }\n\n        assert(a0_0_val(a) + carry_val(a) * 19 < u64::MAX) by {\n            assert((1u64 << 51) + 19 * 724618875532318195u64 <= u64::MAX) by (compute);\n        }\n\n        assert(a1_0_val(a) + (a0_1_val(a) >> 51) < 1u64 << 52) by {\n            assert(a0_1_val(a) as u128 >> 51 <= u64::MAX as u128 >> 51) by {\n                lemma_shr_51_le(a0_1_val(a) as u128, u64::MAX as u128);\n            }\n            assert(((u64::MAX as u128) >> 51) < (1u64 << 13)) by (compute);\n            assert((1u64 << 51) + (1u64 << 13) < (1u64 << 52)) by (compute);\n        }\n\n        assert(a0_2_val(a) < 1u64 << 51) by {\n            lemma_masked_lt_51(a0_1_val(a) as u64);\n        }\n    }\n\n    // bv arithmetic, some bounds have 51, some have 52, all therefore have 54\n    assert((1u64 << 51) < (1u64 << 52)) by (bit_vector);\n    assert((1u64 << 52) < (1u64 << 54)) by (bit_vector);\n}",
      "start_line": 236,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 23
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_product_of_squares_eq_square_of_product().",
      "display_name": "lemma_product_of_squares_eq_square_of_product",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_product_of_squares_eq_square_of_product().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "file_name": "field_algebra_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_product_of_squares_eq_square_of_product(x: nat, y: nat)\n    ensures\n        math_field_mul(math_field_square(x), math_field_square(y)) == math_field_square(math_field_mul(x, y)),\n{\n    let p = p();\n    p_gt_2();\n    \n    let x2 = math_field_square(x);  // (x * x) % p\n    let y2 = math_field_square(y);  // (y * y) % p\n    let xy = math_field_mul(x, y);  // (x * y) % p\n    let xy2 = math_field_square(xy);  // ((x * y) % p * (x * y) % p) % p\n    \n    // Goal: (x² * y²) % p = ((xy) * (xy)) % p\n    assert(math_field_mul(x2, y2) == xy2) by {\n        // Step 1: Apply mod absorption for both sides\n        // LHS: ((x*x) % p * (y*y) % p) % p = ((x*x) * (y*y)) % p\n        lemma_mul_mod_noop((x * x) as int, (y * y) as int, p as int);\n        \n        // RHS: ((x*y) % p * (x*y) % p) % p = ((x*y) * (x*y)) % p\n        lemma_mul_mod_noop((x * y) as int, (x * y) as int, p as int);\n        \n        // Step 2: Show (x*x)*(y*y) = (x*y)*(x*y) as integers\n        // (x*y)*(x*y) = x*(y*x)*y = x*(x*y)*y = (x*x)*(y*y)\n        assert((x * y) * (x * y) == (x * x) * (y * y)) by {\n            // (x*y)*(x*y) = x * (y * (x * y))\n            lemma_mul_is_associative(x as int, y as int, (x * y) as int);\n            // y * (x * y) = (y * x) * y\n            lemma_mul_is_associative(y as int, x as int, y as int);\n            // y * x = x * y\n            lemma_mul_is_commutative(y as int, x as int);\n            // So x * (y * (x * y)) = x * ((x * y) * y) = x * (x * (y * y))\n            lemma_mul_is_associative(x as int, y as int, y as int);\n            // x * (x * (y * y)) = (x * x) * (y * y)\n            lemma_mul_is_associative(x as int, x as int, (y * y) as int);\n        };\n    };\n}",
      "start_line": 380,
      "end_line": 59,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_from_montgomery_limbs_conversion().",
      "display_name": "lemma_from_montgomery_limbs_conversion",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_from_montgomery_limbs_conversion().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_from_montgomery_limbs_conversion(limbs: &[u128; 9], self_limbs: &[u64; 5])\n    requires\n        forall|j: int| #![auto] 0 <= j < 5 ==> limbs[j] == self_limbs[j] as u128,\n        forall|j: int| 5 <= j < 9 ==> limbs[j] == 0,\n    ensures\n        slice128_to_nat(limbs) == to_nat(self_limbs),\n{\n    lemma_nine_limbs_equals_slice128_to_nat(limbs);\n    lemma_five_limbs_equals_to_nat(self_limbs);\n    assert(limbs[0] == self_limbs[0] as u128);\n    assert(nine_limbs_to_nat_aux(limbs) == (self_limbs[0] as nat) + (self_limbs[1] as nat) * pow2(\n        52,\n    ) + (self_limbs[2] as nat) * pow2(104) + (self_limbs[3] as nat) * pow2(156) + (\n    self_limbs[4] as nat) * pow2(208) + 0 * pow2(260) + 0 * pow2(312) + 0 * pow2(364) + 0 * pow2(\n        416,\n    ));\n}",
      "start_line": 351,
      "end_line": 52,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "display_name": "from",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "            fn from(P: &'a RistrettoPoint) -> BatchCompressState {\n                let XX = P.0.X.square();\n                let YY = P.0.Y.square();\n                let ZZ = P.0.Z.square();\n                let dTT = &P.0.T.square() * &constants::EDWARDS_D;\n\n                let e = &P.0.X * &(&P.0.Y + &P.0.Y); // = 2*X*Y\n                let f = &ZZ + &dTT;                  // = Z^2 + d*T^2\n                let g = &YY + &XX;                   // = Y^2 - a*X^2\n                let h = &ZZ - &dTT;                  // = Z^2 - d*T^2\n\n                let eg = &e * &g;\n                let fh = &f * &h;\n\n                BatchCompressState{ e, f, g, h, eg, fh }\n            }",
      "start_line": 574,
      "end_line": 20,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#decode_253_bits().",
      "display_name": "decode_253_bits",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#decode_253_bits().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    pub fn decode_253_bits(&self) -> (u8, [[u8; 32]; 8]) {\n        let mut ret = [[0u8; 32]; 8];\n        let (mask, fes) = self.elligator_ristretto_flavor_inverse();\n\n        for j in 0..8 {\n            ret[j] = fes[j].as_bytes();\n        }\n        (mask, ret)\n    }",
      "start_line": 86,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t3_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t3().",
      "display_name": "lemma_pow22501_prove_t3",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t3_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t3().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow22501_t3_lemma.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow22501_t3_lemma.rs",
      "file_name": "pow22501_t3_lemma.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_pow22501_prove_t3(\n    self_limbs: [u64; 5],\n    t0_limbs: [u64; 5],\n    t0_sq_limbs: [u64; 5],\n    t1_limbs: [u64; 5],\n    t2_limbs: [u64; 5],\n    t3_limbs: [u64; 5],\n)\n    requires\n// Limbs are bounded\n\n        forall|i: int| 0 <= i < 5 ==> self_limbs[i] < 1u64 << 54,\n        forall|i: int| 0 <= i < 5 ==> t0_limbs[i] < 1u64 << 54,\n        forall|i: int| 0 <= i < 5 ==> t0_sq_limbs[i] < 1u64 << 54,\n        forall|i: int| 0 <= i < 5 ==> t1_limbs[i] < 1u64 << 54,\n        forall|i: int| 0 <= i < 5 ==> t2_limbs[i] < 1u64 << 54,\n        forall|i: int| 0 <= i < 5 ==> t3_limbs[i] < 1u64 << 54,\n        // Computational relationships (from field operation postconditions)\n        u64_5_as_nat(t0_limbs) % p() == pow(u64_5_as_nat(self_limbs) as int, 2) as nat % p(),\n        u64_5_as_nat(t0_sq_limbs) % p() == pow(u64_5_as_nat(t0_limbs) as int, 2) as nat % p(),\n        u64_5_as_nat(t1_limbs) % p() == pow(u64_5_as_nat(t0_sq_limbs) as int, 2) as nat % p(),\n        u64_5_as_nat(t2_limbs) % p() == (u64_5_as_nat(self_limbs) * u64_5_as_nat(t1_limbs)) % p(),\n        u64_5_as_nat(t3_limbs) % p() == (u64_5_as_nat(t0_limbs) * u64_5_as_nat(t2_limbs)) % p(),\n    ensures\n        u64_5_as_nat(t3_limbs) % p() == pow(u64_5_as_nat(self_limbs) as int, 11) as nat % p(),\n        u64_5_as_nat(t0_sq_limbs) % p() == pow(u64_5_as_nat(self_limbs) as int, 4) as nat % p(),\n        u64_5_as_nat(t1_limbs) % p() == pow(u64_5_as_nat(self_limbs) as int, 8) as nat % p(),\n        u64_5_as_nat(t2_limbs) % p() == pow(u64_5_as_nat(self_limbs) as int, 9) as nat % p(),\n{\n    let base = u64_5_as_nat(self_limbs) as int;\n\n    assert(p() > 0) by {\n        pow255_gt_19();\n    }\n\n    // ========================================================================\n    // Prove t0_sq = x^4 using lemma_prove_pow2k_step\n    // ========================================================================\n    // t0_sq = (x^2)^2 = x^(2*2) = x^4\n    lemma_prove_pow2k_step(base, u64_5_as_nat(t0_limbs), u64_5_as_nat(t0_sq_limbs), 2, 2);\n    assert(u64_5_as_nat(t0_sq_limbs) % p() == pow(base, 4) as nat % p());\n\n    // ========================================================================\n    // Prove t1 = x^8 using lemma_prove_pow2k_step\n    // ========================================================================\n    // t1 = (x^4)^2 = x^(4*2) = x^8\n    lemma_prove_pow2k_step(base, u64_5_as_nat(t0_sq_limbs), u64_5_as_nat(t1_limbs), 4, 2);\n    assert(u64_5_as_nat(t1_limbs) % p() == pow(base, 8) as nat % p());\n\n    // ========================================================================\n    // Prove t2 = x^9 using lemma_prove_geometric_mul_step\n    // ========================================================================\n    // t2 = x^1 * x^8 = x^(1+8) = x^9\n    assert(pow(base, 1) == base) by {\n        lemma_pow1(base);\n    }\n    assert(pow(base, 1) as nat == u64_5_as_nat(self_limbs));\n    lemma_prove_geometric_mul_step(\n        base,\n        u64_5_as_nat(self_limbs),\n        u64_5_as_nat(t1_limbs),\n        u64_5_as_nat(t2_limbs),\n        1,\n        8,\n    );\n    assert(u64_5_as_nat(t2_limbs) % p() == pow(base, 9) as nat % p());\n\n    // ========================================================================\n    // Prove t3 = x^11 using lemma_prove_geometric_mul_step\n    // ========================================================================\n    // t3 = x^2 * x^9 = x^(2+9) = x^11\n    lemma_prove_geometric_mul_step(\n        base,\n        u64_5_as_nat(t0_limbs),\n        u64_5_as_nat(t2_limbs),\n        u64_5_as_nat(t3_limbs),\n        2,\n        9,\n    );\n    assert(u64_5_as_nat(t3_limbs) % p() == pow(base, 11) as nat % p());\n}",
      "start_line": 44,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#part1().",
      "display_name": "part1",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#part1().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn part1(sum: u128) -> (res: (u128, u64))\n        ensures\n            ({\n                let carry = res.0;\n                let p = res.1;\n                &&& p < (1u64 << 52)  // VER NOTE: p is bounded by 52 bits\n                // VER NOTE: The sum plus p*L[0] equals carry shifted left by 52 bits (i.e., divisible by 2^52)\n                &&& sum + (p as u128) * (constants::L.limbs[0] as u128) == carry << 52\n            }),",
      "start_line": 961,
      "end_line": 13,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "display_name": "collect",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "display_name": "sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn sub(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n        requires\n            limbs_bounded(a),\n            limbs_bounded(b),\n            // Without the following condition, all we can prove is something like:\n            // to_nat(&a.limbs) >= to_nat(&b.limbs) ==> to_nat(&s.limbs) == to_nat(&a.limbs) - to_nat(&b.limbs),\n            // to_nat(&a.limbs) < to_nat(&b.limbs) ==> to_nat(&s.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs) + pow2(260) + group_order()) % (pow2(260) as int),\n            // In the 2nd case, `sub` doesn't always do subtraction mod group_order\n            -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order(),\n        ensures\n            to_nat(&s.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int),\n            limbs_bounded(&s),\n            // VERIFICATION NOTE: Result is in canonical form\n            to_nat(&s.limbs) < group_order(),\n    {\n        let mut difference = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        proof {\n            assert(1u64 << 52 > 0) by (bit_vector);\n        }\n        let mask = (1u64 << 52) - 1;\n\n        // a - b\n        let mut borrow: u64 = 0;\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 0 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 0 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 0 as int)));\n        assert((borrow >> 63) == 0) by (bit_vector)\n            requires\n                borrow == 0,\n        ;\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 0 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 0 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 0 as int)) - (borrow >> 63) * pow2(\n            (52 * (0) as nat),\n        ));\n        for i in 0..5\n            invariant\n                limbs_bounded(b),\n                limbs_bounded(a),\n                forall|j: int| 0 <= j < i ==> difference.limbs[j] < (1u64 << 52),\n                mask == (1u64 << 52) - 1,\n                seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(\n                    b.limbs@.subrange(0, i as int),\n                ) == seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) - (borrow >> 63)\n                    * pow2((52 * (i) as nat)),\n        {\n            proof {\n                assert((borrow >> 63) < 2) by (bit_vector);\n            }\n            let ghost old_borrow = borrow;\n            borrow = a.limbs[i].wrapping_sub(b.limbs[i] + (borrow >> 63));\n            let ghost difference_loop1_start = difference;\n            difference.limbs[i] = borrow & mask;\n            assert(difference_loop1_start.limbs@.subrange(0, i as int)\n                == difference.limbs@.subrange(0, i as int));\n            assert(seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(\n                b.limbs@.subrange(0, i as int),\n            ) == seq_u64_to_nat(difference_loop1_start.limbs@.subrange(0, i as int)) - (old_borrow\n                >> 63) * pow2((52 * (i) as nat)));\n            proof {\n                lemma_sub_loop1_invariant(\n                    difference,\n                    borrow,\n                    i,\n                    a,\n                    b,\n                    old_borrow,\n                    mask,\n                    difference_loop1_start,\n                );\n            }\n            proof {\n                lemma_borrow_and_mask_bounded(borrow, mask);\n            }\n        }\n\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) - (borrow >> 63) * pow2(\n            (52 * (5) as nat),\n        ));\n        // conditionally add l if the difference is negative\n        assert(borrow >> 63 == 1 || borrow >> 63 == 0) by (bit_vector);\n        let mut carry: u64 = 0;\n        let ghost difference_after_loop1 = difference;\n        assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 0 as int)) == 0);\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 0 as int)) == 0);\n        assert(seq_u64_to_nat(difference.limbs@.subrange(0, 0 as int)) == 0);\n        assert(carry >> 52 == 0) by (bit_vector)\n            requires\n                carry == 0,\n        ;\n        for i in 0..5\n            invariant\n                forall|j: int| 0 <= j < 5 ==> difference.limbs[j] < (1u64 << 52),  // from first loop\n                forall|j: int|\n                    i <= j < 5 ==> difference.limbs[j] == difference_after_loop1.limbs[j],\n                mask == (1u64 << 52) - 1,\n                i == 0 ==> carry == 0,\n                i >= 1 ==> (carry >> 52) < 2,\n                (i >= 1 && borrow >> 63 == 0) ==> carry == difference.limbs[i - 1],\n                borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n                borrow >> 63 == 1 ==> seq_u64_to_nat(\n                    difference_after_loop1.limbs@.subrange(0, i as int),\n                ) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) == seq_u64_to_nat(\n                    difference.limbs@.subrange(0, i as int),\n                ) + (carry >> 52) * pow2(52 * i as nat),\n        {\n            let ghost old_carry = carry;\n            let underflow = Choice::from((borrow >> 63) as u8);\n            let addend = select(&0, &constants::L.limbs[i], underflow);\n            if borrow >> 63 == 0 {\n                assert(addend == 0);\n            }\n            if borrow >> 63 == 1 {\n                assert(addend == constants::L.limbs[i as int]);\n            }\n            proof {\n                lemma_scalar_subtract_no_overflow(\n                    carry,\n                    difference.limbs[i as int],\n                    addend,\n                    i as u32,\n                    &constants::L,\n                );\n            }\n            carry = (carry >> 52) + difference.limbs[i] + addend;\n            let ghost difference_loop2_start = difference;\n            difference.limbs[i] = carry & mask;\n            proof {\n                lemma_carry_bounded_after_mask(carry, mask);\n                assert(difference_loop2_start.limbs@.subrange(0, i as int)\n                    == difference.limbs@.subrange(0, i as int));\n                lemma_sub_loop2_invariant(\n                    difference,\n                    i,\n                    a,\n                    b,\n                    mask,\n                    difference_after_loop1,\n                    difference_loop2_start,\n                    carry,\n                    old_carry,\n                    addend,\n                    borrow,\n                );\n            }\n        }\n        proof {\n            lemma_sub_correct_after_loops(difference, carry, a, b, difference_after_loop1, borrow);\n        }\n        difference\n    }",
      "start_line": 655,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 13
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Add#add().",
      "display_name": "add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Add#add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn add(self, other: &'b AffineNielsPoint) -> (result: CompletedPoint)\n        ensures\n    // The result represents the Edwards addition of the affine forms of self and other\n\n            is_valid_completed_point(result),\n            completed_point_as_affine_edwards(result) == spec_edwards_add_affine_niels(\n                *self,\n                *other,\n            ),\n    {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        proof {\n            assume(sum_of_limbs_bounded(&Y_plus_X, &Y_minus_X, u64::MAX));\n            assume(fe51_limbs_bounded(&Y_plus_X, 54) && fe51_limbs_bounded(&Y_minus_X, 54));\n        }\n        let PP = &Y_plus_X * &other.y_plus_x;\n        let MM = &Y_minus_X * &other.y_minus_x;\n        let Txy2d = &self.T * &other.xy2d;\n        let Z2 = &self.Z + &self.Z;\n        proof {\n            assume(sum_of_limbs_bounded(&Z2, &Txy2d, u64::MAX));\n            assume(sum_of_limbs_bounded(&PP, &MM, u64::MAX));\n            assume(fe51_limbs_bounded(&PP, 54) && fe51_limbs_bounded(&MM, 54));\n            assume(fe51_limbs_bounded(&Z2, 54) && fe51_limbs_bounded(&Txy2d, 54));\n        }\n        let result = CompletedPoint {\n            X: &PP - &MM,\n            Y: &PP + &MM,\n            Z: &Z2 + &Txy2d,\n            T: &Z2 - &Txy2d,\n        };\n        proof {\n            // postconditions\n            assume(is_valid_completed_point(result));\n            assume(completed_point_as_affine_edwards(result) == spec_edwards_add_affine_niels(\n                *self,\n                *other,\n            ));\n        }\n        result\n    }",
      "start_line": 769,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "display_name": "from_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    pub const fn from_bytes(bytes: &[u8; 32]) -> (r: FieldElement51)\n        ensures\n    // last bit is ignored\n\n            u64_5_as_nat(r.limbs) == u8_32_as_nat(bytes) % pow2(255),\n            // each limb is masked with (2^51 - 1), so bounded by 51 bits\n            fe51_limbs_bounded(&r, 51),\n    {\n        /* MANUALLY moved outside */\n        /*\n        const fn load8_at(input: &[u8], i: usize) -> u64 {\n                (input[i] as u64)\n            | ((input[i + 1] as u64) << 8)\n            | ((input[i + 2] as u64) << 16)\n            | ((input[i + 3] as u64) << 24)\n            | ((input[i + 4] as u64) << 32)\n            | ((input[i + 5] as u64) << 40)\n            | ((input[i + 6] as u64) << 48)\n            | ((input[i + 7] as u64) << 56)\n        }\n        */\n        proof {\n            assert(mask51 == (1u64 << 51) - 1) by (compute);\n\n            let l0 = spec_load8_at(bytes, 0);\n            let l1 = spec_load8_at(bytes, 6);\n            let l2 = spec_load8_at(bytes, 12);\n            let l3 = spec_load8_at(bytes, 19);\n            let l4 = spec_load8_at(bytes, 24);\n\n            assert(l0 <= u64::MAX && l1 <= u64::MAX && l2 <= u64::MAX && l3 <= u64::MAX && l4\n                <= u64::MAX) by {\n                lemma_spec_load8_at_fits_u64(bytes, 0);\n                lemma_spec_load8_at_fits_u64(bytes, 6);\n                lemma_spec_load8_at_fits_u64(bytes, 12);\n                lemma_spec_load8_at_fits_u64(bytes, 19);\n                lemma_spec_load8_at_fits_u64(bytes, 24);\n            }\n\n            let rr = [\n                l0 as u64 & mask51,\n                (l1 as u64 >> 3) & mask51,\n                (l2 as u64 >> 6) & mask51,\n                (l3 as u64 >> 1) & mask51,\n                (l4 as u64 >> 12) & mask51,\n            ];\n\n            assert(u64_5_as_nat(rr) == u8_32_as_nat(bytes) % pow2(255)) by {\n                lemma_from_bytes_as_nat(bytes);\n                lemma_as_nat_32_mod_255(bytes);\n            }\n\n            // Prove limbs are bounded: x & mask51 < 2^51\n            assert(forall|x: u64| #[trigger] (x & mask51) < (1u64 << 51)) by (bit_vector);\n        }\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51 {\n            limbs:\n            // load bits [  0, 64), no shift\n            [\n                load8_at(bytes, 0)\n                    & low_51_bit_mask\n                // load bits [ 48,112), shift to [ 51,112)\n                ,\n                (load8_at(bytes, 6) >> 3)\n                    & low_51_bit_mask\n                // load bits [ 96,160), shift to [102,160)\n                ,\n                (load8_at(bytes, 12) >> 6)\n                    & low_51_bit_mask\n                // load bits [152,216), shift to [153,216)\n                ,\n                (load8_at(bytes, 19) >> 1)\n                    & low_51_bit_mask\n                // load bits [192,256), shift to [204,112)\n                ,\n                (load8_at(bytes, 24) >> 12) & low_51_bit_mask,\n            ],\n        }\n    }",
      "start_line": 918,
      "end_line": 28,
      "is_libsignal": false,
      "caller_count": 12,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "display_name": "lemma_pow22501_prove_t19",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow22501_t19_lemma.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow22501_t19_lemma.rs",
      "file_name": "pow22501_t19_lemma.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_pow22501_prove_t19(\n    self_limbs: [u64; 5],\n    t0_limbs: [u64; 5],\n    t1_limbs: [u64; 5],\n    t2_limbs: [u64; 5],\n    t3_limbs: [u64; 5],\n    t4_limbs: [u64; 5],\n    t5_limbs: [u64; 5],\n    t6_limbs: [u64; 5],\n    t7_limbs: [u64; 5],\n    t8_limbs: [u64; 5],\n    t9_limbs: [u64; 5],\n    t10_limbs: [u64; 5],\n    t11_limbs: [u64; 5],\n    t12_limbs: [u64; 5],\n    t13_limbs: [u64; 5],\n    t14_limbs: [u64; 5],\n    t15_limbs: [u64; 5],\n    t16_limbs: [u64; 5],\n    t17_limbs: [u64; 5],\n    t18_limbs: [u64; 5],\n    t19_limbs: [u64; 5],\n)\n    requires\n// Limbs are bounded\n\n        forall|i: int| 0 <= i < 5 ==> self_limbs[i] < 1u64 << 54,\n        // Already established by lemma_pow22501_prove_t3\n        u64_5_as_nat(t2_limbs) % p() == pow(u64_5_as_nat(self_limbs) as int, 9) as nat % p(),\n        u64_5_as_nat(t3_limbs) % p() == pow(u64_5_as_nat(self_limbs) as int, 11) as nat % p(),\n        // Postconditions from square operations\n        u64_5_as_nat(t0_limbs) % p() == pow(u64_5_as_nat(self_limbs) as int, 2) as nat % p(),\n        u64_5_as_nat(t1_limbs) % p() == pow(u64_5_as_nat(self_limbs) as int, 8) as nat % p(),\n        u64_5_as_nat(t4_limbs) % p() == pow(u64_5_as_nat(t3_limbs) as int, 2) as nat % p(),\n        // Postconditions from pow2k operations\n        u64_5_as_nat(t6_limbs) % p() == pow(u64_5_as_nat(t5_limbs) as int, pow2(5)) as nat % p(),\n        u64_5_as_nat(t8_limbs) % p() == pow(u64_5_as_nat(t7_limbs) as int, pow2(10)) as nat % p(),\n        u64_5_as_nat(t10_limbs) % p() == pow(u64_5_as_nat(t9_limbs) as int, pow2(20)) as nat % p(),\n        u64_5_as_nat(t12_limbs) % p() == pow(u64_5_as_nat(t11_limbs) as int, pow2(10)) as nat % p(),\n        u64_5_as_nat(t14_limbs) % p() == pow(u64_5_as_nat(t13_limbs) as int, pow2(50)) as nat % p(),\n        u64_5_as_nat(t16_limbs) % p() == pow(u64_5_as_nat(t15_limbs) as int, pow2(100)) as nat\n            % p(),\n        u64_5_as_nat(t18_limbs) % p() == pow(u64_5_as_nat(t17_limbs) as int, pow2(50)) as nat % p(),\n        // Postconditions from mul operations\n        u64_5_as_nat(t5_limbs) % p() == (u64_5_as_nat(t2_limbs) * u64_5_as_nat(t4_limbs)) % p(),\n        u64_5_as_nat(t7_limbs) % p() == (u64_5_as_nat(t6_limbs) * u64_5_as_nat(t5_limbs)) % p(),\n        u64_5_as_nat(t9_limbs) % p() == (u64_5_as_nat(t8_limbs) * u64_5_as_nat(t7_limbs)) % p(),\n        u64_5_as_nat(t11_limbs) % p() == (u64_5_as_nat(t10_limbs) * u64_5_as_nat(t9_limbs)) % p(),\n        u64_5_as_nat(t13_limbs) % p() == (u64_5_as_nat(t12_limbs) * u64_5_as_nat(t7_limbs)) % p(),\n        u64_5_as_nat(t15_limbs) % p() == (u64_5_as_nat(t14_limbs) * u64_5_as_nat(t13_limbs)) % p(),\n        u64_5_as_nat(t17_limbs) % p() == (u64_5_as_nat(t16_limbs) * u64_5_as_nat(t15_limbs)) % p(),\n        u64_5_as_nat(t19_limbs) % p() == (u64_5_as_nat(t18_limbs) * u64_5_as_nat(t13_limbs)) % p(),\n    ensures\n        u64_5_as_nat(t19_limbs) % p() == pow(\n            u64_5_as_nat(self_limbs) as int,\n            (pow2(250) - 1) as nat,\n        ) as nat % p(),\n        u64_5_as_nat(t2_limbs) % p() == pow(u64_5_as_nat(self_limbs) as int, 9) as nat % p(),\n        u64_5_as_nat(t3_limbs) % p() == pow(u64_5_as_nat(self_limbs) as int, 11) as nat % p(),\n        u64_5_as_nat(t4_limbs) % p() == pow(u64_5_as_nat(self_limbs) as int, 22) as nat % p(),\n        u64_5_as_nat(t5_limbs) % p() == pow(\n            u64_5_as_nat(self_limbs) as int,\n            (pow2(5) - 1) as nat,\n        ) as nat % p(),\n        u64_5_as_nat(t7_limbs) % p() == pow(\n            u64_5_as_nat(self_limbs) as int,\n            (pow2(10) - 1) as nat,\n        ) as nat % p(),\n        u64_5_as_nat(t9_limbs) % p() == pow(\n            u64_5_as_nat(self_limbs) as int,\n            (pow2(20) - 1) as nat,\n        ) as nat % p(),\n        u64_5_as_nat(t11_limbs) % p() == pow(\n            u64_5_as_nat(self_limbs) as int,\n            (pow2(40) - 1) as nat,\n        ) as nat % p(),\n        u64_5_as_nat(t13_limbs) % p() == pow(\n            u64_5_as_nat(self_limbs) as int,\n            (pow2(50) - 1) as nat,\n        ) as nat % p(),\n        u64_5_as_nat(t15_limbs) % p() == pow(\n            u64_5_as_nat(self_limbs) as int,\n            (pow2(100) - 1) as nat,\n        ) as nat % p(),\n        u64_5_as_nat(t17_limbs) % p() == pow(\n            u64_5_as_nat(self_limbs) as int,\n            (pow2(200) - 1) as nat,\n        ) as nat % p(),\n{\n    let base = u64_5_as_nat(self_limbs) as int;\n\n    assert(p() > 0) by {\n        pow255_gt_19();\n    }\n\n    // Establish that base >= 0, which makes all pow(base, n) >= 0\n    assert(base >= 0);\n\n    // t2 = x^9 and t3 = x^11 are already established as preconditions\n    // (proven by lemma_pow22501_prove_t3 before calling this lemma)\n\n    // ========================================================================\n    // Establish non-negativity facts needed throughout the proof\n    // ========================================================================\n\n    // Prove pow(base, 9) >= 0 for use throughout the proof\n    assert(pow(base, 9) >= 0) by {\n        lemma_pow_nonnegative(base, 9);\n    }\n\n    // ========================================================================\n    // Prove t4 = x^22\n    // ========================================================================\n    // t4 = t3^2 = (x^11)^2 = x^22\n\n    // Establish pow(base, 11) >= 0 for use in subsequent proofs\n    assert(pow(base, 11) >= 0) by {\n        lemma_pow_nonnegative(base, 11);\n    }\n\n    let t3_val = u64_5_as_nat(t3_limbs) as int;\n    assert(t3_val >= 0);\n    assert(pow(t3_val, 2) >= 0) by {\n        lemma_pow_nonnegative(t3_val, 2);\n    }\n    assert(pow(base, 22) >= 0) by {\n        lemma_pow_nonnegative(base, 22);\n    }\n\n    assert((pow(u64_5_as_nat(t3_limbs) as int, 2) as nat) % p() == (pow(\n        u64_5_as_nat(t3_limbs) as int,\n        2,\n    ) % (p() as int)) as nat);\n    assert((pow(base, 22) as nat) % p() == (pow(base, 22) % (p() as int)) as nat);\n\n    assert((pow(u64_5_as_nat(t3_limbs) as int, 2) % (p() as int)) as nat == (pow(pow(base, 11), 2)\n        % (p() as int)) as nat) by {\n        lemma_pow_mod_congruent(u64_5_as_nat(t3_limbs) as int, pow(base, 11), 2, p() as int);\n    }\n\n    assert(pow(pow(base, 11), 2) == pow(base, 22)) by {\n        lemma_pow_multiplies(base, 11, 2);\n    }\n\n    assert(u64_5_as_nat(t4_limbs) % p() == pow(base, 22) as nat % p());\n\n    // ========================================================================\n    // Prove t5 = x^31 = x^(2^5-1)\n    // ========================================================================\n    // t5 = t2 * t4 = x^9 * x^22 = x^31\n\n    assert(u64_5_as_nat(t5_limbs) % p() == ((u64_5_as_nat(t2_limbs) % p()) * (u64_5_as_nat(t4_limbs)\n        % p())) % p()) by {\n        lemma_mul_mod_noop_general(\n            u64_5_as_nat(t2_limbs) as int,\n            u64_5_as_nat(t4_limbs) as int,\n            p() as int,\n        );\n    }\n\n    assert(u64_5_as_nat(t5_limbs) % p() == ((pow(base, 9) as nat % p()) * (pow(base, 22) as nat\n        % p())) % p());\n\n    assert(u64_5_as_nat(t5_limbs) % p() == (pow(base, 9) as nat * pow(base, 22) as nat) % p()) by {\n        lemma_mul_mod_noop_general(\n            pow(base, 9) as nat as int,\n            pow(base, 22) as nat as int,\n            p() as int,\n        );\n    }\n\n    assert(pow(base, 9) * pow(base, 22) == pow(base, 31)) by {\n        lemma_pow_adds(base, 9, 22);\n    }\n\n    assert(pow(base, 22) >= 0);  // known from earlier\n    assert((pow(base, 9) * pow(base, 22)) >= 0) by {\n        lemma_mul_nonnegative(pow(base, 9), pow(base, 22));\n    }\n    assert(pow(base, 9) as nat * pow(base, 22) as nat == (pow(base, 9) * pow(base, 22)) as nat);\n    assert(pow(base, 9) as nat * pow(base, 22) as nat == pow(base, 31) as nat);\n\n    assert(31 == pow2(5) - 1) by {\n        lemma2_to64();\n    }\n\n    assert(u64_5_as_nat(t5_limbs) % p() == pow(base, (pow2(5) - 1) as nat) as nat % p());\n\n    // ========================================================================\n    // Prove t6 = x^((2^5-1)*2^5)\n    // ========================================================================\n    // t6 = t5.pow2k(5) = (x^(2^5-1))^(2^5)\n    assert(pow2(5) > 0) by {\n        lemma_pow2_pos(5);\n    }\n    lemma_prove_pow2k_step(\n        base,\n        u64_5_as_nat(t5_limbs),\n        u64_5_as_nat(t6_limbs),\n        (pow2(5) - 1) as nat,\n        pow2(5),\n    );\n\n    // ========================================================================\n    // Prove t7 = x^(2^10-1)\n    // ========================================================================\n    // t7 = t6 * t5 = x^((2^5-1)*2^5) * x^(2^5-1) = x^(2^10-1)\n    lemma_prove_geometric_mul_step(\n        base,\n        u64_5_as_nat(t6_limbs),\n        u64_5_as_nat(t5_limbs),\n        u64_5_as_nat(t7_limbs),\n        ((pow2(5) - 1) * pow2(5)) as nat,\n        (pow2(5) - 1) as nat,\n    );\n    lemma_pow2_geometric(5, 5);\n\n    // ========================================================================\n    // Prove t8 = x^((2^10-1)*2^10)\n    // ========================================================================\n    // t8 = t7.pow2k(10) = (x^(2^10-1))^(2^10)\n    assert(pow2(10) > 0) by {\n        lemma_pow2_pos(10);\n    }\n    lemma_prove_pow2k_step(\n        base,\n        u64_5_as_nat(t7_limbs),\n        u64_5_as_nat(t8_limbs),\n        (pow2(10) - 1) as nat,\n        pow2(10),\n    );\n\n    // ========================================================================\n    // Prove t9 = x^(2^20-1)\n    // ========================================================================\n    // t9 = t8 * t7 = x^((2^10-1)*2^10) * x^(2^10-1) = x^(2^20-1)\n    lemma_prove_geometric_mul_step(\n        base,\n        u64_5_as_nat(t8_limbs),\n        u64_5_as_nat(t7_limbs),\n        u64_5_as_nat(t9_limbs),\n        ((pow2(10) - 1) * pow2(10)) as nat,\n        (pow2(10) - 1) as nat,\n    );\n    lemma_pow2_geometric(10, 10);\n\n    // ========================================================================\n    // Prove t10 = x^((2^20-1)*2^20)\n    // ========================================================================\n    // t10 = t9.pow2k(20) = (x^(2^20-1))^(2^20)\n    assert(pow2(20) > 0) by {\n        lemma_pow2_pos(20);\n    }\n    lemma_prove_pow2k_step(\n        base,\n        u64_5_as_nat(t9_limbs),\n        u64_5_as_nat(t10_limbs),\n        (pow2(20) - 1) as nat,\n        pow2(20),\n    );\n\n    // ========================================================================\n    // Prove t11 = x^(2^40-1)\n    // ========================================================================\n    // t11 = t10 * t9 = x^((2^20-1)*2^20) * x^(2^20-1) = x^(2^40-1)\n    lemma_prove_geometric_mul_step(\n        base,\n        u64_5_as_nat(t10_limbs),\n        u64_5_as_nat(t9_limbs),\n        u64_5_as_nat(t11_limbs),\n        ((pow2(20) - 1) * pow2(20)) as nat,\n        (pow2(20) - 1) as nat,\n    );\n    lemma_pow2_geometric(20, 20);\n\n    // ========================================================================\n    // Prove t12 = x^((2^40-1)*2^10)\n    // ========================================================================\n    // t12 = t11.pow2k(10) = (x^(2^40-1))^(2^10)\n    assert(pow2(10) > 0) by {\n        lemma_pow2_pos(10);\n    }\n    lemma_prove_pow2k_step(\n        base,\n        u64_5_as_nat(t11_limbs),\n        u64_5_as_nat(t12_limbs),\n        (pow2(40) - 1) as nat,\n        pow2(10),\n    );\n\n    // ========================================================================\n    // Prove t13 = x^(2^50-1)\n    // ========================================================================\n    // t13 = t12 * t7 = x^((2^40-1)*2^10) * x^(2^10-1) = x^(2^50-1)\n    lemma_prove_geometric_mul_step(\n        base,\n        u64_5_as_nat(t12_limbs),\n        u64_5_as_nat(t7_limbs),\n        u64_5_as_nat(t13_limbs),\n        ((pow2(40) - 1) * pow2(10)) as nat,\n        (pow2(10) - 1) as nat,\n    );\n    lemma_pow2_geometric(40, 10);\n\n    // ========================================================================\n    // Prove t14 = x^((2^50-1)*2^50)\n    // ========================================================================\n    // t14 = t13.pow2k(50) = (x^(2^50-1))^(2^50)\n    assert(pow2(50) > 0) by {\n        lemma_pow2_pos(50);\n    }\n    lemma_prove_pow2k_step(\n        base,\n        u64_5_as_nat(t13_limbs),\n        u64_5_as_nat(t14_limbs),\n        (pow2(50) - 1) as nat,\n        pow2(50),\n    );\n\n    // ========================================================================\n    // Prove t15 = x^(2^100-1)\n    // ========================================================================\n    // t15 = t14 * t13 = x^((2^50-1)*2^50) * x^(2^50-1) = x^(2^100-1)\n    lemma_prove_geometric_mul_step(\n        base,\n        u64_5_as_nat(t14_limbs),\n        u64_5_as_nat(t13_limbs),\n        u64_5_as_nat(t15_limbs),\n        ((pow2(50) - 1) * pow2(50)) as nat,\n        (pow2(50) - 1) as nat,\n    );\n    lemma_pow2_geometric(50, 50);\n\n    // ========================================================================\n    // Prove t16 = x^((2^100-1)*2^100)\n    // ========================================================================\n    // t16 = t15.pow2k(100) = (x^(2^100-1))^(2^100)\n    assert(pow2(100) > 0) by {\n        lemma_pow2_pos(100);\n    }\n    lemma_prove_pow2k_step(\n        base,\n        u64_5_as_nat(t15_limbs),\n        u64_5_as_nat(t16_limbs),\n        (pow2(100) - 1) as nat,\n        pow2(100),\n    );\n\n    // ========================================================================\n    // Prove t17 = x^(2^200-1)\n    // ========================================================================\n    // t17 = t16 * t15 = x^((2^100-1)*2^100) * x^(2^100-1) = x^(2^200-1)\n    lemma_prove_geometric_mul_step(\n        base,\n        u64_5_as_nat(t16_limbs),\n        u64_5_as_nat(t15_limbs),\n        u64_5_as_nat(t17_limbs),\n        ((pow2(100) - 1) * pow2(100)) as nat,\n        (pow2(100) - 1) as nat,\n    );\n    lemma_pow2_geometric(100, 100);\n\n    // ========================================================================\n    // Prove t18 = x^((2^200-1)*2^50)\n    // ========================================================================\n    // t18 = t17.pow2k(50) = (x^(2^200-1))^(2^50)\n    assert(pow2(50) > 0) by {\n        lemma_pow2_pos(50);\n    }\n    lemma_prove_pow2k_step(\n        base,\n        u64_5_as_nat(t17_limbs),\n        u64_5_as_nat(t18_limbs),\n        (pow2(200) - 1) as nat,\n        pow2(50),\n    );\n\n    // ========================================================================\n    // Prove t19 = x^(2^250-1) - FINAL STEP\n    // ========================================================================\n    // t19 = t18 * t13 = x^((2^200-1)*2^50) * x^(2^50-1) = x^(2^250-1)\n    lemma_prove_geometric_mul_step(\n        base,\n        u64_5_as_nat(t18_limbs),\n        u64_5_as_nat(t13_limbs),\n        u64_5_as_nat(t19_limbs),\n        ((pow2(200) - 1) * pow2(50)) as nat,\n        (pow2(50) - 1) as nat,\n    );\n    lemma_pow2_geometric(200, 50);\n}",
      "start_line": 66,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 16
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a1_1_val().",
      "display_name": "a1_1_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a1_1_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn a1_1_val(a: [u64; 5]) -> u64 {\n    (a1_0_val(a) + (a0_1_val(a) >> 51)) as u64\n}",
      "start_line": 104,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/m().",
      "display_name": "m",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/m().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "fn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        lemma_mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}",
      "start_line": 155,
      "end_line": 5,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/bits_to_nat_rec().",
      "display_name": "bits_to_nat_rec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/bits_to_nat_rec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn bits_to_nat_rec(bits: &[bool; 256], index: int) -> nat\n    decreases 256 - index,\n{\n    if index >= 256 {\n        0\n    } else {\n        let bit_value = if bits[index] {\n            1nat\n        } else {\n            0nat\n        };\n        bit_value * pow2(index as nat) + bits_to_nat_rec(bits, index + 1)\n    }\n}",
      "start_line": 18,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_close_mod_u8().",
      "display_name": "lemma_pow2_mul_div_mod_close_mod_u8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_close_mod_u8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_mul_div_mod_close_mod_u8(x: u8, k: nat, s: nat, t: nat)\n    requires\n        s <= k,\n        k - s <= t,\n    ensures\n        ((x as nat * pow2(k)) / pow2(s)) % pow2(t) == (x as nat % pow2((t - (k - s)) as nat) * pow2(\n            (k - s) as nat,\n        )),\n{\n    assert(x < pow2(8)) by {\n        lemma2_to64();  // pow2(8)\n    }\n    lemma_pow2_mul_div_mod_close_mod(x as nat, 8, k, s, t);\n}",
      "start_line": 569,
      "end_line": 49,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn default() -> (result: ProjectivePoint)\n        ensures\n    // Default returns the identity point\n\n            spec_field_element(&result.U) == 1,\n            spec_field_element(&result.W) == 0,\n    {\n        ProjectivePoint::identity()\n    }",
      "start_line": 596,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_limbs_bounded().",
      "display_name": "edwards_point_limbs_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_limbs_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn edwards_point_limbs_bounded(point: crate::edwards::EdwardsPoint) -> bool {\n    fe51_limbs_bounded(&point.X, 54) && fe51_limbs_bounded(&point.Y, 54) && fe51_limbs_bounded(\n        &point.Z,\n        54,\n    ) && fe51_limbs_bounded(&point.T, 54)\n}",
      "start_line": 240,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 12,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_negate_generic().",
      "display_name": "conditional_negate_generic",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_negate_generic().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn conditional_negate_generic<T>(a: &mut T, choice: Choice) where\n    T: subtle::ConditionallyNegatable,\n {\n    a.conditional_negate(choice);\n}",
      "start_line": 254,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_mul_si_vi_and_reorder().",
      "display_name": "lemma_mul_si_vi_and_reorder",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_mul_si_vi_and_reorder().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "file_name": "u64_5_as_nat_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_mul_si_vi_and_reorder(\n    si: int,\n    vi: int,\n    v0: int,\n    s1: int,\n    v1: int,\n    s2: int,\n    v2: int,\n    s3: int,\n    v3: int,\n    s4: int,\n    v4: int,\n)\n    ensures\n        (si * vi) * (v0 + s1 * v1 + s2 * v2 + s3 * v3 + s4 * v4) == (si) * (vi * v0) + (si * s1) * (\n        vi * v1) + (si * s2) * (vi * v2) + (si * s3) * (vi * v3) + (si * s4) * (vi * v4),\n{\n    // n * (x1 + x2 + x3 + x4 + x5) == n * x1 + n * x2 + n * x3 + n * x4 + n * x5\n    lemma_mul_distributive_5_terms(si * vi, v0, s1 * v1, s2 * v2, s3 * v3, s4 * v4);\n\n    assert((si * vi) * (v0 + s1 * v1 + s2 * v2 + s3 * v3 + s4 * v4) == (si * vi) * v0 + (si * vi)\n        * (s1 * v1) + (si * vi) * (s2 * v2) + (si * vi) * (s3 * v3) + (si * vi) * (s4 * v4));\n\n    lemma_mul_is_associative(si, vi, v0);\n    lemma_mul_quad_prod(si, vi, s1, v1);\n    lemma_mul_quad_prod(si, vi, s2, v2);\n    lemma_mul_quad_prod(si, vi, s3, v3);\n    lemma_mul_quad_prod(si, vi, s4, v4);\n}",
      "start_line": 40,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#From#from().",
      "display_name": "from",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#From#from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_affine_niels(); 64];\n        let A2 = A.double();\n        for i in 0..63 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n        NafLookupTable8(Ai)\n    }",
      "start_line": 617,
      "end_line": 12,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_square().",
      "display_name": "lemma_inv_of_square",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_square().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "file_name": "field_algebra_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_inv_of_square(x: nat)\n    requires\n        x % p() != 0,\n    ensures\n        math_field_inv(math_field_square(x)) == math_field_square(math_field_inv(x)),\n{\n    let p = p();\n    p_gt_2();\n    \n    // math_field_square(x) = (x * x) % p\n    // So inv(x²) = inv(x * x) = inv(x) * inv(x) = inv(x)²\n    \n    // Apply lemma_inv_of_product with a = b = x\n    lemma_inv_of_product(x, x);\n    \n    // inv(x * x) = inv(x) * inv(x)\n    // math_field_mul(x, x) % p = math_field_square(x) when viewed as field ops\n    \n    // Show math_field_mul(x, x) = math_field_square(x)\n    assert(math_field_mul(x, x) == math_field_square(x));\n    \n    // Show math_field_mul(inv(x), inv(x)) = math_field_square(inv(x))\n    assert(math_field_mul(math_field_inv(x), math_field_inv(x)) == math_field_square(math_field_inv(x)));\n}",
      "start_line": 306,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo proptest 1.9.0 traits/arbitrary/any().",
      "display_name": "any",
      "symbol": "rust-analyzer cargo proptest 1.9.0 traits/arbitrary/any().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/axiom_ed25519_basepoint_table_valid().",
      "display_name": "axiom_ed25519_basepoint_table_valid",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/axiom_ed25519_basepoint_table_valid().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub proof fn axiom_ed25519_basepoint_table_valid()\n    ensures\n        is_valid_edwards_basepoint_table(\n            *crate::backend::serial::u64::constants::ED25519_BASEPOINT_TABLE,\n            spec_ed25519_basepoint(),\n        ),\n{\n}",
      "start_line": 104,
      "end_line": 49,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "display_name": "lemma_limb1_contribution_correctness_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub proof fn lemma_limb1_contribution_correctness_52(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[0] < (1u64 << 52),  // Need limb 0 for boundary byte 6\n        limbs[1] < (1u64 << 52),\n        bytes_match_limbs_packing_52(limbs, bytes),\n    ensures\n        limb1_byte_contribution_52(limbs, bytes) == (limbs[1] as nat) * pow2(52),\n{\n    // Proof following docs_22_oct/lemma_limb1_contribution_52_proof.md\n    lemma2_to64();\n    lemma_shift_is_pow2(52);\n\n    // === STEP 1: Define the Split ===\n    let l1_low = limbs[1] as nat % pow2(4);  // Low 4 bits in byte 6\n    let l1_high = limbs[1] as nat / pow2(4);  // High 48 bits in bytes 7-12\n\n    // === STEP 2: Bound the High Part ===\n    lemma_div_bound(limbs[1] as nat, 4, 52);\n    assert(l1_high < pow2(48));\n\n    // === STEP 3: Reconstruction Identity ===\n    lemma_pow2_pos(4);\n    lemma_fundamental_div_mod(limbs[1] as int, pow2(4) as int);\n    assert(pow2(4) * l1_high == l1_high * pow2(4)) by {\n        lemma_mul_is_commutative(pow2(4) as int, l1_high as int);\n    }\n    assert(limbs[1] as nat == l1_low + l1_high * pow2(4));\n\n    // === STEP 4: Byte Reconstruction for High 48 Bits ===\n    lemma_byte_from_limb_shift_52(limbs[1], 4, bytes[7]);\n    lemma_byte_from_limb_shift_52(limbs[1], 12, bytes[8]);\n    lemma_byte_from_limb_shift_52(limbs[1], 20, bytes[9]);\n    lemma_byte_from_limb_shift_52(limbs[1], 28, bytes[10]);\n    lemma_byte_from_limb_shift_52(limbs[1], 36, bytes[11]);\n    lemma_byte_from_limb_shift_52(limbs[1], 44, bytes[12]);\n\n    // Rewrite byte extractions in terms of l1_high = limbs[1] / 2^4\n    lemma_pow2_adds(4, 0);\n    lemma_pow2_pos(0);\n    lemma_div_denominator(limbs[1] as int, pow2(4) as int, pow2(0) as int);\n    assert(bytes[7] as nat == l1_high / pow2(0) % 256);\n\n    lemma_pow2_adds(4, 8);\n    lemma_pow2_pos(8);\n    lemma_div_denominator(limbs[1] as int, pow2(4) as int, pow2(8) as int);\n    assert(bytes[8] as nat == l1_high / pow2(8) % 256);\n\n    lemma_pow2_adds(4, 16);\n    lemma_pow2_pos(16);\n    lemma_div_denominator(limbs[1] as int, pow2(4) as int, pow2(16) as int);\n    assert(bytes[9] as nat == l1_high / pow2(16) % 256);\n\n    lemma_pow2_adds(4, 24);\n    lemma_pow2_pos(24);\n    lemma_div_denominator(limbs[1] as int, pow2(4) as int, pow2(24) as int);\n    assert(bytes[10] as nat == l1_high / pow2(24) % 256);\n\n    lemma_pow2_adds(4, 32);\n    lemma_pow2_pos(32);\n    lemma_div_denominator(limbs[1] as int, pow2(4) as int, pow2(32) as int);\n    assert(bytes[11] as nat == l1_high / pow2(32) % 256);\n\n    lemma_pow2_adds(4, 40);\n    lemma_pow2_pos(40);\n    lemma_div_denominator(limbs[1] as int, pow2(4) as int, pow2(40) as int);\n    assert(bytes[12] as nat == l1_high / pow2(40) % 256);\n\n    // 6-byte reconstruction lemma\n    lemma_6_bytes_reconstruct(\n        l1_high,\n        bytes[7],\n        bytes[8],\n        bytes[9],\n        bytes[10],\n        bytes[11],\n        bytes[12],\n    );\n\n    let bytes_at_offset_0 = bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8) + bytes[9] as nat\n        * pow2(16) + bytes[10] as nat * pow2(24) + bytes[11] as nat * pow2(32) + bytes[12] as nat\n        * pow2(40);\n\n    assert(bytes_at_offset_0 == l1_high);\n\n    // === STEP 5: Position Adjustment ===\n\n    // Multiply reconstruction identity by pow2(52)\n    assert((l1_low + l1_high * pow2(4)) * pow2(52) == limbs[1] as nat * pow2(52));\n\n    // Distribute\n    assert((l1_low + l1_high * pow2(4)) * pow2(52) == l1_low * pow2(52) + (l1_high * pow2(4))\n        * pow2(52)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(52) as int,\n            l1_low as int,\n            (l1_high * pow2(4)) as int,\n        );\n    }\n\n    // Simplify high term\n    lemma_pow2_adds(4, 52);\n    assert((l1_high * pow2(4)) * pow2(52) == l1_high * pow2(56)) by {\n        lemma_mul_is_associative(l1_high as int, pow2(4) as int, pow2(52) as int);\n    }\n\n    // Now we have: limbs[1] * 2^52 = l1_low * 2^52 + l1_high * 2^56\n\n    // === STEP 6: Express Low Part in Contribution Form ===\n    // l1_low * 2^52 = l1_low * 2^48 * 2^4 = (l1_low * 16) * 2^48\n    lemma_pow2_adds(48, 4);\n    assert(pow2(52) == pow2(48) * pow2(4));\n    assert(pow2(4) == 16) by {\n        assert(pow2(2) == 4);\n        assert(pow2(4) == pow2(2) * pow2(2)) by {\n            lemma_pow2_adds(2, 2);\n        }\n    }\n\n    assert(l1_low * pow2(52) == l1_low * (pow2(48) * pow2(4))) by {\n        // pow2(52) = pow2(48) * pow2(4) proven above\n    }\n    assert(l1_low * (pow2(48) * pow2(4)) == (l1_low * pow2(48)) * pow2(4)) by {\n        lemma_mul_is_associative(l1_low as int, pow2(48) as int, pow2(4) as int);\n    }\n    assert((l1_low * pow2(48)) * pow2(4) == pow2(48) * l1_low * pow2(4)) by {\n        lemma_mul_is_commutative((l1_low * pow2(48)) as int, pow2(4) as int);\n    }\n    assert(pow2(48) * l1_low * pow2(4) == pow2(48) * (l1_low * pow2(4))) by {\n        lemma_mul_is_associative(pow2(48) as int, l1_low as int, pow2(4) as int);\n    }\n    assert(l1_low * pow2(52) == (l1_low * 16) * pow2(48));\n\n    // === STEP 7: Expand the High Part ===\n    // Multiply bytes_at_offset_0 by pow2(56)\n    assert(bytes_at_offset_0 * pow2(56) == l1_high * pow2(56));\n\n    // Distribute pow2(56) into each byte term\n    assert(bytes_at_offset_0 * pow2(56) == bytes[7] as nat * pow2(0) * pow2(56) + bytes[8] as nat\n        * pow2(8) * pow2(56) + bytes[9] as nat * pow2(16) * pow2(56) + bytes[10] as nat * pow2(24)\n        * pow2(56) + bytes[11] as nat * pow2(32) * pow2(56) + bytes[12] as nat * pow2(40) * pow2(\n        56,\n    )) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(56) as int,\n            (bytes[7] as nat * pow2(0)) as int,\n            (bytes[8] as nat * pow2(8)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(56) as int,\n            (bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8)) as int,\n            (bytes[9] as nat * pow2(16)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(56) as int,\n            (bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8) + bytes[9] as nat * pow2(\n                16,\n            )) as int,\n            (bytes[10] as nat * pow2(24)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(56) as int,\n            (bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8) + bytes[9] as nat * pow2(16)\n                + bytes[10] as nat * pow2(24)) as int,\n            (bytes[11] as nat * pow2(32)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(56) as int,\n            (bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8) + bytes[9] as nat * pow2(16)\n                + bytes[10] as nat * pow2(24) + bytes[11] as nat * pow2(32)) as int,\n            (bytes[12] as nat * pow2(40)) as int,\n        );\n\n        // Apply associativity: (byte * pow2(k)) * pow2(56) = byte * (pow2(k) * pow2(56))\n        lemma_mul_is_associative(bytes[7] as int, pow2(0) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[8] as int, pow2(8) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[9] as int, pow2(16) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[10] as int, pow2(24) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[11] as int, pow2(32) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[12] as int, pow2(40) as int, pow2(56) as int);\n    }\n\n    // Apply power addition and connect to final positions\n    assert(bytes_at_offset_0 * pow2(56) == bytes[7] as nat * pow2(56) + bytes[8] as nat * pow2(64)\n        + bytes[9] as nat * pow2(72) + bytes[10] as nat * pow2(80) + bytes[11] as nat * pow2(88)\n        + bytes[12] as nat * pow2(96)) by {\n        lemma_mul_is_associative(bytes[7] as int, pow2(0) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[8] as int, pow2(8) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[9] as int, pow2(16) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[10] as int, pow2(24) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[11] as int, pow2(32) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[12] as int, pow2(40) as int, pow2(56) as int);\n        lemma_pow2_adds(0, 56);\n        lemma_pow2_adds(8, 56);\n        lemma_pow2_adds(16, 56);\n        lemma_pow2_adds(24, 56);\n        lemma_pow2_adds(32, 56);\n        lemma_pow2_adds(40, 56);\n    }\n}",
      "start_line": 667,
      "end_line": 53,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "display_name": "lemma_step1_case_analysis",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_step1_case_analysis(\n    y: nat,\n    x: nat,\n    u_math: nat,\n    v_math: nat,\n    is_valid: bool,\n    is_sqrt_ratio_holds: bool,\n)\n    requires\n        // u = Y² - 1, v = d·Y² + 1\n        ({\n            let d = spec_field_element(&EDWARDS_D);\n            let y2 = math_field_square(y);\n            u_math == math_field_sub(y2, 1) &&\n            v_math == math_field_add(math_field_mul(d, y2), 1)\n        }),",
      "start_line": 1153,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/math_on_montgomery_curve().",
      "display_name": "math_on_montgomery_curve",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/math_on_montgomery_curve().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn math_on_montgomery_curve(u: nat, v: nat) -> bool {\n    let a = spec_field_element(&MONTGOMERY_A);\n    let u2 = math_field_square(u);\n    let u3 = math_field_mul(u, u2);\n    let v2 = math_field_square(v);\n\n    // v² = u³ + A·u² + u\n    let rhs = math_field_add(math_field_add(u3, math_field_mul(a, u2)), u);\n\n    v2 == rhs\n}",
      "start_line": 25,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_one_of_fourth_roots().",
      "display_name": "is_one_of_fourth_roots",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_one_of_fourth_roots().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_one_of_fourth_roots(x: nat) -> bool {\n    let (one, neg_one, i, neg_i) = fourth_root_of_unity_values();\n    x % p() == one || x % p() == neg_one || x % p() == i || x % p() == neg_i\n}",
      "start_line": 494,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "display_name": "test_elligator_inv",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    fn test_elligator_inv() {\n        let mut rng = rand::thread_rng();\n\n        for i in 0..100 {\n            let mut fe_bytes = [0u8; 32];\n\n            if i == 0 {\n                // Test for first corner-case: fe = 0\n                fe_bytes = [0u8; 32];\n            } else if i == 1 {\n                // Test for second corner-case: fe = +sqrt(i*d)\n                fe_bytes = [\n                    168, 27, 92, 74, 203, 42, 48, 117, 170, 109, 234, 14, 45, 169, 188, 205, 21,\n                    110, 235, 115, 153, 84, 52, 117, 151, 235, 123, 244, 88, 85, 179, 5,\n                ];\n            } else {\n                // For the rest, just generate a random field element to test.\n                rng.fill_bytes(&mut fe_bytes);\n            }\n            fe_bytes[0] &= 254; // positive\n            fe_bytes[31] &= 127; // < 2^255-19\n            let fe = FieldElement::from_bytes(&fe_bytes);\n\n            let pt = RistrettoPoint::elligator_ristretto_flavor(&fe);\n            for pt2 in &pt.xcoset4() {\n                let (mask, fes) = RistrettoPoint(*pt2).elligator_ristretto_flavor_inverse();\n\n                let mut found = false;\n                for (j, fe_j) in fes.iter().enumerate() {\n                    if mask & (1 << j) != 0 {\n                        assert_eq!(RistrettoPoint::elligator_ristretto_flavor(fe_j), pt);\n                        if *fe_j == fe {\n                            found = true;\n                        }\n                    }\n                }\n                assert!(found);\n            }\n        }\n    }",
      "start_line": 291,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_fourth_root_of_unity().",
      "display_name": "is_fourth_root_of_unity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_fourth_root_of_unity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_fourth_root_of_unity(x: nat) -> bool {\n    pow(x as int, 4nat) as nat % p() == 1\n}",
      "start_line": 479,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_equals_spec().",
      "display_name": "lemma_r_equals_spec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_equals_spec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub(crate) proof fn lemma_r_equals_spec(r: Scalar52)\n    requires\n        r == (Scalar52 {\n            limbs: [\n                0x000f48bd6721e6ed,\n                0x0003bab5ac67e45a,\n                0x000fffffeb35e51b,\n                0x000fffffffffffff,\n                0x00000fffffffffff,\n            ],\n        }),",
      "start_line": 490,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"EdwardsPoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?},\\n\\tT: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z, &self.T\n        )\n    }",
      "start_line": 2372,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#Clone#clone().",
      "display_name": "clone",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#Clone#clone().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn clone(&self) -> Self {\n        EdwardsBasepointTable(self.0)\n    }",
      "start_line": 1974,
      "end_line": 13,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#mul_base().",
      "display_name": "mul_base",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#mul_base().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_base(scalar: &Scalar) -> Self {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_POINT\n        }\n\n        #[cfg(feature = \"precomputed-tables\")]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_TABLE\n        }\n    }",
      "start_line": 951,
      "end_line": 20,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core array/Hash#hash().",
      "display_name": "hash",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core array/Hash#hash().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_general_bound().",
      "display_name": "lemma_general_bound",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_general_bound().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_general_bound(a: Seq<u64>)\n    requires\n        forall|i: int| 0 <= i < a.len() ==> a[i] < (1u64 << 52),\n    ensures\n        seq_u64_to_nat(a) < pow2((52 * a.len() as nat)),\n    decreases a.len(),\n{\n    if a.len() == 0 {\n        assert(seq_u64_to_nat(a) == 0);\n        lemma2_to64();  // Gives us pow2(0) == 1 among other facts\n        assert(pow2(0) == 1);\n    } else {\n        // Inductive case\n        let tail = a.subrange(1, a.len() as int);\n\n        // Apply induction hypothesis on tail\n        assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] < (1u64 << 52)) by {\n            assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] == a[i + 1]);\n        };\n\n        assert(tail.len() == a.len() - 1);\n\n        // Apply induction hypothesis\n        lemma_general_bound(tail);\n        assert(seq_u64_to_nat(tail) < pow2((52 * tail.len() as nat)));\n\n        // Now prove for the full sequence\n        assert(seq_u64_to_nat(a) == seq_to_nat(a.map(|i, x| x as nat)));\n        assert(a.map(|i, x| x as nat).len() == a.len());\n        assert(a.map(|i, x| x as nat)[0] == a[0] as nat);\n        assert(a.map(|i, x| x as nat).subrange(1, a.len() as int) == a.subrange(\n            1,\n            a.len() as int,\n        ).map(|i, x| x as nat));\n        // Therefore:\n        assert(seq_u64_to_nat(a) == a[0] as nat + seq_u64_to_nat(a.subrange(1, a.len() as int))\n            * pow2(52));\n\n        assert(a.subrange(1, a.len() as int) == tail);\n\n        // From precondition\n        assert(a[0] < (1u64 << 52));\n        lemma2_to64_rest();\n        assert(0x10000000000000 == 1u64 << 52) by (compute_only);\n        assert(0x10000000000000 == pow2(52));\n        assert((1u64 << 52) == pow2(52));\n\n        // We have seq_u64_to_nat(a) == a[0] + seq_u64_to_nat(tail) * pow2(52)\n        // We know a[0] < pow2(52) and seq_u64_to_nat(tail) < pow2(52 * (a.len() - 1))\n\n        assert(a[0] as nat <= pow2(52) - 1);\n        assert(seq_u64_to_nat(tail) <= pow2(52 * (a.len() - 1) as nat) - 1);\n\n        assert(seq_u64_to_nat(a) <= (pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(\n            52,\n        )) by {\n            lemma_mul_inequality(\n                (pow2(52 * (a.len() - 1) as nat) - 1) as int,\n                pow2(52 * (a.len() - 1) as nat) as int,\n                pow2(52) as int,\n            );\n        };\n\n        // Expand the right side\n        assert((pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(52) == pow2(52) - 1\n            + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52)) by {\n            broadcast use lemma_mul_is_distributive_sub;\n\n        };\n\n        assert(pow2(52) - 1 + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52) == pow2(\n            52 * (a.len() - 1) as nat,\n        ) * pow2(52) - 1);\n\n        lemma_pow2_adds(52 * (a.len() - 1) as nat, 52);\n        assert(pow2(52 * (a.len() - 1) as nat) * pow2(52) == pow2(52 * (a.len() - 1) as nat + 52));\n        assert(52 * (a.len() - 1) as nat + 52 == 52 * a.len() as nat);\n\n        assert(seq_u64_to_nat(a) <= pow2(52 * a.len() as nat) - 1);\n        assert(seq_u64_to_nat(a) < pow2(52 * a.len() as nat));\n    }\n}",
      "start_line": 704,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_close_mod().",
      "display_name": "lemma_pow2_mul_div_mod_close_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_close_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_mul_div_mod_close_mod(x: nat, px: nat, k: nat, s: nat, t: nat)\n    requires\n        x < pow2(px),\n        s <= k,\n        k - s <= t,\n    ensures\n        ((x * pow2(k)) / pow2(s)) % pow2(t) == (x % pow2((t - (k - s)) as nat) * pow2(\n            (k - s) as nat,\n        )),\n{\n    let d = (k - s) as nat;\n\n    assert((x * pow2(k)) / pow2(s) == x * pow2(d)) by {\n        pow2_MUL_div(x, k, s);\n    }\n\n    let dd = (t - d) as nat;\n\n    assert((x * pow2(d)) % pow2(t) == (x % pow2(dd)) * pow2(d)) by {\n        lemma_pow2_mul_mod(x, d, t);\n    }\n}",
      "start_line": 546,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo proptest 1.9.0 traits/strategy/Strategy#prop_map().",
      "display_name": "prop_map",
      "symbol": "rust-analyzer cargo proptest 1.9.0 traits/strategy/Strategy#prop_map().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_add().",
      "display_name": "montgomery_add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn montgomery_add(P: MontgomeryAffine, Q: MontgomeryAffine) -> MontgomeryAffine {\n    match (P, Q) {\n        (MontgomeryAffine::Infinity, _) => Q,\n        (_, MontgomeryAffine::Infinity) => P,\n        (MontgomeryAffine::Finite { u: u1, v: v1 }, MontgomeryAffine::Finite { u: u2, v: v2 }) => {\n            let A = spec_field_element(&MONTGOMERY_A);\n\n            // P = -Q (same u, opposite v)\n            if u1 == u2 && math_field_add(v1, v2) == 0 {\n                MontgomeryAffine::Infinity\n            }\n            // P = Q (doubling)\n             else if u1 == u2 && v1 == v2 {\n                let u1_sq = math_field_square(u1);\n                let numerator = math_field_add(\n                    math_field_add(\n                        math_field_mul(3, u1_sq),\n                        math_field_mul(math_field_mul(2, A), u1),\n                    ),\n                    1,\n                );\n                let denominator = math_field_mul(2, v1);\n                let lambda = math_field_mul(numerator, math_field_inv(denominator));\n\n                let lambda_sq = math_field_square(lambda);\n                let u3 = math_field_sub(math_field_sub(lambda_sq, A), math_field_mul(2, u1));\n                let v3 = math_field_sub(math_field_mul(lambda, math_field_sub(u1, u3)), v1);\n\n                MontgomeryAffine::Finite { u: u3, v: v3 }\n            }\n            // Add for distinct points P != Q\n             else {\n                let numerator = math_field_sub(v2, v1);\n                let denominator = math_field_sub(u2, u1);\n                let lambda = math_field_mul(numerator, math_field_inv(denominator));\n\n                let lambda_sq = math_field_square(lambda);\n                let u3 = math_field_sub(math_field_sub(math_field_sub(lambda_sq, A), u1), u2);\n                let v3 = math_field_sub(math_field_mul(lambda, math_field_sub(u1, u3)), v1);\n\n                MontgomeryAffine::Finite { u: u3, v: v3 }\n            }\n        },\n    }\n}",
      "start_line": 122,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_distributes_over_neg_mod().",
      "display_name": "lemma_mul_distributes_over_neg_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_distributes_over_neg_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_mul_distributes_over_neg_mod(a: nat, b: nat, m: nat)\n    requires m > 1,\n    ensures (a * ((m - b % m) as nat)) % m == ((m - (a * b) % m) as nat) % m,\n{\n    let b_mod = b % m;\n    let neg_b: nat = (m - b_mod) as nat;\n    let ab_mod = (a * b) % m;\n    let neg_ab: nat = (m - ab_mod) as nat;\n    \n    lemma_mod_bound(b as int, m as int);  // b_mod < m\n    lemma_mod_bound((a * b) as int, m as int);  // ab_mod < m\n    \n    // a * (m - b_mod) = a*m - a*b_mod\n    assert(a * neg_b == a * m - a * b_mod) by {\n        lemma_mul_is_distributive_sub(a as int, m as int, b_mod as int);\n    };\n    \n    // (a*m) % m = 0\n    assert((a * m) % m == 0) by {\n        lemma_mod_multiples_basic(a as int, m as int);\n    };\n    \n    // (a*b_mod) % m = (a*b) % m [mod absorption]\n    assert((a * b_mod) % m == ab_mod) by {\n        lemma_mul_mod_noop_right(a as int, b as int, m as int);\n    };\n    \n    // (a*m - a*b_mod) % m = (0 - ab_mod) % m\n    assert(((a * m) as int - (a * b_mod) as int) % (m as int) \n        == (0int - ab_mod as int) % (m as int)) by {\n        lemma_sub_mod_noop((a * m) as int, (a * b_mod) as int, m as int);\n    };\n    \n    // (0 - ab_mod) % m = (m - ab_mod) % m\n    assert((0int - ab_mod as int) % (m as int) == (m as int - ab_mod as int) % (m as int)) by {\n        lemma_mod_add_multiples_vanish(-(ab_mod as int), m as int);\n    };\n    \n    // Connect: a*m >= a*b_mod (so subtraction is non-negative)\n    assert((a as int) * (m as int) >= (a as int) * (b_mod as int)) by {\n        lemma_mul_inequality(b_mod as int, m as int, a as int);\n        lemma_mul_is_commutative(a as int, b_mod as int);\n        lemma_mul_is_commutative(a as int, m as int);\n    };\n    \n    assert((a * neg_b) % m == neg_ab % m);\n}",
      "start_line": 210,
      "end_line": 48,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb3_byte_contribution().",
      "display_name": "limb3_byte_contribution",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb3_byte_contribution().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "spec fn limb3_byte_contribution(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    // Byte 19 high 7 bits (limbs[3]'s bits 0-6)\n    ((limbs[3] as nat % pow2(7)) * 2) * pow2(19 * 8) + bytes[20] as nat * pow2(20 * 8)\n        + bytes[21] as nat * pow2(21 * 8) + bytes[22] as nat * pow2(22 * 8) + bytes[23] as nat\n        * pow2(23 * 8) + bytes[24] as nat * pow2(24 * 8)\n        +\n    // Byte 25 low 4 bits (limbs[3]'s bits 47-50)\n    ((limbs[3] as nat / pow2(47)) % pow2(4)) * pow2(25 * 8)\n}",
      "start_line": 197,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/lookup_table_projective_limbs_bounded().",
      "display_name": "lookup_table_projective_limbs_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/lookup_table_projective_limbs_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "pub open spec fn lookup_table_projective_limbs_bounded<const N: usize>(\n    table: [ProjectiveNielsPoint; N],\n) -> bool {\n    forall|j: int|\n        0 <= j < table.len() ==> {\n            let entry = #[trigger] table[j];\n            fe51_limbs_bounded(&entry.Y_plus_X, 54) && fe51_limbs_bounded(&entry.Y_minus_X, 54)\n                && fe51_limbs_bounded(&entry.Z, 54) && fe51_limbs_bounded(&entry.T2d, 54)\n        }\n}",
      "start_line": 59,
      "end_line": 55,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Add#add().",
      "display_name": "add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Add#add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn add(self, _rhs: &'a FieldElement51) -> (output: FieldElement51)\n        ensures\n            output == spec_add_fe51_limbs(self, _rhs),\n            spec_field_element_as_nat(&output) == spec_field_element_as_nat(self)\n                + spec_field_element_as_nat(_rhs),\n            spec_field_element(&output) == math_field_add(\n                spec_field_element(self),\n                spec_field_element(_rhs),\n            ),\n            // Bound propagation: tighter inputs give tighter output\n            fe51_limbs_bounded(self, 51) && fe51_limbs_bounded(_rhs, 51) ==> fe51_limbs_bounded(\n                &output,\n                52,\n            ),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    0 <= j < i ==> #[trigger] output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| i <= j < 5 ==> #[trigger] output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        proof {\n            // Trigger the forall invariant\n            assert(output.limbs == [\n                (original_limbs[0] + _rhs.limbs[0]) as u64,\n                (original_limbs[1] + _rhs.limbs[1]) as u64,\n                (original_limbs[2] + _rhs.limbs[2]) as u64,\n                (original_limbs[3] + _rhs.limbs[3]) as u64,\n                (original_limbs[4] + _rhs.limbs[4]) as u64,\n            ]);\n\n            lemma_field51_add(self, _rhs);\n\n            // Prove bound propagation: 51-bit inputs → 52-bit output\n            // If a < 2^51 and b < 2^51, then a + b < 2^52\n            assert((1u64 << 51) + (1u64 << 51) == (1u64 << 52)) by (bit_vector);\n        }\n\n        output\n    }",
      "start_line": 225,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/test_canonical_scalar_generator().",
      "display_name": "test_canonical_scalar_generator",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/test_canonical_scalar_generator().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn test_canonical_scalar_generator() {\n        use proptest::prelude::*;\n        use proptest::strategy::ValueTree;\n        use proptest::test_runner::{Config, TestRunner};\n\n        let mut runner = TestRunner::new(Config::default());\n        let l = group_order_exec();\n\n        println!(\"Testing canonical scalar generator round-trip:\");\n        for i in 0..10 {\n            let scalar = arb_canonical_scalar52()\n                .new_tree(&mut runner)\n                .unwrap()\n                .current();\n\n            // Convert to nat\n            let value = to_nat_exec(&scalar.limbs);\n\n            // Check it's canonical\n            assert!(value < l, \"Generated value should be < L\");\n\n            // Check limbs are bounded\n            for (j, &limb) in scalar.limbs.iter().enumerate() {\n                assert!(\n                    limb < (1u64 << 52),\n                    \"Limb {} should be < 2^52, got {}\",\n                    j,\n                    limb\n                );\n            }\n\n            // Convert back to Scalar52 manually and check it matches\n            let mut limbs_check = [0u64; 5];\n            let mask = (1u64 << 52) - 1;\n            let mut remaining = value.clone();\n\n            for j in 0..5 {\n                let limb_big = &remaining & BigUint::from(mask);\n                limbs_check[j] = limb_big.to_u64_digits().first().copied().unwrap_or(0);\n                remaining >>= 52;\n            }\n\n            // Check round-trip\n            assert_eq!(\n                scalar.limbs,\n                limbs_check,\n                \"Round-trip failed for test {}\",\n                i + 1\n            );\n\n            // Convert back to nat and verify\n            let value_check = to_nat_exec(&limbs_check);\n            assert_eq!(\n                value,\n                value_check,\n                \"Value mismatch after round-trip for test {}\",\n                i + 1\n            );\n\n            println!(\n                \"Test {}: value = {}, limbs = {:?} ✓\",\n                i + 1,\n                value,\n                scalar.limbs\n            );\n        }\n    }",
      "start_line": 1356,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_mul_v0_and_reorder().",
      "display_name": "lemma_mul_v0_and_reorder",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_mul_v0_and_reorder().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "file_name": "u64_5_as_nat_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_mul_v0_and_reorder(\n    v0: int,\n    s1: int,\n    v1: int,\n    s2: int,\n    v2: int,\n    s3: int,\n    v3: int,\n    s4: int,\n    v4: int,\n)\n    ensures\n        v0 * (v0 + s1 * v1 + s2 * v2 + s3 * v3 + s4 * v4) == s4 * (v0 * v4) + s3 * (v0 * v3) + s2\n            * (v0 * v2) + s1 * (v0 * v1) + (v0 * v0),\n{\n    lemma_mul_distributive_5_terms(v0, v0, s1 * v1, s2 * v2, s3 * v3, s4 * v4);\n\n    lemma_mul_is_associative(v0, v1, s1);\n    lemma_mul_is_associative(v0, v2, s2);\n    lemma_mul_is_associative(v0, v3, s3);\n    lemma_mul_is_associative(v0, v4, s4);\n}",
      "start_line": 17,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/identity_affine_niels().",
      "display_name": "identity_affine_niels",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/identity_affine_niels().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn identity_affine_niels() -> AffineNielsPoint {\n    AffineNielsPoint {\n        y_plus_x: crate::field::FieldElement { limbs: [1, 0, 0, 0, 0] },  // 1\n        y_minus_x: crate::field::FieldElement { limbs: [1, 0, 0, 0, 0] },  // 1\n        xy2d: crate::field::FieldElement { limbs: [0, 0, 0, 0, 0] },  // 0\n    }\n}",
      "start_line": 532,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_mod().",
      "display_name": "lemma_pow2_mul_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_mul_mod(x: nat, k: nat, s: nat)\n    requires\n        k <= s,\n    ensures\n        (x * pow2(k)) % pow2(s) == (x % pow2((s - k) as nat)) * pow2(k),\n{\n    let d = (s - k) as nat;\n\n    assert(pow2(s) == pow2(k) * pow2(d)) by {\n        lemma_pow2_adds(k, d);\n    }\n\n    assert(pow2(k) * pow2(d) > 0) by {\n        lemma_pow2_pos(s);\n    }\n\n    assert((pow2(k) * x) % (pow2(k) * pow2(d)) == pow2(k) * (x % pow2(d))) by {\n        lemma_truncate_middle(x as int, pow2(k) as int, pow2(d) as int);\n    }\n}",
      "start_line": 294,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_affine_niels_point().",
      "display_name": "spec_affine_niels_point",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_affine_niels_point().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_affine_niels_point(niels: AffineNielsPoint) -> (nat, nat, nat) {\n    let y_plus_x = spec_field_element(&niels.y_plus_x);\n    let y_minus_x = spec_field_element(&niels.y_minus_x);\n    let xy2d = spec_field_element(&niels.xy2d);\n    (y_plus_x, y_minus_x, xy2d)\n}",
      "start_line": 349,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/edwards_y_from_montgomery_u().",
      "display_name": "edwards_y_from_montgomery_u",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/edwards_y_from_montgomery_u().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn edwards_y_from_montgomery_u(u: nat) -> nat\n    recommends\n        u != math_field_sub(0, 1),\n{\n    let denom = math_field_add(u, 1);\n    let numerator = math_field_sub(u, 1);\n    math_field_mul(numerator, math_field_inv(denom))\n}",
      "start_line": 254,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_zero_is_id().",
      "display_name": "lemma_shl_zero_is_id",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_zero_is_id().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub broadcast proof fn lemma_shl_zero_is_id(v: u64)\n    ensures\n        #![trigger v << 0]\n        v << 0 == v,\n{\n    assert(v << 0 == v) by (bit_vector);\n}",
      "start_line": 25,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#as_affine().",
      "display_name": "as_affine",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#as_affine().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    pub fn as_affine(&self) -> (result: MontgomeryPoint)\n        requires\n            crate::specs::field_specs::fe51_limbs_bounded(&self.U, 54),\n            crate::specs::field_specs::fe51_limbs_bounded(&self.W, 54),\n        ensures\n    // For projective point (U:W), the affine u-coordinate is u = U/W (or 0 if W=0)\n\n            spec_montgomery_point(result) == {\n                let u_proj = spec_field_element(&self.U);\n                let w_proj = spec_field_element(&self.W);\n                if w_proj == 0 {\n                    0\n                } else {\n                    math_field_mul(u_proj, math_field_inv(w_proj))\n                }\n            },",
      "start_line": 661,
      "end_line": 21,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_square_matches_math_field_square().",
      "display_name": "lemma_square_matches_math_field_square",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_square_matches_math_field_square().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_square_matches_math_field_square(y_raw: nat, y2_raw: nat)\n    requires\n        // y2_raw comes from square()'s postcondition\n        y2_raw % p() == pow(y_raw as int, 2) as nat % p(),\n    ensures\n        y2_raw % p() == math_field_square(y_raw % p()),\n{\n    let y = y_raw % p();\n    let p = p();\n    p_gt_2();\n    \n    // pow(y_raw, 2) = y_raw * y_raw\n    assert(pow(y_raw as int, 2) == y_raw as int * y_raw as int) by {\n        reveal(pow);\n        assert(pow(y_raw as int, 2) == y_raw as int * pow(y_raw as int, 1));\n        assert(pow(y_raw as int, 1) == y_raw as int * pow(y_raw as int, 0));\n        assert(pow(y_raw as int, 0) == 1int);\n    };\n    \n    // (y_raw * y_raw) % p == ((y_raw % p) * (y_raw % p)) % p\n    assert((y_raw * y_raw) % p == (y * y) % p) by {\n        lemma_mul_mod_noop_general(y_raw as int, y_raw as int, p as int);\n    };\n    \n    // math_field_square(y) = (y * y) % p\n    assert(math_field_square(y) == (y * y) % p);\n    \n    // Chain: y2_raw % p == pow(...) % p == (y_raw * y_raw) % p == (y * y) % p == math_field_square(y)\n}",
      "start_line": 856,
      "end_line": 52,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#optional_mixed_multiscalar_mul().",
      "display_name": "optional_mixed_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#optional_mixed_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "backend",
      "body": "    pub fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: core::borrow::Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: core::borrow::Borrow<Scalar>,\n        K: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            // #[cfg(curve25519_dalek_backend = \"simd\")]\n            // VartimePrecomputedStraus::Avx2(inner) => inner.optional_mixed_multiscalar_mul(\n            //     static_scalars,\n            //     dynamic_scalars,\n            //     dynamic_points,\n            // ),\n            // #[cfg(all(curve25519_dalek_backend = \"simd\", nightly))]\n            // VartimePrecomputedStraus::Avx512ifma(inner) => inner.optional_mixed_multiscalar_mul(\n            //     static_scalars,\n            //     dynamic_scalars,\n            //     dynamic_points,\n            // ),\n            VartimePrecomputedStraus::Scalar(inner) => inner.optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points,\n            ),\n        }\n    }",
      "start_line": 148,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 Choice#unwrap_u8().",
      "display_name": "unwrap_u8",
      "symbol": "rust-analyzer cargo subtle 2.6.1 Choice#unwrap_u8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#One#one().",
      "display_name": "one",
      "symbol": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#One#one().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#select().",
      "display_name": "select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    pub fn select(&self, x: usize) -> T {\n        debug_assert_eq!(x & 1, 1);\n        debug_assert!(x < 16);\n\n        self.0[x / 2]\n    }",
      "start_line": 537,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_u8().",
      "display_name": "ct_eq_u8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_u8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn ct_eq_u8(a: &u8, b: &u8) -> (c: Choice)\n    ensures\n        choice_is_true(c) == (*a == *b),\n{\n    a.ct_eq(b)\n}",
      "start_line": 94,
      "end_line": 16,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_sign_bit_correct().",
      "display_name": "lemma_decompress_sign_bit_correct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_sign_bit_correct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_decompress_sign_bit_correct(\n    x_before_negate: nat,\n    sign_bit: u8,\n    x_after_negate: nat,\n)\n    requires\n        (x_before_negate % p()) % 2 == 0,  // sqrt_ratio_i returns even (LSB=0)\n        sign_bit == 0 || sign_bit == 1,\n        sign_bit == 1 ==> x_before_negate % p() != 0,  // x ≠ 0 when negating\n        x_after_negate == if sign_bit == 1 { math_field_neg(x_before_negate) } else { x_before_negate % p() },\n    ensures",
      "start_line": 482,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/reduce_with_q_spec().",
      "display_name": "reduce_with_q_spec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/reduce_with_q_spec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn reduce_with_q_spec(input_limbs: [u64; 5], q: u64) -> [u64; 5] {\n    let l = compute_unmasked_limbs(input_limbs, q);\n    let l0 = l[0];\n    let l1 = l[1];\n    let l2 = l[2];\n    let l3 = l[3];\n    let l4 = l[4];\n    let l0_masked = (l0 & mask51) as u64;\n    let l1_masked = (l1 & mask51) as u64;\n    let l2_masked = (l2 & mask51) as u64;\n    let l3_masked = (l3 & mask51) as u64;\n    let l4_masked = (l4 & mask51) as u64;\n    [l0_masked, l1_masked, l2_masked, l3_masked, l4_masked]\n}",
      "start_line": 154,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_limb_from_adjacent_words().",
      "display_name": "lemma_limb_from_adjacent_words",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_limb_from_adjacent_words().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "file_name": "scalar_lemmas_extra.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_limb_from_adjacent_words(\n    prev_word: u64,\n    next_word: u64,\n    prev_shift: u64,\n    high_bits: u64,\n    low_mask_shift: u64,\n    limb: nat,\n    high_part: nat,\n    low_part: nat,\n)\n    requires\n        high_bits > 0 && high_bits < 52,\n        prev_shift + high_bits == 64,\n        low_mask_shift + (52 - high_bits) == 64,\n        limb == (((prev_word >> prev_shift) | (next_word << high_bits)) & (u64::MAX >> 12)) as nat,\n        high_part == (prev_word >> prev_shift) as nat,\n        low_part == (next_word & (u64::MAX >> low_mask_shift)) as nat,\n    ensures\n        limb == high_part + pow2(high_bits as nat) * low_part,\n{\n    let mask = u64::MAX >> 12;\n    let low_mask = u64::MAX >> low_mask_shift;\n    let high_val = prev_word >> prev_shift;\n    let low_val = next_word & low_mask;\n\n    // High part is bounded by 2^high_bits\n    assert((prev_word >> prev_shift) < (1u64 << high_bits)) by (bit_vector)\n        requires\n            high_bits > 0 && high_bits < 52 && prev_shift + high_bits == 64,\n    ;\n\n    // Low part fits when shifted by high_bits\n    assert((next_word & low_mask) <= u64::MAX >> high_bits) by (bit_vector)\n        requires\n            high_bits > 0 && high_bits < 52 && low_mask_shift + (52 - high_bits) == 64 && low_mask\n                == u64::MAX >> low_mask_shift,\n    ;\n\n    // OR with mask simplifies\n    assert(((prev_word >> prev_shift) | (next_word << high_bits)) & mask == (prev_word\n        >> prev_shift) | ((next_word & low_mask) << high_bits)) by (bit_vector)\n        requires\n            high_bits > 0 && high_bits < 52 && prev_shift + high_bits == 64 && low_mask_shift + (52\n                - high_bits) == 64 && low_mask == u64::MAX >> low_mask_shift && mask == u64::MAX\n                >> 12,\n    ;\n\n    // Combined value fits in 52 bits\n    assert(((prev_word >> prev_shift) | ((next_word & low_mask) << high_bits)) < (1u64 << 52))\n        by (bit_vector)\n        requires\n            high_bits > 0 && high_bits < 52 && prev_shift + high_bits == 64 && low_mask_shift + (52\n                - high_bits) == 64 && low_mask == u64::MAX >> low_mask_shift,\n    ;\n\n    lemma_bit_or_is_plus(high_val, low_val, high_bits);\n    vstd::bits::lemma_u64_mul_pow2_le_max_iff_max_shr(low_val, high_bits, u64::MAX);\n    vstd::bits::lemma_u64_shl_is_mul(low_val, high_bits);\n}",
      "start_line": 121,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_to_le_bytes().",
      "display_name": "u32_to_le_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_to_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub fn u32_to_le_bytes(x: u32) -> (bytes: [u8; 4])\n    ensures\n        bytes_seq_to_nat(seq_from4(&bytes)) == x as nat,\n{\n    x.to_le_bytes()\n}",
      "start_line": 95,
      "end_line": 23,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_identity_affine_niels().",
      "display_name": "spec_identity_affine_niels",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_identity_affine_niels().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_identity_affine_niels() -> (nat, nat, nat) {\n    (1nat, 1nat, 0nat)\n}",
      "start_line": 527,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base().",
      "display_name": "mul_base",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_base(scalar: &Scalar) -> (result: Self)\n        requires\n            scalar.bytes[31] <= 127,\n        ensures\n            is_well_formed_edwards_point(result),\n            // Functional correctness: result = [scalar] * B where B is the basepoint\n            edwards_point_as_affine(result) == edwards_scalar_mul(\n                spec_ed25519_basepoint(),\n                spec_scalar(scalar),\n            ),\n    {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        { scalar * constants::ED25519_BASEPOINT_POINT }\n        #[cfg(feature = \"precomputed-tables\")]\n        { scalar * constants::ED25519_BASEPOINT_TABLE }\n    }",
      "start_line": 1724,
      "end_line": 20,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn identity() -> (result: MontgomeryPoint)\n        ensures\n    // The identity point has u-coordinate = 0\n\n            spec_montgomery(result) == 0,\n    {\n        let result = MontgomeryPoint([0u8;32]);\n        proof {\n            // The byte array [0, 0, ..., 0] represents the field element 0\n            assume(spec_field_element_from_bytes(&result.0) == 0);\n        }\n        result\n    }",
      "start_line": 207,
      "end_line": 16,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_q_arr().",
      "display_name": "compute_q_arr",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_q_arr().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn compute_q_arr(limbs: [u64; 5]) -> [u64; 5] {\n    let q0 = ((limbs[0] + 19) as u64 >> 51) as u64;\n    let q1 = ((limbs[1] + q0) as u64 >> 51) as u64;\n    let q2 = ((limbs[2] + q1) as u64 >> 51) as u64;\n    let q3 = ((limbs[3] + q2) as u64 >> 51) as u64;\n    let q4 = ((limbs[4] + q3) as u64 >> 51) as u64;\n    [q0, q1, q2, q3, q4]\n}",
      "start_line": 130,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_zero_case().",
      "display_name": "lemma_invert_zero_case",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_zero_case().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "file_name": "invert_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_invert_zero_case(\n    self_fe: &FieldElement51,\n    t3: &FieldElement51,\n    t20: &FieldElement51,\n    t21: &FieldElement51,\n)\n    requires\n        spec_field_element(self_fe) == 0,\n        // From pow22501 postcondition\n        spec_field_element(t3) == (pow(spec_field_element(self_fe) as int, 11) as nat) % p(),\n        // From mul postcondition\n        spec_field_element(t21) == math_field_mul(spec_field_element(t20), spec_field_element(t3)),\n    ensures\n        spec_field_element(t21) == 0,\n{\n    assert(0nat % p() == 0) by {\n        pow255_gt_19();  // Proves p() > 0 (since p = 2^255 - 19)\n        lemma_mod_is_mod_recursive(0, p() as int);\n    }\n\n    // From requires: spec_field_element(t3) == (pow(0, 11) as nat) % p() == 0\n    assert(spec_field_element(t3) == 0) by {\n        assert(pow(0int, 11) == 0) by {\n            lemma0_pow(11);  // vstd lemma: proves 0^k = 0 for k > 0\n        }\n    }\n\n    // From mul postcondition: t21 = t20 * t3 = t20 * 0 = 0\n    assert(spec_field_element(t21) == 0) by {\n        assert(spec_field_element(t21) == math_field_mul(spec_field_element(t20), 0));\n        assert((spec_field_element(t20) * 0) == 0);\n    }\n}",
      "start_line": 81,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_projective_point().",
      "display_name": "is_valid_projective_point",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_projective_point().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_valid_projective_point(point: ProjectivePoint) -> bool {\n    let (x, y, z) = spec_projective_point_edwards(point);\n\n    // Z must be non-zero\n    z != 0 &&\n    // The affine coordinates (X/Z, Y/Z) must be on the curve\n    math_on_edwards_curve(\n        math_field_mul(x, math_field_inv(z)),\n        math_field_mul(y, math_field_inv(z)),\n    )\n}",
      "start_line": 674,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_negate_projective_niels().",
      "display_name": "spec_negate_projective_niels",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_negate_projective_niels().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_negate_projective_niels(p: (nat, nat, nat, nat)) -> (nat, nat, nat, nat) {\n    let (y_plus_x, y_minus_x, z, t2d) = p;\n    (y_minus_x, y_plus_x, z, math_field_neg(t2d))\n}",
      "start_line": 577,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_by_sum().",
      "display_name": "lemma_shr_by_sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_by_sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_shr_by_sum(v: u64, a: nat, b: nat)\n    requires\n        (a + b) < 64,\n    ensures\n        (v >> (a + b)) == ((v >> a) >> b),\n{\n    if (a == 0 || b == 0) {\n        broadcast use lemma_shr_zero_is_id;\n\n    } else {\n        lemma2_to64_rest();  // pow2(64)\n        lemma_pow2_strictly_increases(a, a + b);\n        lemma_pow2_strictly_increases(b, a + b);\n        lemma_pow2_strictly_increases(a + b, 64);  // pow2(a + b) fits in u64\n\n        // 2^(a + b) == 2^a * 2^b\n        lemma_pow2_adds(a, b);\n        // v >> a + b = v / 2^(a+b)\n        lemma_u64_shr_is_div(v, (a + b) as u64);\n        // v >> a = v / 2^a\n        lemma_u64_shr_is_div(v, a as u64);\n        // (v / 2^a) << b = (v / 2^a) / 2^b\n        lemma_u64_shr_is_div((v / (pow2(a) as u64)) as u64, b as u64);\n\n        // 2^k > 0\n        lemma_pow2_pos(a);\n        lemma_pow2_pos(b);\n\n        // v / 2^a / 2^b = v / 2^(a + b)\n        lemma_div_denominator(v as int, pow2(a) as int, pow2(b) as int);\n    }\n}",
      "start_line": 136,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#from_bytes_le().",
      "display_name": "from_bytes_le",
      "symbol": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#from_bytes_le().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_canonical_scalar52().",
      "display_name": "arb_canonical_scalar52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_canonical_scalar52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn arb_canonical_scalar52() -> impl Strategy<Value = Scalar52> {\n        // Generate random bytes and interpret as BigUint, then reduce mod L\n        proptest::collection::vec(any::<u8>(), 32..=64).prop_map(|bytes| {\n            let l = group_order_exec();\n            let value = BigUint::from_bytes_le(&bytes) % &l;\n\n            // Convert BigUint to limbs in base 2^52\n            let mut limbs = [0u64; 5];\n            let mask = (1u64 << 52) - 1;\n            let mut remaining = value;\n\n            for i in 0..5 {\n                let limb_big = &remaining & BigUint::from(mask);\n                limbs[i] = limb_big.to_u64_digits().first().copied().unwrap_or(0);\n                remaining >>= 52;\n            }\n\n            Scalar52 { limbs }\n        })\n    }",
      "start_line": 1271,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 CtOption#is_some().",
      "display_name": "is_some",
      "symbol": "rust-analyzer cargo subtle 2.6.1 CtOption#is_some().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "display_name": "lemma_no_square_root_when_times_i",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "file_name": "sqrt_ratio_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_no_square_root_when_times_i(u: nat, v: nat)\n    requires\n        v % p() != 0,\n        u % p() != 0,\n        // There exists x with x²·v = i·u\n        exists|x: nat| x < p() && math_field_mul(math_field_square(x), v) == (spec_sqrt_m1() * u) % p(),\n    ensures\n        // Then no r exists with r²·v = u or r²·v = -u\n        forall|r: nat| r < p() ==>\n            math_field_mul(math_field_square(r), v) != u % p() &&\n            math_field_mul(math_field_square(r), v) != math_field_neg(u),\n{\n    // Step 1: Establish that i and -i are not squares\n    assert(!is_square_mod_p(spec_sqrt_m1())) by {\n        axiom_sqrt_m1_not_square();\n    };\n    \n    assert(!is_square_mod_p((p() - spec_sqrt_m1()) as nat)) by {\n        axiom_neg_sqrt_m1_not_square();\n    };\n    \n    // Step 2: Get the witness x with x²·v = i·u\n    let x = choose|x: nat| x < p() && math_field_mul(math_field_square(x), v) == (spec_sqrt_m1() * u) % p();\n    let i = spec_sqrt_m1();\n    let p = p();\n    \n    // Step 3: Show x ≠ 0 (if x = 0, then 0 = i·u, but u ≠ 0 and i ≠ 0)\n    assert(x != 0) by {\n        if x == 0 {\n            // x² = 0, so x²·v = 0\n            assert(math_field_square(0nat) == 0) by { lemma_small_mod(0nat, p); };\n            assert(math_field_mul(0, v) == 0) by { lemma_small_mod(0nat, p); };\n            // But x²·v = i·u ≠ 0 (since i ≠ 0 and u ≠ 0)\n            assert(i != 0) by {\n                if i == 0 {\n                    assert((i * i) % p == 0);\n                    axiom_sqrt_m1_squared();\n                    assert((i * i) % p == (p - 1) as nat);\n                    assert(false);\n                }\n            };\n            assert((i * u) % p != 0) by {\n                // i ≠ 0, u ≠ 0, p prime => i·u ≠ 0 (mod p)\n                // This is the contrapositive of Euclid's lemma\n                if (i * u) % p == 0 {\n                    axiom_p_is_prime();\n                    lemma_euclid_prime(i, u, p);\n                    // Gives i % p == 0 or u % p == 0\n                    assert(i % p != 0) by { lemma_small_mod(i, p); };\n                    // So u % p == 0, but u % p != 0 by precondition\n                    assert(false);\n                }\n            };\n            assert(false);\n        }\n    };\n    \n    // Step 4: For any r, show r²·v ≠ u and r²·v ≠ -u by contradiction\n    assert forall|r: nat| r < p ==>\n        math_field_mul(math_field_square(r), v) != u % p &&\n        math_field_mul(math_field_square(r), v) != math_field_neg(u)\n    by {\n        // Proof by contradiction for both cases\n        \n        // Case 1: If r²·v = u, then (r/x)² = u/(i·u) = 1/i = -i (not a square)\n        if math_field_mul(math_field_square(r), v) == u % p {\n            // We have: r²·v ≡ u (mod p) and x²·v ≡ i·u (mod p)\n            // Need to derive that -i is a square, which is a contradiction\n            \n            // x % p != 0 (since x < p and x != 0)\n            assert(x % p != 0) by { lemma_small_mod(x, p); };\n            \n            // Define q = r · x⁻¹\n            let x_inv = math_field_inv(x);\n            let q = math_field_mul(r, x_inv);\n            \n            // q² = (r · x⁻¹)² = r² · (x⁻¹)² = r² · x⁻²\n            let q2 = math_field_square(q);\n            let r2 = math_field_square(r);\n            let x2 = math_field_square(x);\n            \n            // Step 1: Show q² = r² · inv(x²) using lemma_quotient_of_squares\n            assert(q2 == math_field_mul(r2, math_field_inv(x2))) by {\n                // q = r · inv(x), so q² = (r · inv(x))²\n                // By lemma_quotient_of_squares: r²/x² = (r/x)² = (r · inv(x))²\n                // i.e., r² · inv(x²) = (r · inv(x))²\n                lemma_quotient_of_squares(r, x);\n            };\n            \n            // Step 2-4: Combined algebraic + contradiction proof\n            // The key algebraic fact: q² = -i (which would mean -i is a square)\n            // But -i is NOT a square by axiom - contradiction!\n            //\n            // Algebraic derivation (why q² = -i):\n            //   From preconditions: r²·v = u and x²·v = i·u\n            //   => r² = u · inv(v) and x² = (i·u) · inv(v)\n            //   => r² / x² = u / (i·u) = 1/i = -i (by lemma_i_inverse_is_neg_i)\n            //   => q² = (r/x)² = r²/x² = -i\n            //\n            // If q² = -i, then -i is a square (with witness q).\n            // But axiom_neg_sqrt_m1_not_square says -i is NOT a square.\n            // Contradiction!\n            \n            // First establish i ≠ 0 (needed for p - i < p)\n            // i = spec_sqrt_m1() which satisfies i² = -1\n            // If i = 0, then i² = 0, but i² = -1 = p-1 ≠ 0. Contradiction.\n            assert(i != 0) by {\n                if i == 0 {\n                    axiom_sqrt_m1_squared();\n                    assert(math_field_square(0nat) == 0);\n                    assert(math_field_neg(1nat) != 0);\n                    assert(false);\n                }\n            };\n            \n            // Define -i in the form used by the axiom: (p - i) as nat\n            let neg_i = (p - i) as nat;\n            \n            // Connect math_field_neg(i) to (p - i) as nat\n            assert(math_field_neg(i) == neg_i) by {\n                // math_field_neg(i) = (p - i % p) % p\n                // Since i < p: i % p = i\n                // So math_field_neg(i) = (p - i) % p\n                // Since 0 < i < p: 0 < p - i < p\n                // So (p - i) % p = p - i\n                lemma_small_mod(i, p);\n                assert(p - i < p);  // Since i > 0\n                lemma_small_mod((p - i) as nat, p);\n            };\n            \n            // Get the axiom that -i is not a square (using axiom's exact form)\n            axiom_neg_sqrt_m1_not_square();\n            // axiom gives: !is_square_mod_p((p() - spec_sqrt_m1()) as nat)\n            // Since i = spec_sqrt_m1(), this is !is_square_mod_p(neg_i)\n            assert(!is_square_mod_p(neg_i));\n            \n            // Prove q² ≡ -i (mod p) (would make -i a square, contradiction)\n            // q < p (since q is a field element)\n            assert(q < p) by { lemma_mod_bound((r * x_inv) as int, p as int); };\n            \n            // The core algebraic step: q² = -i\n            // This uses the field division lemmas to transform:\n            //   q² = (r/x)² = r²/x² = (u·inv(v))/(i·u·inv(v)) = u/(i·u) = 1/i = -i\n            //\n            // We have established: q2 = r2 * inv(x2) (mod p) by lemma_quotient_of_squares\n            // From r²·v = u: r2 = u · inv(v)\n            // From x²·v = i·u: x2 = (i·u) · inv(v)\n            //\n            // So: q2 = (u · inv(v)) · inv((i·u) · inv(v))\n            //       = (u · inv(v)) · (inv(i·u) · v)        [inv of product, double inverse]\n            //       = u · inv(i·u)                         [inv(v) · v = 1]\n            //       = u · inv(i) · inv(u)                  [inv of product]\n            //       = inv(i)                               [u · inv(u) = 1]\n            //       = -i                                   [lemma_i_inverse_is_neg_i]\n            \n            assert((q * q) % p == neg_i % p) by {\n                // Key intermediate values\n                let inv_v = math_field_inv(v);\n                \n                // From preconditions:\n                // math_field_mul(r2, v) = u % p, i.e., r2 * v % p = u % p\n                // math_field_mul(x2, v) = (i * u) % p, i.e., x2 * v % p = (i * u) % p\n                \n                // Since we have r2 * v ≡ u and v ≠ 0:\n                // r2 ≡ u * inv(v) (mod p)\n                // Similarly, x2 ≡ (i * u) * inv(v) (mod p)\n                \n                // q2 = r2 * inv(x2) (mod p)\n                // From lemma_quotient_of_squares, q2 = (q * q) % p\n                \n                // The algebraic chain is complex. For now we axiomatize.\n                // In a full proof, we would:\n                // 1. Show r2 = u * inv(v) (mod p) from r2 * v = u\n                // 2. Show x2 = (i*u) * inv(v) (mod p) from x2 * v = i*u\n                // 3. Use lemma_inv_of_product to simplify inv(x2)\n                // 4. Cancel terms to get q2 = inv(i)\n                // 5. Use lemma_i_inverse_is_neg_i to get q2 = -i\n                \n                admit(); // Full algebraic chain\n            };\n            \n            // Now we have a square root of -i, so -i is a square\n            // is_square_mod_p(a) := exists|y: nat| (y * y) % p() == a % p()\n            assert(is_square_mod_p(neg_i));\n            \n            // Contradiction: -i is both a square and not a square\n            assert(false);\n        }\n        \n        // Case 2: If r²·v = -u, then (r/x)² = -u/(i·u) = -1/i = i (not a square)\n        if math_field_mul(math_field_square(r), v) == math_field_neg(u) {\n            // We have: r²·v ≡ -u (mod p) and x²·v ≡ i·u (mod p)\n            // Need to derive that i is a square, which is a contradiction\n            \n            // x % p != 0 (since x < p and x != 0)\n            assert(x % p != 0) by { lemma_small_mod(x, p); };\n            \n            // Define q = r · x⁻¹\n            let x_inv = math_field_inv(x);\n            let q = math_field_mul(r, x_inv);\n            \n            // q² = (r · x⁻¹)² \n            let q2 = math_field_square(q);\n            let r2 = math_field_square(r);\n            let x2 = math_field_square(x);\n            \n            // Step 1: Show q² = r² · inv(x²) using lemma_quotient_of_squares\n            assert(q2 == math_field_mul(r2, math_field_inv(x2))) by {\n                lemma_quotient_of_squares(r, x);\n            };\n            \n            // Step 2: Show r² · inv(x²) = -u · inv(i·u) = -inv(i) = -(-i) = i\n            // Derivation:\n            //   r²·v = -u  =>  r² = (-u) · inv(v)\n            //   x²·v = i·u  =>  x² = (i·u) · inv(v)\n            //\n            // r² · inv(x²) = ((-u) · inv(v)) · inv((i·u) · inv(v))\n            //              = (-u) · inv(i·u)                       [v terms cancel]\n            //              = (-u) · inv(i) · inv(u)                [inv of product]\n            //              = -inv(i)                               [u · inv(u) = 1]\n            //              = -(-i)                                 [by lemma_i_inverse_is_neg_i]\n            //              = i\n            assert(q2 == i) by {\n                // The key insight: (r²·v)/(x²·v) = -u/(i·u) = -(1/i) = -(-i) = i\n                // And (r²·v)/(x²·v) = r²/x² = q²\n                admit();\n            };\n            \n            // Step 3: Get the axiom that i is NOT a square\n            axiom_sqrt_m1_not_square();\n            assert(!is_square_mod_p(i));\n            \n            // q < p (since q is a field element)\n            assert(q < p) by { lemma_mod_bound((r * x_inv) as int, p as int); };\n            \n            // i < p (since i is a field element)\n            assert(i < p) by { \n                lemma_mod_bound(spec_field_element_as_nat(&constants::SQRT_M1) as int, p as int); \n            };\n            lemma_small_mod(i, p);\n            \n            // The core algebraic step: (q * q) % p == i % p\n            assert((q * q) % p == i % p) by {\n                // From q2 == i and q2 = (q * q) % p\n                // And i % p == i since i < p\n                admit();\n            };\n            \n            // is_square_mod_p(i) requires exists|y: nat| (y * y) % p() == i % p()\n            // We have q such that (q * q) % p == i % p\n            assert(is_square_mod_p(i));\n            \n            // Step 4: Contradiction: i is both a square and not a square\n            assert(false);\n        }\n    };\n}",
      "start_line": 446,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 16
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "display_name": "pow255_gt_19",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub proof fn pow255_gt_19()\n    ensures\n        pow2(255) > 19,\n{\n    lemma2_to64();  // 2^5\n    lemma_pow2_strictly_increases(5, 255);\n}",
      "start_line": 18,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 36,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_shift_bounded().",
      "display_name": "lemma_c_i_shift_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_shift_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_c_i_shift_bounded(a: [u64; 5], bound: u64)\n    requires\n        19 * bound <= u64::MAX,\n        77 * (bound * bound) + u64::MAX <= ((u64::MAX as u128) << 51),\n        ci_0_val_boundaries(a, bound),\n    ensures\n        ci_val_boundaries(a),\n{\n    lemma_shr_51_fits_u64(c0_val(a));\n    lemma_shr_51_fits_u64(c1_val(a));\n    lemma_shr_51_fits_u64(c2_val(a));\n    lemma_shr_51_fits_u64(c3_val(a));\n    lemma_shr_51_fits_u64(c4_val(a));\n}",
      "start_line": 184,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Sub#sub().",
      "display_name": "sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Sub#sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn sub(self, other: &'b EdwardsPoint) -> (result:\n        EdwardsPoint)/* requires clause in SubSpecImpl<&EdwardsPoint> for &EdwardsPoint above:\n            is_well_formed_edwards_point(*self) && is_well_formed_edwards_point(*rhs)\n        */\n\n        ensures\n            is_valid_edwards_point(result),\n            // Semantic correctness: affine subtraction law\n            ({\n                let (x1, y1) = edwards_point_as_affine(*self);\n                let (x2, y2) = edwards_point_as_affine(*other);\n                edwards_point_as_affine(result) == edwards_sub(x1, y1, x2, y2)\n            }),",
      "start_line": 1460,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/radix_16_digit_bounded().",
      "display_name": "radix_16_digit_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/radix_16_digit_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn radix_16_digit_bounded(digit: i8) -> bool {\n    -8 <= digit && digit <= 8\n}",
      "start_line": 231,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "display_name": "step_1",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub(super) fn step_1(repr: &CompressedEdwardsY) -> (result: (\n        Choice,\n        FieldElement,\n        FieldElement,\n        FieldElement,\n    ))  // Result components: (is_valid, X, Y, Z)\n        ensures\n    // The returned Y field element matches the one extracted from the compressed representation\n\n            ({\n                let (is_valid, X, Y, Z) = result;\n                spec_field_element(&Y) == spec_field_element_from_bytes(&repr.0)\n                    &&\n                // The returned Z field element is 1\n                spec_field_element(&Z) == 1\n                    &&\n                // The choice is true iff the Y is valid and (X, Y) is on the curve\n                (choice_is_true(is_valid) <==> math_is_valid_y_coordinate(spec_field_element(&Y)))\n                    && (choice_is_true(is_valid) ==> math_on_edwards_curve(\n                    spec_field_element(&X),\n                    spec_field_element(&Y),\n                )) &&\n                // Limb bounds for step_2\n                // X is 52-bit bounded from sqrt_ratio_i (relaxed from 51)\n                fe51_limbs_bounded(&X, 52) && fe51_limbs_bounded(&Y, 51) && fe51_limbs_bounded(\n                    &Z,\n                    51,\n                ) &&\n                // NEW: X is the non-negative root (LSB = 0) - from sqrt_ratio_i\n                (spec_field_element(&X) % p()) % 2 == 0 &&\n                // NEW: X is bounded (< p) - from sqrt_ratio_i\n                spec_field_element(&X) < p()\n            }),",
      "start_line": 308,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 24
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "display_name": "nonspec_map_to_curve",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn nonspec_map_to_curve<D>(bytes: &[u8]) -> EdwardsPoint where\n        D: Digest<OutputSize = U64> + Default,\n     {\n        let mut hash = D::new();\n        hash.update(bytes);\n        let h = hash.finalize();\n        let mut res = [0u8;32];\n        res.copy_from_slice(&h[0..32]);\n\n        let sign_bit = (res[31] & 0x80) >> 7;\n\n        let fe = FieldElement::from_bytes(&res);\n\n        let M1 = crate::montgomery::elligator_encode(&fe);\n        let E1_opt = M1.to_edwards(sign_bit);\n\n        E1_opt.expect(\n            \"Montgomery conversion to Edwards point in Elligator failed\",\n        ).mul_by_cofactor()\n    }",
      "start_line": 1254,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sign_bit_one_implies_x_nonzero().",
      "display_name": "lemma_sign_bit_one_implies_x_nonzero",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sign_bit_one_implies_x_nonzero().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_sign_bit_one_implies_x_nonzero(sign_bit: u8, x: nat)\n    requires\n        sign_bit == 1,\n        sign_bit == ((x % p()) % 2) as u8,  // sign_bit = LSB(x)\n    ensures\n        x % p() != 0,\n{\n    // sign_bit = 1 means LSB(x % p) = 1\n    // But LSB(0) = 0, so x % p ≠ 0\n    if x % p() == 0 {\n        assert((0nat % 2) == 0);  // contradiction with sign_bit = 1\n    }\n}",
      "start_line": 554,
      "end_line": 50,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "display_name": "lemma_fundamental_div_mod",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "is_libsignal": false,
      "caller_count": 39,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/binomial_sum().",
      "display_name": "binomial_sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/binomial_sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "spec fn binomial_sum(a: nat, n: nat, max_k: nat) -> nat\n    decreases max_k,\n{\n    if max_k == 0 {\n        binomial(n, 0) * pow(a as int, 0) as nat\n    } else {\n        binomial_sum(a, n, (max_k - 1) as nat) + binomial(n, max_k) * pow(a as int, max_k) as nat\n    }\n}",
      "start_line": 506,
      "end_line": 21,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_montgomery_affine().",
      "display_name": "is_valid_montgomery_affine",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_montgomery_affine().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_valid_montgomery_affine(point: MontgomeryAffine) -> bool {\n    match point {\n        MontgomeryAffine::Infinity => true,\n        MontgomeryAffine::Finite { u, v } => math_on_montgomery_curve(u, v),\n    }\n}",
      "start_line": 41,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "display_name": "lemma_boundary_byte_combines",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_boundary_byte_combines(\n    low_limb: u64,\n    high_limb: u64,\n    byte: u8,\n    low_shift: nat,\n    low_bits: nat,\n)\n    requires\n        low_limb < pow2(51),\n        high_limb < pow2(51),\n        low_bits < 8,\n        low_shift + low_bits == 51,  // Strengthened from <= to == (all call sites use equality)\n        byte == ((low_limb >> low_shift) | (high_limb << low_bits)) as u8,\n    ensures\n        byte as nat == (low_limb as nat / pow2(low_shift)) % pow2(low_bits) + (high_limb as nat\n            % pow2((8 - low_bits) as nat)) * pow2(low_bits),\n{\n    lemma2_to64();\n\n    assert(low_limb >> low_shift == low_limb as nat / pow2(low_shift)) by {\n        lemma_u64_shr_is_div(low_limb, low_shift as u64);\n    }\n\n    assert(pow2(51) == pow2(low_shift) * pow2(low_bits) == pow2(low_bits) * pow2(low_shift)) by {\n        lemma_pow2_adds(low_shift, low_bits);\n        lemma_mul_is_commutative(pow2(low_bits) as int, pow2(low_shift) as int);\n    }\n\n    assert(low_limb as nat / pow2(low_shift) < pow2(low_bits)) by {\n        assert(pow2(51) / pow2(low_shift) == pow2(low_bits)) by {\n            lemma_div_by_multiple(pow2(low_bits) as int, pow2(low_shift) as int);\n        }\n        assert(pow2(low_shift) > 0) by {\n            lemma_pow2_pos(low_shift);\n        }\n        lemma_div_by_multiple_is_strongly_ordered(\n            low_limb as int,\n            pow2(51) as int,\n            pow2(low_bits) as int,\n            pow2(low_shift) as int,\n        );\n    }\n\n    let a = low_limb >> low_shift;\n    let b = high_limb;\n\n    assert(b << low_bits == high_limb * pow2(low_bits)) by {\n        assert(b * pow2(low_bits) < u64::MAX) by {\n            assert(b * pow2(low_bits) < pow2(51 + 8)) by {\n                lemma_pow2_strictly_increases(low_bits, 8);\n                lemma_mul_lt(b as nat, pow2(51), pow2(low_bits), pow2(8));\n                lemma_pow2_adds(51, 8);\n            }\n            assert(pow2(59) <= u64::MAX) by {\n                lemma_pow2_le_max64(59);\n            }\n        }\n        lemma_u64_shl_is_mul(high_limb, low_bits as u64);\n    }\n\n    assert((a | b << low_bits) == a + (b << low_bits)) by {\n        assert(b <= (u64::MAX >> low_bits)) by {\n            assert(u64::MAX >> low_bits == u64::MAX as nat / pow2(low_bits)) by {\n                lemma_u64_shr_is_div(u64::MAX, low_bits as u64);\n            }\n            assert(u64::MAX as nat / pow2(low_bits) >= u64::MAX as nat / pow2(8)) by {\n                lemma_pow2_pos(low_bits);\n                lemma_pow2_strictly_increases(low_bits, 8);\n                lemma_div_is_ordered_by_denominator(\n                    u64::MAX as int,\n                    pow2(low_bits) as int,\n                    pow2(8) as int,\n                );\n            }\n            assert(u64::MAX / 256 >= pow2(51)) by {\n                lemma2_to64_rest();\n            }\n        }\n\n        assert(pow2(low_bits) == 1u64 << low_bits) by {\n            lemma_shift_is_pow2(low_bits);\n        }\n\n        assert((a | b << low_bits) == a + (b << low_bits)) by {\n            lemma_bit_or_is_plus(a, b, low_bits as u64);\n        }\n    }\n\n    assert((a | (b << low_bits)) as u8 == (a + (b * pow2(low_bits))) as nat % pow2(8)) by {\n        lemma_u8_cast_is_mod_256(a | (b << low_bits));\n    }\n\n    assert((a + (b * pow2(low_bits))) as nat % pow2(8) == a as nat % pow2(8) + (b as nat * pow2(\n        low_bits,\n    )) % pow2(8)) by {\n        lemma_binary_sum_mod_decomposition(a as nat, b as nat, low_bits, 8);\n    }\n\n    assert((low_limb as nat / pow2(low_shift)) % pow2(8) == ((low_limb as nat) % pow2(\n        low_shift + 8,\n    )) / pow2(low_shift)) by {\n        lemma_pow2_div_mod(low_limb as nat, low_shift, 8);\n    }\n\n    assert(((low_limb as nat) % pow2(low_shift + 8)) == low_limb as nat) by {\n        lemma_pow2_strictly_increases(\n            low_shift + low_bits  /* = 51 */\n            ,\n            low_shift + 8,\n        );\n        lemma_small_mod(low_limb as nat, pow2(low_shift + 8));\n    }\n\n    assert(low_limb as nat / pow2(low_shift) == (low_limb as nat / pow2(low_shift)) % pow2(\n        low_bits,\n    )) by {\n        lemma_small_mod(low_limb as nat / pow2(low_shift), pow2(low_bits));\n    }\n\n    assert((b as nat * pow2(low_bits)) % pow2(8) == (b as nat % pow2((8 - low_bits) as nat)) * pow2(\n        low_bits,\n    )) by {\n        lemma_pow2_mul_mod(b as nat, low_bits, 8);\n    }\n\n}",
      "start_line": 1929,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 19
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar52: {:?}\", self.limbs)\n    }",
      "start_line": 73,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_quad_prod().",
      "display_name": "lemma_mul_quad_prod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_quad_prod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_mul_quad_prod(a1: int, b1: int, a2: int, b2: int)\n    ensures\n        (a1 * b1) * (a2 * b2) == (a1 * a2) * (b1 * b2),\n{\n    // commutativity is baked-in\n    // (a1 * b1) * (a2 * b2) =  ((a1 * b1) * a2) * b2\n    lemma_mul_is_associative(a1 * b1, a2, b2);\n    // (a1 * b1) * a2 = a2 * (a1 * b1) = (a2 * a1) * b1\n    lemma_mul_is_associative(a2, a1, b1);\n    // ((a2 * a1) * b1) * b2 = (a2 * a1) * (b1 * b2)\n    lemma_mul_is_associative(a2 * a1, b1, b2);\n}",
      "start_line": 191,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/carry_val().",
      "display_name": "carry_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/carry_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn carry_val(a: [u64; 5]) -> u64 {\n    (c4_val(a) >> 51) as u64\n}",
      "start_line": 76,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/MultiscalarMul#multiscalar_mul().",
      "display_name": "multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/MultiscalarMul#multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "curve25519-dalek/src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>;\n}\n\n/// A trait for variable-time multiscalar multiplication without precomputation.\npub trait VartimeMultiscalarMul {\n    /// The type of point being multiplied, e.g., `RistrettoPoint`.\n    type Point;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// `Option`s of points, compute either `Some(Q)`, where\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// if all points were `Some(P_i)`, or else return `None`.\n    ///\n    /// This function is particularly useful when verifying statements\n    /// involving compressed points.  Accepting `Option<Point>` allows\n    /// inlining point decompression into the multiscalar call,\n    /// avoiding the need for temporary buffers.\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    /// let abc = [a,b,c];\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    /// let PQR = [P, Q, R];\n    ///\n    /// let compressed = [P.compress(), Q.compress(), R.compress()];\n    ///\n    /// // Now we can compute A1 = a*P + b*Q + c*R using P, Q, R:\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &PQR);\n    ///\n    /// // Or using the compressed points:\n    /// let A2 = RistrettoPoint::optional_multiscalar_mul(\n    ///     &abc,\n    ///     compressed.iter().map(|pt| pt.decompress()),\n    /// );\n    ///\n    /// assert_eq!(A2, Some(A1));\n    ///\n    /// // It's also possible to mix compressed and uncompressed points:\n    /// let A3 = RistrettoPoint::optional_multiscalar_mul(\n    ///     abc.iter()\n    ///         .chain(abc.iter()),\n    ///     compressed.iter().map(|pt| pt.decompress())\n    ///         .chain(PQR.iter().map(|&pt| Some(pt))),\n    /// );\n    ///\n    /// assert_eq!(A3, Some(A1+A1));\n    /// # }\n    /// ```\n    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<Self::Point>>;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// public points, compute\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// using variable-time operations.\n    ///\n    /// It is an error to call this function with two iterators of different lengths.\n    ///\n    /// # Examples\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    ///\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    ///\n    /// // A1 = a*P + b*Q + c*R\n    /// let abc = [a,b,c];\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &[P,Q,R]);\n    /// // Note: (&abc).into_iter(): Iterator<Item=&Scalar>\n    ///\n    /// // A2 = (-a)*P + (-b)*Q + (-c)*R\n    /// let minus_abc = abc.iter().map(|x| -x);\n    /// let A2 = RistrettoPoint::vartime_multiscalar_mul(minus_abc, &[P,Q,R]);\n    /// // Note: minus_abc.into_iter(): Iterator<Item=Scalar>\n    ///\n    /// assert_eq!(A1.compress(), (-A2).compress());\n    /// # }\n    /// ```\n    fn vartime_multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>,\n        Self::Point: Clone,\n    {\n        Self::optional_multiscalar_mul(\n            scalars,\n            points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }\n}",
      "start_line": 129,
      "end_line": 23,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "display_name": "select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    pub fn select(&self, x: i8) -> (result: ProjectiveNielsPoint)\n        requires\n            -8 <= x,\n            x <= 8,\n            // Table entries must have bounded limbs\n            lookup_table_projective_limbs_bounded(self.0),\n        ensures\n    // Formal specification for all cases:\n\n            (x > 0 ==> result == self.0[(x - 1) as int]),\n            (x == 0 ==> result == identity_projective_niels()),\n            (x < 0 ==> result == negate_projective_niels(self.0[((-x) - 1) as int])),\n            // Limb bounds for the result (derived from table bounds)\n            fe51_limbs_bounded(&result.Y_plus_X, 54),\n            fe51_limbs_bounded(&result.Y_minus_X, 54),\n            fe51_limbs_bounded(&result.Z, 54),\n            fe51_limbs_bounded(&result.T2d, 54),\n    {\n        /* ORIGINAL CODE: for generic type T, $name, $size, $neg, $range, and $conv_range.\n\n            debug_assert!(x >= $neg);\n            debug_assert!(x as i16 <= $size as i16); // XXX We have to convert to i16s here for the radix-256 case.. this is wrong.\n\n            // Compute xabs = |x|\n                let xmask = x as i16 >> 7;\n                let xabs = (x as i16 + xmask) ^ xmask;\n\n                // Set t = 0 * P = identity\n                let mut t = T::identity();\n                for j in $range {\n                    // Copy `points[j-1] == j*P` onto `t` in constant time if `|x| == j`.\n                    let c = (xabs as u16).ct_eq(&(j as u16));\n                    t.conditional_assign(&self.0[j - 1], c);\n                }\n                // Now t == |x| * P.\n\n                let neg_mask = Choice::from((xmask & 1) as u8);\n                t.conditional_negate(neg_mask);\n                // Now t == x * P.\n\n                t\n        In our instantiation we have T = ProjectiveNielsPoint, $name = LookupTable, $size = 8, $neg = -8, $range = 1..9, and $conv_range = 0..7.\n         */\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(x >= -8);\n            debug_assert!(x <= 8);\n        }\n\n        assume(false);\n\n        // Compute xabs = |x|\n        let xmask = x as i16 >> 7;\n        let xabs = (x as i16 + xmask) ^ xmask;\n\n        // Set t = 0 * P = identity\n        let mut t = ProjectiveNielsPoint::identity();\n        for j in 1..9 {\n            // Copy `points[j-1] == j*P` onto `t` in constant time if `|x| == j`.\n            /* ORIGINAL CODE: let c = (xabs as u16).ct_eq(&(j as u16)); */\n            let c = ct_eq_u16(&(xabs as u16), &(j as u16));\n            /* ORIGINAL CODE: t.conditional_assign(&self.0[j - 1], c); */\n            conditional_assign_generic(&mut t, &self.0[j - 1], c);\n        }\n        // Now t == |x| * P.\n\n        let neg_mask = Choice::from((xmask & 1) as u8);\n        /* ORIGINAL CODE: t.conditional_negate(neg_mask); */\n        conditional_negate_generic(&mut t, neg_mask);\n        // Now t == x * P.\n\n        t\n    }",
      "start_line": 202,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 12
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"ProjectivePoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z\n        )\n    }",
      "start_line": 869,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_sum_bounded().",
      "display_name": "edwards_point_sum_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_sum_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn edwards_point_sum_bounded(point: crate::edwards::EdwardsPoint) -> bool {\n    sum_of_limbs_bounded(&point.Y, &point.X, u64::MAX)\n}",
      "start_line": 249,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/zeroize_bytes32().",
      "display_name": "zeroize_bytes32",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/zeroize_bytes32().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub fn zeroize_bytes32(bytes: &mut [u8; 32])\n    ensures\n        forall|i: int| 0 <= i < 32 ==> #[trigger] bytes[i] == 0u8,\n{\n    use zeroize::Zeroize;\n    bytes.zeroize();\n}",
      "start_line": 284,
      "end_line": 23,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "display_name": "lemma_u8_32_as_nat_mod_truncates",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "file_name": "u8_32_as_nat_injectivity_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_u8_32_as_nat_mod_truncates(bytes: &[u8; 32], n: nat)\n    requires\n        n <= 32,\n    ensures\n        u8_32_as_nat(bytes) % pow2(n * 8) == as_nat_prefix(bytes, n),\n{\n    lemma2_to64();\n\n    if n == 0 {\n        // Base case: u8_32_as_nat(bytes) % pow2(0) == 0 == as_nat_prefix(bytes, 0)\n        assert(pow2(0) == 1) by {\n            lemma2_to64();\n        }\n        assert(u8_32_as_nat(bytes) % 1 == 0);\n        assert(as_nat_prefix(bytes, 0) == 0);\n    } else {\n        // Use the recursive representation\n        assert(u8_32_as_nat(bytes) == u8_32_as_nat_rec(bytes, 0)) by {\n            lemma_u8_32_as_nat_equals_rec(bytes);\n        }\n\n        // Decompose u8_32_as_nat_rec(bytes, 0) into prefix + suffix\n        assert(u8_32_as_nat_rec(bytes, 0) == as_nat_prefix(bytes, n) + u8_32_as_nat_rec(bytes, n))\n            by {\n            lemma_decomposition_prefix_rec(bytes, n);\n        }\n\n        // Show that as_nat_prefix(bytes, n) < pow2(n*8)\n        assert(as_nat_prefix(bytes, n) < pow2((n * 8) as nat)) by {\n            lemma_as_nat_prefix_bounded(bytes, n);\n        }\n\n        // Show that u8_32_as_nat_rec(bytes, n) is divisible by pow2(n*8)\n        assert(u8_32_as_nat_rec(bytes, n) % pow2((n * 8) as nat) == 0) by {\n            lemma_rec_suffix_divisible(bytes, n);\n        }\n\n        // Apply modular arithmetic: (a + b) % m == a % m when b % m == 0 and a < m\n        let prefix = as_nat_prefix(bytes, n);\n        let suffix = u8_32_as_nat_rec(bytes, n);\n        let d = pow2((n * 8) as nat);\n\n        lemma_pow2_pos((n * 8) as nat);\n        assert(prefix % d == prefix) by {\n            lemma_small_mod(prefix, d);\n        }\n\n        // REFACTORED: Inline the proof instead of using lemma_mod_sum_factor_specific\n        // Since suffix % d == 0, we have suffix = (suffix/d) * d\n        lemma_fundamental_div_mod(suffix as int, d as int);\n        let k = suffix / d;\n        assert(suffix == d * k + 0);\n        assert(suffix == d * k);\n\n        // Now use lemma_mod_sum_factor: (k * d + prefix) % d == prefix % d\n        lemma_mod_sum_factor(k as int, prefix as int, d as int);\n        assert((k * d + prefix) % d == prefix % d);\n\n        // We need to show (prefix + suffix) % d == prefix\n        // We have suffix == d * k, so prefix + suffix == prefix + d * k\n        assert(prefix + suffix == prefix + d * k);\n        // And d * k == k * d\n        assert(d * k == k * d) by {\n            lemma_mul_is_commutative(d as int, k as int);\n        }\n        // Therefore prefix + suffix == prefix + k * d == k * d + prefix\n        assert(prefix + suffix == k * d + prefix);\n        // And we know (k * d + prefix) % d == prefix % d == prefix\n        assert((prefix + suffix) % d == prefix);\n\n        // Therefore: u8_32_as_nat(bytes) % pow2(n*8) == as_nat_prefix(bytes, n)\n        assert(u8_32_as_nat(bytes) % pow2((n * 8) as nat) == prefix);\n    }\n}",
      "start_line": 169,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_point_as_affine_edwards().",
      "display_name": "affine_niels_point_as_affine_edwards",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_point_as_affine_edwards().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn affine_niels_point_as_affine_edwards(niels: AffineNielsPoint) -> (nat, nat) {\n    let y_plus_x = spec_field_element(&niels.y_plus_x);\n    let y_minus_x = spec_field_element(&niels.y_minus_x);\n\n    let x = math_field_mul(math_field_sub(y_plus_x, y_minus_x), math_field_inv(2));\n    let y = math_field_mul(math_field_add(y_plus_x, y_minus_x), math_field_inv(2));\n\n    (x, y)\n}",
      "start_line": 514,
      "end_line": 54,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_negate_field_element().",
      "display_name": "conditional_negate_field_element",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_negate_field_element().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn conditional_negate_field_element(a: &mut FieldElement51, choice: Choice)\n    requires\n        fe51_limbs_bounded(old(a), 52),  // Relaxed from 51 to 52 to match mul/square output\n    ensures\n        fe51_limbs_bounded(a, 52),\n        spec_field_element(a) == if choice_is_true(choice) {\n            math_field_neg(spec_field_element(old(a)))\n        } else {\n            spec_field_element(old(a))\n        },",
      "start_line": 267,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_p58_lemma/field_lemmas/lemmas/lemma_pow_p58_prove().",
      "display_name": "lemma_pow_p58_prove",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_p58_lemma/field_lemmas/lemmas/lemma_pow_p58_prove().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow_p58_lemma.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow_p58_lemma.rs",
      "file_name": "pow_p58_lemma.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_pow_p58_prove(\n    self_limbs: [u64; 5],\n    t19_limbs: [u64; 5],\n    t20_limbs: [u64; 5],\n    t21_limbs: [u64; 5],\n)\n    requires\n// t19 = x^(2^250-1) from pow22501\n\n        u64_5_as_nat(t19_limbs) % p() == pow(\n            u64_5_as_nat(self_limbs) as int,\n            (pow2(250) - 1) as nat,\n        ) as nat % p(),\n        // t20 = t19^4 (from pow2k(2))\n        u64_5_as_nat(t20_limbs) % p() == pow(u64_5_as_nat(t19_limbs) as int, pow2(2)) as nat % p(),\n        // t21 = self * t20\n        u64_5_as_nat(t21_limbs) % p() == (u64_5_as_nat(self_limbs) * u64_5_as_nat(t20_limbs)) % p(),\n    ensures\n        u64_5_as_nat(t21_limbs) % p() == pow(\n            u64_5_as_nat(self_limbs) as int,\n            (pow2(252) - 3) as nat,\n        ) as nat % p(),\n{\n    let base = u64_5_as_nat(self_limbs) as int;\n\n    assert(p() > 0) by {\n        pow255_gt_19();\n    }\n\n    let exp_250_m1 = (pow2(250) - 1) as nat;\n    let exp_252_m4 = (pow2(252) - 4) as nat;\n    let exp_252_m3 = (pow2(252) - 3) as nat;\n\n    // ========================================================================\n    // Prove t20 = x^(2^252-4) using lemma_prove_pow2k_step\n    // ========================================================================\n    // t20 = t19^4 = (x^(2^250-1))^4 = x^(4*(2^250-1)) = x^(2^252-4)\n\n    // First prove that 4 = pow2(2)\n    assert(pow2(2) == 4) by {\n        lemma2_to64();\n    }\n\n    // Prove the arithmetic: 4 * (2^250 - 1) = 2^252 - 4\n    assert(exp_250_m1 * 4 == exp_252_m4) by {\n        assert(pow2(252) == pow2(2) * pow2(250)) by {\n            lemma_pow2_adds(2, 250);\n        }\n        assert(4 * pow2(250) == pow2(252));\n\n        // Prove bounds needed for the cast\n        assert(pow2(250) >= 1) by {\n            lemma_pow2_pos(250);\n        }\n        assert(pow2(252) >= 4) by {\n            lemma_pow2_pos(252);\n            lemma_pow2_strictly_increases(2, 252);\n        }\n\n        // Use distributive property: 4 * (2^250 - 1) = 4 * 2^250 - 4 = 2^252 - 4\n        let a_int = pow2(250) as int - 1;\n        let b_int = pow2(252) as int - 4;\n\n        assert(4 * a_int == b_int) by {\n            lemma_mul_is_distributive_sub(4, pow2(250) as int, 1);\n        }\n\n        assert(a_int >= 0);\n        assert(b_int >= 0);\n        assert((4 * a_int) as nat == 4 * (a_int as nat));\n        assert(exp_250_m1 == a_int as nat);\n        assert(exp_252_m4 == b_int as nat);\n    }\n\n    // Apply the helper lemma\n    assert(pow2(2) > 0) by {\n        lemma_pow2_pos(2);\n    }\n    lemma_prove_pow2k_step(\n        base,\n        u64_5_as_nat(t19_limbs),\n        u64_5_as_nat(t20_limbs),\n        exp_250_m1,\n        pow2(2),\n    );\n\n    assert(u64_5_as_nat(t20_limbs) % p() == pow(base, exp_252_m4) as nat % p());\n\n    // ========================================================================\n    // Prove t21 = x^(2^252-3) using lemma_prove_geometric_mul_step\n    // ========================================================================\n    // t21 = self * t20 = x^1 * x^(2^252-4) = x^(1 + 2^252-4) = x^(2^252-3)\n\n    // Establish self = x^1\n    assert(pow(base, 1) == base) by {\n        lemma_pow1(base);\n    }\n    assert(pow(base, 1) as nat == u64_5_as_nat(self_limbs));\n\n    // Prove the arithmetic: 1 + (2^252 - 4) = 2^252 - 3\n    assert(1 + exp_252_m4 == exp_252_m3) by {\n        // Simple arithmetic: 1 + (n - 4) = n - 3 when n >= 4\n        assert(pow2(252) >= 4) by {\n            lemma_pow2_pos(252);\n            lemma_pow2_strictly_increases(2, 252);\n        }\n        let n = pow2(252) as int;\n        assert(1 + (n - 4) == n - 3);\n        assert(exp_252_m4 == (n - 4) as nat);\n        assert(exp_252_m3 == (n - 3) as nat);\n    }\n\n    // Apply the helper lemma\n    lemma_prove_geometric_mul_step(\n        base,\n        u64_5_as_nat(self_limbs),\n        u64_5_as_nat(t20_limbs),\n        u64_5_as_nat(t21_limbs),\n        1,\n        exp_252_m4,\n    );\n\n    assert(u64_5_as_nat(t21_limbs) % p() == pow(base, exp_252_m3) as nat % p());\n}",
      "start_line": 42,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 13
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/bytes_match_limbs_packing_52().",
      "display_name": "bytes_match_limbs_packing_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/bytes_match_limbs_packing_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub open spec fn bytes_match_limbs_packing_52(limbs: [u64; 5], bytes: [u8; 32]) -> bool {\n    &&& bytes[0] == (limbs[0] >> 0) as u8\n    &&& bytes[1] == (limbs[0] >> 8) as u8\n    &&& bytes[2] == (limbs[0] >> 16) as u8\n    &&& bytes[3] == (limbs[0] >> 24) as u8\n    &&& bytes[4] == (limbs[0] >> 32) as u8\n    &&& bytes[5] == (limbs[0] >> 40) as u8\n    &&& bytes[6] == ((limbs[0] >> 48) | (limbs[1] << 4)) as u8\n    &&& bytes[7] == (limbs[1] >> 4) as u8\n    &&& bytes[8] == (limbs[1] >> 12) as u8\n    &&& bytes[9] == (limbs[1] >> 20) as u8\n    &&& bytes[10] == (limbs[1] >> 28) as u8\n    &&& bytes[11] == (limbs[1] >> 36) as u8\n    &&& bytes[12] == (limbs[1] >> 44) as u8\n    &&& bytes[13] == (limbs[2] >> 0) as u8\n    &&& bytes[14] == (limbs[2] >> 8) as u8\n    &&& bytes[15] == (limbs[2] >> 16) as u8\n    &&& bytes[16] == (limbs[2] >> 24) as u8\n    &&& bytes[17] == (limbs[2] >> 32) as u8\n    &&& bytes[18] == (limbs[2] >> 40) as u8\n    &&& bytes[19] == ((limbs[2] >> 48) | (limbs[3] << 4)) as u8\n    &&& bytes[20] == (limbs[3] >> 4) as u8\n    &&& bytes[21] == (limbs[3] >> 12) as u8\n    &&& bytes[22] == (limbs[3] >> 20) as u8\n    &&& bytes[23] == (limbs[3] >> 28) as u8\n    &&& bytes[24] == (limbs[3] >> 36) as u8\n    &&& bytes[25] == (limbs[3] >> 44) as u8\n    &&& bytes[26] == (limbs[4] >> 0) as u8\n    &&& bytes[27] == (limbs[4] >> 8) as u8\n    &&& bytes[28] == (limbs[4] >> 16) as u8\n    &&& bytes[29] == (limbs[4] >> 24) as u8\n    &&& bytes[30] == (limbs[4] >> 32) as u8\n    &&& bytes[31] == (limbs[4] >> 40) as u8\n}",
      "start_line": 27,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "display_name": "lemma_mod_multiples_basic",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "file_name": "u8_32_as_nat_injectivity_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 16,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_low_recombine().",
      "display_name": "lemma_high_low_recombine",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_low_recombine().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "file_name": "scalar_lemmas_extra.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_high_low_recombine(\n    w0: nat,\n    w1: nat,\n    w2: nat,\n    w3: nat,\n    w4: nat,\n    w5: nat,\n    w6: nat,\n    w7: nat,\n    w4_low: nat,\n    w4_high: nat,\n)\n    requires\n        w4_low == w4 % 16,\n        w4_high == w4 / 16,\n    ensures\n        ({\n            let low_expr = w0 + pow2(64) * w1 + pow2(128) * w2 + pow2(192) * w3 + pow2(256)\n                * w4_low;\n            let high_expr = w4_high + pow2(60) * w5 + pow2(124) * w6 + pow2(188) * w7;\n            let wide_sum = w0 + pow2(64) * w1 + pow2(128) * w2 + pow2(192) * w3 + pow2(256) * w4\n                + pow2(320) * w5 + pow2(384) * w6 + pow2(448) * w7;\n            pow2(260) * high_expr + low_expr == wide_sum\n        }),",
      "start_line": 589,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_seq_u64_to_nat_subrange_extend().",
      "display_name": "lemma_seq_u64_to_nat_subrange_extend",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_seq_u64_to_nat_subrange_extend().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_seq_u64_to_nat_subrange_extend(seq: Seq<u64>, i: int)\n    requires\n        0 <= i < seq.len(),\n    ensures\n        seq_u64_to_nat(seq.subrange(0, i + 1)) == seq_u64_to_nat(seq.subrange(0, i)) + seq[i]\n            * pow2(52 * i as nat),\n    decreases i,\n{\n    if i == 0 {\n        reveal_with_fuel(seq_to_nat, 3);\n        assert(seq.len() > 0);\n        assert(seq.subrange(0, 1) == seq![seq[0]]);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, 0 + 1 as int)); {\n                assert(seq.subrange(0, 1) == seq![seq[0]]);\n            }\n            seq_u64_to_nat(seq![seq[0]]); {\n                let single_elem = seq![seq[0]];\n                let nat_single = single_elem.map(|idx, x| x as nat);\n                assert(nat_single == seq![seq[0] as nat]);\n                assert(seq_u64_to_nat(single_elem) == seq_to_nat(nat_single));\n                assert(nat_single.len() == 1);\n                assert(seq_to_nat(nat_single) == nat_single[0] + seq_to_nat(\n                    nat_single.subrange(1, 1),\n                ) * pow2(52));\n                assert(nat_single.subrange(1, 1).len() == 0);\n                assert(seq_to_nat(nat_single.subrange(1, 1)) == 0);\n                assert(seq_to_nat(nat_single) == nat_single[0]);\n                assert(nat_single[0] == seq[0] as nat);\n            }\n            seq[0] as nat; {\n                assert(pow2(0) == 1) by {\n                    lemma2_to64();\n                }\n                assert(52 * 0 == 0);\n                assert(pow2(52 * 0 as nat) == pow2(0));\n                assert((seq[0] * pow2(0)) as nat == (seq[0] * 1) as nat);\n                assert((seq[0] * 1) as nat == seq[0] as nat);\n            }\n            (seq[0] * pow2(52 * 0 as nat)) as nat; {}\n            (seq_u64_to_nat(seq.subrange(0, 0)) + seq[0] * pow2(52 * 0 as nat)) as nat;\n        }\n        return ;\n    } else {\n        let limbs1 = seq.subrange(0, i + 1).map(|i, x| x as nat);\n        let limbs2 = seq.subrange(0, i).map(|i, x| x as nat);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, i + 1)); {\n                assert(seq_to_nat(limbs1) == limbs1[0] + seq_to_nat(\n                    limbs1.subrange(1, limbs1.len() as int),\n                ) * pow2(52));\n            }\n            limbs1[0] + seq_to_nat(limbs1.subrange(1, limbs1.len() as int)) * pow2(52); {\n                assert(seq.subrange(1, i + 1).map(|i, x| x as nat) == limbs1.subrange(\n                    1,\n                    limbs1.len() as int,\n                ));\n            }\n            limbs1[0] + seq_u64_to_nat(seq.subrange(1, i + 1)) * pow2(52); {\n                let tail = seq.subrange(1, i + 1);\n                assert(i >= 1);\n                assert(0 <= i - 1 < tail.len());\n                lemma_seq_u64_to_nat_subrange_extend(tail, i - 1);\n                assert(seq_u64_to_nat(tail.subrange(0, i)) == seq_u64_to_nat(\n                    tail.subrange(0, i - 1),\n                ) + tail[i - 1] * pow2(52 * (i - 1) as nat));\n                assert(tail.subrange(0, i) == seq.subrange(1, i + 1));\n                assert(tail.subrange(0, i - 1) == seq.subrange(1, i));\n                assert(seq_u64_to_nat(seq.subrange(1, i + 1)) == seq_u64_to_nat(seq.subrange(1, i))\n                    + seq[i] * pow2(52 * (i - 1) as nat));\n            }\n            limbs1[0] + ((seq_u64_to_nat(seq.subrange(1, i)) + seq[i] * pow2(52 * (i - 1) as nat))\n                * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i)) * pow2(52) + seq[i] * pow2(\n                52 * (i - 1) as nat,\n            ) * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_associative;\n\n                lemma_pow2_adds(52 * (i - 1) as nat, 52);\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i)) * pow2(52) + seq[i] * pow2(\n                52 * i as nat,\n            )) as nat; {\n                assert(seq.subrange(1, i).map(|i, x| x as nat) == limbs2.subrange(\n                    1,\n                    limbs2.len() as int,\n                ));\n            }\n            (limbs2[0] + seq_to_nat(limbs2.subrange(1, limbs2.len() as int)) * pow2(52) + seq[i]\n                * pow2(52 * i as nat)) as nat; {\n                assert(seq_to_nat(limbs2) == limbs2[0] + seq_to_nat(\n                    limbs2.subrange(1, limbs2.len() as int),\n                ) * pow2(52));\n            }\n            (seq_to_nat(limbs2) + seq[i] * pow2(52 * i as nat)) as nat; {}\n            (seq_u64_to_nat(seq.subrange(0, i)) + seq[i] * pow2(52 * i as nat)) as nat;\n        }\n    }\n}",
      "start_line": 574,
      "end_line": 50,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_nine_limbs_one_canonical().",
      "display_name": "arb_nine_limbs_one_canonical",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_nine_limbs_one_canonical().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn arb_nine_limbs_one_canonical() -> impl Strategy<Value = [u128; 9]> {\n        (arb_bounded_scalar52(), arb_canonical_scalar52())\n            .prop_map(|(a, b)| Scalar52::mul_internal(&a, &b))\n    }",
      "start_line": 1425,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/check_equals_u_times_fourth_root().",
      "display_name": "check_equals_u_times_fourth_root",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/check_equals_u_times_fourth_root().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn check_equals_u_times_fourth_root(check: nat, u: nat) -> bool {\n    let (one, neg_one, i, neg_i) = fourth_root_of_unity_values();\n    check % p() == (u * one) % p()        // check = u\n    || check % p() == (u * neg_one) % p() // check = -u\n    || check % p() == (u * i) % p()       // check = u*i  \n    || check % p() == (u * neg_i) % p()   // check = -u*i\n}",
      "start_line": 506,
      "end_line": 50,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_sqrt_ratio().",
      "display_name": "is_sqrt_ratio",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_sqrt_ratio().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_sqrt_ratio(u: &FieldElement51, v: &FieldElement51, r: &FieldElement51) -> bool {\n    (spec_field_element(r) * spec_field_element(r) * spec_field_element(v)) % p()\n        == spec_field_element(u)\n}",
      "start_line": 437,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_limbs_bounded().",
      "display_name": "lemma_r_limbs_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_limbs_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_r_limbs_bounded()\n    ensures\n        0x000f48bd6721e6edu64 < (1u64 << 52),\n        0x0003bab5ac67e45au64 < (1u64 << 52),\n        0x000fffffeb35e51bu64 < (1u64 << 52),\n        0x000fffffffffffffu64 < (1u64 << 52),\n        0x00000fffffffffff_u64 < (1u64 << 52),\n{\n    assert(0x000f48bd6721e6edu64 < (1u64 << 52)) by (bit_vector);\n    assert(0x0003bab5ac67e45au64 < (1u64 << 52)) by (bit_vector);\n    assert(0x000fffffeb35e51bu64 < (1u64 << 52)) by (bit_vector);\n    assert(0x000fffffffffffffu64 < (1u64 << 52)) by (bit_vector);\n    assert(0x00000fffffffffff_u64 < (1u64 << 52)) by (bit_vector);\n}",
      "start_line": 369,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "display_name": "lemma_spec_fe51_to_bytes_matches_array",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/as_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/as_bytes_lemmas.rs",
      "file_name": "as_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_spec_fe51_to_bytes_matches_array(fe: &FieldElement51, bytes: &[u8; 32])\n    requires\n        u8_32_as_nat(bytes) == u64_5_as_nat(fe.limbs) % p(),\n    ensures\n        forall|i: int| 0 <= i < 32 ==> spec_fe51_to_bytes(fe)[i] == bytes[i],\n{\n    // Strategy: Both as_bytes() and spec_fe51_to_bytes() use the identical algorithm.\n    // We'll compute the canonical limbs and show that the byte packing formulas\n    // in spec_fe51_to_bytes (which are explicit in the seq![...]) match what as_bytes produces.\n    // Step 1: Compute the canonical limbs (same as in spec_fe51_to_bytes)\n    proof_reduce(fe.limbs);  // Ensures limbs are bounded by 2^52 and value is preserved mod p()\n    let limbs = spec_reduce(fe.limbs);\n\n    // Step 2: Prove preconditions for lemma_to_bytes_reduction\n    lemma_reduce_bound_2p(fe.limbs);  // Ensures u64_5_as_nat(limbs) < 2 * p()\n\n    // Compute q using compute_q_spec (matches spec_fe51_to_bytes)\n    let q = compute_q_spec(limbs);\n    lemma_compute_q(limbs, q);  // Establishes: q == 0 || q == 1, and u64_5_as_nat(limbs) >= p() <==> q == 1\n\n    // Step 3: Apply canonical reduction using reduce_with_q_spec\n    let canonical_limbs = reduce_with_q_spec(limbs, q);\n\n    // Step 4: Extract canonical limb values\n    let limbs0_canon = canonical_limbs[0];\n    let limbs1_canon = canonical_limbs[1];\n    let limbs2_canon = canonical_limbs[2];\n    let limbs3_canon = canonical_limbs[3];\n    let limbs4_canon = canonical_limbs[4];\n\n    // Now assert that each byte formula in spec_fe51_to_bytes matches\n    // The spec_fe51_to_bytes function defines its output as seq![...] with these exact formulas.\n    // By the definition of seq![...], spec_fe51_to_bytes(fe)[i] equals the i-th element.\n\n    assert(spec_fe51_to_bytes(fe)[0] == limbs0_canon as u8);\n    assert(spec_fe51_to_bytes(fe)[1] == (limbs0_canon >> 8) as u8);\n    assert(spec_fe51_to_bytes(fe)[2] == (limbs0_canon >> 16) as u8);\n    assert(spec_fe51_to_bytes(fe)[3] == (limbs0_canon >> 24) as u8);\n    assert(spec_fe51_to_bytes(fe)[4] == (limbs0_canon >> 32) as u8);\n    assert(spec_fe51_to_bytes(fe)[5] == (limbs0_canon >> 40) as u8);\n    assert(spec_fe51_to_bytes(fe)[6] == ((limbs0_canon >> 48) | (limbs1_canon << 3)) as u8);\n    assert(spec_fe51_to_bytes(fe)[7] == (limbs1_canon >> 5) as u8);\n    assert(spec_fe51_to_bytes(fe)[8] == (limbs1_canon >> 13) as u8);\n    assert(spec_fe51_to_bytes(fe)[9] == (limbs1_canon >> 21) as u8);\n    assert(spec_fe51_to_bytes(fe)[10] == (limbs1_canon >> 29) as u8);\n    assert(spec_fe51_to_bytes(fe)[11] == (limbs1_canon >> 37) as u8);\n    assert(spec_fe51_to_bytes(fe)[12] == ((limbs1_canon >> 45) | (limbs2_canon << 6)) as u8);\n    assert(spec_fe51_to_bytes(fe)[13] == (limbs2_canon >> 2) as u8);\n    assert(spec_fe51_to_bytes(fe)[14] == (limbs2_canon >> 10) as u8);\n    assert(spec_fe51_to_bytes(fe)[15] == (limbs2_canon >> 18) as u8);\n    assert(spec_fe51_to_bytes(fe)[16] == (limbs2_canon >> 26) as u8);\n    assert(spec_fe51_to_bytes(fe)[17] == (limbs2_canon >> 34) as u8);\n    assert(spec_fe51_to_bytes(fe)[18] == (limbs2_canon >> 42) as u8);\n    assert(spec_fe51_to_bytes(fe)[19] == ((limbs2_canon >> 50) | (limbs3_canon << 1)) as u8);\n    assert(spec_fe51_to_bytes(fe)[20] == (limbs3_canon >> 7) as u8);\n    assert(spec_fe51_to_bytes(fe)[21] == (limbs3_canon >> 15) as u8);\n    assert(spec_fe51_to_bytes(fe)[22] == (limbs3_canon >> 23) as u8);\n    assert(spec_fe51_to_bytes(fe)[23] == (limbs3_canon >> 31) as u8);\n    assert(spec_fe51_to_bytes(fe)[24] == (limbs3_canon >> 39) as u8);\n    assert(spec_fe51_to_bytes(fe)[25] == ((limbs3_canon >> 47) | (limbs4_canon << 4)) as u8);\n    assert(spec_fe51_to_bytes(fe)[26] == (limbs4_canon >> 4) as u8);\n    assert(spec_fe51_to_bytes(fe)[27] == (limbs4_canon >> 12) as u8);\n    assert(spec_fe51_to_bytes(fe)[28] == (limbs4_canon >> 20) as u8);\n    assert(spec_fe51_to_bytes(fe)[29] == (limbs4_canon >> 28) as u8);\n    assert(spec_fe51_to_bytes(fe)[30] == (limbs4_canon >> 36) as u8);\n    assert(spec_fe51_to_bytes(fe)[31] == (limbs4_canon >> 44) as u8);\n\n    // Step 5: Now show that bytes[i] equals each canonical byte formula\n    //\n    // Key insight: Both as_bytes() and spec_fe51_to_bytes() implement the SAME algorithm.\n    // Since they start with the same fe.limbs and apply identical operations, they must\n    // produce the same canonical limbs and therefore the same packed bytes.\n    //\n    // We know:\n    // - u8_32_as_nat(bytes) == u64_5_as_nat(fe.limbs) % p() (from requires)\n    // - The canonical limbs [limbs0_canon, ...] represent u64_5_as_nat(fe.limbs) % p()\n    // - Both are < p() (canonical form)\n    // - The byte packing formulas are deterministic\n    //\n    // Since the canonical representation is unique, and both representations\n    // equal u64_5_as_nat(fe.limbs) % p(), we have bytes[i] == (packed canonical byte)[i]\n\n    // The canonical limbs are already bounded by 2^51 (from reduce_with_q_spec)\n    // This is guaranteed by lemma_to_bytes_reduction's postcondition\n\n    // Create an array matching the spec_fe51_to_bytes byte packing\n    let spec_bytes: [u8; 32] = [\n        limbs0_canon as u8,\n        (limbs0_canon >> 8) as u8,\n        (limbs0_canon >> 16) as u8,\n        (limbs0_canon >> 24) as u8,\n        (limbs0_canon >> 32) as u8,\n        (limbs0_canon >> 40) as u8,\n        ((limbs0_canon >> 48) | (limbs1_canon << 3)) as u8,\n        (limbs1_canon >> 5) as u8,\n        (limbs1_canon >> 13) as u8,\n        (limbs1_canon >> 21) as u8,\n        (limbs1_canon >> 29) as u8,\n        (limbs1_canon >> 37) as u8,\n        ((limbs1_canon >> 45) | (limbs2_canon << 6)) as u8,\n        (limbs2_canon >> 2) as u8,\n        (limbs2_canon >> 10) as u8,\n        (limbs2_canon >> 18) as u8,\n        (limbs2_canon >> 26) as u8,\n        (limbs2_canon >> 34) as u8,\n        (limbs2_canon >> 42) as u8,\n        ((limbs2_canon >> 50) | (limbs3_canon << 1)) as u8,\n        (limbs3_canon >> 7) as u8,\n        (limbs3_canon >> 15) as u8,\n        (limbs3_canon >> 23) as u8,\n        (limbs3_canon >> 31) as u8,\n        (limbs3_canon >> 39) as u8,\n        ((limbs3_canon >> 47) | (limbs4_canon << 4)) as u8,\n        (limbs4_canon >> 4) as u8,\n        (limbs4_canon >> 12) as u8,\n        (limbs4_canon >> 20) as u8,\n        (limbs4_canon >> 28) as u8,\n        (limbs4_canon >> 36) as u8,\n        (limbs4_canon >> 44) as u8,\n    ];\n\n    // Now we need to show: spec_bytes == bytes\n    // This follows from uniqueness of canonical representation:\n    // Both represent u64_5_as_nat(fe.limbs) % p(), so they must be equal\n\n    // First, show that spec_bytes matches the canonical limbs packing\n    assert(bytes_match_limbs_packing(canonical_limbs, spec_bytes));\n\n    // First call lemma_to_bytes_reduction to establish canonical_limbs properties\n    // The preconditions are already established:\n    // - limbs[i] < 2^52 from proof_reduce\n    // - q == 0 || q == 1 from lemma_compute_q\n    // - u64_5_as_nat(limbs) >= p() <==> q == 1 from lemma_compute_q\n    // - u64_5_as_nat(limbs) < 2*p() from lemma_reduce_bound_2p\n    // - canonical_limbs == reduce_with_q_spec(limbs, q) by construction\n    lemma_to_bytes_reduction(limbs, canonical_limbs, q);\n    // Now we know: canonical_limbs[i] < 2^51 and u64_5_as_nat(canonical_limbs) == u64_5_as_nat(limbs) % p()\n\n    // Use lemma_limbs_to_bytes to show u8_32_as_nat(spec_bytes) == u64_5_as_nat(canonical_limbs)\n    lemma_limbs_to_bytes(canonical_limbs, spec_bytes);\n    assert(u8_32_as_nat(&spec_bytes) == u64_5_as_nat(canonical_limbs));\n\n    // From proof_reduce (called earlier), we know:\n    // u64_5_as_nat(spec_reduce(fe.limbs)) % p() == u64_5_as_nat(fe.limbs) % p()\n    // Since limbs = spec_reduce(fe.limbs), we have:\n    assert(u64_5_as_nat(limbs) % p() == u64_5_as_nat(fe.limbs) % p());\n\n    // Therefore: u8_32_as_nat(spec_bytes) == u64_5_as_nat(fe.limbs) % p()\n    assert(u8_32_as_nat(&spec_bytes) == u64_5_as_nat(fe.limbs) % p());\n\n    // Both bytes and spec_bytes represent u64_5_as_nat(fe.limbs) % p()\n    // By uniqueness of canonical representation, they must be equal\n    assert(u8_32_as_nat(bytes) == u8_32_as_nat(&spec_bytes));\n\n    // If two byte arrays have the same u8_32_as_nat value,\n    // they must be equal element-wise (by injectivity of little-endian encoding)\n    lemma_canonical_bytes_equal(bytes, &spec_bytes);\n}",
      "start_line": 182,
      "end_line": 48,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_montgomery_lift().",
      "display_name": "canonical_montgomery_lift",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_montgomery_lift().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn canonical_montgomery_lift(u: nat) -> MontgomeryAffine\n    recommends\n        is_valid_u_coordinate(u),\n{\n    let v = canonical_sqrt(montgomery_rhs(u));\n    MontgomeryAffine::Finite { u: u % p(), v }\n}",
      "start_line": 82,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoBasepointTable#basepoint().",
      "display_name": "basepoint",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoBasepointTable#basepoint().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn basepoint(&self) -> RistrettoPoint {\n        RistrettoPoint(self.0.basepoint())\n    }",
      "start_line": 1109,
      "end_line": 21,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c0_val().",
      "display_name": "c0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn c0_val(a: [u64; 5]) -> u128 {\n    c0_0_val(a)\n}",
      "start_line": 56,
      "end_line": 24,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_add_projective_niels().",
      "display_name": "spec_edwards_add_projective_niels",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_add_projective_niels().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_edwards_add_projective_niels(\n    p: crate::edwards::EdwardsPoint,\n    q: crate::backend::serial::curve_models::ProjectiveNielsPoint,\n) -> (nat, nat) {\n    let self_affine = edwards_point_as_affine(p);\n    let other_affine = projective_niels_point_as_affine_edwards(q);\n    edwards_add(self_affine.0, self_affine.1, other_affine.0, other_affine.1)\n}",
      "start_line": 623,
      "end_line": 51,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#AddAssign#add_assign().",
      "display_name": "add_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#AddAssign#add_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn add_assign(&mut self, _rhs: &'a FieldElement51)\n        requires\n            sum_of_limbs_bounded(old(self), _rhs, u64::MAX),\n        ensures\n            *self == spec_add_fe51_limbs(old(self), _rhs),\n            spec_field_element_as_nat(self) == spec_field_element_as_nat(old(self))\n                + spec_field_element_as_nat(_rhs),\n            spec_field_element(self) == math_field_add(\n                spec_field_element(old(self)),\n                spec_field_element(_rhs),\n            ),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    0 <= j < i ==> #[trigger] self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| i <= j < 5 ==> #[trigger] self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_fe51_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_fe51_limbs(old(self), _rhs).limbs);\n            // Discharge the rest of the ensures\n            lemma_field51_add(old(self), _rhs);\n        }\n\n    }",
      "start_line": 168,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow252().",
      "display_name": "lemma_pow252",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow252().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_pow252()\n    ensures\n        pow2(252) == 0x1000000000000000000000000000000000000000000000000000000000000000,\n{\n    assert(pow2(63) == 0x8000000000000000) by {\n        lemma2_to64_rest();\n    }\n    lemma_pow2_adds(63, 63);\n    assert(pow2(126) == 0x40000000000000000000000000000000);\n    lemma_pow2_adds(126, 126);\n}",
      "start_line": 1060,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/to_le_bytes().",
      "display_name": "to_le_bytes",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/to_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_zero_is_id().",
      "display_name": "lemma_shr_zero_is_id",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_zero_is_id().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub broadcast proof fn lemma_shr_zero_is_id(v: u64)\n    ensures\n        #![trigger v >> 0]\n        v >> 0 == v,\n{\n    assert(v >> 0 == v) by (bit_vector);\n}",
      "start_line": 127,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_sub().",
      "display_name": "montgomery_sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn montgomery_sub(P: MontgomeryAffine, Q: MontgomeryAffine) -> MontgomeryAffine {\n    montgomery_add(P, montgomery_neg(Q))\n}",
      "start_line": 169,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/spec_state_after_hash().",
      "display_name": "spec_state_after_hash",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/spec_state_after_hash().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub spec fn spec_state_after_hash<H, T, const N: usize>(initial_state: H, bytes: &[T; N]) -> H;\n\n/// Spec function: the hash state after hashing a MontgomeryPoint\n/// This is defined as the hash state of its canonical byte representation\npub open spec fn spec_state_after_hash_montgomery<H>(\n    initial_state: H,\n    point: &MontgomeryPoint,\n) -> H {\n    // The hash state of a MontgomeryPoint is determined by its canonical bytes\n    // Canonical bytes are: spec_fe51_to_bytes(spec_fe51_from_bytes(point.0))\n    let canonical_seq = spec_fe51_to_bytes(&spec_fe51_from_bytes(&point.0));\n    let canonical_bytes = seq_to_array_32(canonical_seq);\n    spec_state_after_hash(initial_state, &canonical_bytes)\n}",
      "start_line": 195,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base_clamped().",
      "display_name": "mul_base_clamped",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base_clamped().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_base_clamped(bytes: [u8; 32]) -> (result: Self)\n        ensures\n            is_valid_montgomery_point(result),\n            // Functional correctness: result.u = [clamp(bytes)] * basepoint (u-coordinate)\n            spec_montgomery(result) == montgomery_scalar_mul_u(\n                spec_x25519_basepoint_u(),\n                spec_scalar(&Scalar { bytes: spec_clamp_integer(bytes) }),\n            ),",
      "start_line": 314,
      "end_line": 28,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#AddAssign#add_assign().",
      "display_name": "add_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#AddAssign#add_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn add_assign(&mut self, _rhs: &'a Scalar)\n        ensures\n            bytes_to_nat(&self.bytes) == (bytes_to_nat(&old(self).bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order(),\n    {\n        *self = &*self + _rhs;\n    }",
      "start_line": 692,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow2_260_greater_than_2_group_order().",
      "display_name": "lemma_pow2_260_greater_than_2_group_order",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow2_260_greater_than_2_group_order().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_pow2_260_greater_than_2_group_order()\n    ensures\n        pow2(260) > 2 * group_order(),\n{\n    // The group order is approximately 2^252, so 2 * group_order ≈ 2^253\n    // And 2^260 >> 2^253\n    assert(pow2(260) == pow2(252) * pow2(8)) by {\n        lemma_pow2_adds(252, 8);\n    };\n    assert(pow2(8) == 256) by {\n        lemma2_to64();\n    };\n    lemma_pow252();\n    // Now Verus knows what the powers of 2 mean, so it can figure out the rest\n}",
      "start_line": 1072,
      "end_line": 55,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_4_terms().",
      "display_name": "lemma_mul_distributive_4_terms",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_4_terms().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_mul_distributive_4_terms(n: int, x1: int, x2: int, x3: int, x4: int)\n    ensures\n        n * (x1 + x2 + x3 + x4) == (x1 + x2 + x3 + x4) * n == n * x1 + n * x2 + n * x3 + n * x4,\n{\n    assert(n * (x1 + x2 + x3 + x4) == (x1 + x2 + x3 + x4) * n) by {\n        lemma_mul_is_commutative(n, x1 + x2 + x3 + x4);\n    }\n\n    assert(n * (x1 + x2 + x3 + x4) == n * (x1 + x2 + x3) + n * x4) by {\n        lemma_mul_is_distributive_add(n, x1 + x2 + x3, x4);\n    }\n\n    assert(n * (x1 + x2 + x3) == n * x1 + n * x2 + n * x3) by {\n        lemma_mul_distributive_3_terms(n, x1, x2, x3);\n    }\n}",
      "start_line": 70,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat_rec().",
      "display_name": "u8_32_as_nat_rec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat_rec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/core_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/core_specs.rs",
      "file_name": "core_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn u8_32_as_nat_rec(bytes: &[u8; 32], index: nat) -> nat\n    decreases 32 - index,\n{\n    if index >= 32 {\n        0\n    } else {\n        (bytes[index as int] as nat) * pow2(index * 8) + u8_32_as_nat_rec(bytes, index + 1)\n    }\n}",
      "start_line": 63,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        let coset = self.coset4();\n        write!(\n            f,\n            \"RistrettoPoint: coset \\n{:?}\\n{:?}\\n{:?}\\n{:?}\",\n            coset[0], coset[1], coset[2], coset[3]\n        )\n    }",
      "start_line": 1163,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#vartime_double_scalar_mul_basepoint().",
      "display_name": "vartime_double_scalar_mul_basepoint",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#vartime_double_scalar_mul_basepoint().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn vartime_double_scalar_mul_basepoint(\n        a: &Scalar,\n        A: &EdwardsPoint,\n        b: &Scalar,\n    ) -> EdwardsPoint {\n        crate::backend::vartime_double_base_mul(a, A, b)\n    }",
      "start_line": 1904,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "display_name": "mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
      "file_name": "variable_base.rs",
      "parent_folder": "scalar_mul",
      "body": "pub(crate) fn mul(point: &EdwardsPoint, scalar: &Scalar) -> (result: EdwardsPoint)\n    requires\n// as_radix_16 requires scalar.bytes[31] <= 127 (MSB clear, i.e. scalar < 2^255)\n\n        scalar.bytes[31] <= 127,\n        // Input point must be well-formed (valid coordinates with proper limb bounds)\n        is_well_formed_edwards_point(*point),\n    ensures\n// Result is a well-formed Edwards point\n\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result represents scalar * point\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            edwards_point_as_affine(*point),\n            spec_scalar(scalar),\n        ),\n{\n    // Construct a lookup table of [P,2P,3P,4P,5P,6P,7P,8P]\n    let lookup_table = LookupTable::<ProjectiveNielsPoint>::from(point);\n    // Setting s = scalar, compute\n    //\n    //    s = s_0 + s_1*16^1 + ... + s_63*16^63,\n    //\n    // with `-8 ≤ s_i < 8` for `0 ≤ i < 63` and `-8 ≤ s_63 ≤ 8`.\n    // This decomposition requires s < 2^255, which is guaranteed by Scalar invariant #1.\n    let scalar_digits = scalar.as_radix_16();\n    // Compute s*P as\n    //\n    //    s*P = P*(s_0 +   s_1*16^1 +   s_2*16^2 + ... +   s_63*16^63)\n    //    s*P =  P*s_0 + P*s_1*16^1 + P*s_2*16^2 + ... + P*s_63*16^63\n    //    s*P = P*s_0 + 16*(P*s_1 + 16*(P*s_2 + 16*( ... + P*s_63)...))\n    //\n    // We sum right-to-left.\n\n    // Unwrap first loop iteration to save computing 16*identity\n    let mut tmp2;\n    let mut tmp3 = EdwardsPoint::identity();\n    proof {\n        // From identity() postcondition\n        assert(is_well_formed_edwards_point(tmp3));\n        // From as_radix_16 postcondition: radix_16_all_bounded ensures all digits in [-8, 8]\n        assert(radix_16_all_bounded(&scalar_digits));\n        assert(radix_16_digit_bounded(scalar_digits[63]));  // instantiate for index 63\n    }\n    let mut tmp1 = &tmp3 + &lookup_table.select(scalar_digits[63]);\n\n    // Now tmp1 = s_63*P in P1xP1 coords\n    /* ORIGINAL CODE:\n    for i in (0..63).rev() {\n    */\n    // REFACTORED: Verus doesn't support .rev() on ranges, so iterate forward and compute reverse index\n    for j in 0usize..63\n        invariant\n    // scalar_digits bounds remain valid throughout the loop\n\n            radix_16_all_bounded(&scalar_digits),\n            // lookup_table has bounded limbs (from from() postcondition)\n            lookup_table_projective_limbs_bounded(lookup_table.0),\n            // tmp1 is always a valid completed point (from Add postcondition)\n            is_valid_completed_point(tmp1),\n            // tmp1 limb bounds (from Add postcondition, preserved through loop)\n            fe51_limbs_bounded(&tmp1.X, 54),\n            fe51_limbs_bounded(&tmp1.Y, 54),\n            fe51_limbs_bounded(&tmp1.Z, 54),\n            fe51_limbs_bounded(&tmp1.T, 54),\n    {\n        let i = 62 - j;  // i goes from 62 down to 0\n        tmp2 = tmp1.as_projective();  // tmp2 =    (prev) in P2 coords\n        tmp1 = tmp2.double();  // tmp1 =  2*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective();  // tmp2 =  2*(prev) in P2 coords\n        tmp1 = tmp2.double();  // tmp1 =  4*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective();  // tmp2 =  4*(prev) in P2 coords\n        tmp1 = tmp2.double();  // tmp1 =  8*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective();  // tmp2 =  8*(prev) in P2 coords\n        tmp1 = tmp2.double();  // tmp1 = 16*(prev) in P1xP1 coords\n        tmp3 = tmp1.as_extended();  // tmp3 = 16*(prev) in P3 coords\n        tmp1 = &tmp3 + &lookup_table.select(scalar_digits[i]);\n        // Now tmp1 = s_i*P + 16*(prev) in P1xP1 coords\n    }\n    proof {\n        // From loop invariant\n        assert(is_valid_completed_point(tmp1));\n        // From Add<ProjectiveNielsPoint> postconditions (now includes limb bounds)\n        assert(fe51_limbs_bounded(&tmp1.X, 54));\n        assert(fe51_limbs_bounded(&tmp1.Y, 54));\n        assert(fe51_limbs_bounded(&tmp1.Z, 54));\n        assert(fe51_limbs_bounded(&tmp1.T, 54));\n    }\n    let result = tmp1.as_extended();\n    proof {\n        // postconditions\n        assume(edwards_point_as_affine(result) == edwards_scalar_mul(\n            edwards_point_as_affine(*point),\n            spec_scalar(scalar),\n        ));\n    }\n    result\n}\n\n} // verus!",
      "start_line": 29,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_equals_group_order().",
      "display_name": "lemma_l_equals_group_order",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_equals_group_order().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub(crate) proof fn lemma_l_equals_group_order()\n    ensures\n        to_nat(&constants::L.limbs) == group_order(),\n        seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order(),\n{\n    // First show that the subrange equals the full array\n    assert(constants::L.limbs@ == constants::L.limbs@.subrange(0, 5 as int));\n    assert(seq_u64_to_nat(constants::L.limbs@) == seq_u64_to_nat(\n        constants::L.limbs@.subrange(0, 5 as int),\n    ));\n    assert(to_nat(&constants::L.limbs) == seq_u64_to_nat(constants::L.limbs@));\n\n    assert(pow2(52) == 0x10000000000000) by {\n        lemma2_to64_rest();\n    };\n    lemma_pow2_adds(52, 52);\n    assert(pow2(104) == 0x100000000000000000000000000);\n    lemma_pow2_adds(104, 104);\n    assert(pow2(208) == 0x10000000000000000000000000000000000000000000000000000);\n    lemma_pow252();\n    lemma_five_limbs_equals_to_nat(&constants::L.limbs);\n    assert(five_limbs_to_nat_aux(constants::L.limbs) == group_order()) by (compute);\n}",
      "start_line": 1036,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_into().",
      "display_name": "choice_into",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_into().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn choice_into(c: Choice) -> (b: bool)\n    ensures\n        b == choice_is_true(c),\n{\n    c.into()\n}",
      "start_line": 112,
      "end_line": 19,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimeMultiscalarMul#vartime_multiscalar_mul().",
      "display_name": "vartime_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimeMultiscalarMul#vartime_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "curve25519-dalek/src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn vartime_multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>,\n        Self::Point: Clone,\n    {\n        Self::optional_multiscalar_mul(\n            scalars,\n            points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }",
      "start_line": 250,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_cofactor().",
      "display_name": "mul_by_cofactor",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_cofactor().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_by_cofactor(&self) -> (result: EdwardsPoint)\n        requires\n            edwards_point_limbs_bounded(*self),\n    {\n        self.mul_by_pow_2(3)\n    }",
      "start_line": 2263,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_montgomery_lemmas/lemmas/lemma_from_montgomery_is_product_with_one().",
      "display_name": "lemma_from_montgomery_is_product_with_one",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_montgomery_lemmas/lemmas/lemma_from_montgomery_is_product_with_one().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_montgomery_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_montgomery_lemmas.rs",
      "file_name": "scalar_montgomery_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_from_montgomery_is_product_with_one(self_scalar: &Scalar52, limbs: &[u128; 9])\n    requires\n        limbs_bounded(self_scalar),\n        forall|j: int| #![auto] 0 <= j < 5 ==> limbs[j] == self_scalar.limbs[j] as u128,\n        forall|j: int| #![auto] 5 <= j < 9 ==> limbs[j] == 0,\n    ensures\n        (exists|bounded1: &Scalar52, bounded2: &Scalar52|\n            limbs_bounded(bounded1) && limbs_bounded(bounded2) && spec_mul_internal(\n                bounded1,\n                bounded2,\n            ) == limbs),\n{\n    let one = Scalar52 { limbs: [1, 0, 0, 0, 0] };\n    assert(1 < (1u64 << 52)) by (bit_vector);\n    let product = spec_mul_internal(self_scalar, &one);\n    assert(product[0] == (self_scalar.limbs[0] as u128) * 1);\n    assert(product[1] == (self_scalar.limbs[0] as u128) * 0 + (self_scalar.limbs[1] as u128) * 1);\n    assert(product[2] == ((self_scalar.limbs[0] as u128) * (0) + (self_scalar.limbs[1] as u128) * (\n    0) + (self_scalar.limbs[2] as u128) * (1)) as u128);\n    assert(product[3] == ((self_scalar.limbs[0] as u128) * (0) + (self_scalar.limbs[1] as u128) * (\n    0) + (self_scalar.limbs[2] as u128) * (0) + (self_scalar.limbs[3] as u128) * (1)) as u128);\n    assert(product[4] == ((self_scalar.limbs[0] as u128) * (0) + (self_scalar.limbs[1] as u128) * (\n    0) + (self_scalar.limbs[2] as u128) * (0) + (self_scalar.limbs[3] as u128) * (0) + (\n    self_scalar.limbs[4] as u128) * (1)) as u128);\n    assert(product[8] == ((self_scalar.limbs[4] as u128) * (0)) as u128);\n    assert(&product =~= limbs);\n}",
      "start_line": 12,
      "end_line": 55,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_p_minus_1_div_4().",
      "display_name": "lemma_p_minus_1_div_4",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_p_minus_1_div_4().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/unused_sqrt_ratio_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/unused_sqrt_ratio_lemmas.rs",
      "file_name": "unused_sqrt_ratio_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_p_minus_1_div_4()\n    ensures (p() - 1) % 4 == 0,\n{\n    pow255_gt_19();\n    lemma_pow2_adds(2, 253);\n    assume(pow2(2) == 4);  // 2^2 = 4\n    \n    assert(pow2(255) % 4 == 0) by { lemma_mul_mod_noop_left(4int, pow2(253) as int, 4int); };\n    assert(20int % 4 == 0) by (compute);\n    lemma_sub_mod_noop(pow2(255) as int, 20int, 4int);\n}",
      "start_line": 40,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/product_of_scalars().",
      "display_name": "product_of_scalars",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/product_of_scalars().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn product_of_scalars(scalars: Seq<Scalar>) -> nat\n    decreases scalars.len(),\n{\n    if scalars.len() == 0 {\n        1\n    } else {\n        (product_of_scalars(scalars.skip(1)) * bytes_to_nat(&scalars[0].bytes)) % group_order()\n    }\n}",
      "start_line": 62,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order().",
      "display_name": "from_bytes_mod_order",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn from_bytes_mod_order(bytes: [u8; 32]) -> (result: Scalar)\n        ensures\n    // Result is equivalent to input modulo the group order\n\n            bytes_to_nat(&result.bytes) % group_order() == bytes_to_nat(&bytes) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        // Temporarily allow s_unreduced.bytes > 2^255 ...\n        let s_unreduced = Scalar { bytes };\n\n        // Then reduce mod the group order and return the reduced representative.\n        let s = s_unreduced.reduce();\n        /*** <VERIFICATION NOTE> We omit debug asserts from verification  </VERIFICATION NOTE> ***/\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }",
      "start_line": 246,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "display_name": "lemma_bitops_lifted",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/bit_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/bit_lemmas.rs",
      "file_name": "bit_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_bitops_lifted(a: u64, b: u64, s: nat, k: nat)\n    requires\n        a < pow2(s),\n        a + b * pow2(s) <= u64::MAX,\n        s < 64,\n        k < 64,\n    ensures\n        (a + b * pow2(s)) as nat / pow2(k) == (a as nat) / pow2(k) + (b * pow2(s)) as nat / pow2(k),\n        (a + b * pow2(s)) as nat % pow2(k) == (a as nat) % pow2(k) + (b * pow2(s)) as nat % pow2(k),\n{\n    let pk = pow2(k);\n    let pk64 = pk as u64;\n\n    let ps = pow2(s);\n\n    let s64 = s as u64;\n    let k64 = k as u64;\n\n    let x = a;\n    let y = (b * ps) as u64;\n\n    assert(0 < pow2(k) <= u64::MAX) by {\n        lemma_pow2_pos(k);\n        lemma_pow2_le_max64(k);\n    }\n\n    assert(b * ps == b << s64) by {\n        lemma_u64_shl_is_mul(b, s as u64);\n    }\n\n    assert(b <= (u64::MAX >> s64)) by {\n        assert(b * ps <= (u64::MAX));  // x + y <= C => y <= C for x,y >= 0\n        assert((b << s64) >> s64 <= u64::MAX >> s64) by (bit_vector);\n        assert(b == (b << s64) >> s64) by {\n            lemma_left_right_shift(b, s64, s64);\n            lemma_shl_zero_is_id(b);\n        }\n    }\n\n    assert(x < 1u64 << s64) by {\n        lemma_shift_is_pow2(s);\n    }\n\n    assert(x + y == x | y) by {\n        lemma_bit_or_is_plus(a, b, s64);\n    }\n\n    let xory = x | y;\n    let lbm = (low_bits_mask(k) as u64);\n\n    assert(xory >> k64 == (x >> k64) | (y >> k64) && xory & lbm == (x & lbm) | (y & lbm)) by {\n        lemma_bitops(x, y, k64);\n    }\n\n    assert((a + b * ps) as nat / pk == (a as nat) / pk + (b * ps) as nat / pk) by {\n        assert(xory >> k64 == xory / pk64) by {\n            lemma_u64_shr_is_div(xory, k64);\n        }\n        assert(x >> k64 == x / pk64) by {\n            lemma_u64_shr_is_div(x, k64);\n        }\n        assert(y >> k64 == y / pk64) by {\n            lemma_u64_shr_is_div(y, k64);\n        }\n\n        assert((x / pk64) | (y / pk64) == (x / pk64) + (y / pk64)) by {\n            if (s >= k) {\n                let d = (s64 - k64) as u64;\n                assert(y / pk64 == (b << s64) >> k64);\n                assert((b << s64) >> k64 == b << d) by {\n                    lemma_left_right_shift(b, s64, k64);\n                }\n\n                assert(b <= u64::MAX >> d) by {\n                    assert(b <= u64::MAX >> s64);  // known\n                    assert(u64::MAX >> s64 <= u64::MAX >> d) by {\n                        lemma_shr_nonincreasing(u64::MAX, d as nat, s);\n                    }\n                }\n\n                assert(x / pk64 < 1u64 << d) by {\n                    assert(x < pow2(s));  // known\n                    assert(x < pow2(d as nat) * pow2(k)) by {\n                        lemma_pow2_adds(d as nat, k);\n                    }\n                    assert(pow2(k) > 0);  // known\n\n                    assert(x as nat / pow2(k) < pow2(d as nat)) by {\n                        lemma_multiply_divide_lt(x as int, pow2(k) as int, pow2(d as nat) as int);\n                    }\n\n                    assert(pow2(d as nat) == 1u64 << d) by {\n                        lemma_shift_is_pow2(d as nat);\n                    }\n                }\n\n                assert((x / pk64) | (b << d) == (x / pk64) + (b << d)) by {\n                    lemma_bit_or_is_plus(x / pk64, b, d);\n                }\n            } else {\n                // s < k\n                assert(x / pk64 == 0) by {\n                    assert(pow2(s) < pow2(k)) by {\n                        lemma_pow2_strictly_increases(s, k);\n                    }\n                    lemma_basic_div(x as int, pk64 as int);\n                }\n\n                assert(0 | (y / pk64) == (y / pk64)) by {\n                    lemma_bitwise_or_l_zero_is_id(y / pk64);\n                }\n            }\n\n        }\n    }\n\n    assert((a + b * ps) as nat % pk == (a as nat) % pk + (b * ps) as nat % pk) by {\n        assert(xory & lbm == xory % pk64) by {\n            lemma_u64_low_bits_mask_is_mod(xory, k);\n        }\n        assert(x & lbm == x % pk64) by {\n            lemma_u64_low_bits_mask_is_mod(x, k);\n        }\n        assert(y & lbm == y % pk64) by {\n            lemma_u64_low_bits_mask_is_mod(y, k);\n        }\n\n        assert((x % pk64) | (y % pk64) == (x % pk64) + (y % pk64)) by {\n            if (s >= k) {\n                let d = (s - k) as nat;\n                assert(y % pk64 == 0) by {\n                    assert(y == pow2(k) * (b * pow2(d))) by {\n                        lemma_pow2_adds(d, k);\n                        lemma_mul_is_associative(b as int, pow2(d) as int, pow2(k) as int);\n                        lemma_mul_is_commutative((b * pow2(d)) as int, pow2(k) as int);\n                    }\n                    assert(y as nat % pow2(k) == 0) by {\n                        lemma_mod_multiples_basic((b * pow2(d)) as int, pow2(k) as int);\n                    }\n                }\n                assert((x % pk64) | 0 == (x % pk64)) by {\n                    lemma_bitwise_or_r_zero_is_id(x % pk64);\n                }\n            } else {\n                // s < k\n                let d = (k - s) as nat;\n                let b_n = b as nat;\n\n                assert(pow2(d) > 0) by {\n                    lemma_pow2_pos(d);\n                }\n\n                assert(x & lbm < 1u64 << s64) by {\n                    assert(x & lbm <= x) by (bit_vector);\n                }\n\n                assert(y % pk64 == (b_n % pow2(d)) * pow2(s)) by {\n                    lemma_pow2_mul_mod(b_n, s, k);\n                }\n\n                assert(b_n % pow2(d) <= b) by {\n                    lemma_mod_decreases(b as nat, pow2(d) as nat);\n                }\n\n                assert((x & lbm) | ((b_n % pow2(d)) * pow2(s)) as u64 == (x & lbm) + ((b_n % pow2(\n                    d,\n                )) * pow2(s))) by {\n                    assert(((b_n % pow2(d)) * pow2(s)) == (((b_n % pow2(d)) as u64) << s64)) by {\n                        lemma_u64_shl_is_mul((b_n % pow2(d)) as u64, s64);\n                    }\n                    lemma_bit_or_is_plus(x & lbm, (b_n % pow2(d)) as u64, s64);\n                }\n            }\n        }\n    }\n}",
      "start_line": 54,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 21
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_decreases().",
      "display_name": "lemma_mod_decreases",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_decreases().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/bit_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/bit_lemmas.rs",
      "file_name": "bit_lemmas.rs",
      "parent_folder": "common_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#len().",
      "display_name": "len",
      "symbol": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#len().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#elligator_ristretto_flavor_inverse().",
      "display_name": "elligator_ristretto_flavor_inverse",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#elligator_ristretto_flavor_inverse().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    pub fn elligator_ristretto_flavor_inverse(&self) -> (u8, [FieldElement; 8]) {\n        // Elligator2 computes a Point from a FieldElement in two steps: first\n        // it computes a (s,t) on the Jacobi quartic and then computes the\n        // corresponding even point on the Edwards curve.\n        //\n        // We invert in three steps.  Any Ristretto point has four representatives\n        // as even Edwards points.  For each of those even Edwards points,\n        // there are two points on the Jacobi quartic that map to it.\n        // Each of those eight points on the Jacobi quartic might have an\n        // Elligator2 preimage.\n        //\n        // Essentially we first loop over the four representatives of our point,\n        // then for each of them consider both points on the Jacobi quartic and\n        // check whether they have an inverse under Elligator2.  We take the\n        // following shortcut though.\n        //\n        // We can compute two Jacobi quartic points for (x,y) and (-x,-y)\n        // at the same time.  The four Jacobi quartic points are two of\n        // such pairs.\n\n        let mut mask: u8 = 0;\n        let jcs = self.to_jacobi_quartic_ristretto();\n        let mut ret = [FieldElement::ONE; 8];\n\n        for i in 0..4 {\n            let (ok, fe) = jcs[i].elligator_inv();\n            let mut tmp: u8 = 0;\n            ret[2 * i] = fe;\n            tmp.conditional_assign(&1, ok);\n            mask |= tmp << (2 * i);\n\n            let jc = jcs[i].dual();\n            let (ok, fe) = jc.elligator_inv();\n            let mut tmp: u8 = 0;\n            ret[2 * i + 1] = fe;\n            tmp.conditional_assign(&1, ok);\n            mask |= tmp << (2 * i + 1);\n        }\n\n        (mask, ret)\n    }",
      "start_line": 111,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_sqrt_m1_not_square().",
      "display_name": "axiom_sqrt_m1_not_square",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_sqrt_m1_not_square().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "file_name": "sqrt_ratio_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn axiom_sqrt_m1_not_square()\n    ensures\n        !is_square_mod_p(spec_sqrt_m1()),\n{\n    admit();\n}",
      "start_line": 95,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_multiply_by_i_flips_sign().",
      "display_name": "lemma_multiply_by_i_flips_sign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_multiply_by_i_flips_sign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "file_name": "sqrt_ratio_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_multiply_by_i_flips_sign(r: nat)\n    ensures\n        ((r * spec_sqrt_m1()) % p() * (r * spec_sqrt_m1()) % p()) % p()\n            == ((p() as int - ((r * r) % p()) as int) % p() as int) as nat,\n{\n    pow255_gt_19();\n    \n    let ri = r * spec_sqrt_m1();\n    let pn = p();\n    let r2 = r * r;\n    let i2 = spec_sqrt_m1() * spec_sqrt_m1();\n    let pn_minus_1: nat = (pn - 1) as nat;\n    let r2_mod = r2 % pn;\n    let neg_r2: nat = (pn - r2_mod) as nat;\n    \n    // Main chain: (ri)² % p = -r² % p = (p - r²%p) % p\n    assert((ri * ri) % pn == neg_r2 % pn) by {\n        // (ri)² = r²·i²  [product square factorization]\n        assert(ri * ri == r2 * i2) by {\n            lemma_product_square(r, spec_sqrt_m1());\n        };\n        \n        // (r²·i²) % p = (r²·(p-1)) % p  [because i² ≡ p-1 (mod p)]\n        assert((r2 * i2) % pn == (r2 * pn_minus_1) % pn) by {\n            assert(i2 % pn == pn_minus_1) by { axiom_sqrt_m1_squared(); };\n            lemma_mul_mod_noop_right(r2 as int, i2 as int, pn as int);\n        };\n        \n        // r²·(p-1) % p = (p - r²%p) % p  [multiplication by -1 is negation]\n        assert((r2 * pn_minus_1) % pn == neg_r2 % pn) by {\n            lemma_mul_by_minus_one_is_negation(r2, pn);\n        };\n    };\n    \n    // Connect neg_r2 to ensures RHS form\n    assert(neg_r2 % pn == ((pn as int - r2_mod as int) % (pn as int)) as nat) by {\n        lemma_mod_bound(r2 as int, pn as int);\n    };\n    \n    // Handle operator precedence: ensures LHS parses as (((ri % pn) * ri) % pn) % pn\n    // Show this equals (ri * ri) % pn\n    assert((((ri % pn) * ri) % pn) % pn == (ri * ri) % pn) by {\n        // ((a%m)*b) % m = (a*b) % m\n        assert(((ri % pn) * ri) % pn == (ri * ri) % pn) by {\n            lemma_mul_mod_noop_left(ri as int, ri as int, pn as int);\n        };\n        // (x % m) % m = x % m\n        lemma_mod_twice(((ri % pn) * ri) as int, pn as int);\n    };\n}",
      "start_line": 230,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#from_uniform_bytes_single_elligator().",
      "display_name": "from_uniform_bytes_single_elligator",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#from_uniform_bytes_single_elligator().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    pub fn from_uniform_bytes_single_elligator(bytes: &[u8; 32]) -> RistrettoPoint {\n        RistrettoPoint::elligator_ristretto_flavor(&FieldElement::from_bytes(bytes))\n    }",
      "start_line": 25,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/lemma_low_bits_mask_unfold().",
      "display_name": "lemma_low_bits_mask_unfold",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/lemma_low_bits_mask_unfold().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mask_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mask_lemmas.rs",
      "file_name": "mask_lemmas.rs",
      "parent_folder": "common_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/word_from_bytes_partial().",
      "display_name": "word_from_bytes_partial",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/word_from_bytes_partial().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn word_from_bytes_partial(bytes: &[u8; 64], word_idx: int, upto: int) -> nat\n    decreases\n            if upto <= 0 {\n                0\n            } else if upto >= 8 {\n                0\n            } else {\n                upto as nat\n            },",
      "start_line": 144,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_plus_ver_div_mod().",
      "display_name": "lemma_load8_plus_ver_div_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_plus_ver_div_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_load8_plus_ver_div_mod(input: &[u8], i: usize, k: nat, s: nat)\n    requires\n        i + 7 < input.len(),\n        0 < k <= 7,\n        s < 64,\n    ensures\n        load8_at_plus_version_rec(input, i, k) / (pow2(s) as u64) == load8_at_plus_version_rec(\n            input,\n            i,\n            (k - 1) as nat,\n        ) / (pow2(s) as u64) + (pow2(k * 8) * input[i + k]) as u64 / (pow2(s) as u64),\n        load8_at_plus_version_rec(input, i, k) % (pow2(s) as u64) == load8_at_plus_version_rec(\n            input,\n            i,\n            (k - 1) as nat,\n        ) % (pow2(s) as u64) + (pow2(k * 8) * input[i + k]) as u64 % (pow2(s) as u64),\n{\n    assert(pow2(s) <= u64::MAX) by {\n        lemma_pow2_le_max64(s);\n    }\n\n    assert(pow2(s) > 0) by {\n        lemma_pow2_pos(s);\n    }\n\n    assert(pow2(k * 8) <= u64::MAX) by {\n        lemma_pow2_le_max64(k * 8);\n    }\n\n    let p64 = pow2(s) as u64;\n\n    let xk = load8_at_plus_version_rec(input, i, k);\n    let xk_1 = load8_at_plus_version_rec(input, i, (k - 1) as nat);\n    let v = input[i + k];\n    let v_n = v as nat;\n\n    assert(xk == (xk_1 + ((v as u64) << k * 8)) as u64) by {\n        reveal_with_fuel(load8_at_plus_version_rec, 1);\n    }\n\n    assert(v * pow2(k * 8) <= u64::MAX) by {\n        lemma_u8_times_pow2_fits_u64(v, k * 8);\n    }\n\n    assert(((v as u64) << k * 8) == pow2(k * 8) * v) by {\n        lemma_u64_shl_is_mul(v as u64, (k * 8) as u64);\n    }\n\n    assert(xk_1 < pow2(8 * k)) by {\n        lemma_load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n    }\n\n    assert((xk_1 + pow2(k * 8) * v) as u64 / p64 == xk_1 / p64 + ((pow2(k * 8) * v) as u64) / p64\n        && (xk_1 + pow2(k * 8) * v) as u64 % p64 == xk_1 % p64 + ((pow2(k * 8) * v) as u64) % p64)\n        by {\n        assert((xk_1 + pow2(k * 8) * v) <= u64::MAX) by {\n            lemma_load8_at_plus_fits_u64(input, i, k);\n        }\n        lemma_bitops_lifted(xk_1, v as u64, (k * 8) as nat, s);\n    }\n}",
      "start_line": 300,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/lemma_low_bits_mask_values().",
      "display_name": "lemma_low_bits_mask_values",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/lemma_low_bits_mask_values().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mask_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mask_lemmas.rs",
      "file_name": "mask_lemmas.rs",
      "parent_folder": "common_lemmas",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/completed_point_as_affine_edwards().",
      "display_name": "completed_point_as_affine_edwards",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/completed_point_as_affine_edwards().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn completed_point_as_affine_edwards(\n    point: crate::backend::serial::curve_models::CompletedPoint,\n) -> (nat, nat) {\n    let (x_abs, y_abs, z_abs, t_abs) = spec_completed_point(point);\n    let z_inv = math_field_inv(z_abs);\n    let t_inv = math_field_inv(t_abs);\n    (math_field_mul(x_abs, z_inv), math_field_mul(y_abs, t_inv))\n}",
      "start_line": 292,
      "end_line": 51,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "display_name": "lemma_pow2k_loop_value",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_pow2k_loop_value(a: [u64; 5], limbs: [u64; 5], i: nat)\n    requires\n        pow2k_loop_boundary_spec(a),\n        u64_5_as_nat(a) % p() == pow(u64_5_as_nat(limbs) as int, pow2(i)) as nat % p(),\n    ensures\n        u64_5_as_nat(pow2k_loop_return(a)) % p() == pow(\n            u64_5_as_nat(limbs) as int,\n            pow2(i + 1),\n        ) as nat % p(),\n{\n    lemma2_to64_rest();  // pow2(51)\n    assert(p() > 0) by {\n        pow255_gt_19();\n    }\n\n    assert(mask51 == low_bits_mask(51)) by {\n        l51_bit_mask_lt();\n    }\n\n    // let a_hat = [a0_2, a1_1, a2, a3, a4];\n    let a_hat = pow2k_loop_return(a);\n    let a0_1 = a0_1_val(a);\n    let a0_2 = a0_2_val(a);\n    let a1_0 = a1_0_val(a);\n    let a1_1 = a1_1_val(a);\n    let a2 = a2_0_val(a);\n    let a3 = a3_0_val(a);\n    let a4 = a4_0_val(a);\n\n    assert(u64_5_as_nat(a_hat) % p() == (u64_5_as_nat(a) * u64_5_as_nat(a)) % p()) by {\n        // it suffices to prove u64_5_as_nat(a_hat) == (u64_5_as_nat(a))^2 (mod p)\n        // let s = pow2(51) for brevity\n        // By definition, u64_5_as_nat(a_hat) = a0_2 + s * a1_1 + s^2 * a2 + s^3 * a3 + s^4 * a4\n        // a0_2 + s * a1_1 cancel out terms via the div/mod identity:\n        assert(u64_5_as_nat(a_hat) == a0_1 + pow2(51) * a1_0 + pow2(102) * a2 + pow2(153) * a3\n            + pow2(204) * a4) by {\n            // a0_2 + s * a1_1 =\n            // a0_1 % s  + s * (a1_0 + s * (a0_1 / s)) =\n            // s * a1_0 + [s * (a0_1 / s) + a0_1 % s] = (by the div-mod identity)\n            // s * a1_0 + a0_1\n            assert(a0_2 + pow2(51) * a1_1 == a0_1 + pow2(51) * a1_0) by {\n                assert(a0_2 == a0_1 % (pow2(51) as u64)) by {\n                    lemma_u64_low_bits_mask_is_mod(a0_1, 51);\n                }\n\n                assert(a0_1 >> 51 == a0_1 / (pow2(51) as u64)) by {\n                    lemma_u64_shr_is_div(a0_1, 51);\n                }\n\n                lemma_div_and_mod_51((a0_1 >> 51), a0_2, a0_1);\n            }\n        }\n\n        let c0_0 = c0_0_val(a);\n        let c1_0 = c1_0_val(a);\n        let c2_0 = c2_0_val(a);\n        let c3_0 = c3_0_val(a);\n        let c4_0 = c4_0_val(a);\n        let c1 = c1_val(a);\n        let c2 = c2_val(a);\n        let c3 = c3_val(a);\n        let c4 = c4_val(a);\n        let carry = carry_val(a);\n\n        // Next, we replace all _ & LOW_BITS_MASK with (mod s)\n        assert(u64_5_as_nat(a_hat) == ((c0_0 as u64) % (pow2(51) as u64)) + 19 * carry + pow2(51)\n            * ((c1 as u64) % (pow2(51) as u64)) + pow2(102) * ((c2 as u64) % (pow2(51) as u64))\n            + pow2(153) * ((c3 as u64) % (pow2(51) as u64)) + pow2(204) * ((c4 as u64) % (pow2(\n            51,\n        ) as u64))) by {\n            l51_bit_mask_lt();\n\n            assert((pow2(51) as u64) == (pow2(51) as u128));\n\n            assert(a0_1 == ((c0_0 as u64) % (pow2(51) as u64)) + 19 * carry) by {\n                lemma_u64_low_bits_mask_is_mod(c0_0 as u64, 51);\n            }\n\n            assert(a1_0 == (c1 as u64) % (pow2(51) as u64)) by {\n                lemma_u64_low_bits_mask_is_mod(c1 as u64, 51);\n            }\n\n            assert(a2 == (c2 as u64) % (pow2(51) as u64)) by {\n                lemma_u64_low_bits_mask_is_mod(c2 as u64, 51);\n            }\n\n            assert(a3 == (c3 as u64) % (pow2(51) as u64)) by {\n                lemma_u64_low_bits_mask_is_mod(c3 as u64, 51);\n            }\n\n            assert(a4 == (c4 as u64) % (pow2(51) as u64)) by {\n                lemma_u64_low_bits_mask_is_mod(c4 as u64, 51);\n            }\n        }\n\n        // We can see all mod operations in u128\n        assert(u64_5_as_nat(a_hat) == (c0_0 % (pow2(51) as u128)) + 19 * carry + pow2(51) * (c1 % (\n        pow2(51) as u128)) + pow2(102) * (c2 % (pow2(51) as u128)) + pow2(153) * (c3 % (pow2(\n            51,\n        ) as u128)) + pow2(204) * (c4 % (pow2(51) as u128))) by {\n            // pow2(51) is the same in u64 and 128\n            lemma_cast_then_mod_51(c0_0);\n            lemma_cast_then_mod_51(c1);\n            lemma_cast_then_mod_51(c2);\n            lemma_cast_then_mod_51(c3);\n            lemma_cast_then_mod_51(c4);\n        }\n\n        // Next, we categorically replace a % s with a - s * ( a / s )\n        assert(u64_5_as_nat(a_hat) == (c0_0 - pow2(51) * (c0_0 / (pow2(51) as u128))) + 19 * carry\n            + pow2(51) * (c1 - pow2(51) * (c1 / (pow2(51) as u128))) + pow2(102) * (c2 - pow2(51)\n            * (c2 / (pow2(51) as u128))) + pow2(153) * (c3 - pow2(51) * (c3 / (pow2(51) as u128)))\n            + pow2(204) * (c4 - pow2(51) * (c4 / (pow2(51) as u128)))) by {\n            lemma_fundamental_div_mod(c0_0 as int, pow2(51) as int);\n            lemma_fundamental_div_mod(c1 as int, pow2(51) as int);\n            lemma_fundamental_div_mod(c2 as int, pow2(51) as int);\n            lemma_fundamental_div_mod(c3 as int, pow2(51) as int);\n            lemma_fundamental_div_mod(c4 as int, pow2(51) as int);\n        }\n\n        // Then, we know that\n        // carry = c4/s\n        // c4 = c4_0 + c3/s <=> c3/s = c4 - c4_0\n        // c3 = c3_0 + c2/s <=> c2/s = c3 - c3_0\n        // c2 = c2_0 + c1/s <=> c1/s = c2 - c2_0\n        // c1 = c1_0 + c0_0/s <=> c0_0/s = c1 - c1_0\n        assert(u64_5_as_nat(a_hat) == (c0_0 - pow2(51) * (c1 - c1_0)) + 19 * carry + pow2(51) * (c1\n            - pow2(51) * (c2 - c2_0)) + pow2(102) * (c2 - pow2(51) * (c3 - c3_0)) + pow2(153) * (c3\n            - pow2(51) * (c4 - c4_0)) + pow2(204) * (c4 - pow2(51) * carry)) by {\n            lemma_u128_shr_is_div(c0_0, 51);\n            lemma_u128_shr_is_div(c1, 51);\n            lemma_u128_shr_is_div(c2, 51);\n            lemma_u128_shr_is_div(c3, 51);\n            lemma_u128_shr_is_div(c4, 51);\n        }\n\n        // Now we use distributivity and pow exponent sums, which cancels out any ci terms and leaves only ci_0 terms\n        // Conveniently, we're left with a difference of c * p\n        assert(u64_5_as_nat(a_hat) == c0_0 + pow2(51) * c1_0 + pow2(102) * c2_0 + pow2(153) * c3_0\n            + pow2(204) * c4_0 - p() * carry) by {\n            assert(c0_0 - pow2(51) * (c1 - c1_0) == c0_0 - pow2(51) * c1 + pow2(51) * c1_0) by {\n                lemma_mul_is_distributive_sub(pow2(51) as int, c1 as int, c1_0 as int);\n            }\n\n            assert(pow2(51) * (c1 - pow2(51) * (c2 - c2_0)) == pow2(51) * c1 - pow2(102) * c2\n                + pow2(102) * c2_0) by {\n                lemma_mul_sub(c1 as int, c2 as int, c2_0 as int, 51);\n            }\n\n            assert(pow2(102) * (c2 - pow2(51) * (c3 - c3_0)) == pow2(102) * c2 - pow2(153) * c3\n                + pow2(153) * c3_0) by {\n                lemma_mul_sub(c2 as int, c3 as int, c3_0 as int, 102);\n            }\n\n            assert(pow2(153) * (c3 - pow2(51) * (c4 - c4_0)) == pow2(153) * c3 - pow2(204) * c4\n                + pow2(204) * c4_0) by {\n                lemma_mul_sub(c3 as int, c4 as int, c4_0 as int, 153);\n            }\n\n            assert(pow2(204) * (c4 - pow2(51) * carry) == pow2(204) * c4 - pow2(255) * carry) by {\n                lemma_mul_is_distributive_sub(pow2(204) as int, c4 as int, pow2(51) * carry);\n                lemma_mul_is_associative(pow2(204) as int, pow2(51) as int, carry as int);\n                lemma_pow2_adds(204, 51);\n            }\n\n            // carry on the right, get p\n            assert(c0_0 + pow2(51) * c1_0 + pow2(102) * c2_0 + pow2(153) * c3_0 + pow2(204) * c4_0\n                + 19 * carry - pow2(255) * carry == c0_0 + pow2(51) * c1_0 + pow2(102) * c2_0\n                + pow2(153) * c3_0 + pow2(204) * c4_0 - p() * carry) by {\n                pow255_gt_19();\n                lemma_mul_is_distributive_sub_other_way(carry as int, pow2(255) as int, 19);\n            }\n        }\n\n        let c_arr_as_nat = (c0_0 + pow2(51) * c1_0 + pow2(102) * c2_0 + pow2(153) * c3_0 + pow2(204)\n            * c4_0);\n\n        assert(u64_5_as_nat(a_hat) % p() == c_arr_as_nat as nat % p()) by {\n            lemma_mod_diff_factor(carry as int, c_arr_as_nat as int, p() as int);\n        }\n\n        // We use the lemma_u64_5_as_nat_squared lemma to see what (u64_5_as_nat(a)^2) evaluates to (mod p)\n\n        // The nat_squared lemma gives us the following:\n        // u64_5_as_nat(a) * u64_5_as_nat(a) ==\n        // pow2(8 * 51) * (a[4] * a[4]) +\n        // pow2(7 * 51) * (2 * (a[3] * a[4])) +\n        // pow2(6 * 51) * (a[3] * a[3] + 2 * (a[2] * a[4])) +\n        // pow2(5 * 51) * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])) +\n        // pow2(4 * 51) * (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])) +\n        // pow2(3 * 51) * (2 * (a[1] * a[2]) + 2 * (a[0] * a[3])) +\n        // pow2(2 * 51) * (a[1] * a[1] + 2 * (a[0] * a[2])) +\n        // pow2(1 * 51) * (2 * (a[0] * a[1])) +\n        //                (a[0] * a[0])\n        //\n        // AND\n        //\n        // (u64_5_as_nat(a) * u64_5_as_nat(a)) % p() ==\n        // (\n        //     pow2(4 * 51) * (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])) +\n        //     pow2(3 * 51) * (2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])) +\n        //     pow2(2 * 51) * (a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))) +\n        //     pow2(1 * 51) * (2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))) +\n        //                    (a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])))\n        // ) as nat % p()\n        lemma_u64_5_as_nat_squared(a);\n\n        // We're basically done, what remains is to prove that the coefficients next to pow2(i * 51)\n        // are exactly ci_0s (via distributivity and associativity)\n\n        let a3_19 = 19 * a[3];\n        let a4_19 = 19 * a[4];\n\n        // let c0_0: u128 = a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19);\n        assert(c0_0 == (a[0] * a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])))) by {\n            // The solver does distributivity on its own.\n            // LHS = a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19);\n            //     = a[0] *  a[0] + 2*( a[1] * a4_19 ) + 2 * (a[2] * a3_19);\n            // RHS = a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4]))\n            //     = a[0] *  a[0] + 19 * (2 * (a[2] * a[3])) + 19 * (2 * (a[1] * a[4]))\n            // goals\n            // 1) 2 * (a[1] * a4_19) = 19 * (2 * (a[1] * a[4]))\n            // 2) 2 * (a[2] * a3_19) = 19 * (2 * (a[2] * a[3]))\n            assert(2 * (a[1] * a4_19) == 19 * (2 * (a[1] * a[4]))) by {\n                lemma_reorder_mul(a[1] as int, a[4] as int);\n            }\n\n            assert(2 * (a[2] * a3_19) == 19 * (2 * (a[2] * a[3]))) by {\n                lemma_reorder_mul(a[2] as int, a[3] as int);\n            }\n        }\n\n        // let c1_0: u128 = a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19);\n        assert(c1_0 == (2 * (a[0] * a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4])))) by {\n            // The solver does distributivity on its own.\n            // LHS = a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19)\n            //     = a[3] * a3_19 + 2*( a[0] *  a[1]) + 2 * (a[2] * a4_19)\n            // RHS = 2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))\n            //     = 2 * (a[0] *  a[1]) + 19 * (a[3] * a[3]) + 19 * (2 * (a[2] * a[4]))\n            // goals: 1) a[3] * a3_19 = 19 * (a[3] * a[3])\n            //        2) 2 * (a[2] * a4_19) = 19 * (2 * (a[2] * a[4]))\n            assert(a[3] * a3_19 == 19 * (a[3] * a[3])) by {\n                lemma_mul_is_associative(a[3] as int, a[3] as int, 19);\n            }\n\n            assert(2 * (a[2] * a4_19) == 19 * (2 * (a[2] * a[4]))) by {\n                lemma_reorder_mul(a[2] as int, a[4] as int);\n            }\n        }\n\n        // let c2_0: u128 = a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * a3_19);\n        assert(c2_0 == (a[1] * a[1] + 2 * (a[0] * a[2]) + 19 * (2 * (a[3] * a[4])))) by {\n            // The solver does distributivity on its own.\n            // LHS = a[1] * a[1] + 2 * (a[0] *  a[2] + a[4] * a3_19)\n            //     = a[1] * a[1] + 2 * (a[0] *  a[2]) +  2 * (a[4] * a3_19)\n            // RHS = a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))\n            // goals: 2 * (a[4] * a3_19) = 19 * (2 * (a[3] * a[4]))\n            assert(2 * (a[4] * a3_19) == 19 * (2 * (a[3] * a[4]))) by {\n                lemma_mul_is_associative(a[4] as int, a[3] as int, 19);\n            }\n        }\n\n        // let c3_0: u128 = a[4] * a4_19 + 2*( a[0] *  a[3] + a[1] *  a[2]);\n        assert(c3_0 == (2 * (a[1] * a[2]) + 2 * (a[0] * a[3]) + 19 * (a[4] * a[4]))) by {\n            // The solver does distributivity on its own.\n            // LHS = a[4] * a4_19 + 2 * (a[0] *  a[3] + a[1] *  a[2])\n            //     = a[4] * a4_19 + 2 * (a[0] *  a[3]) + 2 * (a[1] *  a[2])\n            // RHS = 2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])\n            // goals: a[4] * a4_19 = 19 * (a[4] * a[4])\n            assert(a[4] * a4_19 == 19 * (a[4] * a[4])) by {\n                lemma_mul_is_associative(a[4] as int, a[4] as int, 19);\n            }\n        }\n\n        // let c4_0: u128 = a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3]);\n        assert(c4_0 == (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4]))) by {\n            // The solver does distributivity on its own.\n            // LHS = a[2] * a[2] + 2 * (a[0] * a[4] + a[1] * a[3])\n            //     = a[2] * a[2] + 2 * (a[0] * a[4]) + 2 * (a[1] * a[3])\n            // RHS = a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])\n            // goals: none\n        }\n    }\n\n    let a_pow_2i_int = pow(u64_5_as_nat(limbs) as int, pow2(i));\n    assert(a_pow_2i_int >= 0) by {\n        lemma_pow_nat_is_nat(u64_5_as_nat(limbs), i);\n    }\n    let a_pow_2i: nat = a_pow_2i_int as nat;\n\n    assert(u64_5_as_nat(a_hat) % p() == ((u64_5_as_nat(a) % p()) * (u64_5_as_nat(a) % p())) % p())\n        by {\n        lemma_mul_mod_noop(u64_5_as_nat(a) as int, u64_5_as_nat(a) as int, p() as int);\n    }\n\n    // (a_pow_2i % p)^2 % p = (a_pow_2i^2) % p\n    assert(((a_pow_2i % p()) * (a_pow_2i % p())) % p() == (a_pow_2i * a_pow_2i) % p()) by {\n        lemma_mul_mod_noop(a_pow_2i as int, a_pow_2i as int, p() as int);\n    }\n\n    // We know, by the loop inv, that\n    // u64_5_as_nat(a) % p == a_pow_2i % p\n    // and, by the above\n    // u64_5_as_nat(a_hat) % p  = (u64_5_as_nat(a) * u64_5_as_nat(a)) % p = (a_pow_2i ^ 2)) % p\n    // It suffices to prove that\n    // (v^(2^i))^2 = v^(2^(i + 1))\n    assert(pow(u64_5_as_nat(limbs) as int, pow2(i)) * pow(u64_5_as_nat(limbs) as int, pow2(i))\n        == pow(u64_5_as_nat(limbs) as int, pow2(i + 1))) by {\n        lemma_pow2_square(u64_5_as_nat(limbs) as int, i);\n    }\n}",
      "start_line": 327,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 41
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_nonzero_mod_prime().",
      "display_name": "lemma_product_nonzero_mod_prime",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_nonzero_mod_prime().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_product_nonzero_mod_prime(a: nat, i: nat, p: nat)\n    requires\n        is_prime(p),\n        a % p != 0,\n        i % p != 0,\n    ensures\n        (a * i) % p != 0,\n{\n    // Proof by contradiction: suppose (a * i) % p == 0\n    // Then p | (a * i). Since p is prime and p doesn't divide a or i,\n    // this contradicts Euclid's lemma: if p | ab and p is prime, then p | a or p | b\n    if (a * i) % p == 0 {\n        // p divides a * i\n        // By Euclid's lemma for primes, p must divide a or p must divide i\n        lemma_euclid_prime(a, i, p);\n        // This gives us a % p == 0 || i % p == 0, contradicting our preconditions\n        assert(false);\n    }\n}",
      "start_line": 1034,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn identity() -> (result: ProjectivePoint)\n        ensures\n    // The identity point is (1:0) in projective coordinates\n\n            spec_field_element(&result.U) == 1,\n            spec_field_element(&result.W) == 0,\n    {\n        let result = ProjectivePoint { U: FieldElement::ONE, W: FieldElement::ZERO };\n        proof {\n            // The identity point is (1, 0) in projective coordinates\n            assume(spec_field_element(&result.U) == 1);\n            assume(spec_field_element(&result.W) == 0);\n        }\n        result\n    }",
      "start_line": 578,
      "end_line": 16,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_strictly_bounded().",
      "display_name": "lemma_div_strictly_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_strictly_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_div_strictly_bounded(x: int, a: int, b: int)\n    requires\n        a > 0,\n        b >= 0,\n        x < a * b,\n    ensures\n        x / a < b,\n{\n    // (b * a) / a == b\n    lemma_div_by_multiple(b, a);\n    // x < b * a && a > 0 => x / a < (b * a) / a\n    lemma_div_by_multiple_is_strongly_ordered(x, a * b, b, a);\n}",
      "start_line": 97,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/lemma_u8_32_as_nat_equals_rec().",
      "display_name": "lemma_u8_32_as_nat_equals_rec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/lemma_u8_32_as_nat_equals_rec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/core_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/core_specs.rs",
      "file_name": "core_specs.rs",
      "parent_folder": "specs",
      "body": "pub proof fn lemma_u8_32_as_nat_equals_rec(bytes: &[u8; 32])\n    ensures\n        u8_32_as_nat(bytes) == u8_32_as_nat_rec(bytes, 0),\n{\n    // Reveal the recursive definition with enough fuel to unfold from 0 to 32\n    reveal_with_fuel(u8_32_as_nat_rec, 33);\n\n    // u8_32_as_nat is defined explicitly as the sum\n    // u8_32_as_nat_rec(bytes, 0) unfolds recursively to the same sum\n    assert(u8_32_as_nat_rec(bytes, 32) == 0);\n}",
      "start_line": 75,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_adds().",
      "display_name": "lemma_mod_adds",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_adds().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/pow256().",
      "display_name": "pow256",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/pow256().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn pow256(n: nat) -> nat {\n    pow2(8 * n)\n}",
      "start_line": 76,
      "end_line": 24,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo digest 0.10.7 digest/Digest#digest().",
      "display_name": "digest",
      "symbol": "rust-analyzer cargo digest 0.10.7 digest/Digest#digest().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_52_52().",
      "display_name": "lemma_52_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_52_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_52_52(x: u64, y: u64)\n    requires\n        x < (1u64 << 52),\n        y < (1u64 << 52),\n    ensures\n        (x as u128) * (y as u128) < (1u128 << 104),\n{\n    assert(1u128 << 52 == 1u64 << 52) by (bit_vector);\n    calc! {\n        (<)\n        (x as u128) * (y as u128); (<=) {\n            if x > 0 {\n                lemma_mul_strict_inequality(y as int, (1u128 << 52) as int, x as int);\n                assert(x * y < x * (1u128 << 52));\n            } else {\n                assert((0 as u128) * (y as u128) == 0);\n            }\n        }\n        (x as u128) * (1u128 << 52); (<) {\n            lemma_mul_strict_inequality(x as int, (1u128 << 52) as int, (1u128 << 52) as int);\n        }\n        (1u128 << 52) * (1u128 << 52);\n    }\n    assert((1u128 << 52) * (1u128 << 52) == (1u128 << 104)) by (compute);\n}",
      "start_line": 48,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bytes_to_nat_rec_bound().",
      "display_name": "lemma_bytes_to_nat_rec_bound",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bytes_to_nat_rec_bound().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "proof fn lemma_bytes_to_nat_rec_bound(bytes: &[u8; 32], start: usize, target: usize)\n    requires\n        start <= target < 32,\n    ensures\n        bytes_to_nat_rec(bytes, start as int) >= (bytes[target as int] as nat) * pow2(\n            (target * 8) as nat,\n        ),\n    decreases 32 - start,\n{\n    if start == target {\n        // Base case: the current term is exactly what we're looking for\n        // bytes_to_nat_rec(bytes, target) = bytes[target] * pow2(target*8) + (rest >= 0)\n    } else {\n        // Inductive case: recurse to the next position\n        lemma_bytes_to_nat_rec_bound(bytes, (start + 1) as usize, target);\n    }\n}",
      "start_line": 1600,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_u16().",
      "display_name": "ct_eq_u16",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_u16().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn ct_eq_u16(a: &u16, b: &u16) -> (c: Choice)\n    ensures\n        choice_is_true(c) == (*a == *b),\n{\n    a.ct_eq(b)\n}",
      "start_line": 103,
      "end_line": 17,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_niels_point().",
      "display_name": "spec_projective_niels_point",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_niels_point().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_projective_niels_point(niels: ProjectiveNielsPoint) -> (nat, nat, nat, nat) {\n    let y_plus_x = spec_field_element(&niels.Y_plus_X);\n    let y_minus_x = spec_field_element(&niels.Y_minus_X);\n    let z = spec_field_element(&niels.Z);\n    let t2d = spec_field_element(&niels.T2d);\n    (y_plus_x, y_minus_x, z, t2d)\n}",
      "start_line": 337,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow1().",
      "display_name": "lemma_pow1",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow1().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "display_name": "optional_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
      "file_name": "pippenger.rs",
      "parent_folder": "scalar_mul",
      "body": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::traits::Identity;\n\n        let mut scalars = scalars.into_iter();\n        let size = scalars.by_ref().size_hint().0;\n\n        // Digit width in bits. As digit width grows,\n        // number of point additions goes down, but amount of\n        // buckets and bucket additions grows exponentially.\n        let w = if size < 500 {\n            6\n        } else if size < 800 {\n            7\n        } else {\n            8\n        };\n\n        let max_digit: usize = 1 << w;\n        let digits_count: usize = Scalar::to_radix_2w_size_hint(w);\n        let buckets_count: usize = max_digit / 2; // digits are signed+centered hence 2^w/2, excluding 0-th bucket\n\n        // Collect optimized scalars and points in buffers for repeated access\n        // (scanning the whole set per digit position).\n        let scalars = scalars.map(|s| s.borrow().as_radix_2w(w));\n\n        let points = points\n            .into_iter()\n            .map(|p| p.map(|P| P.as_projective_niels()));\n\n        let scalars_points = scalars\n            .zip(points)\n            .map(|(s, maybe_p)| maybe_p.map(|p| (s, p)))\n            .collect::<Option<Vec<_>>>()?;\n\n        // Prepare 2^w/2 buckets.\n        // buckets[i] corresponds to a multiplication factor (i+1).\n        let mut buckets: Vec<_> = (0..buckets_count)\n            .map(|_| EdwardsPoint::identity())\n            .collect();\n\n        let mut columns = (0..digits_count).rev().map(|digit_index| {\n            // Clear the buckets when processing another digit.\n            for bucket in &mut buckets {\n                *bucket = EdwardsPoint::identity();\n            }\n\n            // Iterate over pairs of (point, scalar)\n            // and add/sub the point to the corresponding bucket.\n            // Note: if we add support for precomputed lookup tables,\n            // we'll be adding/subtracting point premultiplied by `digits[i]` to buckets[0].\n            for (digits, pt) in scalars_points.iter() {\n                // Widen digit so that we don't run into edge cases when w=8.\n                let digit = digits[digit_index] as i16;\n                match digit.cmp(&0) {\n                    Ordering::Greater => {\n                        let b = (digit - 1) as usize;\n                        buckets[b] = (&buckets[b] + pt).as_extended();\n                    }\n                    Ordering::Less => {\n                        let b = (-digit - 1) as usize;\n                        buckets[b] = (&buckets[b] - pt).as_extended();\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            // Add the buckets applying the multiplication factor to each bucket.\n            // The most efficient way to do that is to have a single sum with two running sums:\n            // an intermediate sum from last bucket to the first, and a sum of intermediate sums.\n            //\n            // For example, to add buckets 1*A, 2*B, 3*C we need to add these points:\n            //   C\n            //   C B\n            //   C B A   Sum = C + (C+B) + (C+B+A)\n            let mut buckets_intermediate_sum = buckets[buckets_count - 1];\n            let mut buckets_sum = buckets[buckets_count - 1];\n            for i in (0..(buckets_count - 1)).rev() {\n                buckets_intermediate_sum += buckets[i];\n                buckets_sum += buckets_intermediate_sum;\n            }\n\n            buckets_sum\n        });\n\n        // Take the high column as an initial value to avoid wasting time doubling the identity element in `fold()`.\n        let hi_column = columns.next().expect(\"should have more than zero digits\");\n\n        Some(columns.fold(hi_column, |total, p| total.mul_by_pow_2(w as u32) + p))\n    }",
      "start_line": 65,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 12
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "display_name": "as_extended",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    pub fn as_extended(&self) -> (result: EdwardsPoint)\n        requires\n            is_valid_projective_point(*self),\n            // preconditions for arithmetic traits\n            fe51_limbs_bounded(&self.X, 54),\n            fe51_limbs_bounded(&self.Y, 54),\n            fe51_limbs_bounded(&self.Z, 54),\n        ensures\n            is_valid_edwards_point(result),\n            spec_edwards_point(result) == spec_projective_to_extended(*self),\n            edwards_point_as_affine(result) == projective_point_as_affine_edwards(*self),\n    {\n        let result = EdwardsPoint {\n            X: &self.X * &self.Z,\n            Y: &self.Y * &self.Z,\n            Z: self.Z.square(),\n            T: &self.X * &self.Y,\n        };\n        proof {\n            // postconditions\n            assume(is_valid_edwards_point(result));\n            assume(spec_edwards_point(result) == spec_projective_to_extended(*self));\n            assume(edwards_point_as_affine(result) == projective_point_as_affine_edwards(*self));\n        }\n        result\n    }",
      "start_line": 408,
      "end_line": 23,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_to_nat_gen_u32().",
      "display_name": "words_to_nat_gen_u32",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_to_nat_gen_u32().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn words_to_nat_gen_u32(words: &[u32], num_words: int, bits_per_word: int) -> nat\n    decreases num_words,\n{\n    if num_words <= 0 {\n        0\n    } else {\n        let word_value = (words[num_words - 1] as nat) * pow2(\n            ((num_words - 1) * bits_per_word) as nat,\n        );\n        word_value + words_to_nat_gen_u32(words, num_words - 1, bits_per_word)\n    }\n}",
      "start_line": 118,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "display_name": "lizard_decode",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    pub fn lizard_decode<D: Digest>(&self) -> Option<[u8; 16]>\n    where\n        D: Digest<OutputSize = U32>,\n    {\n        let mut result: [u8; 16] = Default::default();\n        let mut h: [u8; 32] = Default::default();\n        let (mask, fes) = self.elligator_ristretto_flavor_inverse();\n        let mut n_found = 0;\n        for (j, fe_j) in fes.iter().enumerate() {\n            let mut ok = Choice::from((mask >> j) & 1);\n            let buf2 = fe_j.as_bytes(); // array\n            h.copy_from_slice(&D::digest(&buf2[8..24])); // array\n            h[8..24].copy_from_slice(&buf2[8..24]);\n            h[0] &= 254;\n            h[31] &= 63;\n            ok &= h.ct_eq(&buf2);\n            for i in 0..16 {\n                result[i] = u8::conditional_select(&result[i], &buf2[8 + i], ok);\n            }\n            n_found += ok.unwrap_u8();\n        }\n        if n_found == 1 {\n            Some(result)\n        } else {\n            None\n        }\n    }",
      "start_line": 46,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_0_val().",
      "display_name": "a0_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn a0_0_val(a: [u64; 5]) -> u64 {\n    (c0_val(a) as u64) & mask51\n}",
      "start_line": 80,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/as_nat_prefix().",
      "display_name": "as_nat_prefix",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/as_nat_prefix().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "file_name": "u8_32_as_nat_injectivity_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn as_nat_prefix(bytes: &[u8; 32], n: nat) -> nat\n    recommends\n        n <= 32,\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else {\n        as_nat_prefix(bytes, (n - 1) as nat) + bytes[(n - 1) as int] as nat * pow2(\n            ((n - 1) * 8) as nat,\n        )\n    }\n}",
      "start_line": 15,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base().",
      "display_name": "mul_base",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_base(scalar: &Scalar) -> (result: Self)\n        requires\n            scalar.bytes[31] <= 127,\n        ensures\n            is_valid_montgomery_point(result),\n            // Functional correctness: result.u = [scalar] * basepoint (u-coordinate)\n            spec_montgomery(result) == montgomery_scalar_mul_u(\n                spec_x25519_basepoint_u(),\n                spec_scalar(scalar),\n            ),\n    {\n        // ORIGINAL CODE: EdwardsPoint::mul_base(scalar).to_montgomery()\n        // REFACTORED: to assume postconditions for EdwardsPoint::mul_base\n        let temp = EdwardsPoint::mul_base(scalar);\n        proof {\n            assume(fe51_limbs_bounded(&temp.X, 54));\n            // to_montgomery requires 51-bit bounds for Y, Z so U = Z + Y fits in 52 bits\n            assume(fe51_limbs_bounded(&temp.Y, 51) && fe51_limbs_bounded(&temp.Z, 51));\n            assume(sum_of_limbs_bounded(&temp.Z, &temp.Y, u64::MAX));\n        }\n        let result = temp.to_montgomery();\n        proof {\n            assume(is_valid_montgomery_point(result));\n            assume(spec_montgomery(result) == montgomery_scalar_mul_u(\n                spec_x25519_basepoint_u(),\n                spec_scalar(scalar),\n            ));\n        }\n        result\n    }",
      "start_line": 243,
      "end_line": 20,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "display_name": "as_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    pub fn as_bytes(self) -> (r: [u8; 32])\n        ensures\n    // canonical encoding, i.e. mod p value\n\n            u8_32_as_nat(&r) == u64_5_as_nat(self.limbs) % p(),\n    {\n        proof {\n            // No overflows\n            lemma_as_bytes_boundaries1(self.limbs);\n            lemma_as_bytes_boundaries2(self.limbs);\n\n            // Step 1: Reduce limbs to ensure h < 2*p\n            // The reduce function ensures the limbs are bounded by 2^52\n            proof_reduce(self.limbs);\n            lemma_reduce_bound_2p(self.limbs);\n            let limbs = spec_reduce(self.limbs);\n\n            let q = compute_q_spec(limbs);\n\n            // Step 2: Prove that q is the correct quotient\n            assert((q == 0 || q == 1) && (u64_5_as_nat(limbs) >= p() <==> q == 1) && (u64_5_as_nat(\n                limbs,\n            ) < p() <==> q == 0)) by {\n                lemma_compute_q(limbs, q);\n            }\n\n            let final_limbs = reduce_with_q_spec(limbs, q);\n\n            // Step 3: Prove that the reduction preserves the value mod p\n            lemma_to_bytes_reduction(limbs, final_limbs, q);\n\n            // Now arrange the bits of the limbs.\n            let s = bit_arrange(final_limbs);\n\n            // Step 4: Prove that packing limbs into bytes preserves the value\n            lemma_limbs_to_bytes(final_limbs, s);\n        }\n\n        // Let h = limbs[0] + limbs[1]*2^51 + ... + limbs[4]*2^204.\n        //\n        // Write h = pq + r with 0 <= r < p.\n        //\n        // We want to compute r = h mod p.\n        //\n        // If h < 2*p = 2^256 - 38,\n        // then q = 0 or 1,\n        //\n        // with q = 0 when h < p\n        //  and q = 1 when h >= p.\n        //\n        // Notice that h >= p <==> h + 19 >= p + 19 <==> h + 19 >= 2^255.\n        // Therefore q can be computed as the carry bit of h + 19.\n        // First, reduce the limbs to ensure h < 2*p.\n        let mut limbs = FieldElement51::reduce(self.limbs).limbs;\n\n        let mut q = (limbs[0] + 19) >> 51;\n        q = (limbs[1] + q) >> 51;\n        q = (limbs[2] + q) >> 51;\n        q = (limbs[3] + q) >> 51;\n        q = (limbs[4] + q) >> 51;\n\n        // Now we can compute r as r = h - pq = r - (2^255-19)q = r + 19q - 2^255q\n\n        limbs[0] += 19 * q;\n\n        // Now carry the result to compute r + 19q ...\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        limbs[1] += limbs[0] >> 51;\n        limbs[0] &= low_51_bit_mask;\n        limbs[2] += limbs[1] >> 51;\n        limbs[1] &= low_51_bit_mask;\n        limbs[3] += limbs[2] >> 51;\n        limbs[2] &= low_51_bit_mask;\n        limbs[4] += limbs[3] >> 51;\n        limbs[3] &= low_51_bit_mask;\n        // ... but instead of carrying (limbs[4] >> 51) = 2^255q\n        // into another limb, discard it, subtracting the value\n        limbs[4] &= low_51_bit_mask;\n\n        // Now arrange the bits of the limbs.\n        let mut s = [0u8;32];\n        s[0] = limbs[0] as u8;\n        s[1] = (limbs[0] >> 8) as u8;\n        s[2] = (limbs[0] >> 16) as u8;\n        s[3] = (limbs[0] >> 24) as u8;\n        s[4] = (limbs[0] >> 32) as u8;\n        s[5] = (limbs[0] >> 40) as u8;\n        s[6] = ((limbs[0] >> 48) | (limbs[1] << 3)) as u8;\n        s[7] = (limbs[1] >> 5) as u8;\n        s[8] = (limbs[1] >> 13) as u8;\n        s[9] = (limbs[1] >> 21) as u8;\n        s[10] = (limbs[1] >> 29) as u8;\n        s[11] = (limbs[1] >> 37) as u8;\n        s[12] = ((limbs[1] >> 45) | (limbs[2] << 6)) as u8;\n        s[13] = (limbs[2] >> 2) as u8;\n        s[14] = (limbs[2] >> 10) as u8;\n        s[15] = (limbs[2] >> 18) as u8;\n        s[16] = (limbs[2] >> 26) as u8;\n        s[17] = (limbs[2] >> 34) as u8;\n        s[18] = (limbs[2] >> 42) as u8;\n        s[19] = ((limbs[2] >> 50) | (limbs[3] << 1)) as u8;\n        s[20] = (limbs[3] >> 7) as u8;\n        s[21] = (limbs[3] >> 15) as u8;\n        s[22] = (limbs[3] >> 23) as u8;\n        s[23] = (limbs[3] >> 31) as u8;\n        s[24] = (limbs[3] >> 39) as u8;\n        s[25] = ((limbs[3] >> 47) | (limbs[4] << 4)) as u8;\n        s[26] = (limbs[4] >> 4) as u8;\n        s[27] = (limbs[4] >> 12) as u8;\n        s[28] = (limbs[4] >> 20) as u8;\n        s[29] = (limbs[4] >> 28) as u8;\n        s[30] = (limbs[4] >> 36) as u8;\n        s[31] = (limbs[4] >> 44) as u8;\n\n        // High bit should be zero.\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert!((s[31] & 0b1000_0000u8) == 0u8);\n\n        s\n    }",
      "start_line": 1003,
      "end_line": 20,
      "is_libsignal": false,
      "caller_count": 13,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#ConditionallySelectable#conditional_select().",
      "display_name": "conditional_select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#ConditionallySelectable#conditional_select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::conditional_select(&a.y_plus_x, &b.y_plus_x, choice),\n            y_minus_x: FieldElement::conditional_select(&a.y_minus_x, &b.y_minus_x, choice),\n            xy2d: FieldElement::conditional_select(&a.xy2d, &b.xy2d, choice),\n        }\n    }",
      "start_line": 382,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "display_name": "pow_p58",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "curve25519-dalek/src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "    fn pow_p58(&self) -> (result: FieldElement)\n        requires\n            fe51_limbs_bounded(self, 54),\n        ensures\n    // Bounded limbs (maintained by all field operations)\n\n            fe51_limbs_bounded(&result, 54),\n            // Mathematical value\n            spec_field_element(&result) == (pow(\n                spec_field_element(self) as int,\n                (pow2(252) - 3) as nat,\n            ) as nat) % p(),\n    {\n        // The bits of (p-5)/8 are 101111.....11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, _) = self.pow22501();  // 249..0 = x^(2^250-1)\n        let t20 = t19.pow2k(2);  // 251..2 = x^(2^252-4)\n        let t21 = self * &t20;  // 251..2,0 = x^(2^252-3)\n\n        proof {\n            pow255_gt_19();\n\n            // Bridge from spec_field_element to u64_5_as_nat\n            assert(u64_5_as_nat(t19.limbs) % p() == spec_field_element(&t19));\n            assert(u64_5_as_nat(self.limbs) % p() == spec_field_element(self));\n\n            // Use lemma_pow_mod_noop to bridge from spec_field_element to u64_5_as_nat\n            lemma_pow_mod_noop(u64_5_as_nat(self.limbs) as int, (pow2(250) - 1) as nat, p() as int);\n            assert(pow(u64_5_as_nat(self.limbs) as int, (pow2(250) - 1) as nat) >= 0) by {\n                lemma_pow_nonnegative(u64_5_as_nat(self.limbs) as int, (pow2(250) - 1) as nat);\n            }\n            assert(pow((u64_5_as_nat(self.limbs) % p()) as int, (pow2(250) - 1) as nat) >= 0) by {\n                lemma_pow_nonnegative(\n                    (u64_5_as_nat(self.limbs) % p()) as int,\n                    (pow2(250) - 1) as nat,\n                );\n            }\n            assert(pow(u64_5_as_nat(self.limbs) as int, (pow2(250) - 1) as nat) as nat % p() == pow(\n                (u64_5_as_nat(self.limbs) % p()) as int,\n                (pow2(250) - 1) as nat,\n            ) as nat % p());\n            assert(u64_5_as_nat(t19.limbs) % p() == pow(\n                u64_5_as_nat(self.limbs) as int,\n                (pow2(250) - 1) as nat,\n            ) as nat % p());\n\n            // Multiplication: t21 = self * t20\n            assert(u64_5_as_nat(t21.limbs) % p() == (u64_5_as_nat(self.limbs) * u64_5_as_nat(\n                t20.limbs,\n            )) % p()) by {\n                lemma_mul_mod_noop_general(\n                    u64_5_as_nat(self.limbs) as int,\n                    u64_5_as_nat(t20.limbs) as int,\n                    p() as int,\n                );\n            };\n\n            // Use lemma to prove t21 = x^(2^252-3)\n            lemma_pow_p58_prove(self.limbs, t19.limbs, t20.limbs, t21.limbs);\n\n            // Bridge back from u64_5_as_nat to spec_field_element\n            lemma_bridge_pow_as_nat_to_spec(&t21, self, (pow2(252) - 3) as nat);\n\n            // Bounded limbs: t21 is the result of mul (self * &t20), which maintains the bound\n            assert(fe51_limbs_bounded(&t21, 54));\n        }\n\n        t21\n    }",
      "start_line": 712,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_term_product_bounds().",
      "display_name": "lemma_term_product_bounds",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_term_product_bounds().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_term_product_bounds(a: [u64; 5], bound: u64)\n    requires\n        19 * bound <= u64::MAX,\n        forall|i: int| 0 <= i < 5 ==> a[i] < bound,\n    ensures\n        term_product_bounds_spec(a, bound),\n{\n    let bound19 = (19 * bound) as u64;\n\n    assert(bound * (19 * bound) == 19 * (bound * bound)) by {\n        lemma_mul_is_associative(19, bound as int, bound as int);\n    }\n\n    assert forall|i: int, j: int| 0 <= i <= 4 && 0 <= j <= 4 implies (a[i] as u128) * (a[j] as u128)\n        < bound * bound && (a[i] as u128) * ((19 * a[j]) as u128) < 19 * (bound * bound) by {\n        lemma_m(a[i], a[j], bound, bound);\n        lemma_m(a[i], (19 * a[j]) as u64, bound, bound19);\n    }\n}",
      "start_line": 138,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/is_a_scalar().",
      "display_name": "is_a_scalar",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/is_a_scalar().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "pub open spec fn is_a_scalar(s: Scalar) -> bool {\n    true\n}",
      "start_line": 238,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_equal_to_minus_one().",
      "display_name": "is_equal_to_minus_one",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_equal_to_minus_one().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_equal_to_minus_one(u: nat) -> bool {\n    u == math_field_sub(0, 1)  // u == -1\n\n}",
      "start_line": 236,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/clamp_integer().",
      "display_name": "clamp_integer",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/clamp_integer().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "pub const fn clamp_integer(bytes: [u8; 32]) -> (result: [u8; 32])\n    ensures\n// Result is a valid clamped integer for X25519\n\n        is_clamped_integer(&result),\n        // The result matches the spec function\n        result == spec_clamp_integer(bytes),\n        // All bytes except 0 and 31 remain unchanged\n        forall|i: int| 1 <= i < 31 ==> #[trigger] result[i] == bytes[i],\n        // Low byte preserves bits 3-7\n        result[0] & 0b1111_1000 == bytes[0] & 0b1111_1000,\n        // High byte preserves bits 0-5\n        result[31] & 0b0011_1111 == bytes[31] & 0b0011_1111,\n{\n    let mut result = bytes;\n\n    // Clear low 3 bits: result[0] = bytes[0] & 0b1111_1000\n    result[0] &= 0b1111_1000;\n\n    // Clear bit 7 (MSB): result[31] = result[31] & 0b0111_1111\n    result[31] &= 0b0111_1111;\n\n    // Set bit 6: result[31] = result[31] | 0b0100_0000\n    result[31] |= 0b0100_0000;\n\n    proof {\n        // The bitwise operations above produce a clamped integer\n        // (includes result[31] <= 127 since MSB is cleared)\n        assume(is_clamped_integer(&result));\n        // The result matches the spec function\n        assume(result == spec_clamp_integer(bytes));\n        // Bits 3-7 of byte 0 are preserved\n        assume(result[0] & 0b1111_1000 == bytes[0] & 0b1111_1000);\n        // Bits 0-5 of byte 31 are preserved\n        assume(result[31] & 0b0011_1111 == bytes[31] & 0b0011_1111);\n    }\n\n    result\n}",
      "start_line": 3149,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "display_name": "lemma_invert_is_multiplicative_inverse",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "file_name": "invert_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_invert_is_multiplicative_inverse(\n    self_fe: &FieldElement51,\n    t19: &FieldElement51,\n    t20: &FieldElement51,\n    t3: &FieldElement51,\n    t21: &FieldElement51,\n)\n    requires\n        spec_field_element(self_fe) != 0,\n        // From pow22501 postcondition\n        spec_field_element(t19) == (pow(\n            spec_field_element(self_fe) as int,\n            (pow2(250) - 1) as nat,\n        ) as nat) % p(),\n        spec_field_element(t3) == (pow(spec_field_element(self_fe) as int, 11) as nat) % p(),\n        // From pow2k postcondition (using u64_5_as_nat form as that's what pow2k provides)\n        u64_5_as_nat(t20.limbs) % p() == (pow(u64_5_as_nat(t19.limbs) as int, pow2(5)) as nat)\n            % p(),\n        // From mul postcondition\n        spec_field_element(t21) == math_field_mul(spec_field_element(t20), spec_field_element(t3)),\n    ensures\n        (spec_field_element(t21) * spec_field_element(self_fe)) % p() == 1,\n{\n    let x = spec_field_element(self_fe);\n\n    // ========================================================================\n    // PART 1: Prove the exponent chain - show that t21 = x^(p-2) mod p\n    // ========================================================================\n\n    // Step 1: Establish that t21 = x^(2^255 - 21) % p by composing the power operations\n    let pow_exp_t20 = (pow(x as int, (pow2(255) - 32) as nat) as nat) % p();\n    let pow_exp_t3 = (pow(x as int, 11) as nat) % p();\n\n    // Show that t21 = (x^(2^255 - 32) * x^11) % p = x^(2^255 - 21) % p\n    assert(spec_field_element(t21) == (pow(x as int, (pow2(255) - 21) as nat) as nat) % p()) by {\n        // First, express t21 as product of powers\n        assert(spec_field_element(t21) == (pow_exp_t20 * pow_exp_t3) % p()) by {\n            lemma_invert_power_chain(self_fe, t19, t20, t3, t21);\n        }\n\n        // Prove precondition: (2^255 - 32) > 0\n        assert((pow2(255) - 32) > 0) by {\n            assert(pow2(5) == 32) by {\n                lemma2_to64();\n            }\n            lemma_pow2_strictly_increases(5, 255);\n        }\n\n        // Apply power addition: (x^a % p) * (x^b % p) % p = x^(a+b) % p\n        // This gives us: t21 = x^((2^255 - 32) + 11) % p\n        assert(spec_field_element(t21) == (pow(x as int, ((pow2(255) - 32) + 11) as nat) as nat)\n            % p()) by {\n            lemma_modular_power_addition(x, (pow2(255) - 32) as nat, 11, p());\n        }\n\n        // Simplify the exponent: (2^255 - 32) + 11 = 2^255 - 21\n        assert(((pow2(255) - 32) + 11) as nat == (pow2(255) - 21) as nat);\n    }\n\n    // Step 2: Show that 2^255 - 21 = p - 2\n    assert(spec_field_element(t21) == (pow(x as int, (p() - 2) as nat) as nat) % p()) by {\n        // The exponent arithmetic lemma proves: 2^255 - 21 = p() - 2\n        assert(pow2(255) - 21 == p() - 2) by {\n            lemma_invert_exponent_arithmetic();\n        }\n    }\n\n    // ========================================================================\n    // PART 2: Apply Fermat's Little Theorem to prove (t21 * x) % p = 1\n    // ========================================================================\n\n    // We've shown: t21 = x^(p-2) % p\n    // Now prove: (x^(p-2) * x) % p = x^(p-1) % p = 1\n\n    // Step 1: Use power addition to get x^(p-1)\n    assert((spec_field_element(t21) * x) % p() == (pow(x as int, (p() - 1) as nat) as nat) % p())\n        by {\n        lemma_multiply_by_base_power_addition(x, self_fe, t21);\n    }\n\n    // Step 2: Apply Fermat's Little Theorem: x^(p-1) ≡ 1 (mod p) for non-zero x\n    assert((spec_field_element(t21) * x) % p() == 1) by {\n        assert((pow(x as int, (p() - 1) as nat) as nat) % p() == 1) by {\n            // Prove the precondition: x % p() != 0\n            assert(x % p() != 0) by {\n                // x < p() and x != 0, therefore x % p() = x != 0\n                assert(x < p()) by {\n                    assert(p() > 0) by {\n                        pow255_gt_19();\n                    }\n                    lemma_mod_bound(spec_field_element_as_nat(self_fe) as int, p() as int);\n                }\n\n                assert(x % p() == x) by {\n                    lemma_small_mod(x, p());\n                }\n            }\n\n            // Apply Fermat's Little Theorem for p()\n            lemma_fermat_for_p(x);\n        }\n    }\n}",
      "start_line": 290,
      "end_line": 52,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 17
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/inv_montgomery_radix().",
      "display_name": "inv_montgomery_radix",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/inv_montgomery_radix().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn inv_montgomery_radix() -> nat {\n    0x8e84371e098e4fc4_u64 as nat + pow2(64) * 0xfb2697cda3adacf5_u64 as nat + pow2(128)\n        * 0x3614e75438ffa36b_u64 as nat + pow2(192) * 0xc9db6c6f26fe918_u64 as nat\n}",
      "start_line": 202,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core default/Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core default/Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_upper_bound().",
      "display_name": "lemma_mul_upper_bound",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_upper_bound().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "file_name": "scalar_lemmas_extra.rs",
      "parent_folder": "lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c0_0_val().",
      "display_name": "c0_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c0_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn c0_0_val(a: [u64; 5]) -> u128 {\n    (a[0] * a[0] + 2 * (a[1] * (19 * a[4]) + a[2] * (19 * a[3]))) as u128\n}",
      "start_line": 36,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_point_as_affine_edwards().",
      "display_name": "projective_point_as_affine_edwards",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_point_as_affine_edwards().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn projective_point_as_affine_edwards(point: ProjectivePoint) -> (nat, nat) {\n    let (x, y, z) = spec_projective_point_edwards(point);\n    let z_inv = math_field_inv(z);\n    (math_field_mul(x, z_inv), math_field_mul(y, z_inv))\n}",
      "start_line": 327,
      "end_line": 52,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/nine_limbs_to_nat_aux().",
      "display_name": "nine_limbs_to_nat_aux",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/nine_limbs_to_nat_aux().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn nine_limbs_to_nat_aux(limbs: &[u128; 9]) -> nat {\n    (limbs[0] as nat) +\n    (limbs[1] as nat) * pow2( 52) +\n    (limbs[2] as nat) * pow2(104) +\n    (limbs[3] as nat) * pow2(156) +\n    (limbs[4] as nat) * pow2(208) +\n    (limbs[5] as nat) * pow2(260) +\n    (limbs[6] as nat) * pow2(312) +\n    (limbs[7] as nat) * pow2(364) +\n    (limbs[8] as nat) * pow2(416)\n}",
      "start_line": 34,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#SubAssign#sub_assign().",
      "display_name": "sub_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#SubAssign#sub_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn sub_assign(&mut self, _rhs: &'b EdwardsPoint)\n        requires\n            is_well_formed_edwards_point(*old(self)),\n            is_well_formed_edwards_point(*_rhs),\n        ensures\n            is_valid_edwards_point(*self),\n            // Semantic correctness: result is the subtraction of old(self) - rhs\n            ({\n                let (x1, y1) = edwards_point_as_affine(*old(self));\n                let (x2, y2) = edwards_point_as_affine(*_rhs);\n                edwards_point_as_affine(*self) == edwards_sub(x1, y1, x2, y2)\n            }),",
      "start_line": 1520,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "display_name": "proof_reduce",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/reduce_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/reduce_lemmas.rs",
      "file_name": "reduce_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn proof_reduce(limbs: [u64; 5])\n    ensures\n        forall|i: int| 0 <= i < 5 ==> spec_reduce(limbs)[i] < (1u64 << 52),\n        // Suppose l = (l0, l1, l2, l3, l4) are the input limbs.\n        // They represent a number\n        // e(l) =  l0 + l1 * 2^51 + l2 * 2^102 + l3 * 2^153 + l4 * 2^204\n        // in Z_p, for p = 2^255 - 19\n        // reduce(l) returns v = (v0, v1, v2, v3, v4), such that\n        // v0 = 19 * a4 + b0\n        // v1 =      a0 + b1\n        // v2 =      a1 + b2\n        // v3 =      a2 + b3\n        // v4 =      a3 + b4\n        // where ai = li >> 51 and bi = li & mask51\n        // we can reformulate this as ai = li / 2^51 (flooring division) and bi = li % 2^51\n        // Using the following identity connecting integer division and remainder:\n        // x = y * (x / y) + x % y\n        // we can see that li = ai * 2^51 + bi\n        // Plugging the above identities into the equations for v, we can observe that\n        // e(v) = e(l) - p * (l4 >> 51)\n        // IOW, e(reduce(l)) = e(l) (mod p)\n        // additionally, if all limbs are below 2^51, reduce(l) = l\n        (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (spec_reduce(limbs) =~= limbs),\n        u64_5_as_nat(spec_reduce(limbs)) == u64_5_as_nat(limbs) - p() * (limbs[4] >> 51),\n        u64_5_as_nat(spec_reduce(limbs)) % p() == u64_5_as_nat(limbs) % p(),\n{\n    // -----\n    // reduce identity for small limbs\n    // Can't seem to reference r within this proof block, we reconstruct it here\n    let rr: [u64; 5] = spec_reduce(limbs);\n\n    assert((forall|i: int| 0 <= i < 5 ==> #[trigger] limbs[i] < (1u64 << 51)) ==> (rr =~= limbs))\n        by {\n        if (forall|i: int| 0 <= i < 5 ==> #[trigger] limbs[i] < (1u64 << 51)) {\n            assert forall|i: int| 0 <= i < 5 implies #[trigger] limbs[i] & mask51 == limbs[i] by {\n                l51_bit_mask_lt();  // mask51 = low_bits_mask(51)\n                lemma_shift_is_pow2(51);\n                lemma_u64_low_bits_mask_is_mod(limbs[i], 51);\n                lemma_small_mod(limbs[i] as nat, pow2(51));\n            }\n            assert forall|i: int| 0 <= i < 5 implies #[trigger] limbs[i] >> 51 == 0 by {\n                l51_bit_mask_lt();  // mask51 = low_bits_mask(51)\n                lemma_shift_is_pow2(51);\n                lemma_u64_shr_is_div(limbs[i], 51);\n                lemma_basic_div(limbs[i] as int, pow2(51) as int);\n            }\n        }\n    }\n\n    // -- u64_5_as_nat identity\n\n    // ai = limbs[i] / 2^52\n    let a0 = (limbs[0] >> 51);\n    let a1 = (limbs[1] >> 51);\n    let a2 = (limbs[2] >> 51);\n    let a3 = (limbs[3] >> 51);\n    let a4 = (limbs[4] >> 51);\n\n    // bi = limbs[i] % 2^52\n    let b0 = (limbs[0] & mask51);\n    let b1 = (limbs[1] & mask51);\n    let b2 = (limbs[2] & mask51);\n    let b3 = (limbs[3] & mask51);\n    let b4 = (limbs[4] & mask51);\n\n    lemma_reduce_boundaries(limbs);\n\n    // distribute\n    assert(u64_5_as_nat(rr) == 19 * a4 + b0 + pow2(51) * a0 + pow2(51) * b1 + pow2(102) * a1 + pow2(\n        102,\n    ) * b2 + pow2(153) * a2 + pow2(153) * b3 + pow2(204) * a3 + pow2(204) * b4) by {\n        lemma_mul_is_distributive_add(pow2(51) as int, a0 as int, b1 as int);\n        lemma_mul_is_distributive_add(pow2(102) as int, a1 as int, b2 as int);\n        lemma_mul_is_distributive_add(pow2(153) as int, a2 as int, b3 as int);\n        lemma_mul_is_distributive_add(pow2(204) as int, a3 as int, b4 as int);\n    }\n\n    // factor out\n    assert(u64_5_as_nat(rr) == 19 * a4 + b0 + pow2(51) * a0 + pow2(51) * b1 + pow2(51) * (pow2(51)\n        * a1) + pow2(102) * b2 + pow2(102) * (pow2(51) * a2) + pow2(153) * b3 + pow2(153) * (pow2(\n        51,\n    ) * a3) + pow2(204) * b4) by {\n        lemma_two_factoring_51(51, a1);\n        lemma_two_factoring_51(102, a2);\n        lemma_two_factoring_51(153, a3);\n    }\n\n    // change groupings\n    assert(u64_5_as_nat(rr) == (b0 + pow2(51) * a0) + pow2(51) * (b1 + pow2(51) * a1) + pow2(102)\n        * (b2 + pow2(51) * a2) + pow2(153) * (b3 + pow2(51) * a3) + pow2(204) * b4 + 19 * a4) by {\n        lemma_mul_is_distributive_add(pow2(51) as int, b1 as int, pow2(51) * a1);\n        lemma_mul_is_distributive_add(pow2(102) as int, b2 as int, pow2(51) * a2);\n        lemma_mul_is_distributive_add(pow2(153) as int, b3 as int, pow2(51) * a3);\n    }\n\n    // invoke div/mod identity\n    assert(u64_5_as_nat(rr) == limbs[0] + pow2(51) * limbs[1] + pow2(102) * limbs[2] + pow2(153)\n        * limbs[3] + pow2(204) * b4 + 19 * a4) by {\n        lemma_div_and_mod_51(a0, b0, limbs[0]);\n        lemma_div_and_mod_51(a1, b1, limbs[1]);\n        lemma_div_and_mod_51(a2, b2, limbs[2]);\n        lemma_div_and_mod_51(a3, b3, limbs[3]);\n    }\n\n    // Add missing limbs[4] parts\n    assert(u64_5_as_nat(rr) == limbs[0] + pow2(51) * limbs[1] + pow2(102) * limbs[2] + pow2(153)\n        * limbs[3] + pow2(204) * limbs[4] - pow2(204) * (pow2(51) * a4) + 19 * a4) by {\n        lemma_div_and_mod_51(a4, b4, limbs[4]);\n        assert(pow2(204) * limbs[4] == pow2(204) * b4 + pow2(204) * (pow2(51) * a4)) by {\n            lemma_mul_is_distributive_add(pow2(204) as int, pow2(51) * a4 as int, b4 as int);\n        }\n    }\n\n    // The solver can collect components of u64_5_as_nat(limbs) automatically:\n    // u64_5_as_nat(rr) == u64_5_as_nat(limbs) - pow2(204) * (pow2(51) * a4 ) + 19 * a4\n    // ... as well as pull in minus\n    // u64_5_as_nat(rr) == u64_5_as_nat(limbs) - (pow2(204) * (pow2(51) * a4 ) - 19 * a4)\n\n    // collect components of p() * a4\n    assert(pow2(204) * (pow2(51) * a4) - 19 * a4 == p() * a4) by {\n        lemma_mul_is_associative(pow2(204) as int, pow2(51) as int, a4 as int);\n        lemma_pow2_adds(204, 51);\n        lemma_mul_is_distributive_sub_other_way(a4 as int, pow2(255) as int, 19);\n        pow255_gt_19();  // we need to prove 2^255 - 19 doesn't underflow\n    }\n\n    pow255_gt_19();\n    lemma_mod_multiples_vanish(\n        (limbs[4] >> 51) as int,\n        u64_5_as_nat(spec_reduce(limbs)) as int,\n        p() as int,\n    );\n}",
      "start_line": 66,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 17
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#random().",
      "display_name": "random",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#random().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn random<R: CryptoRngCore + ?Sized>(rng: &mut R) -> Self {\n        let mut uniform_bytes = [0u8; 64];\n        rng.fill_bytes(&mut uniform_bytes);\n\n        RistrettoPoint::from_uniform_bytes(&uniform_bytes)\n    }",
      "start_line": 711,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo proptest 1.9.0 config/test_runner/Config#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo proptest 1.9.0 config/test_runner/Config#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_from_bytes_to_nat().",
      "display_name": "words_from_bytes_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_from_bytes_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn words_from_bytes_to_nat(bytes: &[u8; 64], count: int) -> nat\n    decreases\n            if count <= 0 {\n                0\n            } else {\n                count as nat\n            },",
      "start_line": 167,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes().",
      "display_name": "from_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn from_bytes(bytes: &[u8; 32]) -> (s: Scalar52)\n        ensures\n            bytes_to_nat(bytes) == to_nat(&s.limbs),\n            limbs_bounded(&s),\n    {\n        let mut words = [0u64;4];\n        for i in 0..4\n            invariant\n                0 <= i <= 4  // proof\n                ,\n        {\n            for j in 0..8\n                invariant\n                    0 <= j <= 8 && i < 4,\n            {\n                proof {\n                    assert(i < 4 && j < 8);\n                    assert((i as u64) * 8u64 < 32u64);\n                    let idx = (i as u64) * 8 + (j as u64);\n                    assert(idx < 32);\n                }\n                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);\n            }\n        }\n        //TODO: prove that bytes_to_nat(bytes) == words_to_nat(&words)\n        assume(bytes_to_nat(bytes) == words_to_nat(&words));\n        proof {\n            assert(1u64 << 52 > 0) by (bit_vector);\n            assert(1u64 << 48 > 0) by (bit_vector);\n            // TODO: prove property about words array\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let top_mask = (1u64 << 48) - 1;\n        let mut s = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        //test workflow graphs\n        s.limbs[0] = words[0] & mask;\n        s.limbs[1] = ((words[0] >> 52) | (words[1] << 12)) & mask;\n        s.limbs[2] = ((words[1] >> 40) | (words[2] << 24)) & mask;\n        s.limbs[3] = ((words[2] >> 28) | (words[3] << 36)) & mask;\n        s.limbs[4] = (words[3] >> 16) & top_mask;\n\n        assume(false);  // TODO: complete the proof\n\n        s\n    }",
      "start_line": 132,
      "end_line": 22,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_square_mod_noop().",
      "display_name": "lemma_square_mod_noop",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_square_mod_noop().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "file_name": "field_algebra_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_square_mod_noop(x: nat)\n    ensures math_field_square(x % p()) == math_field_square(x),\n{\n    // ((x%p) * (x%p)) % p = (x * x) % p by mod absorption on both factors\n    let p = p();\n    p_gt_2();\n    lemma_mul_mod_noop_left(x as int, x as int, p as int);\n    lemma_mul_mod_noop_right((x % p) as int, x as int, p as int);\n}",
      "start_line": 122,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_bounded_scalar52().",
      "display_name": "arb_bounded_scalar52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_bounded_scalar52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn arb_bounded_scalar52() -> impl Strategy<Value = Scalar52> {\n        prop::array::uniform5(0u64..(1u64 << 52)).prop_map(|limbs| Scalar52 { limbs })\n    }",
      "start_line": 1265,
      "end_line": 28,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "display_name": "square",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    pub fn square(&self) -> (r: FieldElement51)\n        requires\n    // The precondition in pow2k loop propagates to here\n\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54,\n        ensures\n    // Actual bound: 2^51 + 2^13 < 2^52 (from carry propagation)\n\n            forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 52,\n            // 52-bit implies 54-bit (for compatibility with callers)\n            forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 54,\n            u64_5_as_nat(r.limbs) % p() == pow(u64_5_as_nat(self.limbs) as int, 2) as nat % p(),\n    {\n        proof {\n            // pow2(1) == 2\n            lemma2_to64();\n        }\n        self.pow2k(1)\n    }",
      "start_line": 1299,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 14,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn identity() -> (result: ProjectiveNielsPoint)\n        ensures\n            result == identity_projective_niels(),\n    {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::ONE,\n            Y_minus_X: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T2d: FieldElement::ZERO,\n        }\n    }",
      "start_line": 247,
      "end_line": 16,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Sum#sum().",
      "display_name": "sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Sum#sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(RistrettoPoint::identity(), |acc, item| acc + item.borrow())\n    }",
      "start_line": 898,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "display_name": "lemma_shift_is_pow2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_shift_is_pow2(k: nat)\n    requires\n        k < 64,\n    ensures\n        (1u64 << k) == pow2(k),\n{\n    lemma_pow2_le_max64(k);\n    lemma_u64_shl_is_mul(1u64, k as u64);\n}",
      "start_line": 14,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 22,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/zeroize_limbs5().",
      "display_name": "zeroize_limbs5",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/zeroize_limbs5().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub fn zeroize_limbs5(limbs: &mut [u64; 5])\n    ensures\n        forall|i: int| 0 <= i < 5 ==> #[trigger] limbs[i] == 0u64,\n{\n    use zeroize::Zeroize;\n    limbs.zeroize();\n}",
      "start_line": 296,
      "end_line": 22,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c4_0_val().",
      "display_name": "c4_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c4_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn c4_0_val(a: [u64; 5]) -> u128 {\n    (a[2] * a[2] + 2 * (a[0] * a[4] + a[1] * a[3])) as u128\n}",
      "start_line": 52,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "display_name": "choice_is_true",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub uninterp spec fn choice_is_true(c: Choice) -> bool;\n\npub assume_specification[ Choice::from ](u: u8) -> (c: Choice)\n    ensures\n        (u == 1) == choice_is_true(c),\n;\n\npub assume_specification[ Choice::unwrap_u8 ](c: &Choice) -> (u: u8)\n    ensures\n        choice_is_true(*c) ==> u == 1u8,\n        !choice_is_true(*c) ==> u == 0u8,\n;\n\n// VERIFICATION NOTE: For other external functions, we use wrapper functions because:\n// - Generic functions don't work well with assume_specification\n// - Trait implementations on arrays have issues with assume_specification\n/// Wrapper for conditional_select on u64\n#[verifier::external_body]\npub fn select(a: &u64, b: &u64, c: Choice) -> (res: u64)\n    ensures\n        !choice_is_true(c) ==> res == *a,\n        choice_is_true(c) ==> res == *b,\n{\n    u64::conditional_select(a, b, c)\n}",
      "start_line": 38,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 39,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#invert().",
      "display_name": "invert",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#invert().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn invert(&self) -> (result: Scalar)\n        requires\n            is_canonical_scalar(self),\n        ensures\n    // Result is the multiplicative inverse: result * self ≡ 1 (mod group_order)\n\n            (scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1,\n            is_canonical_scalar(\n                &result,\n            ),\n    // VERIFICATION NOTE: is this true and/or necessary?\n    // Result is canonical\n    // scalar_to_nat(&result) < group_order(),\n    // result.bytes[31] <= 127,\n\n    {\n        let unpacked = self.unpack();\n        let inv_unpacked = unpacked.invert();\n        let result = inv_unpacked.pack();\n        assume((scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1);\n        assume(is_canonical_scalar(&result));\n        result\n    }",
      "start_line": 1540,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_x_zero_implies_y_squared_one().",
      "display_name": "lemma_x_zero_implies_y_squared_one",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_x_zero_implies_y_squared_one().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_x_zero_implies_y_squared_one(x: nat, y: nat)\n    requires\n        math_on_edwards_curve(x, y),\n        x % p() == 0,\n    ensures\n        math_field_square(y) == 1,\n{\n    let modulus = p();\n    let d = spec_field_element(&EDWARDS_D);\n    let x2 = math_field_square(x);\n    let y2 = math_field_square(y);\n    let x2y2 = math_field_mul(x2, y2);\n    let d_x2y2 = math_field_mul(d, x2y2);\n    let lhs = math_field_sub(y2, x2);\n    let rhs = math_field_add(1, d_x2y2);\n    \n    // Establish p > 1 for lemma preconditions\n    assert(modulus > 1) by { p_gt_2(); };\n    \n    // Goal: y² = 1\n    // Strategy: From curve equation y² - x² = 1 + d·x²·y², show all terms simplify\n    \n    assert(x2 == 0) by {\n        // x² = (x * x) % p = ((x % p) * (x % p)) % p = (0 * 0) % p = 0\n        lemma_mul_mod_noop_general(x as int, x as int, modulus as int);\n        assert((x * x) % modulus == ((x % modulus) * (x % modulus)) % modulus);\n        \n        assert((0nat * 0nat) % modulus == 0nat) by {\n            lemma_mul_by_zero_is_zero(0int);\n            lemma_small_mod(0nat, modulus);\n        };\n    };\n    \n    assert(x2y2 == 0) by {\n        // x²·y² = 0 * y² = 0\n        assert(x2 == 0);\n        lemma_mul_by_zero_is_zero(y2 as int);\n        lemma_small_mod(0nat, modulus);\n    };\n    \n    assert(d_x2y2 == 0) by {\n        // d * x²y² = d * 0 = 0\n        assert(x2y2 == 0);\n        lemma_mul_by_zero_is_zero(d as int);\n        lemma_small_mod(0nat, modulus);\n    };\n    \n    assert(rhs == 1) by {\n        // rhs = 1 + d·x²·y² = 1 + 0 = 1\n        assert(d_x2y2 == 0);\n        lemma_small_mod(1nat, modulus);\n    };\n    \n    // From curve equation (precondition): lhs == rhs\n    assert(lhs == rhs);\n    assert(lhs == 1);\n    \n    assert(lhs == y2) by {\n        // lhs = math_field_sub(y2, 0) = (y2 + p) % p = y2\n        assert(x2 == 0);\n        \n        // y2 < p (math_field_square output is reduced)\n        assert(y2 < modulus) by {\n            lemma_mod_bound(y as int * y as int, modulus as int);\n        };\n        \n        // (p + y2) % p = y2 % p = y2 (since y2 < p)\n        lemma_small_mod(y2, modulus);\n        lemma_mod_multiples_vanish(1int, y2 as int, modulus as int);\n    };\n    \n    // Conclusion: y2 == lhs == 1\n    assert(y2 == 1);\n}",
      "start_line": 616,
      "end_line": 48,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 13
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shifted_lt().",
      "display_name": "lemma_shifted_lt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shifted_lt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_shifted_lt(v: u64, k: nat)\n    requires\n        1 <= k <= 64,\n    ensures\n        v >> k < 1u64 << (64 - k),\n{\n    if (k == 64) {\n        assert(v >> 64 == 0) by (bit_vector);\n        lemma_shl_zero_is_id(1u64);\n    } else {\n        // (v >> k) <= (u64::MAX >> k)\n        lemma_shr_le_u64(v, u64::MAX, k);\n        // u64::MAX >> k < 1u64 << (64 - k)\n        lemma_u64_max_shifting(k);\n    }\n}",
      "start_line": 305,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/projective_represents_montgomery().",
      "display_name": "projective_represents_montgomery",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/projective_represents_montgomery().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn projective_represents_montgomery(\n    P_proj: ProjectivePoint,\n    P_aff: MontgomeryAffine,\n) -> bool {\n    match P_aff {\n        MontgomeryAffine::Infinity =>\n        // The ladder never uses or produces ∞, so it should never be represented.\n        false,\n        MontgomeryAffine::Finite { u, v } => {\n            // W must not be zero for a meaningful U/W value\n            let W = spec_field_element(&P_proj.W);\n            let U = spec_field_element(&P_proj.U);\n\n            W != 0 &&\n            // Encoding requirement: U/W = u\n            // Use cross-multiplication to avoid division.\n            U == math_field_mul(u, W)\n        },\n    }\n}",
      "start_line": 283,
      "end_line": 50,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb0_byte_contribution_52().",
      "display_name": "limb0_byte_contribution_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb0_byte_contribution_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub open spec fn limb0_byte_contribution_52(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    bytes[0] as nat * pow2(0 * 8) +\n    bytes[1] as nat * pow2(1 * 8) +\n    bytes[2] as nat * pow2(2 * 8) +\n    bytes[3] as nat * pow2(3 * 8) +\n    bytes[4] as nat * pow2(4 * 8) +\n    bytes[5] as nat * pow2(5 * 8) +\n    // Byte 6 is a boundary byte - limb 0 contributes only the low 4 bits\n    // These 4 bits represent limbs[0]'s bits 48-51\n    ((limbs[0] as nat / pow2(48)) % 16) * pow2(6 * 8)\n}",
      "start_line": 70,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "display_name": "rev",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
      "file_name": "straus.rs",
      "parent_folder": "scalar_mul",
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_neg_square_eq().",
      "display_name": "lemma_neg_square_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_neg_square_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "file_name": "field_algebra_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_neg_square_eq(x: nat)\n    ensures math_field_square(math_field_neg(x)) == math_field_square(x % p()),\n{\n    let a = x % p();\n    let neg_x = math_field_neg(x);\n    let p = p();\n    p_gt_2();\n    \n    if a == 0 {\n        // neg_x = (p - 0) % p = 0, so (-0)² = 0 = 0²\n        lemma_mod_self_0(p as int);\n        lemma_small_mod(0nat, p);\n    } else {\n        // a > 0: neg_x = p - a, use (p-a)² ≡ a² (mod p)\n        lemma_small_mod((p - a) as nat, p);\n        lemma_square_of_complement(a, p);\n    }\n}",
      "start_line": 69,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_ratio_check_structure().",
      "display_name": "lemma_sqrt_ratio_check_structure",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_ratio_check_structure().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "file_name": "sqrt_ratio_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_sqrt_ratio_check_structure(u: nat, v: nat, r: nat)\n    requires\n        v % p() != 0,\n        r % p() == ((u * v * v * v) % p() * pow(\n            ((u * v * v * v * v * v * v * v) % p()) as int,\n            sqrt_ratio_exponent(),\n        ) as nat) % p(),\n    ensures\n        check_equals_u_times_fourth_root((v * r * r) % p(), u),\n{\n    // The algebraic steps above are mathematically sound but complex to\n    // formalize in Verus due to the interaction of pow, mod, and field ops\n    assume(check_equals_u_times_fourth_root((v * r * r) % p(), u));\n}",
      "start_line": 730,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_borrow_and_mask_bounded().",
      "display_name": "lemma_borrow_and_mask_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_borrow_and_mask_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_borrow_and_mask_bounded(borrow: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        (borrow & mask) < (1u64 << 52),\n{\n    assert((borrow & mask) <= mask) by (bit_vector);\n}",
      "start_line": 269,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_from_bytes().",
      "display_name": "prop_from_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_from_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "        fn prop_from_bytes(bytes in prop::array::uniform32(any::<u8>())) {\n            // Call from_bytes\n            let s = Scalar52::from_bytes(&bytes);\n\n            // Convert to BigUint using executable spec functions\n            let bytes_nat = bytes_to_nat_exec(&bytes);\n            let result_nat = to_nat_exec(&s.limbs);\n\n            // Postcondition 1: bytes_to_nat(bytes) == to_nat(&s.limbs)\n            prop_assert_eq!(bytes_nat, result_nat,\n                \"from_bytes spec violated: bytes_to_nat(bytes) != to_nat(&s.limbs)\");\n\n            // Postcondition 2: limbs_bounded(&s)\n            prop_assert!(limbs_bounded_exec(&s),\n                \"from_bytes spec violated: result limbs not bounded by 2^52\");\n        }",
      "start_line": 1480,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_by_sum().",
      "display_name": "lemma_shl_by_sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_by_sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_shl_by_sum(v: u64, a: nat, b: nat)\n    requires\n        (a + b) < 64,\n        v * pow2(a + b) <= u64::MAX,\n    ensures\n        (v << (a + b)) == ((v << a) << b),\n{\n    if (a == 0 || b == 0) {\n        broadcast use lemma_shl_zero_is_id;\n\n    } else {\n        // 2^(a + b) == 2^a * 2^b\n        lemma_pow2_adds(a, b);\n        // 2^a < 2^(a + b) ...\n        lemma_pow2_strictly_increases(a, a + b);\n        // ..., which implies v * 2^a < v * 2^(a + b) <= u64::MAX\n        lemma_mul_le(v as nat, v as nat, pow2(a), pow2(a + b));\n        // v << a + b = v * 2^(a+b)\n        lemma_u64_shl_is_mul(v, (a + b) as u64);\n        // v << a = v * 2^a\n        lemma_u64_shl_is_mul(v, a as u64);\n        // (v * 2^a) * 2^b = v * (2^a * 2^b)\n        lemma_mul_is_associative(v as int, pow2(a) as int, pow2(b) as int);\n        // (v * 2^a) << b = (v * 2^a) * 2^b\n        lemma_u64_shl_is_mul((v * pow2(a)) as u64, b as u64);\n    }\n}",
      "start_line": 34,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#sum_of_slice().",
      "display_name": "sum_of_slice",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#sum_of_slice().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar_helpers.rs",
      "relative_path": "curve25519-dalek/src/scalar_helpers.rs",
      "file_name": "scalar_helpers.rs",
      "parent_folder": "src",
      "body": "    pub fn sum_of_slice(scalars: &[Scalar]) -> (result: Scalar)\n        ensures\n    // Result is a valid scalar (bytes represent a value < group_order)\n\n            scalar_to_nat(&result) < group_order(),\n            // Result represents the sum of all scalars in the slice (mod group_order)\n            scalar_congruent_nat(&result, sum_of_scalars(scalars@)),\n    {\n        let n = scalars.len();\n        let mut acc = Scalar::ZERO;\n\n        proof {\n            // Assume properties of Scalar::ZERO\n            assume(scalar_to_nat(&acc) < group_order());\n            assume(scalar_to_nat(&acc) == 0);\n            assume(scalar_congruent_nat(&acc, sum_of_scalars(scalars@.subrange(0, 0))));\n        }\n\n        for i in 0..n\n            invariant\n                n == scalars.len(),\n                scalar_to_nat(&acc) < group_order(),\n                // acc represents the sum of scalars[0..i]\n                scalar_congruent_nat(&acc, sum_of_scalars(scalars@.subrange(0, i as int))),\n        {\n            proof {\n                // Assume preconditions for addition are satisfied\n                assume(false);\n            }\n            acc = &acc + &scalars[i];\n\n            proof {\n                // Assume the result maintains the invariant\n                assume(scalar_to_nat(&acc) < group_order());\n                assume(scalar_congruent_nat(\n                    &acc,\n                    sum_of_scalars(scalars@.subrange(0, (i + 1) as int)),\n                ));\n            }\n        }\n\n        proof {\n            // At this point, acc is the sum of all scalars\n            assert(scalars@.subrange(0, n as int) =~= scalars@);\n        }\n\n        acc\n    }",
      "start_line": 106,
      "end_line": 24,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries2().",
      "display_name": "lemma_as_bytes_boundaries2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/as_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/as_bytes_lemmas.rs",
      "file_name": "as_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_as_bytes_boundaries2(raw_limbs: [u64; 5])\n    ensures\n        mask51 == (1u64 << 51) - 1,\n        // no `forall` for pattern match reasons\n        compute_unmasked_limbs(spec_reduce(raw_limbs), compute_q_spec(spec_reduce(raw_limbs)))[0]\n            >> 51 <= 2,\n        compute_unmasked_limbs(spec_reduce(raw_limbs), compute_q_spec(spec_reduce(raw_limbs)))[1]\n            >> 51 <= 2,\n        compute_unmasked_limbs(spec_reduce(raw_limbs), compute_q_spec(spec_reduce(raw_limbs)))[2]\n            >> 51 <= 2,\n        compute_unmasked_limbs(spec_reduce(raw_limbs), compute_q_spec(spec_reduce(raw_limbs)))[3]\n            >> 51 <= 2,\n        compute_unmasked_limbs(spec_reduce(raw_limbs), compute_q_spec(spec_reduce(raw_limbs)))[4]\n            >> 51 <= 2,\n{\n    lemma_as_bytes_boundaries1(raw_limbs);\n    let limbs = spec_reduce(raw_limbs);\n    let q = compute_q_spec(limbs);\n\n    proof_reduce(raw_limbs);\n    lemma_reduce_bound_2p(raw_limbs);\n\n    assert(mask51 == (1u64 << 51) - 1) by (compute);\n\n    assert(q == 0 || q == 1) by {\n        lemma_compute_q(limbs, q);\n    }\n\n    assert(limbs[0] < 1u64 << 52);\n\n    let l = compute_unmasked_limbs(limbs, q);\n    let l0 = l[0];\n    let l1 = l[1];\n    let l2 = l[2];\n    let l3 = l[3];\n    let l4 = l[4];\n\n    assert(l0 >> 51 <= 2) by {\n        lemma_shr_le_u64(l0, ((1u64 << 52) + 19) as u64, 51);\n    }\n\n    assert(l1 >> 51 <= 2) by {\n        lemma_shr_le_u64(l1, ((1u64 << 52) + 2) as u64, 51);\n    }\n\n    assert(l2 >> 51 <= 2) by {\n        lemma_shr_le_u64(l2, ((1u64 << 52) + 2) as u64, 51);\n    }\n\n    assert(l3 >> 51 <= 2) by {\n        lemma_shr_le_u64(l3, ((1u64 << 52) + 2) as u64, 51);\n    }\n\n    assert(l4 >> 51 <= 2) by {\n        lemma_shr_le_u64(l4, ((1u64 << 52) + 2) as u64, 51);\n    }\n}",
      "start_line": 79,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_to_le_bytes().",
      "display_name": "u64_to_le_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_to_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub fn u64_to_le_bytes(x: u64) -> (bytes: [u8; 8])\n    ensures\n        bytes_seq_to_nat(seq_from8(&bytes)) == x as nat,\n{\n    x.to_le_bytes()\n}",
      "start_line": 103,
      "end_line": 23,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "display_name": "elligator_encode",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "pub(crate) fn elligator_encode(r_0: &FieldElement) -> MontgomeryPoint {\n    let one = FieldElement::ONE;\n    let d_1 = &one + &r_0.square2(); /* 2r^2 */\n\n    let d = &MONTGOMERY_A_NEG * &(d_1.invert()); /* A/(1+2r^2) */\n\n    let d_sq = &d.square();\n    let au = &MONTGOMERY_A * &d;\n\n    let inner = &(d_sq + &au) + &one;\n    let eps = &d * &inner; /* eps = d^3 + Ad^2 + d */\n\n    let (eps_is_sq, _eps) = FieldElement::sqrt_ratio_i(&eps, &one);\n\n    let zero = FieldElement::ZERO;\n    let Atemp = FieldElement::conditional_select(&MONTGOMERY_A, &zero, eps_is_sq); /* 0, or A if nonsquare*/\n    let mut u = &d + &Atemp; /* d, or d+A if nonsquare */\n    u.conditional_negate(!eps_is_sq); /* d, or -d-A if nonsquare */\n\n    MontgomeryPoint(u.as_bytes())\n}",
      "start_line": 544,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fourth_root_of_unity_values().",
      "display_name": "fourth_root_of_unity_values",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fourth_root_of_unity_values().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn fourth_root_of_unity_values() -> (nat, nat, nat, nat) {\n    let one = 1nat;\n    let neg_one = (p() - 1) as nat;\n    let i = spec_sqrt_m1();\n    let neg_i = ((p() - spec_sqrt_m1()) as int % p() as int) as nat;\n    (one, neg_one, i, neg_i)\n}",
      "start_line": 485,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#copied().",
      "display_name": "copied",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#copied().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_produces_valid_point().",
      "display_name": "lemma_decompress_produces_valid_point",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_produces_valid_point().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_decompress_produces_valid_point(\n    x: nat,\n    y: nat,\n    z: nat,\n    t: nat,\n    sign_applied: bool,\n)\n    requires\n        z == 1,\n        math_on_edwards_curve(x, y),\n        t == math_field_mul(x, y),\n    ensures\n        ({\n            z != 0 &&\n            math_on_edwards_curve(\n                math_field_mul(x, math_field_inv(z)),\n                math_field_mul(y, math_field_inv(z)),\n            ) &&\n            t == math_field_mul(math_field_mul(x, y), math_field_inv(z))\n        }),",
      "start_line": 173,
      "end_line": 51,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_composition().",
      "display_name": "lemma_pow_mod_composition",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_composition().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow_mod_composition(x: nat, a: nat, b: nat, m: nat)\n    requires\n        a > 0,\n        b > 0,\n        m > 0,\n    ensures\n        (pow(((pow(x as int, a) as nat) % m) as int, b) as nat) % m == (pow(x as int, a * b) as nat)\n            % m,\n{\n    // =================================================================\n    // PART 1: Core mathematical proof on int level\n    // =================================================================\n    // Prove: pow(pow(x, a) % m, b) % m == pow(pow(x, a), b) % m\n    assert(pow(pow(x as int, a) % (m as int), b) % (m as int) == pow(pow(x as int, a), b) % (\n    m as int)) by {\n        lemma_pow_mod_noop(pow(x as int, a), b, m as int);\n    }\n\n    // Prove: pow(pow(x, a), b) == pow(x, a*b)\n    assert(pow(pow(x as int, a), b) == pow(x as int, a * b)) by {\n        lemma_pow_multiplies(x as int, a, b);\n    }\n\n    // Combining the above: pow(pow(x, a) % m, b) % m == pow(x, a*b) % m (on int level)\n\n    // =================================================================\n    // PART 2: Bridge int-level proof to nat-level postcondition\n    // =================================================================\n    // The mathematical proof is complete on the int level:\n    //   pow(pow(x, a) % m, b) % m == pow(x, a*b) % m  (on int)\n    //\n    // To bridge to the nat-level postcondition, we prove int/nat modulo equivalence:\n    //   For v >= 0, m > 0: v % (m as int) == ((v as nat) % m) as int\n\n    // Bridge 1: pow(x, a) % m on int is same as ((pow(x, a) as nat) % m) as int\n    assert(pow(x as int, a) % (m as int) == ((pow(x as int, a) as nat) % m) as int) by {\n        assert(pow(x as int, a) >= 0) by {\n            lemma_pow_nonnegative(x as int, a);\n        }\n        lemma_int_nat_mod_equiv(pow(x as int, a), m);\n    }\n\n    // Bridge 2: pow((pow(x, a) % m), b) % m\n    let base_int = pow(x as int, a) % (m as int);\n    assert(pow(base_int, b) % (m as int) == ((pow(base_int, b) as nat) % m) as int) by {\n        assert(base_int >= 0) by {\n            lemma_fundamental_div_mod(pow(x as int, a), m as int);\n        }\n        assert(pow(base_int, b) >= 0) by {\n            lemma_pow_nonnegative(base_int, b);\n        }\n        lemma_int_nat_mod_equiv(pow(base_int, b), m);\n    }\n\n    // Bridge 3: pow(x, a*b) % m on int is same as ((pow(x, a*b) as nat) % m) as int\n    assert(pow(x as int, a * b) % (m as int) == ((pow(x as int, a * b) as nat) % m) as int) by {\n        assert(a * b > 0) by {\n            assert(a >= 1 && b >= 1);\n            assert(a * b >= 1) by (nonlinear_arith)\n                requires\n                    a >= 1,\n                    b >= 1,\n            ;\n        }\n        assert(pow(x as int, a * b) >= 0) by {\n            lemma_pow_nonnegative(x as int, a * b);\n        }\n        lemma_int_nat_mod_equiv(pow(x as int, a * b), m);\n    }\n\n    // The int-level equality now carries over to the nat-level postcondition ✓\n}",
      "start_line": 967,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "display_name": "as_projective",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    pub fn as_projective(&self) -> (result: ProjectivePoint)\n        requires\n            is_valid_completed_point(*self),\n            // preconditions for arithmetic traits\n            fe51_limbs_bounded(&self.X, 54),\n            fe51_limbs_bounded(&self.Y, 54),\n            fe51_limbs_bounded(&self.Z, 54),\n            fe51_limbs_bounded(&self.T, 54),\n        ensures\n            is_valid_projective_point(result),\n            spec_projective_point_edwards(result) == spec_completed_to_projective(*self),\n            projective_point_as_affine_edwards(result) == completed_point_as_affine_edwards(*self),\n            // Limb bounds from mul() postconditions\n            fe51_limbs_bounded(&result.X, 54),\n            fe51_limbs_bounded(&result.Y, 54),\n            fe51_limbs_bounded(&result.Z, 54),\n            // Sum bounded: X, Y each < 2^54, so sum < 2^55 < u64::MAX\n            sum_of_limbs_bounded(&result.X, &result.Y, u64::MAX),\n    {\n        let result = ProjectivePoint {\n            X: &self.X * &self.T,\n            Y: &self.Y * &self.Z,\n            Z: &self.Z * &self.T,\n        };\n        proof {\n            // Limb bounds follow from mul() postconditions\n            assert(fe51_limbs_bounded(&result.X, 54));\n            assert(fe51_limbs_bounded(&result.Y, 54));\n            assert(fe51_limbs_bounded(&result.Z, 54));\n            // Sum bounded: each limb < 2^54, so X[i] + Y[i] < 2^55 < u64::MAX\n            assert((1u64 << 54) + (1u64 << 54) < u64::MAX) by (bit_vector);\n            assume(sum_of_limbs_bounded(&result.X, &result.Y, u64::MAX));\n            // Semantic postconditions\n            assume(is_valid_projective_point(result));\n            assume(spec_projective_point_edwards(result) == spec_completed_to_projective(*self));\n            assume(projective_point_as_affine_edwards(result) == completed_point_as_affine_edwards(\n                *self,\n            ));\n        }\n        result\n    }",
      "start_line": 441,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_equality_converse().",
      "display_name": "lemma_mul_equality_converse",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_equality_converse().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_swap_u64().",
      "display_name": "conditional_swap_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_swap_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn conditional_swap_u64(a: &mut u64, b: &mut u64, choice: Choice)\n    ensures\n        !choice_is_true(choice) ==> (*a == *old(a) && *b == *old(b)),\n        choice_is_true(choice) ==> (*a == *old(b) && *b == *old(a)),\n{\n    u64::conditional_swap(a, b, choice)\n}",
      "start_line": 232,
      "end_line": 28,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_twice().",
      "display_name": "lemma_mod_twice",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_twice().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 10,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "display_name": "lemma_mul_is_distributive_add_other_way",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 16,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_failure_means_invalid_y().",
      "display_name": "lemma_sqrt_ratio_failure_means_invalid_y",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_failure_means_invalid_y().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_sqrt_ratio_failure_means_invalid_y(y: nat, u: nat, v: nat)\n    requires\n        ({\n            let d = spec_field_element(&EDWARDS_D);\n            let y2 = math_field_square(y);\n            u == math_field_sub(y2, 1) &&\n            v == math_field_add(math_field_mul(d, y2), 1)\n        }),",
      "start_line": 1067,
      "end_line": 54,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "display_name": "lemma_pow2_pos",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 67,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "curve25519-dalek/src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>;\n\n    /// Given `static_scalars`, an iterator of public scalars\n    /// \\\\(b_i\\\\), compute\n    /// $$\n    /// Q = b_1 B_1 + \\cdots + b_m B_m,\n    /// $$\n    /// where the \\\\(B_j\\\\) are the points that were supplied to `new`.\n    ///\n    /// It is an error to call this function with iterators of\n    /// inconsistent lengths.\n    ///\n    /// The trait bound aims for maximum flexibility: the input must\n    /// be convertible to iterators (`I: IntoIter`), and the\n    /// iterator's items must be `Borrow<Scalar>`, to allow iterators\n    /// returning either `Scalar`s or `&Scalar`s.\n    fn vartime_multiscalar_mul<I>(&self, static_scalars: I) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n    {\n        use core::iter;\n\n        Self::vartime_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            iter::empty::<Scalar>(),\n            iter::empty::<Self::Point>(),\n        )\n    }",
      "start_line": 298,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "display_name": "math_field_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn math_field_mul(a: nat, b: nat) -> nat {\n    (a * b) % p()\n}",
      "start_line": 104,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 53,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod_converse_mod().",
      "display_name": "lemma_fundamental_div_mod_converse_mod",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod_converse_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/spec_montgomery().",
      "display_name": "spec_montgomery",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/spec_montgomery().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "pub open spec fn spec_montgomery(point: MontgomeryPoint) -> nat {\n    spec_field_element_from_bytes(&point.0)\n}",
      "start_line": 102,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_bytes_wide_to_nat_rec_matches_word_partial().",
      "display_name": "lemma_bytes_wide_to_nat_rec_matches_word_partial",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_bytes_wide_to_nat_rec_matches_word_partial().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "file_name": "scalar_lemmas_extra.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_bytes_wide_to_nat_rec_matches_word_partial(\n    bytes: &[u8; 64],\n    word_idx: int,\n    upto: int,\n)\n    requires\n        0 <= word_idx < 8,\n        0 <= upto <= 8,\n    ensures\n        bytes_wide_to_nat_rec(bytes, word_idx * 8) == pow2(((word_idx * 8) * 8) as nat)\n            * word_from_bytes_partial(bytes, word_idx, upto) + bytes_wide_to_nat_rec(\n            bytes,\n            word_idx * 8 + upto,\n        ),\n    decreases upto,\n{\n    let base = word_idx * 8;\n    let pow_base = pow2((base * 8) as nat);\n    if upto == 0 {\n        assert(pow_base * 0 + bytes_wide_to_nat_rec(bytes, base + 0) == pow_base\n            * word_from_bytes_partial(bytes, word_idx, 0) + bytes_wide_to_nat_rec(bytes, base + 0));\n    } else {\n        let prev = upto - 1;\n        lemma_bytes_wide_to_nat_rec_matches_word_partial(bytes, word_idx, prev);\n        if upto >= 8 {\n            // Inline lemma_word_from_bytes_partial_step_last\n            reveal_with_fuel(word_from_bytes_partial, 9);\n        }\n        let partial_prev = word_from_bytes_partial(bytes, word_idx, prev);\n        let byte_val = bytes[(base + prev) as int] as nat;\n        lemma_pow2_adds(((base * 8) as nat), ((prev * 8) as nat));\n\n        // Rewriting byte_val * pow2((base + prev) * 8) = pow_base * byte_val * pow2(prev * 8)\n        assert(byte_val * (pow_base * pow2((prev * 8) as nat)) == pow_base * byte_val * pow2(\n            (prev * 8) as nat,\n        )) by (nonlinear_arith);\n        // Factor out pow_base\n        assert(pow_base * partial_prev + pow_base * byte_val * pow2((prev * 8) as nat) == pow_base\n            * (partial_prev + byte_val * pow2((prev * 8) as nat))) by (nonlinear_arith);\n    }\n}",
      "start_line": 181,
      "end_line": 62,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "display_name": "optional_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
      "file_name": "straus.rs",
      "parent_folder": "scalar_mul",
      "body": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::backend::serial::curve_models::{\n            CompletedPoint, ProjectiveNielsPoint, ProjectivePoint,\n        };\n        use crate::traits::Identity;\n        use crate::window::NafLookupTable5;\n\n        let nafs: Vec<_> = scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect();\n\n        let lookup_tables = points\n            .into_iter()\n            .map(|P_opt| P_opt.map(|P| NafLookupTable5::<ProjectiveNielsPoint>::from(&P)))\n            .collect::<Option<Vec<_>>>()?;\n\n        let mut r = ProjectivePoint::identity();\n\n        for i in (0..256).rev() {\n            let mut t: CompletedPoint = r.double();\n\n            for (naf, lookup_table) in nafs.iter().zip(lookup_tables.iter()) {\n                match naf[i].cmp(&0) {\n                    Ordering::Greater => {\n                        t = &t.as_extended() + &lookup_table.select(naf[i] as usize)\n                    }\n                    Ordering::Less => t = &t.as_extended() - &lookup_table.select(-naf[i] as usize),\n                    Ordering::Equal => {}\n                }\n            }\n\n            r = t.as_projective();\n        }\n\n        Some(r.as_extended())\n    }",
      "start_line": 157,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#vartime_double_scalar_mul_basepoint().",
      "display_name": "vartime_double_scalar_mul_basepoint",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#vartime_double_scalar_mul_basepoint().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn vartime_double_scalar_mul_basepoint(\n        a: &Scalar,\n        A: &RistrettoPoint,\n        b: &Scalar,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::vartime_double_scalar_mul_basepoint(\n            a, &A.0, b,\n        ))\n    }",
      "start_line": 1055,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "display_name": "spec_field_element_from_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_field_element_from_bytes(bytes: &[u8; 32]) -> nat {\n    (u8_32_as_nat(bytes) % pow2(255)) % p()\n}",
      "start_line": 82,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 17,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self(crate::backend::VartimePrecomputedStraus::new(\n            static_points.into_iter().map(|P| P.borrow().0),\n        ))\n    }",
      "start_line": 1019,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/negate_projective_niels().",
      "display_name": "negate_projective_niels",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/negate_projective_niels().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn negate_projective_niels(p: ProjectiveNielsPoint) -> ProjectiveNielsPoint {\n    ProjectiveNielsPoint {\n        Y_plus_X: p.Y_minus_X,\n        Y_minus_X: p.Y_plus_X,\n        Z: p.Z,\n        T2d: crate::field::FieldElement {\n            limbs: crate::specs::field_specs_u64::spec_negate(p.T2d.limbs),\n        },\n    }\n}",
      "start_line": 583,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_square_of().",
      "display_name": "is_square_of",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_square_of().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_square_of(a: &FieldElement51, b: &FieldElement51) -> bool {\n    (spec_field_element(b) * spec_field_element(b)) % p() == spec_field_element(a) % p()\n}",
      "start_line": 432,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimeMultiscalarMul#optional_multiscalar_mul().",
      "display_name": "optional_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimeMultiscalarMul#optional_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "curve25519-dalek/src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<Self::Point>>;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// public points, compute\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// using variable-time operations.\n    ///\n    /// It is an error to call this function with two iterators of different lengths.\n    ///\n    /// # Examples\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    ///\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    ///\n    /// // A1 = a*P + b*Q + c*R\n    /// let abc = [a,b,c];\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &[P,Q,R]);\n    /// // Note: (&abc).into_iter(): Iterator<Item=&Scalar>\n    ///\n    /// // A2 = (-a)*P + (-b)*Q + (-c)*R\n    /// let minus_abc = abc.iter().map(|x| -x);\n    /// let A2 = RistrettoPoint::vartime_multiscalar_mul(minus_abc, &[P,Q,R]);\n    /// // Note: minus_abc.into_iter(): Iterator<Item=Scalar>\n    ///\n    /// assert_eq!(A1.compress(), (-A2).compress());\n    /// # }",
      "start_line": 197,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_point_edwards().",
      "display_name": "spec_projective_point_edwards",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_point_edwards().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_projective_point_edwards(point: ProjectivePoint) -> (nat, nat, nat) {\n    let x = spec_field_element(&point.X);\n    let y = spec_field_element(&point.Y);\n    let z = spec_field_element(&point.Z);\n    (x, y, z)\n}",
      "start_line": 303,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_from_limb_shift().",
      "display_name": "lemma_byte_from_limb_shift",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_from_limb_shift().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_byte_from_limb_shift(limb: u64, shift: u64, byte: u8)\n    requires\n        limb < pow2(51),\n        shift < 64,\n        byte == (limb >> shift) as u8,\n    ensures\n        byte as nat == (limb as nat / pow2(shift as nat)) % 256,\n{\n    // Bitwise shift to arithmetic conversion\n    // When we shift right by `shift` bits and cast to u8, we extract 8 bits starting at position `shift`\n    // In arithmetic terms: (limb / 2^shift) % 256\n    lemma2_to64();\n    lemma_u64_shr_is_div(limb, shift);\n    assert((limb >> shift) as nat == limb as nat / pow2(shift as nat));\n\n    // The u8 cast takes the low 8 bits, which is % 256\n    assert((limb >> shift) as u8 == (limb >> shift) as nat % 256) by {\n        lemma_u8_cast_is_mod_256(limb >> shift);\n    }\n}",
      "start_line": 133,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/variable_base_mul().",
      "display_name": "variable_base_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/variable_base_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "backend",
      "body": "pub fn variable_base_mul(point: &EdwardsPoint, scalar: &Scalar) -> (result: EdwardsPoint)\n    requires\n// as_radix_16 requires scalar.bytes[31] <= 127 (MSB clear, i.e. scalar < 2^255)\n\n        scalar.bytes[31] <= 127,\n        // Input point must be well-formed (valid coordinates with proper limb bounds)\n        is_well_formed_edwards_point(*point),\n    ensures\n// Result is a well-formed Edwards point\n\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result represents scalar * point\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            edwards_point_as_affine(*point),\n            spec_scalar(scalar),\n        ),\n{\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 => vector::scalar_mul::variable_base::spec_avx2::mul(point, scalar),\n        // #[cfg(all(curve25519_dalek_backend = \"simd\", nightly))]\n        // BackendKind::Avx512 => {\n        //     vector::scalar_mul::variable_base::spec_avx512ifma_avx512vl::mul(point, scalar)\n        // }\n        BackendKind::Serial => serial::scalar_mul::variable_base::mul(point, scalar),\n    }\n}",
      "start_line": 247,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "display_name": "lemma_i_inverse_is_neg_i",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "file_name": "sqrt_ratio_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_i_inverse_is_neg_i()\n    ensures\n        math_field_mul(spec_sqrt_m1(), math_field_neg(spec_sqrt_m1())) == 1,\n        math_field_inv(spec_sqrt_m1()) == math_field_neg(spec_sqrt_m1()),\n{\n    let i = spec_sqrt_m1();\n    let p = p();\n    p_gt_2();\n    \n    // Step 1: Show i < p (since spec_sqrt_m1() = spec_field_element(...) % p)\n    assert(i < p) by { \n        lemma_mod_bound(spec_field_element_as_nat(&constants::SQRT_M1) as int, p as int); \n    };\n    \n    // Step 2: Define -i = (p - i) % p = p - i (since i < p and i > 0)\n    let neg_i = math_field_neg(i);\n    \n    // Show i ≠ 0: If i = 0, then i² = 0, but i² ≡ -1 (mod p), contradiction\n    assert(i != 0) by {\n        if i == 0 {\n            // 0 * 0 = 0, so (0 * 0) % p = 0\n            assert(0 * 0 == 0nat);\n            assert(0nat % p == 0) by { lemma_small_mod(0nat, p); };\n            // But axiom says i² % p = p - 1\n            assert((i * i) % p == (p - 1) as nat) by { axiom_sqrt_m1_squared(); };\n            // Since i = 0, we have 0 = p - 1, but p > 2\n            assert(false);\n        }\n    };\n    \n    // Step 3: neg_i = p - i (since i < p and i ≠ 0, we have 0 < p - i < p)\n    assert(neg_i == (p - i) as nat) by {\n        // math_field_neg(i) = (p - i % p) % p = (p - i) % p\n        lemma_small_mod(i, p);  // i % p = i\n        // (p - i) < p since i > 0\n        assert(0 < p - i && p - i < p);\n        lemma_small_mod((p - i) as nat, p);  // (p - i) % p = p - i\n    };\n    \n    // Step 4: Show i · neg_i ≡ 1 (mod p)\n    // Key: i · (p - i) = i·p - i² ≡ 0 - (-1) = 1 (mod p)\n    assert(((i % p) * neg_i) % p == 1) by {\n        // i % p = i (since i < p)\n        lemma_small_mod(i, p);\n        \n        // neg_i = p - i\n        assert(neg_i == (p - i) as nat);\n        \n        // Goal: show (i * (p - i)) % p == 1\n        \n        // Step 4a: i·p % p = 0\n        assert((i * p) % p == 0) by {\n            lemma_mod_multiples_basic(i as int, p as int);\n        };\n        \n        // Step 4b: i² % p = p - 1 (from axiom)\n        let i2_mod: nat = (p - 1) as nat;\n        assert((i * i) % p == i2_mod) by { axiom_sqrt_m1_squared(); };\n        \n        // Step 4c: i * (p - i) = i*p - i² by distributivity\n        let product = i * (p - i);\n        assert(product == i * p - i * i) by {\n            lemma_mul_is_distributive_sub(i as int, p as int, i as int);\n        };\n        \n        // Step 4d: Use sub_mod_noop to relate (i*p - i*i) % p to (i*p % p - i*i % p) % p\n        // lemma_sub_mod_noop gives: ((x % m) - (y % m)) % m == (x - y) % m\n        lemma_sub_mod_noop((i * p) as int, (i * i) as int, p as int);\n        // This gives: ((i*p % p) - (i*i % p)) % p == (i*p - i*i) % p\n        // i.e., (0 - i2_mod) % p == product % p\n        \n        // Step 4e: (0 - (p-1)) % p = (-(p-1)) % p\n        // In modular arithmetic, -x % p = (p - (x % p)) % p for x > 0\n        // Since i2_mod = p - 1 < p, we have:\n        // (0 - i2_mod) % p = (-(p-1)) % p = (p - (p-1)) % p = 1 % p = 1\n        \n        // The key: (0 - (p-1)) is 1 - p, which is negative\n        // (1 - p) % p in Euclidean mod = ((1 - p) % p + p) % p = 1\n        assert((0int - i2_mod as int) % (p as int) == 1) by {\n            // 0 - (p - 1) = 1 - p = -(p - 1)\n            assert(0int - i2_mod as int == 1 - p as int);\n            \n            // We need: (1 - p) % p == 1\n            // Using: (-p + 1) % p == 1 % p == 1\n            // lemma_mod_sub_multiples_vanish: (-m + b) % m == b % m\n            lemma_mod_sub_multiples_vanish(1int, p as int);\n            // This gives: (-p + 1) % p == 1 % p\n            lemma_small_mod(1, p);  // 1 % p = 1\n        };\n        \n        // Step 4f: Chain together\n        // product % p = (i*p - i*i) % p  [by def of product]\n        //             = ((i*p % p) - (i*i % p)) % p  [by lemma_sub_mod_noop]\n        //             = (0 - i2_mod) % p  [by Steps 4a, 4b]\n        //             = 1  [by Step 4e]\n        \n        // The final assertion\n        assert(((i * (p - i)) as int) % (p as int) == 1);\n        assert((((i % p) * (p - i)) as int) % (p as int) == 1) by {\n            lemma_mul_mod_noop_left(i as int, ((p - i) as nat) as int, p as int);\n        };\n    };\n    \n    // Step 5: math_field_mul(i, neg_i) = (i * neg_i) % p = 1\n    assert(math_field_mul(i, neg_i) == 1) by {\n        // math_field_mul(i, neg_i) = (i * neg_i) % p\n        // We showed (i % p * neg_i) % p = 1\n        // Since i % p = i, we have (i * neg_i) % p = 1\n        lemma_small_mod(i, p);\n        lemma_mul_mod_noop_left(i as int, neg_i as int, p as int);\n    };\n    \n    // Step 6: By uniqueness of inverse, inv(i) = neg_i\n    assert(math_field_inv(i) == neg_i) by {\n        // We have: i % p ≠ 0, neg_i < p, and (i % p) * neg_i % p = 1\n        // By field_inv_unique, neg_i = inv(i)\n        assert(i % p != 0) by { lemma_small_mod(i, p); };\n        assert(neg_i < p);\n        field_inv_unique(i, neg_i);\n    };\n}",
      "start_line": 294,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 16
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/identity_projective_point_edwards().",
      "display_name": "identity_projective_point_edwards",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/identity_projective_point_edwards().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn identity_projective_point_edwards() -> ProjectivePoint {\n    ProjectivePoint {\n        X: crate::field::FieldElement { limbs: [0, 0, 0, 0, 0] },  // 0\n        Y: crate::field::FieldElement { limbs: [1, 0, 0, 0, 0] },  // 1\n        Z: crate::field::FieldElement { limbs: [1, 0, 0, 0, 0] },  // 1\n    }\n}",
      "start_line": 317,
      "end_line": 51,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_field_element_sign_bit().",
      "display_name": "lemma_decompress_field_element_sign_bit",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_field_element_sign_bit().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_decompress_field_element_sign_bit(\n    x_before_negate: nat,\n    x_after_negate: nat,\n    repr_byte_31: u8,\n)\n    requires\n        (x_before_negate % p()) % 2 == 0,  // sqrt_ratio_i returns even\n        (repr_byte_31 >> 7) == 1 ==> x_before_negate % p() != 0,  // x ≠ 0 when negating\n        x_after_negate == if (repr_byte_31 >> 7) == 1 { \n            math_field_neg(x_before_negate) \n        } else { \n            x_before_negate % p() \n        },",
      "start_line": 502,
      "end_line": 53,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_negate_affine_niels().",
      "display_name": "spec_negate_affine_niels",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_negate_affine_niels().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_negate_affine_niels(p: (nat, nat, nat)) -> (nat, nat, nat) {\n    let (y_plus_x, y_minus_x, xy2d) = p;\n    (y_minus_x, y_plus_x, math_field_neg(xy2d))\n}",
      "start_line": 559,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/main().",
      "display_name": "main",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/main().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mask_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mask_lemmas.rs",
      "file_name": "mask_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "fn main() {\n}",
      "start_line": 67,
      "end_line": 8,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_valid_compressed_enables_sign_proof().",
      "display_name": "lemma_valid_compressed_enables_sign_proof",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_valid_compressed_enables_sign_proof().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_valid_compressed_enables_sign_proof(\n    repr_byte_31: u8,\n    x_sqrt: nat,\n)\n    requires\n        (x_sqrt % p()) % 2 == 0,  // non-negative root\n        x_sqrt < p(),\n        valid_compressed_for_sign_bit(repr_byte_31, x_sqrt),\n    ensures\n        (repr_byte_31 >> 7) == 1 ==> x_sqrt % p() != 0,\n{\n    // Direct consequence of valid_compressed_for_sign_bit spec\n    lemma_small_mod(x_sqrt, p());\n}",
      "start_line": 586,
      "end_line": 55,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "display_name": "elligator_inv",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/jacobi_quartic.rs",
      "relative_path": "curve25519-dalek/src/lizard/jacobi_quartic.rs",
      "file_name": "jacobi_quartic.rs",
      "parent_folder": "lizard",
      "body": "    pub(crate) fn elligator_inv(&self) -> (Choice, FieldElement) {\n        let mut out = FieldElement::ZERO;\n\n        // Special case: s = 0.  If s is zero, either t = 1 or t = -1.\n        // If t=1, then sqrt(i*d) is the preimage.  Otherwise it's 0.\n        let s_is_zero = self.S.is_zero();\n        let t_equals_one = self.T.ct_eq(&FieldElement::ONE);\n        out.conditional_assign(&lizard_constants::SQRT_ID, t_equals_one);\n        let mut ret = s_is_zero;\n        let mut done = s_is_zero;\n\n        // a := (t+1) (d+1)/(d-1)\n        let a = &(&self.T + &FieldElement::ONE) * &lizard_constants::DP1_OVER_DM1;\n        let a2 = a.square();\n\n        // y := 1/sqrt(i (s^4 - a^2)).\n        let s2 = self.S.square();\n        let s4 = s2.square();\n        let invSqY = &(&s4 - &a2) * &constants::SQRT_M1;\n\n        // There is no preimage if the square root of i*(s^4-a^2) does not exist.\n        let (sq, y) = invSqY.invsqrt();\n        ret |= sq;\n        done |= !sq;\n\n        // x := (a + sign(s)*s^2) y\n        let mut pms2 = s2;\n        pms2.conditional_negate(self.S.is_negative());\n        let mut x = &(&a + &pms2) * &y;\n        let x_is_negative = x.is_negative();\n        x.conditional_negate(x_is_negative);\n        out.conditional_assign(&x, !done);\n\n        (ret, out)\n    }",
      "start_line": 29,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_exponent_arithmetic().",
      "display_name": "lemma_invert_exponent_arithmetic",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_exponent_arithmetic().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "file_name": "invert_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_invert_exponent_arithmetic()\n    ensures\n        (pow2(250) - 1) * pow2(5) == pow2(255) - 32,\n        pow2(255) - 21 == p() - 2,\n{\n    assert((pow2(250) - 1) * pow2(5) == pow2(255) - 32) by {\n        assert(pow2(250) * pow2(5) == pow2(255)) by {\n            lemma_pow2_adds(250, 5);\n        };\n        assert(pow2(5) == 32) by {\n            lemma2_to64();\n        };\n    }\n\n    assert(pow2(255) - 21 == p() - 2) by {\n        pow255_gt_19();\n    }\n}",
      "start_line": 119,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_denominator().",
      "display_name": "lemma_div_denominator",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_denominator().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 9,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/From#from().",
      "display_name": "from",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/From#from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_multiplies().",
      "display_name": "lemma_pow_multiplies",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_multiplies().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/product_of_multiples().",
      "display_name": "product_of_multiples",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/product_of_multiples().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub open spec fn product_of_multiples(a: nat, n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        1\n    } else {\n        (n * a) * product_of_multiples(a, (n - 1) as nat)\n    }\n}",
      "start_line": 764,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_factors_congruent_implies_products_congruent().",
      "display_name": "lemma_mul_factors_congruent_implies_products_congruent",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_factors_congruent_implies_products_congruent().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_mul_factors_congruent_implies_products_congruent(c: int, a: int, b: int, m: int)\n    requires\n        m > 0,\n        a % m == b % m,\n    ensures\n        (c * a) % m == (c * b) % m,\n{\n    assert((c * a) % m == (c * (a % m)) % m) by { lemma_mul_mod_noop_right(c, a, m) };\n    assert((c * a) % m == (c * (b % m)) % m);\n    assert((c * a) % m == (c * b) % m) by { lemma_mul_mod_noop_right(c, b, m) };\n\n}",
      "start_line": 1825,
      "end_line": 68,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#dual().",
      "display_name": "dual",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#dual().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/jacobi_quartic.rs",
      "relative_path": "curve25519-dalek/src/lizard/jacobi_quartic.rs",
      "file_name": "jacobi_quartic.rs",
      "parent_folder": "lizard",
      "body": "    pub(crate) fn dual(&self) -> JacobiPoint {\n        JacobiPoint {\n            S: -(&self.S),\n            T: -(&self.T),\n        }\n    }",
      "start_line": 65,
      "end_line": 23,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "display_name": "spec_field_element",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_field_element(fe: &FieldElement51) -> nat {\n    spec_field_element_as_nat(fe) % p()\n}",
      "start_line": 75,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 72,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#as_bytes().",
      "display_name": "as_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#as_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub const fn as_bytes(&self) -> (result: &[u8; 32])\n        ensures\n            result == self.0,\n    {\n        &self.0\n    }",
      "start_line": 219,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_is_ordered().",
      "display_name": "lemma_div_is_ordered",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_is_ordered().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "display_name": "lemma_reduce_bound_2p",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/reduce_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/reduce_lemmas.rs",
      "file_name": "reduce_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_reduce_bound_2p(limbs: [u64; 5])\n    ensures\n        u64_5_as_nat(spec_reduce(limbs)) < 2 * p(),\n{\n    lemma2_to64();\n    pow255_gt_19();\n\n    let r = spec_reduce(limbs);\n\n    assert(1u64 << 51 == pow2(51)) by {\n        lemma_shift_is_pow2(51);\n    }\n\n    // For r[i] where i > 0: (limbs[i] & mask51) + (limbs[i-1] >> 51) < 2^51 + 2^13\n    assert forall|i: int| 0 <= i <= 4 implies #[trigger] (limbs[i] & mask51) < pow2(51) by {\n        lemma_masked_lt_51(limbs[i]);\n    }\n    // separate foralls, because they trigger on i and i-1\n    assert forall|i: int| 0 <= i <= 4 implies #[trigger] limbs[i] >> 51 < pow2(13) by {\n        assert(limbs[i] >> 51 <= u64::MAX >> 51) by {\n            lemma_shr_le_u64(limbs[i], u64::MAX, 51);\n        }\n        assert(u64::MAX >> 51 < pow2(13)) by {\n            assert(1u64 << 13 == pow2(13)) by {\n                lemma_shift_is_pow2(13);\n            }\n            lemma_u64_max_shifting(51);\n        }\n    }\n\n    // For r[0] we have the extra factor of 19:\n    // r[0] = (limbs[0] & mask51) + (limbs[4] >> 51) * 19\n    assert((limbs[4] >> 51) * 19 < pow2(18)) by {\n        assert(19 < pow2(5)) by {\n            lemma2_to64();\n        }\n        assert(pow2(18) == pow2(13) * pow2(5)) by {\n            lemma_pow2_adds(13, 5);\n        }\n        lemma_mul_lt((limbs[4] >> 51) as nat, pow2(13), 19, pow2(5));\n    }\n\n    assert forall|i: nat| 1 <= i <= 4 implies #[trigger] pow2(i * 51) * r[i as int] < pow2(i * 51)\n        * pow2(13) + pow2((i + 1) * 51) by {\n        assert(pow2(i * 51) * r[i as int] < pow2(i * 51) * (pow2(51) + pow2(13))) by {\n            lemma_pow2_pos(i * 51);\n            lemma_mul_strict_inequality(\n                r[i as int] as int,\n                (pow2(51) + pow2(13)) as int,\n                pow2(i * 51) as int,\n            );\n            lemma_mul_is_commutative(pow2(i * 51) as int, r[i as int] as int);\n            lemma_mul_is_commutative(pow2(i * 51) as int, (pow2(51) + pow2(13)) as int);\n        }\n\n        assert(pow2(i * 51) * (pow2(51) + pow2(13)) == pow2((i + 1) * 51) + pow2(i * 51) * pow2(13))\n            by {\n            assert(pow2(i * 51) * (pow2(51) + pow2(13)) == pow2(i * 51) * pow2(51) + pow2(i * 51)\n                * pow2(13)) by {\n                lemma_mul_is_distributive_add(\n                    pow2(i * 51) as int,\n                    pow2(51) as int,\n                    pow2(13) as int,\n                );\n            }\n            assert(pow2(i * 51) * pow2(51) == pow2((i + 1) * 51)) by {\n                assert(i * 51 + 51 == (i + 1) * 51) by {\n                    lemma_mul_is_distributive_add_other_way(51, i as int, 1);\n                }\n                lemma_pow2_adds(i * 51, 51);\n            }\n        }\n    }\n\n    // write out i * 51s explicitly to trigger forall match\n    let tail = (pow2(18) + pow2(51) + pow2(64) + pow2(102) + pow2(115) + pow2(153) + pow2(166)\n        + pow2(204) + pow2(217));\n    assert(u64_5_as_nat(r) == r[0] + pow2(1 * 51) * r[1] + pow2(2 * 51) * r[2] + pow2(3 * 51) * r[3]\n        + pow2(4 * 51) * r[4] < tail + pow2(255)) by {\n        lemma_pow2_adds(51, 13);\n        lemma_pow2_adds(102, 13);\n        lemma_pow2_adds(153, 13);\n        lemma_pow2_adds(204, 13);\n    }\n\n    assert(2 * p() == pow2(255) + pow2(255) - 38) by {\n        lemma_pow2_adds(255, 1);\n        lemma_pow2_plus_one(255);\n    }\n\n    // we'll prove the tail is small\n    assert(tail < pow2(255) - 38) by {\n        assert forall|i: nat| i <= 204 implies #[trigger] pow2(i) < pow2(217) by {\n            lemma_pow2_strictly_increases(i, 217);\n        }\n        assert(tail < 9 * pow2(217) < pow2(221)) by {\n            assert(9 < pow2(4));  // known\n            assert(pow2(217) > 0) by {\n                lemma_pow2_pos(217);\n            }\n            lemma_mul_strict_inequality(9, pow2(4) as int, pow2(217) as int);\n            lemma_pow2_adds(217, 4);\n        }\n\n        assert(pow2(254) < pow2(255) - 38) by {\n            assert(38 < pow2(6));  // known\n            assert(pow2(255) - 38 > pow2(255) - pow2(6) == pow2(254) + pow2(254) - pow2(6)) by {\n                lemma_pow2_plus_one(254);\n            }\n            assert(pow2(254) - pow2(6) > 0) by {\n                lemma_pow2_strictly_increases(6, 254);\n            }\n        }\n\n        assert(pow2(221) < pow2(254)) by {\n            lemma_pow2_strictly_increases(221, 254);\n        }\n    }\n}",
      "start_line": 205,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 19
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_value_properties().",
      "display_name": "lemma_l_value_properties",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_value_properties().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_l_value_properties(l_value: &Scalar52, sum: &Scalar52)\n    requires\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n    ensures\n        forall|j: int| 0 <= j < 5 ==> l_value.limbs[j] < (1u64 << 52),\n{\n    assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n}",
      "start_line": 336,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_has_value().",
      "display_name": "ct_option_has_value",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_has_value().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub uninterp spec fn ct_option_has_value<T>(opt: CtOption<T>) -> bool;\n\n/// Spec-level view of CtOption::unwrap - what value it contains\npub uninterp spec fn ct_option_value<T>(opt: CtOption<T>) -> T;\n\n/// Wrapper function for CtOption::new\n#[verifier::external_body]\npub fn ct_option_new<T>(value: T, choice: Choice) -> (result: CtOption<T>)\n    ensures\n        ct_option_has_value(result) == choice_is_true(choice),\n        ct_option_value(result) == value,\n{\n    CtOption::new(value, choice)\n}",
      "start_line": 152,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "display_name": "lemma_mul_is_commutative",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 45,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_positive().",
      "display_name": "lemma_pow_positive",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_positive().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "display_name": "step_2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub(super) fn step_2(\n        repr: &CompressedEdwardsY,\n        mut X: FieldElement,\n        Y: FieldElement,\n        Z: FieldElement,\n    ) -> (result: EdwardsPoint)\n        requires\n    // Limb bounds for inputs (X from sqrt_ratio_i, Y from from_bytes, Z = ONE)\n            // X is 52-bit bounded from sqrt_ratio_i (relaxed from 51)\n            fe51_limbs_bounded(&X, 52),\n            fe51_limbs_bounded(&Y, 51),\n            fe51_limbs_bounded(&Z, 51),\n        ensures\n            spec_field_element(&result.X)\n                ==\n            // If the sign bit is 1, negate the X field element\n            if (repr.0[31] >> 7) == 1 {\n                math_field_neg(spec_field_element(&X))\n            } else {\n                spec_field_element(&X)\n            },",
      "start_line": 484,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/binomial().",
      "display_name": "binomial",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/binomial().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub open spec fn binomial(n: nat, k: nat) -> nat\n    decreases n,\n{\n    if k > n {\n        0\n    } else if k == 0 || k == n {\n        1\n    } else {\n        binomial((n - 1) as nat, (k - 1) as nat) + binomial((n - 1) as nat, k)\n    }\n}",
      "start_line": 232,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random().",
      "display_name": "is_random",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub uninterp spec fn is_random(x: u8) -> bool;\n\npub uninterp spec fn is_random_bytes(bytes: &[u8]) -> bool;\n\npub uninterp spec fn is_random_scalar(scalar: &Scalar) -> bool;\n\n#[cfg(feature = \"rand_core\")]\n#[verifier::external_body]\npub fn fill_bytes<R: RngCore>(rng: &mut R, bytes: &mut [u8; 64])\n    ensures\n        is_random_bytes(bytes),\n{\n    rng.fill_bytes(bytes)\n}",
      "start_line": 157,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Neg#neg().",
      "display_name": "neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Neg#neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn neg(self) -> (output: FieldElement51)\n        ensures\n            spec_field_element(&output) == math_field_neg(spec_field_element(self)),\n            forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 52),\n    {\n        let mut output = *self;\n        output.negate();\n\n        proof {\n            lemma_neg(self);\n        }\n\n        output\n    }",
      "start_line": 644,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "display_name": "add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn add(self, _rhs: &'a Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(&_rhs.bytes))\n                % group_order(),\n    {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::add requires inputs < group_order()\n        // By Scalar invariant #2, scalars should be canonical\n        // However, we cannot add requires clauses to trait implementations,\n        // so we assume this property holds\n        proof {\n            assume(to_nat(&self_unpacked.limbs) < group_order());\n            assume(to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::add(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) == (to_nat(&self_unpacked.limbs) + to_nat(\n                &rhs_unpacked.limbs,\n            )) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(to_nat(&result_unpacked.limbs) == to_nat(&result_unpacked.limbs) % pow2(256))\n                by {\n                assert(group_order() < pow2(256)) by {\n                    assume(false);\n                }\n                lemma_small_mod(to_nat(&result_unpacked.limbs), pow2(256));\n            }\n            assert(bytes_to_nat(&result.bytes) == to_nat(&result_unpacked.limbs));\n            assert(bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }",
      "start_line": 627,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#zip().",
      "display_name": "zip",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#zip().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    fn zeroize(&mut self) {\n        self.0.iter_mut().zeroize();\n    }",
      "start_line": 519,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 Choice#BitOr#bitor().",
      "display_name": "bitor",
      "symbol": "rust-analyzer cargo subtle 2.6.1 Choice#BitOr#bitor().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_scalar().",
      "display_name": "is_random_scalar",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_scalar().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub uninterp spec fn is_random_scalar(scalar: &Scalar) -> bool;\n\n#[cfg(feature = \"rand_core\")]\n#[verifier::external_body]\npub fn fill_bytes<R: RngCore>(rng: &mut R, bytes: &mut [u8; 64])\n    ensures\n        is_random_bytes(bytes),\n{\n    rng.fill_bytes(bytes)\n}",
      "start_line": 161,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "display_name": "optional_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        // Sanity-check lengths of input iterators\n        let mut scalars = scalars.into_iter();\n        let mut points = points.into_iter();\n\n        // Lower and upper bounds on iterators\n        let (s_lo, s_hi) = scalars.by_ref().size_hint();\n        let (p_lo, p_hi) = points.by_ref().size_hint();\n\n        // They should all be equal\n        assert_eq!(s_lo, p_lo);\n        assert_eq!(s_hi, Some(s_lo));\n        assert_eq!(p_hi, Some(p_lo));\n\n        // Now we know there's a single size.\n        // Use this as the hint to decide which algorithm to use.\n        let size = s_lo;\n\n        if size < 190 {\n            crate::backend::straus_optional_multiscalar_mul(scalars, points)\n        } else {\n            crate::backend::pippenger_optional_multiscalar_mul(scalars, points)\n        }\n    }",
      "start_line": 1834,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn default() -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == 0 as nat,\n    {\n        let result = Scalar::ZERO;\n        assume(scalar_to_nat(&result) == 0 as nat);\n        result\n    }",
      "start_line": 980,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#ConditionallySelectable#conditional_select().",
      "display_name": "conditional_select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#ConditionallySelectable#conditional_select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn conditional_select(a: &ProjectivePoint, b: &ProjectivePoint, choice: Choice) -> (result:\n        ProjectivePoint)\n        ensures\n    // If choice is false (0), return a\n\n            !choice_is_true(choice) ==> {\n                &&& result.U == a.U\n                &&& result.W == a.W\n            },",
      "start_line": 608,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_nondecreasing().",
      "display_name": "lemma_shl_nondecreasing",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_nondecreasing().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_shl_nondecreasing(v: u64, a: nat, b: nat)\n    requires\n        a <= b < 64,\n        v * pow2(b) <= u64::MAX,\n    ensures\n        (v << a) <= (v << b),\n{\n    lemma2_to64();  // pow2(0)\n\n    if (a == b) {\n        // trivial\n    } else if (a == 0) {\n        // a != b <=> b > 0\n        lemma_pow2_strictly_increases(0, b);\n        lemma_u64_shl_is_mul(v, 0);\n        lemma_u64_shl_is_mul(v, b as u64);\n        lemma_mul_le(v as nat, v as nat, pow2(0), pow2(b));\n    } else {\n        // if a != 0 and a != b then 0 < d < b\n        let d = b - a;\n\n        // v << b = (v << (b - a)) << a\n        lemma_shl_by_sum(v, d as nat, a);\n\n        assert(v << d == v * pow2(d as nat)) by {\n            // we need the precond v * pow2(d) < M\n            lemma_pow2_strictly_increases(d as nat, b);\n            lemma_mul_le(v as nat, v as nat, pow2(d as nat), pow2(b));\n            lemma_u64_shl_is_mul(v, d as u64);\n        }\n\n        assert(v <= v << d) by {\n            lemma_shl_zero_is_id(v);\n            lemma_u64_shl_is_mul(v, 0);\n            lemma_pow2_strictly_increases(0, d as nat);\n            lemma_mul_le(v as nat, v as nat, pow2(0), pow2(d as nat));\n        }\n\n        lemma_pow2_adds(a, d as nat);\n\n        assert((v << (d as u64)) * pow2(a) <= u64::MAX) by {\n            lemma_mul_is_associative(v as int, pow2(d as nat) as int, pow2(a) as int);\n        }\n\n        // [v <= v << d] => [(v << a) <= (v << d) << a]\n        lemma_shl_le_u64(v, v << (d as u64), a);\n    }\n}",
      "start_line": 77,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_to_nat().",
      "display_name": "seq_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn seq_to_nat(limbs: Seq<nat>) -> nat\n    decreases limbs.len(),\n{\n    if limbs.len() == 0 {\n        0\n    } else {\n        limbs[0] + seq_to_nat(limbs.subrange(1, limbs.len() as int)) * pow2(52)\n    }\n}",
      "start_line": 11,
      "end_line": 28,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "display_name": "optional_mixed_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs",
      "file_name": "precomputed_straus.rs",
      "parent_folder": "scalar_mul",
      "body": "    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        let static_nafs = static_scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect::<Vec<_>>();\n        let dynamic_nafs: Vec<_> = dynamic_scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect::<Vec<_>>();\n\n        let dynamic_lookup_tables = dynamic_points\n            .into_iter()\n            .map(|P_opt| P_opt.map(|P| NafLookupTable5::<ProjectiveNielsPoint>::from(&P)))\n            .collect::<Option<Vec<_>>>()?;\n\n        let sp = self.static_lookup_tables.len();\n        let dp = dynamic_lookup_tables.len();\n        assert_eq!(sp, static_nafs.len());\n        assert_eq!(dp, dynamic_nafs.len());\n\n        // We could save some doublings by looking for the highest\n        // nonzero NAF coefficient, but since we might have a lot of\n        // them to search, it's not clear it's worthwhile to check.\n        let mut S = ProjectivePoint::identity();\n        for j in (0..256).rev() {\n            let mut R: CompletedPoint = S.double();\n\n            for i in 0..dp {\n                let t_ij = dynamic_nafs[i][j];\n                match t_ij.cmp(&0) {\n                    Ordering::Greater => {\n                        R = &R.as_extended() + &dynamic_lookup_tables[i].select(t_ij as usize)\n                    }\n                    Ordering::Less => {\n                        R = &R.as_extended() - &dynamic_lookup_tables[i].select(-t_ij as usize)\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            #[allow(clippy::needless_range_loop)]\n            for i in 0..sp {\n                let t_ij = static_nafs[i][j];\n                match t_ij.cmp(&0) {\n                    Ordering::Greater => {\n                        R = &R.as_extended() + &self.static_lookup_tables[i].select(t_ij as usize)\n                    }\n                    Ordering::Less => {\n                        R = &R.as_extended() - &self.static_lookup_tables[i].select(-t_ij as usize)\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            S = R.as_projective();\n        }\n\n        Some(S.as_extended())\n    }",
      "start_line": 47,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/pow2_MUL_div().",
      "display_name": "pow2_MUL_div",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/pow2_MUL_div().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn pow2_MUL_div(x: nat, k: nat, s: nat)\n    requires\n        k >= s,\n    ensures\n        (x * pow2(k)) / pow2(s) == x * pow2((k - s) as nat),\n{\n    assert(pow2(s) > 0) by {\n        lemma_pow2_pos(s);\n    }\n\n    let d = (k - s) as nat;\n    assert(pow2(k) == pow2(d) * pow2(s)) by {\n        lemma_pow2_adds(d, s);\n    }\n    assert(x * pow2(k) == (x * pow2(d)) * pow2(s)) by {\n        lemma_mul_is_associative(x as int, pow2(d) as int, pow2(s) as int);\n    }\n    assert(((x * pow2(d)) * pow2(s)) / pow2(s) == x * pow2(d)) by {\n        lemma_div_by_multiple((x * pow2(d)) as int, pow2(s) as int);\n    }\n}",
      "start_line": 401,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core empty/sources/iter/empty().",
      "display_name": "empty",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core empty/sources/iter/empty().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "curve25519-dalek/src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#select().",
      "display_name": "select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    pub fn select(&self, x: usize) -> T {\n        debug_assert_eq!(x & 1, 1);\n        debug_assert!(x < 128);\n\n        self.0[x / 2]\n    }",
      "start_line": 583,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_telescoping().",
      "display_name": "lemma_reduction_telescoping",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_telescoping().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_reduction_telescoping(\n    input_limbs: [u64; 5],\n    final_limbs: [u64; 5],\n    q: u64,\n    c0: int,\n    c1: int,\n    c2: int,\n    c3: int,\n    c4: int,\n)\n    requires\n// The carry propagation relationships\n\n        input_limbs[0] as int + 19 * q as int == c0 * pow2(51) as int + final_limbs[0] as int,\n        input_limbs[1] as int + c0 == c1 * pow2(51) as int + final_limbs[1] as int,\n        input_limbs[2] as int + c1 == c2 * pow2(51) as int + final_limbs[2] as int,\n        input_limbs[3] as int + c2 == c3 * pow2(51) as int + final_limbs[3] as int,\n        input_limbs[4] as int + c3 == c4 * pow2(51) as int + final_limbs[4] as int,\n        // final_limbs are bounded by 2^51\n        final_limbs[0] < (1u64 << 51),\n        final_limbs[1] < (1u64 << 51),\n        final_limbs[2] < (1u64 << 51),\n        final_limbs[3] < (1u64 << 51),\n        final_limbs[4] < (1u64 << 51),\n    ensures\n        u64_5_as_nat(input_limbs) as int + 19 * q as int == u64_5_as_nat(final_limbs) as int + c4\n            * pow2(255) as int,\n{\n    // Establish power-of-2 relationships\n    lemma_pow2_pos(51);\n    lemma_pow2_adds(51, 51);\n    lemma_pow2_adds(51, 102);\n    lemma_pow2_adds(51, 153);\n    lemma_pow2_adds(51, 204);\n\n    // Expand u64_5_as_nat(input_limbs) + 19*q\n    let lhs = u64_5_as_nat(input_limbs) as int + 19 * q as int;\n\n    // Explicitly expand u64_5_as_nat using its definition\n    assert(u64_5_as_nat(input_limbs) == (input_limbs[0] as nat) + pow2(51) * (input_limbs[1] as nat)\n        + pow2(102) * (input_limbs[2] as nat) + pow2(153) * (input_limbs[3] as nat) + pow2(204) * (\n    input_limbs[4] as nat));\n\n    // Convert to int with commutativity\n    assert(u64_5_as_nat(input_limbs) as int == input_limbs[0] as int + input_limbs[1] as int * pow2(\n        51,\n    ) as int + input_limbs[2] as int * pow2(102) as int + input_limbs[3] as int * pow2(153) as int\n        + input_limbs[4] as int * pow2(204) as int) by {\n        lemma_mul_is_commutative(pow2(51) as int, input_limbs[1] as int);\n        lemma_mul_is_commutative(pow2(102) as int, input_limbs[2] as int);\n        lemma_mul_is_commutative(pow2(153) as int, input_limbs[3] as int);\n        lemma_mul_is_commutative(pow2(204) as int, input_limbs[4] as int);\n    }\n\n    assert(lhs == input_limbs[0] as int + input_limbs[1] as int * pow2(51) as int\n        + input_limbs[2] as int * pow2(102) as int + input_limbs[3] as int * pow2(153) as int\n        + input_limbs[4] as int * pow2(204) as int + 19 * q as int);\n\n    // Substitute the division relationships (solve for input_limbs[i])\n\n    // Expand each term using distributivity (same pattern as lemma_radix51_telescoping_direct)\n    assert((c1 * pow2(51) as int + final_limbs[1] as int - c0) * pow2(51) as int == c1 * pow2(\n        102,\n    ) as int + final_limbs[1] as int * pow2(51) as int - c0 * pow2(51) as int) by {\n        lemma_mul_is_distributive_sub_other_way(\n            pow2(51) as int,\n            c1 * pow2(51) as int + final_limbs[1] as int,\n            c0,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(51) as int,\n            c1 * pow2(51) as int,\n            final_limbs[1] as int,\n        );\n        lemma_mul_is_associative(c1, pow2(51) as int, pow2(51) as int);\n    }\n\n    assert((c2 * pow2(51) as int + final_limbs[2] as int - c1) * pow2(102) as int == c2 * pow2(\n        153,\n    ) as int + final_limbs[2] as int * pow2(102) as int - c1 * pow2(102) as int) by {\n        lemma_mul_is_distributive_sub_other_way(\n            pow2(102) as int,\n            c2 * pow2(51) as int + final_limbs[2] as int,\n            c1,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(102) as int,\n            c2 * pow2(51) as int,\n            final_limbs[2] as int,\n        );\n        lemma_mul_is_associative(c2, pow2(51) as int, pow2(102) as int);\n    }\n\n    assert((c3 * pow2(51) as int + final_limbs[3] as int - c2) * pow2(153) as int == c3 * pow2(\n        204,\n    ) as int + final_limbs[3] as int * pow2(153) as int - c2 * pow2(153) as int) by {\n        lemma_mul_is_distributive_sub_other_way(\n            pow2(153) as int,\n            c3 * pow2(51) as int + final_limbs[3] as int,\n            c2,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(153) as int,\n            c3 * pow2(51) as int,\n            final_limbs[3] as int,\n        );\n        lemma_mul_is_associative(c3, pow2(51) as int, pow2(153) as int);\n    }\n\n    assert((c4 * pow2(51) as int + final_limbs[4] as int - c3) * pow2(204) as int == c4 * pow2(\n        255,\n    ) as int + final_limbs[4] as int * pow2(204) as int - c3 * pow2(204) as int) by {\n        lemma_mul_is_distributive_sub_other_way(\n            pow2(204) as int,\n            c4 * pow2(51) as int + final_limbs[4] as int,\n            c3,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(204) as int,\n            c4 * pow2(51) as int,\n            final_limbs[4] as int,\n        );\n        lemma_mul_is_associative(c4, pow2(51) as int, pow2(204) as int);\n    }\n\n    // Now perform the telescoping sum\n    // lhs = input_limbs[0] + input_limbs[1]*2^51 + input_limbs[2]*2^102 + input_limbs[3]*2^153 + input_limbs[4]*2^204 + 19*q\n\n    // Substitute input_limbs[0]:\n    // = (c0*2^51 + final_limbs[0] - 19*q) + input_limbs[1]*2^51 + ... + 19*q\n    // = c0*2^51 + final_limbs[0] + input_limbs[1]*2^51 + ...\n\n    // Substitute input_limbs[1]:\n    // = c0*2^51 + final_limbs[0] + (c1*2^51 + final_limbs[1] - c0)*2^51 + input_limbs[2]*2^102 + ...\n    // = c0*2^51 + final_limbs[0] + c1*2^102 + final_limbs[1]*2^51 - c0*2^51 + input_limbs[2]*2^102 + ...\n    // = final_limbs[0] + final_limbs[1]*2^51 + c1*2^102 + input_limbs[2]*2^102 + ...\n\n    // Continue substituting - the c0*2^51 terms cancel, then c1*2^102 terms cancel, etc.\n\n    // Expand lhs using the substitutions\n    let rhs = final_limbs[0] as int + final_limbs[1] as int * pow2(51) as int\n        + final_limbs[2] as int * pow2(102) as int + final_limbs[3] as int * pow2(153) as int\n        + final_limbs[4] as int * pow2(204) as int + c4 * pow2(255) as int;\n\n    // Show that lhs == rhs through algebraic expansion\n    assert(lhs == (c0 * pow2(51) as int + final_limbs[0] as int - 19 * q as int) + (c1 * pow2(\n        51,\n    ) as int + final_limbs[1] as int - c0) * pow2(51) as int + (c2 * pow2(51) as int\n        + final_limbs[2] as int - c1) * pow2(102) as int + (c3 * pow2(51) as int\n        + final_limbs[3] as int - c2) * pow2(153) as int + (c4 * pow2(51) as int\n        + final_limbs[4] as int - c3) * pow2(204) as int + 19 * q as int);\n\n    // Use the distributivity facts we proved above\n    assert(lhs == (c0 * pow2(51) as int + final_limbs[0] as int - 19 * q as int) + (c1 * pow2(\n        102,\n    ) as int + final_limbs[1] as int * pow2(51) as int - c0 * pow2(51) as int) + (c2 * pow2(\n        153,\n    ) as int + final_limbs[2] as int * pow2(102) as int - c1 * pow2(102) as int) + (c3 * pow2(\n        204,\n    ) as int + final_limbs[3] as int * pow2(153) as int - c2 * pow2(153) as int) + (c4 * pow2(\n        255,\n    ) as int + final_limbs[4] as int * pow2(204) as int - c3 * pow2(204) as int) + 19 * q as int);\n\n    // Group terms: the carries telescope\n    // c0*2^51 - c0*2^51 = 0\n    // c1*2^102 - c1*2^102 = 0\n    // c2*2^153 - c2*2^153 = 0\n    // c3*2^204 - c3*2^204 = 0\n    // -19*q + 19*q = 0\n    // What remains: final_limbs terms + c4*2^255\n\n    assert(lhs == final_limbs[0] as int + final_limbs[1] as int * pow2(51) as int\n        + final_limbs[2] as int * pow2(102) as int + final_limbs[3] as int * pow2(153) as int\n        + final_limbs[4] as int * pow2(204) as int + c4 * pow2(255) as int);\n\n}",
      "start_line": 27,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/wrapping_sub().",
      "display_name": "wrapping_sub",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/wrapping_sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_of_sum().",
      "display_name": "lemma_div_of_sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_of_sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_div_of_sum(a: nat, b: nat, k: nat)\n    requires\n        (a % k) + (b % k) < k  // also implies k != 0\n        ,\n    ensures\n        (a + b) / k == a / k + b / k,\n{\n    let a0 = a / k;\n    let b0 = b / k;\n\n    assert(a == k * a0 + (a % k)) by {\n        lemma_fundamental_div_mod(a as int, k as int);\n    }\n\n    assert(b == k * b0 + (b % k)) by {\n        lemma_fundamental_div_mod(b as int, k as int);\n    }\n\n    assert(a + b == k * (a0 + b0) + (a % k) + (b % k)) by {\n        lemma_mul_is_distributive_add(k as int, a0 as int, b0 as int);\n    }\n\n    lemma_div_multiples_vanish_fancy((a0 + b0) as int, ((a % k) + (b % k)) as int, k as int);\n}",
      "start_line": 70,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo zeroize 1.8.2 IterMut#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo zeroize 1.8.2 IterMut#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_two_bounded().",
      "display_name": "prop_montgomery_reduce_two_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_two_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "        fn prop_montgomery_reduce_two_bounded(limbs in arb_nine_limbs_two_bounded()) {\n            // Call montgomery_reduce\n            let result = Scalar52::montgomery_reduce(&limbs);\n\n            // Convert to BigUint using executable spec functions\n            let result_nat = to_nat_exec(&result.limbs);\n            let limbs_nat = slice128_to_nat_exec(&limbs);\n            let l = group_order_exec();\n            let r = montgomery_radix_exec();\n\n            // Postcondition 1: Montgomery property (should hold for product of two bounded)\n            let lhs = (&result_nat * &r) % &l;\n            let rhs = &limbs_nat % &l;\n            prop_assert_eq!(lhs, rhs,\n                \"Montgomery reduce spec violated: (result * R) mod L != limbs mod L\");\n\n            // Postcondition 2: limbs_bounded (should hold for product of two bounded)\n            prop_assert!(limbs_bounded_exec(&result),\n                \"Result limbs not bounded by 2^52\");\n\n            // Postcondition 3: Canonicality is NOT guaranteed for product of two bounded scalars\n            // (only guaranteed when one is canonical)\n        }",
      "start_line": 1501,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/bits_to_nat().",
      "display_name": "bits_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/bits_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn bits_to_nat(bits: &[bool; 256]) -> nat {\n    bits_to_nat_rec(bits, 0)\n}",
      "start_line": 14,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "display_name": "lemma_mul_is_distributive_sub",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "is_libsignal": false,
      "caller_count": 20,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_add_then_shift().",
      "display_name": "lemma_add_then_shift",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_add_then_shift().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_add_then_shift(a: u64, b: u64)\n    requires\n        a < (1u64 << 52),\n        b < (1u64 << 52),\n    ensures\n        (a + b) < (1u64 << 53),\n        ((a + b) as u64 >> 51) < 4,\n{\n    lemma2_to64_rest();\n    assert((a + b) < 1u64 << 53) by {\n        assert((1u64 << 52) + (1u64 << 52) == 1u64 << 53) by (compute);\n    }\n    assert(1u64 << 53 == (1u64 << 51) * 4) by (bit_vector);\n    // 0 < b  /\\ a < b * c => a/b < c\n    lemma_multiply_divide_lt((a + b) as int, (1u64 << 51) as int, 4int);\n    lemma_shift_is_pow2(51);\n    lemma_shift_is_pow2(53);\n    assert((a + b) as u64 >> 51 == (a + b) as u64 / (pow2(51) as u64)) by {\n        lemma_u64_shr_is_div((a + b) as u64, 51);\n    }\n    assert(pow2(53) / pow2(51) == 4) by {\n        lemma_pow2_subtracts(51, 53);\n    }\n}",
      "start_line": 25,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_div().",
      "display_name": "lemma_pow2_mul_div_mod_small_div",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_div().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_mul_div_mod_small_div(x: nat, px: nat, k: nat, s: nat, t: nat)\n    requires\n        x < pow2(px),\n        s <= k,\n        px + k - s <= t,\n    ensures\n        ((x * pow2(k)) / pow2(s)) % pow2(t) == x * pow2((k - s) as nat),\n{\n    let d = (k - s) as nat;\n\n    assert((x * pow2(k)) / pow2(s) == x * pow2(d)) by {\n        pow2_MUL_div(x, k, s);\n    }\n\n    let dd = (t - d) as nat;\n\n    assert((x * pow2(d)) % pow2(t) == (x % pow2(dd)) * pow2(d)) by {\n        lemma_pow2_mul_mod(x, d, t);\n    }\n\n    assert(x % pow2(dd) == x) by {\n        assert(x < pow2(px) <= pow2(dd)) by {\n            if (px < dd) {\n                lemma_pow2_strictly_increases(px, dd);\n            }\n        }\n        assert(x % pow2(dd) == x) by {\n            lemma_small_mod(x, pow2(dd));\n        }\n    }\n}",
      "start_line": 449,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mod_cancel().",
      "display_name": "lemma_mod_cancel",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mod_cancel().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_mod_cancel(a: &Scalar52, b: &Scalar52)\n    ensures\n        (group_order() + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int) == (to_nat(\n            &a.limbs,\n        ) - to_nat(&b.limbs)) % (group_order() as int),\n{\n    lemma_mod_add_multiples_vanish(\n        (to_nat(&a.limbs) - to_nat(&b.limbs)) as int,\n        group_order() as int,\n    );\n}",
      "start_line": 680,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "display_name": "conditional_negate",
      "symbol": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_general().",
      "display_name": "lemma_mul_mod_noop_general",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_general().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "is_libsignal": false,
      "caller_count": 10,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_setup().",
      "display_name": "lemma_carry_propagation_setup",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_setup().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_carry_propagation_setup()\n    ensures\n        (1u64 << 51) == pow2(51),\n        (1u64 << 52) == pow2(52),\n        pow2(52) == 2 * pow2(51),\n        19 < pow2(51),\n        3 * pow2(51) <= u64::MAX,\n{\n    lemma2_to64();\n    lemma_shift_is_pow2(51);\n    lemma_shift_is_pow2(52);\n    lemma_pow2_pos(51);\n\n    assert(pow2(52) == 2 * pow2(51)) by {\n        lemma_pow2_adds(1, 51);\n    }\n\n    assert(19 < pow2(51)) by {\n        lemma_pow2_strictly_increases(5, 51);\n    }\n\n    assert(3 * pow2(51) <= u64::MAX) by {\n        lemma2_to64_rest();\n    }\n}",
      "start_line": 290,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConditionallySelectable#conditional_select().",
      "display_name": "conditional_select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConditionallySelectable#conditional_select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn conditional_select(a: &EdwardsPoint, b: &EdwardsPoint, choice: Choice) -> (result:\n        EdwardsPoint)\n        ensures\n    // If choice is false (0), return a\n\n            !choice_is_true(choice) ==> result == *a,\n            // If choice is true (1), return b\n            choice_is_true(choice) ==> result == *b,\n    {\n        let result = EdwardsPoint {\n            X: FieldElement::conditional_select(&a.X, &b.X, choice),\n            Y: FieldElement::conditional_select(&a.Y, &b.Y, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T: FieldElement::conditional_select(&a.T, &b.T, choice),\n        };\n\n        proof {\n            // When all limbs of all fields match, the structs should be equal by extensionality\n            // However, Verus requires explicit extensionality axioms for struct equality\n            // To prove this without assumes would require:\n            // 1. Lemma: FieldElement equality from limb equality (extensionality for FieldElement)\n            // 2. Lemma: EdwardsPoint equality from field equality (extensionality for EdwardsPoint)\n            // For now, we assume the postcondition as it's straightforward from the field-level specs\n            assume(!choice_is_true(choice) ==> result == *a);\n            assume(choice_is_true(choice) ==> result == *b);\n        }\n\n        result\n    }",
      "start_line": 940,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_add_affine_niels().",
      "display_name": "spec_edwards_add_affine_niels",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_add_affine_niels().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_edwards_add_affine_niels(\n    p: crate::edwards::EdwardsPoint,\n    q: crate::backend::serial::curve_models::AffineNielsPoint,\n) -> (nat, nat) {\n    let self_affine = edwards_point_as_affine(p);\n    let other_affine = affine_niels_point_as_affine_edwards(q);\n    edwards_add(self_affine.0, self_affine.1, other_affine.0, other_affine.1)\n}",
      "start_line": 634,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_u64_to_nat().",
      "display_name": "seq_u64_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_u64_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn seq_u64_to_nat(limbs: Seq<u64>) -> nat {\n    seq_to_nat(limbs.map(|i, x| x as nat))\n}",
      "start_line": 25,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 10,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_power_addition().",
      "display_name": "lemma_modular_power_addition",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_power_addition().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_modular_power_addition(x: nat, a: nat, b: nat, m: nat)\n    requires\n        a > 0,\n        b > 0,\n        m > 0,\n    ensures\n        ((pow(x as int, a) as nat) % m) * ((pow(x as int, b) as nat) % m) % m == (pow(\n            x as int,\n            a + b,\n        ) as nat) % m,\n{\n    // =================================================================\n    // PART 1: Core mathematical proof on int level\n    // =================================================================\n    // Prove: pow(x, a + b) == pow(x, a) * pow(x, b)\n    assert(pow(x as int, a + b) == pow(x as int, a) * pow(x as int, b)) by {\n        lemma_pow_adds(x as int, a, b);\n    }\n\n    // Prove: (pow(x, a) * pow(x, b)) % m == ((pow(x, a) % m) * (pow(x, b) % m)) % m\n    assert((pow(x as int, a) * pow(x as int, b)) % (m as int) == ((pow(x as int, a) % (m as int))\n        * (pow(x as int, b) % (m as int))) % (m as int)) by {\n        lemma_mul_mod_noop_general(pow(x as int, a), pow(x as int, b), m as int);\n    }\n\n    // Combining the above: pow(x, a+b) % m == ((pow(x, a) % m) * (pow(x, b) % m)) % m (on int level)\n\n    // =================================================================\n    // PART 2: Bridge int-level proof to nat-level postcondition\n    // =================================================================\n\n    // Bridge 1: pow(x, a) % m on int is same as ((pow(x, a) as nat) % m) as int\n    assert(pow(x as int, a) % (m as int) == ((pow(x as int, a) as nat) % m) as int) by {\n        assert(pow(x as int, a) >= 0) by {\n            lemma_pow_nonnegative(x as int, a);\n        }\n        lemma_int_nat_mod_equiv(pow(x as int, a), m);\n    }\n\n    // Bridge 2: pow(x, b) % m on int is same as ((pow(x, b) as nat) % m) as int\n    assert(pow(x as int, b) % (m as int) == ((pow(x as int, b) as nat) % m) as int) by {\n        assert(pow(x as int, b) >= 0) by {\n            lemma_pow_nonnegative(x as int, b);\n        }\n        lemma_int_nat_mod_equiv(pow(x as int, b), m);\n    }\n\n    // Bridge 3: pow(x, a+b) % m on int is same as ((pow(x, a+b) as nat) % m) as int\n    assert(pow(x as int, a + b) % (m as int) == ((pow(x as int, a + b) as nat) % m) as int) by {\n        assert(pow(x as int, a + b) >= 0) by {\n            lemma_pow_nonnegative(x as int, a + b);\n        }\n        lemma_int_nat_mod_equiv(pow(x as int, a + b), m);\n    }\n\n    // Bridge 4: The product (pow(x, a) % m) * (pow(x, b) % m) on int\n    let pow_a_mod = pow(x as int, a) % (m as int);\n    let pow_b_mod = pow(x as int, b) % (m as int);\n\n    // Prove the product is non-negative\n    assert(pow_a_mod >= 0) by {\n        lemma_fundamental_div_mod(pow(x as int, a), m as int);\n    }\n    assert(pow_b_mod >= 0) by {\n        lemma_fundamental_div_mod(pow(x as int, b), m as int);\n    }\n    assert(pow_a_mod * pow_b_mod >= 0) by (nonlinear_arith)\n        requires\n            pow_a_mod >= 0,\n            pow_b_mod >= 0,\n    ;\n\n    // Bridge the product modulo\n    assert((pow_a_mod * pow_b_mod) % (m as int) == (((pow_a_mod * pow_b_mod) as nat) % m) as int)\n        by {\n        lemma_int_nat_mod_equiv(pow_a_mod * pow_b_mod, m);\n    }\n\n    // The int-level equality now carries over to the nat-level postcondition ✓\n}",
      "start_line": 1048,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#From#from().",
      "display_name": "from",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#From#from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn from(x: u128) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u128_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }",
      "start_line": 1165,
      "end_line": 12,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "display_name": "square_internal",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub(crate) fn square_internal(a: &Scalar52) -> (z: [u128; 9])\n        requires\n            limbs_bounded(a),\n        ensures\n            slice128_to_nat(&z) == to_nat(&a.limbs) * to_nat(&a.limbs),\n            spec_mul_internal(a, a) == z,\n    {\n        proof { lemma_square_internal_no_overflow() }\n\n        let mut z = [0u128;9];\n        z[0] = m(a.limbs[0], a.limbs[0]);\n        z[1] = m(a.limbs[0], a.limbs[1]) * 2;\n        z[2] = m(a.limbs[0], a.limbs[2]) * 2 + m(a.limbs[1], a.limbs[1]);\n        z[3] = m(a.limbs[0], a.limbs[3]) * 2 + m(a.limbs[1], a.limbs[2]) * 2;\n        z[4] = m(a.limbs[0], a.limbs[4]) * 2 + m(a.limbs[1], a.limbs[3]) * 2 + m(\n            a.limbs[2],\n            a.limbs[2],\n        );\n        z[5] = m(a.limbs[1], a.limbs[4]) * 2 + m(a.limbs[2], a.limbs[3]) * 2;\n        z[6] = m(a.limbs[2], a.limbs[4]) * 2 + m(a.limbs[3], a.limbs[3]);\n        z[7] = m(a.limbs[3], a.limbs[4]) * 2;\n        z[8] = m(a.limbs[4], a.limbs[4]);\n\n        proof {\n            lemma_square_internal_correct(&a.limbs, &z);\n        }\n\n        z\n    }",
      "start_line": 873,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.X.limbs[i] == 0,\n            forall|i: int| 0 <= i < 5 ==> self.T.limbs[i] == 0,\n            self.Y == FieldElement::ONE,\n            self.Z == FieldElement::ONE,\n    {\n        self.X.zeroize();\n        self.Y = FieldElement::ONE;\n        self.Z = FieldElement::ONE;\n        self.T.zeroize();\n    }",
      "start_line": 891,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_lemmas/lemmas/lemma_rr_equals_radix_squared().",
      "display_name": "lemma_rr_equals_radix_squared",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_lemmas/lemmas/lemma_rr_equals_radix_squared().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/montgomery_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/montgomery_lemmas.rs",
      "file_name": "montgomery_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub(crate) proof fn lemma_rr_equals_radix_squared()\n    ensures\n        to_nat(&constants::RR.limbs) % group_order() == (montgomery_radix() * montgomery_radix())\n            % group_order(),\n{\n    // Enable conversion between to_nat and five_limbs_to_nat_aux representations\n    lemma_five_limbs_equals_to_nat(&constants::RR.limbs);\n\n    // Establish pow2 facts needed for montgomery_radix() == pow2(260)\n    // lemma_pow2_adds(a, b) proves: pow2(a + b) == pow2(a) * pow2(b)\n    lemma2_to64();\n    lemma2_to64_rest();\n    lemma_pow2_adds(52, 52);\n    lemma_pow2_adds(104, 52);\n    lemma_pow2_adds(156, 52);\n    lemma_pow2_adds(208, 44);\n    lemma_pow2_adds(208, 52);\n\n    // Get the concrete value stored in the RR constant\n    let rr_stored: nat = five_limbs_to_nat_aux(constants::RR.limbs);\n\n    // Key insight: The stored RR value is already reduced (rr_stored < L),\n    // so taking mod L is the identity: rr_stored % L == rr_stored\n    // This is NOT the conclusion - it's an intermediate fact used in the proof chain.\n    lemma_small_mod(rr_stored, group_order());\n\n    // The proof establishes this chain of equalities:\n    //   to_nat(RR.limbs) % L\n    //   == rr_stored % L        (by lemma_five_limbs_equals_to_nat)\n    //   == rr_stored            (by lemma_small_mod, since rr_stored < L)\n    //   == (R * R) % L          (by direct computation below)\n    //\n    // Therefore: to_nat(RR.limbs) % L == (R * R) % L  ✓\n\n    // Verify by direct computation that (R * R) % L equals the stored value\n    // R = 2^260 = 1852673427797059126777135760139006525652319754650249024631321344126610074238976\n    // L = group_order() = 7237005577332262213973186563042994240857116359379907606001950938285454250989\n    assert((1852673427797059126777135760139006525652319754650249024631321344126610074238976_nat\n        * 1852673427797059126777135760139006525652319754650249024631321344126610074238976_nat)\n        % 7237005577332262213973186563042994240857116359379907606001950938285454250989_nat\n        == rr_stored);\n}",
      "start_line": 21,
      "end_line": 50,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_5_terms().",
      "display_name": "lemma_mul_distributive_5_terms",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_5_terms().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_mul_distributive_5_terms(n: int, x1: int, x2: int, x3: int, x4: int, x5: int)\n    ensures\n        n * (x1 + x2 + x3 + x4 + x5) == (x1 + x2 + x3 + x4 + x5) * n == n * x1 + n * x2 + n * x3 + n\n            * x4 + n * x5,\n{\n    assert(n * (x1 + x2 + x3 + x4 + x5) == (x1 + x2 + x3 + x4 + x5) * n) by {\n        lemma_mul_is_commutative(n, x1 + x2 + x3 + x4 + x5);\n    }\n\n    assert(n * (x1 + x2 + x3 + x4 + x5) == n * (x1 + x2 + x3 + x4) + n * x5) by {\n        lemma_mul_is_distributive_add(n, x1 + x2 + x3 + x4, x5);\n    }\n\n    assert(n * (x1 + x2 + x3 + x4) == n * x1 + n * x2 + n * x3 + n * x4) by {\n        lemma_mul_distributive_4_terms(n, x1, x2, x3, x4);\n    }\n}",
      "start_line": 87,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01234().",
      "display_name": "lemma_from_bytes_as_nat_01234",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01234().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_from_bytes_as_nat_01234(bytes: &[u8; 32])\n    ensures\n        (spec_load8_at(bytes, 0) as u64 & mask51) + pow2(51) * ((spec_load8_at(bytes, 6) as u64\n            >> 3) & mask51) + pow2(102) * ((spec_load8_at(bytes, 12) as u64 >> 6) & mask51) + pow2(\n            153,\n        ) * ((spec_load8_at(bytes, 19) as u64 >> 1) & mask51) + pow2(204) * ((spec_load8_at(\n            bytes,\n            24,\n        ) as u64 >> 12) & mask51) == (bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (bytes[2]\n            * pow2(2 * 8)) + (bytes[3] * pow2(3 * 8)) + (bytes[4] * pow2(4 * 8)) + (bytes[5] * pow2(\n            5 * 8,\n        )) + (bytes[6] * pow2(6 * 8)) + (bytes[7] * pow2(7 * 8)) + (bytes[8] * pow2(8 * 8)) + (\n        bytes[9] * pow2(9 * 8)) + (bytes[10] * pow2(10 * 8)) + (bytes[11] * pow2(11 * 8)) + (\n        bytes[12] * pow2(12 * 8)) + (bytes[13] * pow2(13 * 8)) + (bytes[14] * pow2(14 * 8)) + (\n        bytes[15] * pow2(15 * 8)) + (bytes[16] * pow2(16 * 8)) + (bytes[17] * pow2(17 * 8)) + (\n        bytes[18] * pow2(18 * 8)) + (bytes[19] * pow2(19 * 8)) + (bytes[20] * pow2(20 * 8)) + (\n        bytes[21] * pow2(21 * 8)) + (bytes[22] * pow2(22 * 8)) + (bytes[23] * pow2(23 * 8)) + (\n        bytes[24] * pow2(24 * 8)) + (bytes[25] * pow2(25 * 8)) + (bytes[26] * pow2(26 * 8)) + (\n        bytes[27] * pow2(27 * 8)) + (bytes[28] * pow2(28 * 8)) + (bytes[29] * pow2(29 * 8)) + (\n        bytes[30] * pow2(30 * 8)) + ((bytes[31] as nat % pow2(7)) * pow2((31 * 8) as nat)),\n{\n    assert((spec_load8_at(bytes, 0) as u64 & mask51) + pow2(51) * ((spec_load8_at(bytes, 6) as u64\n        >> 3) & mask51) + pow2(102) * ((spec_load8_at(bytes, 12) as u64 >> 6) & mask51) + pow2(153)\n        * ((spec_load8_at(bytes, 19) as u64 >> 1) & mask51) == (bytes[0] * pow2(0 * 8)) + (bytes[1]\n        * pow2(1 * 8)) + (bytes[2] * pow2(2 * 8)) + (bytes[3] * pow2(3 * 8)) + (bytes[4] * pow2(\n        4 * 8,\n    )) + (bytes[5] * pow2(5 * 8)) + (bytes[6] * pow2(6 * 8)) + (bytes[7] * pow2(7 * 8)) + (bytes[8]\n        * pow2(8 * 8)) + (bytes[9] * pow2(9 * 8)) + (bytes[10] * pow2(10 * 8)) + (bytes[11] * pow2(\n        11 * 8,\n    )) + (bytes[12] * pow2(12 * 8)) + (bytes[13] * pow2(13 * 8)) + (bytes[14] * pow2(14 * 8)) + (\n    bytes[15] * pow2(15 * 8)) + (bytes[16] * pow2(16 * 8)) + (bytes[17] * pow2(17 * 8)) + (bytes[18]\n        * pow2(18 * 8)) + (bytes[19] * pow2(19 * 8)) + (bytes[20] * pow2(20 * 8)) + (bytes[21]\n        * pow2(21 * 8)) + (bytes[22] * pow2(22 * 8)) + (bytes[23] * pow2(23 * 8)) + (bytes[24]\n        * pow2(24 * 8)) + ((bytes[25] as nat % pow2(4)) * pow2((25 * 8) as nat))) by {\n        lemma_from_bytes_as_nat_0123(bytes);\n    }\n\n    assert(((spec_load8_at(bytes, 24) as u64) >> 12) & mask51 == (bytes[25] as nat / pow2(4)) + (\n    bytes[26] * pow2((2 * 8 - 12) as nat)) + (bytes[27] * pow2((3 * 8 - 12) as nat)) + (bytes[28]\n        * pow2((4 * 8 - 12) as nat)) + (bytes[29] * pow2((5 * 8 - 12) as nat)) + (bytes[30] * pow2(\n        (6 * 8 - 12) as nat,\n    )) + ((bytes[31] as nat % pow2(7)) * pow2((7 * 8 - 12) as nat))) by {\n        lemma_load8_at_limb4(bytes);\n    }\n\n    assert(pow2(204) * (((spec_load8_at(bytes, 24) as u64) >> 12) & mask51) == pow2(204) * (\n    bytes[25] as nat / pow2(4)) + pow2(204) * (bytes[26] * pow2((2 * 8 - 12) as nat)) + pow2(204)\n        * (bytes[27] * pow2((3 * 8 - 12) as nat)) + pow2(204) * (bytes[28] * pow2(\n        (4 * 8 - 12) as nat,\n    )) + pow2(204) * (bytes[29] * pow2((5 * 8 - 12) as nat)) + pow2(204) * (bytes[30] * pow2(\n        (6 * 8 - 12) as nat,\n    )) + pow2(204) * ((bytes[31] as nat % pow2(7)) * pow2((7 * 8 - 12) as nat))) by {\n        lemma_mul_distributive_7_terms(\n            pow2(204) as int,\n            (bytes[25] as nat / pow2(4)) as int,\n            (bytes[26] * pow2((2 * 8 - 12) as nat)) as int,\n            (bytes[27] * pow2((3 * 8 - 12) as nat)) as int,\n            (bytes[28] * pow2((4 * 8 - 12) as nat)) as int,\n            (bytes[29] * pow2((5 * 8 - 12) as nat)) as int,\n            (bytes[30] * pow2((6 * 8 - 12) as nat)) as int,\n            ((bytes[31] as nat % pow2(7)) * pow2((7 * 8 - 12) as nat)) as int,\n        );\n    }\n\n    assert(((bytes[25] as nat % pow2(4)) * pow2((25 * 8) as nat)) + pow2(204) * (bytes[25] as nat\n        / pow2(4)) == bytes[25] * pow2(25 * 8)) by {\n        lemma_assemble_mod_div(bytes[25] as nat, 4, 25 * 8)\n    }\n\n    assert(pow2(204) * (bytes[26] * pow2((2 * 8 - 12) as nat)) + pow2(204) * (bytes[27] * pow2(\n        (3 * 8 - 12) as nat,\n    )) + pow2(204) * (bytes[28] * pow2((4 * 8 - 12) as nat)) + pow2(204) * (bytes[29] * pow2(\n        (5 * 8 - 12) as nat,\n    )) + pow2(204) * (bytes[30] * pow2((6 * 8 - 12) as nat)) + pow2(204) * ((bytes[31] as nat\n        % pow2(7)) * pow2((7 * 8 - 12) as nat)) == (bytes[26] * pow2(26 * 8)) + (bytes[27] * pow2(\n        27 * 8,\n    )) + (bytes[28] * pow2(28 * 8)) + (bytes[29] * pow2(29 * 8)) + (bytes[30] * pow2(30 * 8)) + ((\n    bytes[31] as nat % pow2(7)) * pow2((31 * 8) as nat))) by {\n        lemma_assemble_pow_a_pow(bytes[26] as nat, 24, 2, 12);\n        lemma_assemble_pow_a_pow(bytes[27] as nat, 24, 3, 12);\n        lemma_assemble_pow_a_pow(bytes[28] as nat, 24, 4, 12);\n        lemma_assemble_pow_a_pow(bytes[29] as nat, 24, 5, 12);\n        lemma_assemble_pow_a_pow(bytes[30] as nat, 24, 6, 12);\n        lemma_assemble_pow_a_pow(bytes[31] as nat % pow2(7), 24, 7, 12);\n    }\n}",
      "start_line": 310,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_flipped_sign_becomes_correct().",
      "display_name": "lemma_flipped_sign_becomes_correct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_flipped_sign_becomes_correct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "file_name": "sqrt_ratio_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_flipped_sign_becomes_correct(u: nat, v: nat, r: nat)\n    requires\n        (v * r * r) % p() == ((p() as int - (u % p()) as int) % p() as int) as nat,\n    ensures\n        ({ let r_prime = (r * spec_sqrt_m1()) % p(); (v * r_prime * r_prime) % p() == u % p() }),\n{\n    use crate::lemmas::common_lemmas::div_mod_lemmas::{\n        lemma_mul_distributes_over_neg_mod,\n        lemma_double_neg_mod,\n    };\n    \n    pow255_gt_19();\n    let pn = p();\n    let r2 = r * r;\n    let ri = r * spec_sqrt_m1();\n    let r_prime = ri % pn;\n    let r_prime_sq = r_prime * r_prime;\n    \n    // === Step 1: (r·i)² % p = -r² % p ===\n    lemma_multiply_by_i_flips_sign(r);\n    let neg_r2 = ((pn as int - (r2 % pn) as int) % (pn as int)) as nat;\n    \n    // Bridge: ((ri%p) * ri) % p = ((ri%p) * (ri%p)) % p  [mod absorption]\n    assert(((ri % pn) * ri) % pn == ((ri % pn) * (ri % pn)) % pn) by {\n        lemma_mul_mod_noop_right((ri % pn) as int, ri as int, pn as int);\n    };\n    \n    // Connect: r_prime_sq % p = neg_r2\n    assert(r_prime_sq % pn == neg_r2) by {\n        assert((((ri % pn) * ri) % pn) % pn == neg_r2);\n        lemma_mod_twice(((ri % pn) * ri) as int, pn as int);\n        assert(((ri % pn) * ri) % pn == neg_r2);\n        lemma_mul_mod_noop_right((ri % pn) as int, ri as int, pn as int);\n        assert(((ri % pn) * (ri % pn)) % pn == neg_r2);\n    };\n    \n    // === Step 2: v * r * r = v * r2 ===\n    assert((v * r * r) == (v * r2)) by {\n        lemma_mul_is_associative(v as int, r as int, r as int);\n    };\n    \n    // From precondition: (v * r2) % p = neg_u\n    let neg_u = ((pn as int - (u % pn) as int) % (pn as int)) as nat;\n    assert((v * r2) % pn == neg_u);\n    \n    // === Step 3: v * neg_r2 % p = neg(v*r2) % p ===\n    let r2_mod = r2 % pn;\n    lemma_mod_bound(r2 as int, pn as int);\n    \n    assert(pn > 1) by { p_gt_2(); };\n    \n    assert((v * neg_r2) % pn == ((pn - (v * r2) % pn) as nat) % pn) by {\n        if r2_mod > 0 {\n            assert(neg_r2 == (pn - r2_mod) as nat) by {\n                lemma_small_mod((pn - r2_mod) as nat, pn);\n            };\n            lemma_mul_distributes_over_neg_mod(v, r2, pn);\n        } else {\n            assert(neg_r2 == 0) by {\n                assert(r2_mod == 0);\n                lemma_mod_self_0(pn as int);\n            };\n            assert(v * neg_r2 == 0) by { lemma_mul_basics(v as int); };\n            assert((v * neg_r2) % pn == 0) by { lemma_small_mod(0nat, pn); };\n            assert((v * r2) % pn == 0) by {\n                lemma_mul_mod_noop_right(v as int, r2 as int, pn as int);\n                assert((v * 0) % pn == 0) by {\n                    lemma_mul_basics(v as int);\n                    lemma_small_mod(0nat, pn);\n                };\n            };\n            assert(((pn - 0nat) as nat) % pn == 0) by {\n                lemma_mod_self_0(pn as int);\n            };\n        }\n    };\n    \n    // === Step 4: neg(neg_u) % p = u % p [double negation] ===\n    let u_mod = u % pn;\n    lemma_mod_bound(u as int, pn as int);\n    \n    assert(((pn - neg_u) as nat) % pn == u_mod) by {\n        if u_mod > 0 {\n            assert(neg_u == (pn - u_mod) as nat) by {\n                lemma_small_mod((pn - u_mod) as nat, pn);\n            };\n            lemma_double_neg_mod(u_mod, pn);\n        } else {\n            assert(neg_u == 0) by { lemma_mod_self_0(pn as int); };\n            assert(((pn - 0nat) as nat) % pn == 0) by { lemma_mod_self_0(pn as int); };\n        }\n    };\n    \n    // === Step 5: Connect v * r_prime_sq to v * r_prime * r_prime ===\n    assert((v * r_prime * r_prime) % pn == (v * r_prime_sq) % pn) by {\n        lemma_mul_is_associative(v as int, r_prime as int, r_prime as int);\n    };\n    \n    // === Step 6: Chain everything together ===\n    assert((v * r_prime_sq) % pn == (v * neg_r2) % pn) by {\n        lemma_mul_mod_noop_right(v as int, r_prime_sq as int, pn as int);\n    };\n}",
      "start_line": 762,
      "end_line": 48,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_seq_eq_implies_array_eq().",
      "display_name": "lemma_seq_eq_implies_array_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_seq_eq_implies_array_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/as_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/as_bytes_lemmas.rs",
      "file_name": "as_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_seq_eq_implies_array_eq(bytes1: &[u8; 32], bytes2: &[u8; 32])\n    requires\n        seq_from32(bytes1) == seq_from32(bytes2),\n    ensures\n        *bytes1 == *bytes2,\n{\n    // If seq representations are equal, then they're equal element-wise\n    // seq_from32 is defined as Seq::new(32, |i: int| b[i])\n    // So if the sequences are equal, each element must be equal\n    assert forall|i: int| 0 <= i < 32 implies bytes1[i] == bytes2[i] by {\n        // From the definition of seq_from32, we have:\n        // seq_from32(bytes1)[i] == bytes1[i]\n        // seq_from32(bytes2)[i] == bytes2[i]\n        // Since seq_from32(bytes1) == seq_from32(bytes2), we get:\n        // bytes1[i] == bytes2[i]\n        assert(seq_from32(bytes1)[i] == bytes1[i]);\n        assert(seq_from32(bytes2)[i] == bytes2[i]);\n        assert(seq_from32(bytes1)[i] == seq_from32(bytes2)[i]);\n    }\n    // Verus axiom: arrays are equal iff all elements are equal\n    assert(*bytes1 == *bytes2);\n}",
      "start_line": 342,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_pow_a_pow().",
      "display_name": "lemma_assemble_pow_a_pow",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_pow_a_pow().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_assemble_pow_a_pow(a: nat, j: nat, k: nat, l: nat)\n    requires\n        k * 8 > l,\n    ensures\n        pow2(j * 8 + l) * (a * pow2((k * 8 - l) as nat)) == a * pow2((j + k) * 8),\n{\n    let d = (k * 8 - l) as nat;\n    let dd = j * 8 + l;\n    let pjl = pow2(j * 8 + l);\n\n    assert(pjl * (a * pow2(d)) == (a * pow2(d)) * pjl) by {\n        lemma_mul_is_commutative(pjl as int, a * pow2(d) as int);\n    }\n\n    assert((a * pow2(d)) * pjl == a * pow2(d + dd)) by {\n        lemma_mul_is_associative(a as int, pow2(d) as int, pjl as int);\n        lemma_pow2_adds(d, dd);\n    }\n\n    assert(d + dd == (j + k) * 8) by {\n        assert((j + k) * 8 == j * 8 + k * 8) by {\n            lemma_mul_is_distributive_add_other_way(8, d as int, dd as int);\n        }\n    }\n}",
      "start_line": 55,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_correctness().",
      "display_name": "lemma_invert_correctness",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_correctness().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "file_name": "invert_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_invert_correctness(\n    self_fe: &FieldElement51,\n    t19: &FieldElement51,\n    t3: &FieldElement51,\n    t20: &FieldElement51,\n    t21: &FieldElement51,\n)\n    requires\n// Postconditions from pow22501\n\n        spec_field_element(t19) == (pow(\n            spec_field_element(self_fe) as int,\n            (pow2(250) - 1) as nat,\n        ) as nat) % p(),\n        spec_field_element(t3) == (pow(spec_field_element(self_fe) as int, 11) as nat) % p(),\n        // Postcondition from pow2k(5) - using the actual form from pow2k\n        u64_5_as_nat(t20.limbs) % p() == (pow(u64_5_as_nat(t19.limbs) as int, pow2(5)) as nat)\n            % p(),\n        // Postcondition from mul\n        spec_field_element(t21) == math_field_mul(spec_field_element(t20), spec_field_element(t3)),\n    ensures\n// If self is non-zero, t21 is the multiplicative inverse\n\n        spec_field_element(self_fe) != 0 ==> (spec_field_element(t21) * spec_field_element(self_fe))\n            % p() == 1,\n        // If self is zero, t21 is zero\n        spec_field_element(self_fe) == 0 ==> spec_field_element(t21) == 0,\n        // t21 equals math_field_inv\n        spec_field_element(t21) == math_field_inv(spec_field_element(self_fe)),\n{\n    // Case 1: When self is zero, prove that t21 is zero\n    if spec_field_element(self_fe) == 0 {\n        assert(spec_field_element(t21) == 0) by {\n            lemma_invert_zero_case(self_fe, t3, t20, t21);\n        }\n    }\n    // Case 2: When self is non-zero, prove that t21 is the multiplicative inverse\n\n    if spec_field_element(self_fe) != 0 {\n        assert((spec_field_element(t21) * spec_field_element(self_fe)) % p() == 1) by {\n            lemma_invert_exponent_arithmetic();\n            lemma_invert_is_multiplicative_inverse(self_fe, t19, t20, t3, t21);\n        }\n    }\n    // Prove that t21 equals the mathematical field inverse\n\n    assert(spec_field_element(t21) == math_field_inv(spec_field_element(self_fe))) by {\n        lemma_invert_equals_math_field_inv(self_fe, t21);\n    }\n}",
      "start_line": 467,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_nine_limbs_equals_slice128_to_nat().",
      "display_name": "lemma_nine_limbs_equals_slice128_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_nine_limbs_equals_slice128_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_nine_limbs_equals_slice128_to_nat(limbs: &[u128; 9])\n    ensures\n        nine_limbs_to_nat_aux(limbs) == slice128_to_nat(limbs),\n{\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        slice128_to_nat(limbs); {}\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 10);\n        }\n        (limbs[0] as nat) + ((limbs[1] as nat) + ((limbs[2] as nat) + ((limbs[3] as nat) + ((\n        limbs[4] as nat) + ((limbs[5] as nat) + ((limbs[6] as nat) + ((limbs[7] as nat) + (\n        limbs[8] as nat) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52))\n            * pow2(52)) * pow2(52); {\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(104, 52);\n            lemma_pow2_adds(156, 52);\n            lemma_pow2_adds(208, 52);\n            lemma_pow2_adds(260, 52);\n            lemma_pow2_adds(312, 52);\n            lemma_pow2_adds(364, 52);\n            broadcast use group_mul_is_distributive;\n            broadcast use lemma_mul_is_associative;\n\n        }\n        nine_limbs_to_nat_aux(limbs);\n    }\n}",
      "start_line": 174,
      "end_line": 53,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "display_name": "montgomery_radix",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn montgomery_radix() -> nat {\n    pow2(260)\n}",
      "start_line": 197,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 18,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "display_name": "is_prime",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/primality_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/primality_specs.rs",
      "file_name": "primality_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_prime(n: nat) -> bool {\n    n > 1 && forall|d: nat| 1 < d < n ==> #[trigger] (n % d) != 0\n}",
      "start_line": 12,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 17,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_boundaries().",
      "display_name": "lemma_reduce_boundaries",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_boundaries().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/reduce_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/reduce_lemmas.rs",
      "file_name": "reduce_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_reduce_boundaries(limbs: [u64; 5])\n    ensures\n        ((limbs[0] & mask51) + (limbs[4] >> 51) * 19) < (1u64 << 52),\n        ((limbs[1] & mask51) + (limbs[0] >> 51)) < (1u64 << 52),\n        ((limbs[2] & mask51) + (limbs[1] >> 51)) < (1u64 << 52),\n        ((limbs[3] & mask51) + (limbs[2] >> 51)) < (1u64 << 52),\n        ((limbs[4] & mask51) + (limbs[3] >> 51)) < (1u64 << 52),\n{\n    // \\A i. limbs[i] < 2^13\n    lemma_shifted_lt(limbs[0], 51);\n    lemma_shifted_lt(limbs[1], 51);\n    lemma_shifted_lt(limbs[2], 51);\n    lemma_shifted_lt(limbs[3], 51);\n    lemma_shifted_lt(limbs[4], 51);\n\n    // \\A i. limbs[i] & mask51 < 2^51\n    lemma_masked_lt_51(limbs[0]);\n    lemma_masked_lt_51(limbs[1]);\n    lemma_masked_lt_51(limbs[2]);\n    lemma_masked_lt_51(limbs[3]);\n    lemma_masked_lt_51(limbs[4]);\n\n    // Since 19 < 2^5 and (limbs[4] >> 51) < 2^13, their product is less than 2^18\n    assert((limbs[4] >> 51) * 19 < (1u64 << 18) as nat) by {\n        assert(19 < (1u64 << 5)) by (bit_vector);\n        lemma_shift_is_pow2(5);\n        lemma_shift_is_pow2(13);\n        lemma_shift_is_pow2(18);\n        lemma_pow2_adds(13, 5);\n        // If (limbs[4] >> 51) < 2^13 and 19 < 2^5 then their product is less than 2^18\n        lemma_mul_lt((limbs[4] >> 51) as nat, (1u64 << 13) as nat, 19nat, (1u64 << 5) as nat);\n    }\n\n    // The final values (limbs[i] += cX) are all bounded by 2^51 + eps, for eps \\in {2^18, 2^13}.\n    assert(((1u64 << 18)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n    assert(((1u64 << 13)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n\n    // In summary, they're all bounded by 2^52\n    // The solver can prove this automatically\n}",
      "start_line": 25,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "display_name": "into",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "display_name": "compress",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn compress(&self) -> (result: CompressedEdwardsY)\n        requires\n            edwards_point_limbs_bounded(*self),\n        ensures\n            compressed_edwards_y_corresponds_to_edwards(result, *self),\n    {\n        let recip = self.Z.invert();\n        let ghost z_abs = spec_field_element(&self.Z);\n        assert(spec_field_element(&recip) == math_field_inv(z_abs));\n        assume(false);\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        let mut s: [u8; 32];\n\n        s = y.as_bytes();\n        s[31] ^= x.is_negative().unwrap_u8() << 7;\n        CompressedEdwardsY(s)\n    }",
      "start_line": 1224,
      "end_line": 20,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_012().",
      "display_name": "lemma_from_bytes_as_nat_012",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_012().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_from_bytes_as_nat_012(bytes: &[u8; 32])\n    ensures\n        (spec_load8_at(bytes, 0) as u64 & mask51) + pow2(51) * ((spec_load8_at(bytes, 6) as u64\n            >> 3) & mask51) + pow2(102) * ((spec_load8_at(bytes, 12) as u64 >> 6) & mask51) == (\n        bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (bytes[2] * pow2(2 * 8)) + (bytes[3]\n            * pow2(3 * 8)) + (bytes[4] * pow2(4 * 8)) + (bytes[5] * pow2(5 * 8)) + (bytes[6] * pow2(\n            6 * 8,\n        )) + (bytes[7] * pow2(7 * 8)) + (bytes[8] * pow2(8 * 8)) + (bytes[9] * pow2(9 * 8)) + (\n        bytes[10] * pow2(10 * 8)) + (bytes[11] * pow2(11 * 8)) + (bytes[12] * pow2(12 * 8)) + (\n        bytes[13] * pow2(13 * 8)) + (bytes[14] * pow2(14 * 8)) + (bytes[15] * pow2(15 * 8)) + (\n        bytes[16] * pow2(16 * 8)) + (bytes[17] * pow2(17 * 8)) + (bytes[18] * pow2(18 * 8)) + ((\n        bytes[19] as nat % pow2(1)) * pow2((19 * 8) as nat)),\n{\n    assert((spec_load8_at(bytes, 0) as u64 & mask51) + pow2(51) * ((spec_load8_at(bytes, 6) as u64\n        >> 3) & mask51) == (bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (bytes[2] * pow2(\n        2 * 8,\n    )) + (bytes[3] * pow2(3 * 8)) + (bytes[4] * pow2(4 * 8)) + (bytes[5] * pow2(5 * 8)) + (bytes[6]\n        * pow2(6 * 8)) + (bytes[7] * pow2(7 * 8)) + (bytes[8] * pow2(8 * 8)) + (bytes[9] * pow2(\n        9 * 8,\n    )) + (bytes[10] * pow2(10 * 8)) + (bytes[11] * pow2(11 * 8)) + ((bytes[12] as nat % pow2(6))\n        * pow2((12 * 8) as nat))) by {\n        lemma_from_bytes_as_nat_01(bytes);\n    }\n\n    assert(((spec_load8_at(bytes, 12) as u64) >> 6) & mask51 == (bytes[12] as nat / pow2(6)) + (\n    bytes[13] * pow2((1 * 8 - 6) as nat)) + (bytes[14] * pow2((2 * 8 - 6) as nat)) + (bytes[15]\n        * pow2((3 * 8 - 6) as nat)) + (bytes[16] * pow2((4 * 8 - 6) as nat)) + (bytes[17] * pow2(\n        (5 * 8 - 6) as nat,\n    )) + (bytes[18] * pow2((6 * 8 - 6) as nat)) + ((bytes[19] as nat % pow2(1)) * pow2(\n        (7 * 8 - 6) as nat,\n    ))) by {\n        lemma_load8_at_limb2(bytes);\n    }\n\n    assert(pow2(102) * ((spec_load8_at(bytes, 12) as u64 >> 6) & mask51) == pow2(102) * (\n    bytes[12] as nat / pow2(6)) + pow2(102) * (bytes[13] * pow2((1 * 8 - 6) as nat)) + pow2(102) * (\n    bytes[14] * pow2((2 * 8 - 6) as nat)) + pow2(102) * (bytes[15] * pow2((3 * 8 - 6) as nat))\n        + pow2(102) * (bytes[16] * pow2((4 * 8 - 6) as nat)) + pow2(102) * (bytes[17] * pow2(\n        (5 * 8 - 6) as nat,\n    )) + pow2(102) * (bytes[18] * pow2((6 * 8 - 6) as nat)) + pow2(102) * ((bytes[19] as nat % pow2(\n        1,\n    )) * pow2((7 * 8 - 6) as nat))) by {\n        lemma_mul_distributive_8_terms(\n            pow2(102) as int,\n            (bytes[12] as nat / pow2(6)) as int,\n            (bytes[13] * pow2((1 * 8 - 6) as nat)) as int,\n            (bytes[14] * pow2((2 * 8 - 6) as nat)) as int,\n            (bytes[15] * pow2((3 * 8 - 6) as nat)) as int,\n            (bytes[16] * pow2((4 * 8 - 6) as nat)) as int,\n            (bytes[17] * pow2((5 * 8 - 6) as nat)) as int,\n            (bytes[18] * pow2((6 * 8 - 6) as nat)) as int,\n            ((bytes[19] as nat % pow2(1)) * pow2((7 * 8 - 6) as nat)) as int,\n        );\n    }\n\n    assert(((bytes[12] as nat % pow2(6)) * pow2((12 * 8) as nat)) + pow2(102) * (bytes[12] as nat\n        / pow2(6)) == bytes[12] * pow2(12 * 8)) by {\n        lemma_assemble_mod_div(bytes[12] as nat, 6, 12 * 8);\n    }\n\n    assert(pow2(102) * (bytes[13] * pow2((1 * 8 - 6) as nat)) + pow2(102) * (bytes[14] * pow2(\n        (2 * 8 - 6) as nat,\n    )) + pow2(102) * (bytes[15] * pow2((3 * 8 - 6) as nat)) + pow2(102) * (bytes[16] * pow2(\n        (4 * 8 - 6) as nat,\n    )) + pow2(102) * (bytes[17] * pow2((5 * 8 - 6) as nat)) + pow2(102) * (bytes[18] * pow2(\n        (6 * 8 - 6) as nat,\n    )) + pow2(102) * ((bytes[19] as nat % pow2(1)) * pow2((7 * 8 - 6) as nat)) == (bytes[13] * pow2(\n        13 * 8,\n    )) + (bytes[14] * pow2(14 * 8)) + (bytes[15] * pow2(15 * 8)) + (bytes[16] * pow2(16 * 8)) + (\n    bytes[17] * pow2(17 * 8)) + (bytes[18] * pow2(18 * 8)) + ((bytes[19] as nat % pow2(1)) * pow2(\n        (19 * 8) as nat,\n    ))) by {\n        lemma_assemble_pow_a_pow(bytes[13] as nat, 12, 1, 6);\n        lemma_assemble_pow_a_pow(bytes[14] as nat, 12, 2, 6);\n        lemma_assemble_pow_a_pow(bytes[15] as nat, 12, 3, 6);\n        lemma_assemble_pow_a_pow(bytes[16] as nat, 12, 4, 6);\n        lemma_assemble_pow_a_pow(bytes[17] as nat, 12, 5, 6);\n        lemma_assemble_pow_a_pow(bytes[18] as nat, 12, 6, 6);\n        lemma_assemble_pow_a_pow(bytes[19] as nat % pow2(1), 12, 7, 6);\n    }\n}",
      "start_line": 147,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_wide_to_nat_rec().",
      "display_name": "bytes_wide_to_nat_rec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_wide_to_nat_rec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn bytes_wide_to_nat_rec(bytes: &[u8; 64], index: int) -> nat\n    decreases 64 - index,\n{\n    if index >= 64 {\n        0\n    } else {\n        (bytes[index] as nat) * pow2((index * 8) as nat) + bytes_wide_to_nat_rec(bytes, index + 1)\n    }\n}",
      "start_line": 81,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Neg#neg().",
      "display_name": "neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Neg#neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn neg(self) -> AffineNielsPoint {\n        AffineNielsPoint {\n            y_plus_x: self.y_minus_x,\n            y_minus_x: self.y_plus_x,\n            xy2d: -(&self.xy2d),\n        }\n    }",
      "start_line": 855,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_p_mod_8_eq_5().",
      "display_name": "lemma_p_mod_8_eq_5",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_p_mod_8_eq_5().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_p_mod_8_eq_5()\n    ensures p() % 8 == 5,\n{\n    pow255_gt_19();\n    \n    // Step 1: 2^3 = 8 (revealed via lemma2_to64)\n    lemma2_to64();\n    assert(pow2(3) == 8);\n    \n    // Step 2: 2^255 = 2^3 · 2^252\n    assert(pow2(255) == pow2(3) * pow2(252)) by {\n        lemma_pow2_adds(3, 252);\n    };\n    \n    // Step 3: 2^255 ≡ 0 (mod 8) since 2^255 = 8 · 2^252\n    assert(pow2(255) % 8 == 0) by {\n        lemma_mul_mod_noop_left(pow2(3) as int, pow2(252) as int, 8int);\n    };\n    \n    // Step 4: 19 ≡ 3 (mod 8)\n    assert(19int % 8 == 3) by (compute);\n    \n    // Step 5: p = 2^255 - 19 ≡ 0 - 3 ≡ -3 (mod 8)\n    assert((pow2(255) as int - 19) % 8 == (-3int) % 8) by {\n        lemma_sub_mod_noop(pow2(255) as int, 19int, 8int);\n    };\n    \n    // Step 6: -3 ≡ 5 (mod 8)\n    assert((-3int) % 8 == 5) by (compute);\n}",
      "start_line": 1859,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_or().",
      "display_name": "choice_or",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_or().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn choice_or(a: Choice, b: Choice) -> (c: Choice)\n    ensures\n        choice_is_true(c) == (choice_is_true(a) || choice_is_true(b)),\n{\n    use core::ops::BitOr;\n    a.bitor(b)\n}",
      "start_line": 141,
      "end_line": 17,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_fourth_roots_are_exactly_four().",
      "display_name": "lemma_fourth_roots_are_exactly_four",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_fourth_roots_are_exactly_four().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/unused_sqrt_ratio_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/unused_sqrt_ratio_lemmas.rs",
      "file_name": "unused_sqrt_ratio_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_fourth_roots_are_exactly_four()\n    ensures forall|x: nat| is_fourth_root_of_unity(x) ==> is_one_of_fourth_roots(x),\n{\n    // x^4 - 1 has exactly 4 roots over F_p\n    assume(forall|x: nat| is_fourth_root_of_unity(x) ==> is_one_of_fourth_roots(x));\n}",
      "start_line": 87,
      "end_line": 49,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_cancellation().",
      "display_name": "lemma_fermat_cancellation",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_cancellation().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "proof fn lemma_fermat_cancellation(a: nat, n: nat, p: nat)\n    requires\n        is_prime(p),\n        a % p != 0,\n        n == (p - 1) as nat,\n        ((a as int) * pow(a as int, n)) % (p as int) == (a as int) % (p as int),\n    ensures\n        (pow(a as int, n) as nat) % p == 1,\n{\n    // a * a^n ≡ a (mod p)\n    // a * (a^n - 1) ≡ 0 (mod p)\n    // Since p is prime and a % p != 0, by Euclid's lemma: (a^n - 1) % p == 0\n    // So a^n ≡ 1 (mod p)\n    // First, show pow(a, n) >= 1 (since a > 0 and n >= 0, and a % p != 0 means a > 0)\n    assert(a > 0) by {\n        if a == 0 {\n            lemma_small_mod(0nat, p);\n        }\n    };\n\n    assert(pow(a as int, n) >= 1) by {\n        lemma_pow_positive(a as int, n);\n    };\n\n    // a * a^n = a * a^(p-1) = a^p\n    // We have a^p ≡ a (mod p)\n    // So a * a^(p-1) ≡ a (mod p)\n\n    // (a * a^n) % p == a % p\n    // (a * a^n - a) % p == 0\n    // a * (a^n - 1) % p == 0\n\n    let pow_n = pow(a as int, n);\n\n    // a * pow_n - a = a * (pow_n - 1)\n    assert((a as int) * pow_n - (a as int) == (a as int) * (pow_n - 1)) by {\n        lemma_mul_is_distributive_sub(a as int, pow_n, 1);\n    };\n\n    // ((a * pow_n) - a) % p == 0\n    // because (a * pow_n) % p == a % p\n    assert(((a as int) * pow_n - (a as int)) % (p as int) == 0) by {\n        // (a * pow_n) % p == a % p\n        // ((a * pow_n) - a) % p == (a % p - a % p) % p == 0\n        // Actually we need: if x % p == y % p then (x - y) % p == 0\n        lemma_mod_sub_eq_implies_zero((a as int) * pow_n, a as int, p as int);\n    };\n\n    // So (a * (pow_n - 1)) % p == 0\n    assert(((a as int) * (pow_n - 1)) % (p as int) == 0);\n\n    // By Euclid's lemma: a % p == 0 or (pow_n - 1) % p == 0\n    // Since a % p != 0, we have (pow_n - 1) % p == 0\n\n    // But we need to be careful: Euclid's lemma works with naturals\n    // pow_n >= 1, so pow_n - 1 >= 0\n\n    if (pow_n - 1) % (p as int) != 0 {\n        // Then a % p == 0 by Euclid\n        // pow_n - 1 >= 0, so we can treat it as nat\n        let diff = (pow_n - 1) as nat;\n        // a * diff % p == 0\n        // But diff % p != 0 (we're assuming)\n        // So a % p == 0 by Euclid\n        lemma_euclid_prime(a, diff, p);\n        // This gives a % p == 0 or diff % p == 0\n        // Since diff % p != 0, we get a % p == 0\n        // But a % p != 0 by precondition, contradiction\n    }\n    // (pow_n - 1) % p == 0 means pow_n % p == 1\n\n    assert(pow_n % (p as int) == 1) by {\n        // pow_n = (pow_n - 1) + 1\n        // pow_n % p = ((pow_n - 1) + 1) % p = (0 + 1) % p = 1\n        lemma_mod_adds(pow_n - 1, 1, p as int);\n        lemma_small_mod(1nat, p);\n    };\n}",
      "start_line": 670,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_to_extended().",
      "display_name": "spec_completed_to_extended",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_to_extended().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_completed_to_extended(\n    point: crate::backend::serial::curve_models::CompletedPoint,\n) -> (nat, nat, nat, nat) {\n    let (x, y, z, t) = spec_completed_point(point);\n    (math_field_mul(x, t), math_field_mul(y, z), math_field_mul(z, t), math_field_mul(x, y))\n}",
      "start_line": 702,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits().",
      "display_name": "determine_curve25519_dalek_bits",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "curve25519-dalek/build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "body": "    pub(super) fn determine_curve25519_dalek_bits(target_arch: &String) -> DalekBits {\n        let target_pointer_width = match std::env::var(\"CARGO_CFG_TARGET_POINTER_WIDTH\") {\n            Ok(pw) => pw,\n            Err(_) => {\n                determine_curve25519_dalek_bits_warning(ERR_MSG_NO_POINTER_WIDTH);\n                return DalekBits::Dalek32;\n            }\n        };\n\n        #[allow(clippy::match_single_binding)]\n        match &target_arch {\n            //Issues: 449 and 456\n            //TODO: When adding arch defaults use proper types not String match\n            //TODO(Arm): Needs tests + benchmarks to back this up\n            //TODO(Wasm32): Needs tests + benchmarks to back this up\n            _ => match target_pointer_width.as_ref() {\n                \"64\" => DalekBits::Dalek64,\n                \"32\" => DalekBits::Dalek32,\n                // Intended default solely for non-32/64 target pointer widths\n                // Otherwise known target platforms only.\n                _ => {\n                    determine_curve25519_dalek_bits_warning(ERR_MSG_UNKNOWN_POINTER_WIDTH);\n                    DalekBits::Dalek32\n                }\n            },\n        }\n    }",
      "start_line": 98,
      "end_line": 50,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "display_name": "is_negative",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "curve25519-dalek/src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn is_negative(&self) -> (result:\n        Choice)/* VERIFICATION NOTE:\n    - DRAFT SPEC: spec_fe51_to_bytes is a complex spec function that should correspond to as_bytes()\n    - Proof uses lemma_as_bytes_equals_spec_fe51_to_bytes to connect as_bytes() with spec_fe51_to_bytes()\n    </VERIFICATION NOTE> */\n\n        ensures\n            choice_is_true(result) == (spec_fe51_to_bytes(self)[0] & 1 == 1),\n    {\n        let bytes = self.as_bytes();\n        let result = Choice::from(bytes[0] & 1);\n\n        proof {\n            // From as_bytes() postcondition: u8_32_as_nat(&bytes) == u64_5_as_nat(self.limbs) % p()\n            // Apply lemma to establish that bytes matches spec_fe51_to_bytes\n            lemma_as_bytes_equals_spec_fe51_to_bytes(self, &bytes);\n        }\n\n        result\n    }",
      "start_line": 221,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/bit_arrange().",
      "display_name": "bit_arrange",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/bit_arrange().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn bit_arrange(limbs: [u64; 5]) -> [u8; 32] {\n    let s = [\n        limbs[0] as u8,\n        (limbs[0] >> 8) as u8,\n        (limbs[0] >> 16) as u8,\n        (limbs[0] >> 24) as u8,\n        (limbs[0] >> 32) as u8,\n        (limbs[0] >> 40) as u8,\n        ((limbs[0] >> 48) | (limbs[1] << 3)) as u8,\n        (limbs[1] >> 5) as u8,\n        (limbs[1] >> 13) as u8,\n        (limbs[1] >> 21) as u8,\n        (limbs[1] >> 29) as u8,\n        (limbs[1] >> 37) as u8,\n        ((limbs[1] >> 45) | (limbs[2] << 6)) as u8,\n        (limbs[2] >> 2) as u8,\n        (limbs[2] >> 10) as u8,\n        (limbs[2] >> 18) as u8,\n        (limbs[2] >> 26) as u8,\n        (limbs[2] >> 34) as u8,\n        (limbs[2] >> 42) as u8,\n        ((limbs[2] >> 50) | (limbs[3] << 1)) as u8,\n        (limbs[3] >> 7) as u8,\n        (limbs[3] >> 15) as u8,\n        (limbs[3] >> 23) as u8,\n        (limbs[3] >> 31) as u8,\n        (limbs[3] >> 39) as u8,\n        ((limbs[3] >> 47) | (limbs[4] << 4)) as u8,\n        (limbs[4] >> 4) as u8,\n        (limbs[4] >> 12) as u8,\n        (limbs[4] >> 20) as u8,\n        (limbs[4] >> 28) as u8,\n        (limbs[4] >> 36) as u8,\n        (limbs[4] >> 44) as u8,\n    ];\n\n    s\n}",
      "start_line": 169,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_valid_branch().",
      "display_name": "lemma_decompress_valid_branch",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_valid_branch().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_decompress_valid_branch(\n    repr_bytes: &[u8; 32],\n    x_orig: nat,\n    y: nat,\n    point: &EdwardsPoint,\n)\n    requires\n        // Precondition\n        is_valid_compressed_edwards_y(repr_bytes),\n        // step_1 postconditions (as nat values)\n        y == spec_field_element_from_bytes(repr_bytes),\n        math_on_edwards_curve(x_orig, y),\n        // X is non-negative root (LSB = 0) and bounded\n        (x_orig % p()) % 2 == 0,\n        x_orig < p(),\n        // step_2 postconditions\n        spec_field_element(&point.X) == (\n            if (repr_bytes[31] >> 7) == 1 {\n                math_field_neg(x_orig)\n            } else {\n                x_orig\n            }",
      "start_line": 1288,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_select_u64().",
      "display_name": "conditional_select_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_select_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn conditional_select_u64(a: &u64, b: &u64, choice: Choice) -> (res: u64)\n    ensures\n        !choice_is_true(choice) ==> res == *a,\n        choice_is_true(choice) ==> res == *b,\n{\n    select(a, b, choice)\n}",
      "start_line": 222,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_squared().",
      "display_name": "lemma_u64_5_as_nat_squared",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_squared().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "file_name": "u64_5_as_nat_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_u64_5_as_nat_squared(v: [u64; 5])\n    ensures\n        u64_5_as_nat(v) * u64_5_as_nat(v) ==\n            pow2(8 * 51) * (v[4] * v[4]) +\n            pow2(7 * 51) * (2 * (v[3] * v[4])) +\n            pow2(6 * 51) * (v[3] * v[3] + 2 * (v[2] * v[4])) +\n            pow2(5 * 51) * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4])) +\n            pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])) +\n            pow2(3 * 51) * (2 * (v[1] * v[2]) + 2 * (v[0] * v[3])) +\n            pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] * v[2])) +\n            pow2(1 * 51) * (2 * (v[0] * v[1])) +\n                           (v[0] * v[0]),\n        // and the mod equality\n        (u64_5_as_nat(v) * u64_5_as_nat(v)) % p() ==\n            (\n                pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])) +\n                pow2(3 * 51) * (2 * (v[1] * v[2]) + 2 * (v[0] * v[3]) + 19 * (v[4] * v[4])) +\n                pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] * v[2]) + 19 * (2 * (v[3] * v[4]))) +\n                pow2(1 * 51) * (2 * (v[0] * v[1]) + 19 * (v[3] * v[3] + 2 * (v[2] * v[4]))) +\n                               (v[0] * v[0] + 19 * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4])))\n            ) as nat % p(),\n{\n    let v0 = v[0];\n    let v1 = v[1];\n    let v2 = v[2];\n    let v3 = v[3];\n    let v4 = v[4];\n\n    let s1 = pow2(1 * 51);\n    let s2 = pow2(2 * 51);\n    let s3 = pow2(3 * 51);\n    let s4 = pow2(4 * 51);\n    let s5 = pow2(5 * 51);\n    let s6 = pow2(6 * 51);\n    let s7 = pow2(7 * 51);\n    let s8 = pow2(8 * 51);\n\n    assert(s1 * s1 == s2) by { lemma_pow2_adds(51, 51) }\n    assert(s1 * s2 == s2 * s1 == s3) by { lemma_pow2_adds(51, 102) }\n    assert(s1 * s3 == s3 * s1 == s4) by { lemma_pow2_adds(51, 153) }\n    assert(s1 * s4 == s4 * s1 == s5) by { lemma_pow2_adds(51, 204) }\n    assert(s2 * s2 == s4) by { lemma_pow2_adds(102, 102) }\n    assert(s2 * s3 == s3 * s2 == s5) by { lemma_pow2_adds(102, 153) }\n    assert(s2 * s4 == s4 * s2 == s6) by { lemma_pow2_adds(102, 204) }\n    assert(s3 * s3 == s6) by { lemma_pow2_adds(153, 153) }\n    assert(s3 * s4 == s4 * s3 == s7) by { lemma_pow2_adds(153, 204) }\n    assert(s4 * s4 == s8) by { lemma_pow2_adds(204, 204) }\n\n    assert(u64_5_as_nat(v) * u64_5_as_nat(v) == v0 * u64_5_as_nat(v) + (s1 * v1) * u64_5_as_nat(v) + (s2 * v2) * u64_5_as_nat(v)\n        + (s3 * v3) * u64_5_as_nat(v) + (s4 * v4) * u64_5_as_nat(v)) by {\n        // (x1 + x2 + x3 + x4 + x5) * n == x1 * n + x2 * n + x3 * n + x4 * n + x5 * n\n        lemma_mul_distributive_5_terms(u64_5_as_nat(v) as int, v0 as int, s1 * v1, s2 * v2, s3 * v3, s4 * v4);\n    }\n\n    // because of the sheer number of possible associativity/distributivity groupings we have\n    // to help the solver along by intermittently asserting chunks\n    assert(v0 * u64_5_as_nat(v) == s4 * (v0 * v4) + s3 * (v0 * v3) + s2 * (v0 * v2) + s1 * (v0 * v1) + v0\n        * v0) by {\n        lemma_mul_v0_and_reorder(\n            v0 as int,\n            s1 as int,\n            v1 as int,\n            s2 as int,\n            v2 as int,\n            s3 as int,\n            v3 as int,\n            s4 as int,\n            v4 as int,\n        );\n    }\n\n    assert((s1 * v1) * u64_5_as_nat(v) == s5 * (v1 * v4) + s4 * (v1 * v3) + s3 * (v1 * v2) + s2 * (v1\n        * v1) + s1 * (v0 * v1)) by {\n        lemma_mul_si_vi_and_reorder(\n            s1 as int,\n            v1 as int,\n            v0 as int,\n            s1 as int,\n            v1 as int,\n            s2 as int,\n            v2 as int,\n            s3 as int,\n            v3 as int,\n            s4 as int,\n            v4 as int,\n        )\n    }\n\n    assert((s2 * v2) * u64_5_as_nat(v) == s6 * (v2 * v4) + s5 * (v2 * v3) + s4 * (v2 * v2) + s3 * (v1\n        * v2) + s2 * (v0 * v2)) by {\n        lemma_mul_si_vi_and_reorder(\n            s2 as int,\n            v2 as int,\n            v0 as int,\n            s1 as int,\n            v1 as int,\n            s2 as int,\n            v2 as int,\n            s3 as int,\n            v3 as int,\n            s4 as int,\n            v4 as int,\n        )\n    }\n\n    assert((s3 * v3) * u64_5_as_nat(v) == s7 * (v3 * v4) + s6 * (v3 * v3) + s5 * (v2 * v3) + s4 * (v1\n        * v3) + s3 * (v0 * v3)) by {\n        lemma_mul_si_vi_and_reorder(\n            s3 as int,\n            v3 as int,\n            v0 as int,\n            s1 as int,\n            v1 as int,\n            s2 as int,\n            v2 as int,\n            s3 as int,\n            v3 as int,\n            s4 as int,\n            v4 as int,\n        )\n    }\n\n    assert((s4 * v4) * u64_5_as_nat(v) == s8 * (v4 * v4) + s7 * (v3 * v4) + s6 * (v2 * v4) + s5 * (v1\n        * v4) + s4 * (v0 * v4)) by {\n        lemma_mul_si_vi_and_reorder(\n            s4 as int,\n            v4 as int,\n            v0 as int,\n            s1 as int,\n            v1 as int,\n            s2 as int,\n            v2 as int,\n            s3 as int,\n            v3 as int,\n            s4 as int,\n            v4 as int,\n        )\n    }\n\n    // we now mash them all together\n    assert(u64_5_as_nat(v) * u64_5_as_nat(v) == s8 * (v4 * v4) + s7 * (2 * (v3 * v4)) + s6 * (v3 * v3 + 2 * (v2\n        * v4)) + s5 * (2 * (v2 * v3) + 2 * (v1 * v4)) + s4 * (v2 * v2 + 2 * (v1 * v3) + 2 * (v0\n        * v4)) + s3 * (2 * (v1 * v2) + 2 * (v0 * v3)) + s2 * (v1 * v1 + 2 * (v0 * v2)) + s1 * (2 * (\n    v0 * v1)) + (v0 * v0)) by {\n        // These assert(a + a = 2a) statements aren't strictly necessary, but they improve the solve time\n        // s1 terms\n        assert(s1 * (v0 * v1) + s1 * (v0 * v1) == s1 * (2 * (v0 * v1))) by {\n            assert(v0 * v1 + v0 * v1 == 2 * (v0 * v1));\n            lemma_mul_is_distributive_add(s1 as int, v0 * v1, v0 * v1);\n        }\n\n        // s2 terms\n        assert(s2 * (v0 * v2) + s2 * (v1 * v1) + s2 * (v0 * v2) == s2 * (v1 * v1 + 2 * (v0 * v2)))\n            by {\n            assert(v0 * v2 + v0 * v2 == 2 * (v0 * v2));\n            lemma_mul_is_distributive_add(s2 as int, v0 * v2, v0 * v2);\n            lemma_mul_is_distributive_add(s2 as int, 2 * (v0 * v2), v1 * v1);\n        }\n\n        // s3 terms\n        assert(s3 * (v0 * v3) + s3 * (v1 * v2) + s3 * (v1 * v2) + s3 * (v0 * v3) == s3 * (2 * (v1\n            * v2) + 2 * (v0 * v3))) by {\n            assert(v1 * v2 + v1 * v2 == 2 * (v1 * v2));\n            assert(v0 * v3 + v0 * v3 == 2 * (v0 * v3));\n            lemma_mul_is_distributive_add(s3 as int, v1 * v2, v1 * v2);\n            lemma_mul_is_distributive_add(s3 as int, v0 * v3, v0 * v3);\n            lemma_mul_is_distributive_add(s3 as int, 2 * (v1 * v2), 2 * (v0 * v3));\n        }\n\n        // s4 terms\n        assert(s4 * (v0 * v4) + s4 * (v1 * v3) + s4 * (v2 * v2) + s4 * (v1 * v3) + s4 * (v0 * v4)\n            == s4 * (v2 * v2 + 2 * (v1 * v3) + 2 * (v0 * v4))) by {\n            assert(v0 * v4 + v0 * v4 == 2 * (v0 * v4));\n            assert(v1 * v3 + v1 * v3 == 2 * (v1 * v3));\n            lemma_mul_is_distributive_add(s4 as int, v0 * v4, v0 * v4);\n            lemma_mul_is_distributive_add(s4 as int, v1 * v3, v1 * v3);\n            lemma_mul_is_distributive_add(s4 as int, v2 * v2, 2 * (v1 * v3));\n            lemma_mul_is_distributive_add(s4 as int, v2 * v2 + 2 * (v1 * v3), 2 * (v0 * v4));\n        }\n\n        // s5 terms\n        assert(s5 * (v1 * v4) + s5 * (v2 * v3) + s5 * (v2 * v3) + s5 * (v1 * v4) == s5 * (2 * (v2\n            * v3) + 2 * (v1 * v4))) by {\n            assert(v1 * v4 + v1 * v4 == 2 * (v1 * v4));\n            assert(v2 * v3 + v2 * v3 == 2 * (v2 * v3));\n            lemma_mul_is_distributive_add(s5 as int, v1 * v4, v1 * v4);\n            lemma_mul_is_distributive_add(s5 as int, v2 * v3, v2 * v3);\n            lemma_mul_is_distributive_add(s5 as int, 2 * (v1 * v4), 2 * (v2 * v3));\n        }\n\n        // s6 terms\n        assert(s6 * (v2 * v4) + s6 * (v3 * v3) + s6 * (v2 * v4) == s6 * (v3 * v3 + 2 * (v2 * v4)))\n            by {\n            assert(v2 * v4 + v2 * v4 == 2 * (v2 * v4));\n            lemma_mul_is_distributive_add(s6 as int, v2 * v4, v2 * v4);\n            lemma_mul_is_distributive_add(s6 as int, 2 * (v2 * v4), v3 * v3);\n        }\n\n        // s7 terms\n        assert(s7 * (v3 * v4) + s7 * (v3 * v4) == s7 * (2 * (v3 * v4))) by {\n            assert(v3 * v4 + v3 * v4 == 2 * (v3 * v4));\n            lemma_mul_is_distributive_add(s7 as int, v3 * v4, v3 * v4);\n        }\n    }\n\n    // This is the explicit version, now we can take everything mod p\n\n    // p well defined\n    pow255_gt_19();\n\n    // By definition, p = s^5 - 19\n    // equivalently,\n    // s^5 = (p + 19)\n    // s^6 = s * (p + 19)\n    // s^7 = s^2 * (p + 19)\n    // s^8 = s^3 * (p + 19)\n    assert(s5 == (p() + 19));\n\n    // we pack together terms to slim down expressions;\n\n    let c0_base = v0 * v0;\n    let c0_x19 = 2 * (v2 * v3) + 2 * (v1 * v4);\n    let c0 = c0_base + 19 * c0_x19;\n\n    let c1_base = 2 * (v0 * v1);\n    let c1_x19 = v3 * v3 + 2 * (v2 * v4);\n    let c1 = c1_base + 19 * c1_x19;\n\n    let c2_base = v1 * v1 + 2 * (v0 * v2);\n    let c2_x19 = 2 * (v3 * v4);\n    let c2 = c2_base + 19 * c2_x19;\n\n    let c3_base = 2 * (v1 * v2) + 2 * (v0 * v3);\n    let c3_x19 = v4 * v4;\n    let c3 = c3_base + 19 * c3_x19;\n\n    let c4 = v2 * v2 + 2 * (v1 * v3) + 2 * (v0 * v4);\n\n    // group in preparation for the substitution\n    assert(u64_5_as_nat(v) * u64_5_as_nat(v) == s4 * c4 + s3 * (s5 * c3_x19 + c3_base) + s2 * (s5 * c2_x19\n        + c2_base) + s1 * (s5 * c1_x19 + c1_base) + (s5 * c0_x19 + c0_base)) by {\n        // s3 terms\n        assert(s8 * c3_x19 + s3 * c3_base == s3 * (s5 * c3_x19 + c3_base)) by {\n            assert(s8 == (s3 * s5)) by {\n                lemma_pow2_adds(3 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s3 as int, s5 as int, c3_x19);\n            lemma_mul_is_distributive_add(s3 as int, s5 * c3_x19, c3_base)\n        }\n\n        // s2 terms\n        assert(s7 * c2_x19 + s2 * c2_base == s2 * (s5 * c2_x19 + c2_base)) by {\n            assert(s7 == (s2 * s5)) by {\n                lemma_pow2_adds(2 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s2 as int, s5 as int, c2_x19);\n            lemma_mul_is_distributive_add(s2 as int, s5 * c2_x19, c2_base)\n        }\n\n        // s1 terms\n        assert(s6 * c1_x19 + s1 * c1_base == s1 * (s5 * c1_x19 + c1_base)) by {\n            assert(s6 == (s1 * s5)) by {\n                lemma_pow2_adds(1 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s1 as int, s5 as int, c1_x19);\n            lemma_mul_is_distributive_add(s1 as int, s5 * c1_x19, c1_base)\n        }\n    }\n\n    // Next we use the identity s5 = p + 19\n    assert(s5 * c3_x19 + c3_base == p() * c3_x19 + c3) by {\n        lemma_mul_is_distributive_add(c3_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c2_x19 + c2_base == p() * c2_x19 + c2) by {\n        lemma_mul_is_distributive_add(c2_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c1_x19 + c1_base == p() * c1_x19 + c1) by {\n        lemma_mul_is_distributive_add(c1_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c0_x19 + c0_base == p() * c0_x19 + c0) by {\n        lemma_mul_is_distributive_add(c0_x19 as int, p() as int, 19);\n    }\n\n    // in summary, we can reorder and regroup terms to get X * p() + Y\n    assert(u64_5_as_nat(v) * u64_5_as_nat(v) == p() * (s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19) + (s4\n        * c4 + s3 * c3 + s2 * c2 + s1 * c1 + c0)) by {\n        lemma_mul_is_distributive_add(s3 as int, p() * c3_x19, c3 as int);\n        lemma_mul_is_distributive_add(s2 as int, p() * c2_x19, c2 as int);\n        lemma_mul_is_distributive_add(s1 as int, p() * c1_x19, c1 as int);\n\n        assert(s3 * (p() * c3_x19) + s2 * (p() * c2_x19) + s1 * (p() * c1_x19) + p() * c0_x19 == p()\n            * (s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19)) by {\n            lemma_mul_is_associative(s3 as int, c3_x19 as int, p() as int);\n            lemma_mul_is_associative(s2 as int, c2_x19 as int, p() as int);\n            lemma_mul_is_associative(s1 as int, c1_x19 as int, p() as int);\n\n            lemma_mul_is_distributive_add(p() as int, s3 * c3_x19, s2 * c2_x19);\n            lemma_mul_is_distributive_add(p() as int, s3 * c3_x19 + s2 * c2_x19, s1 * c1_x19);\n            lemma_mul_is_distributive_add(\n                p() as int,\n                s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19,\n                c0_x19 as int,\n            );\n        }\n    }\n\n    let k = (s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19);\n    let sum = (s4 * c4 + s3 * c3 + s2 * c2 + s1 * c1 + c0);\n\n    assert(u64_5_as_nat(v) * u64_5_as_nat(v) == k * p() + sum);\n    assert(k * p() + sum == (k as nat) * p() + (sum as nat));\n\n    // Now, we simply move to mod p\n\n    assert((u64_5_as_nat(v) * u64_5_as_nat(v)) % p() == ((k as nat) * p() + (sum as nat)) % p());\n    assert(((k as nat) * p() + (sum as nat)) % p() == (sum as nat) % p()) by {\n        lemma_mod_sum_factor(k as int, sum as int, p() as int);\n    }\n\n    // sanity check\n    assert(s4 * c4 == pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])));\n    assert(s3 * c3 == pow2(3 * 51) * (2 * (v[1] * v[2]) + 2 * (v[0] * v[3]) + 19 * (v[4] * v[4])));\n    assert(s2 * c2 == pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] * v[2]) + 19 * (2 * (v[3] * v[4]))));\n    assert(s1 * c1 == pow2(1 * 51) * (2 * (v[0] * v[1]) + 19 * (v[3] * v[3] + 2 * (v[2] * v[4]))));\n    assert(c0 == (v[0] * v[0] + 19 * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4]))));\n}",
      "start_line": 186,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "display_name": "square_multiply",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "fn square_multiply(\n    y: &mut UnpackedScalar,\n    squarings: usize,\n    x: &UnpackedScalar,\n)/*  VERIFICATION NOTE:\n- PROOF BYPASS\n- This function was initially inside the body of montgomery_invert, but was moved outside for Verus\n*/\n\n    requires\n        limbs_bounded(old(y)),  // Use old() for &mut parameters in requires\n        limbs_bounded(x),  // No old() needed for & parameters\n\n    ensures\n        limbs_bounded(y),\n        limbs_bounded(x),\n        // VERIFICATION NOTE: Changed postcondition from the original incorrect version\n        // which used `montgomery_radix()` instead of `pow(montgomery_radix(), pow2(squarings))`\n        (to_nat(&y.limbs) * pow(montgomery_radix() as int, pow2(squarings as nat)) as nat)\n            % group_order() == (pow(to_nat(&old(y).limbs) as int, pow2(squarings as nat)) * to_nat(\n            &x.limbs,\n        )) % (group_order() as int),\n{\n    let ghost y0: nat = to_nat(&y.limbs);\n    let ghost xv: nat = to_nat(&x.limbs);\n    let ghost R: nat = montgomery_radix();\n    let ghost L: nat = group_order();\n\n    proof {\n        lemma_pow2_pos(260);\n        lemma2_to64();\n        lemma_pow0(R as int);\n        lemma_pow1(y0 as int);\n        assert(pow(R as int, 0nat) == 1);\n        assert((y0 * 1) as nat == y0);\n    }\n\n    // VERIFICATION NOTE: Named loop variable allows tracking iteration count\n    for idx in 0..squarings\n        invariant\n            limbs_bounded(y),\n            limbs_bounded(x),\n            L == group_order(),\n            R == montgomery_radix(),\n            L > 0,\n            R > 0,\n            (to_nat(&y.limbs) * pow(R as int, (pow2(idx as nat) - 1) as nat) as nat) % L == (pow(\n                y0 as int,\n                pow2(idx as nat),\n            ) as nat) % L,\n    {\n        let ghost y_before: nat = to_nat(&y.limbs);\n        *y = y.montgomery_square();\n        proof {\n            lemma_square_multiply_step(to_nat(&y.limbs), y_before, y0, R, L, idx as nat);\n        }\n    }\n\n    let ghost y_after: nat = to_nat(&y.limbs);\n    let ghost exp_final: nat = (pow2(squarings as nat) - 1) as nat;\n\n    *y = UnpackedScalar::montgomery_mul(y, x);\n\n    proof {\n        // After loop, i == squarings (from ensures), so invariant gives us:\n        assert((y_after * pow(R as int, exp_final) as nat) % L == (pow(\n            y0 as int,\n            pow2(squarings as nat),\n        ) as nat) % L);\n\n        let final_y: nat = to_nat(&y.limbs);\n        let n: nat = squarings as nat;\n        let R_exp: int = pow(R as int, exp_final);\n        let R_pow2n: int = pow(R as int, pow2(n));\n        let y0_pow: int = pow(y0 as int, pow2(n));\n\n        lemma_pow2_pos(n);\n        lemma_pow_adds(R as int, 1nat, exp_final);\n        lemma_pow1(R as int);\n        lemma_pow_nonnegative(R as int, exp_final);\n        lemma_pow_nonnegative(y0 as int, pow2(n));\n\n        assert((y_after as int * xv as int) * R_exp == (y_after as int * R_exp) * xv as int)\n            by (nonlinear_arith)\n            requires\n                R_exp >= 0,\n        ;\n\n        calc! {\n            (==)\n            (final_y as int * R_pow2n) % (L as int); {\n                lemma_mul_is_associative(final_y as int, R as int, R_exp);\n            }\n            ((final_y * R) as int * R_exp) % (L as int); {\n                lemma_mul_mod_noop((final_y * R) as int, R_exp, L as int);\n                lemma_mul_mod_noop((y_after * xv) as int, R_exp, L as int);\n            }\n            ((y_after * xv) as int * R_exp) % (L as int); {}\n            ((y_after * R_exp as nat) as int * xv as int) % (L as int); {\n                lemma_mul_mod_noop((y_after * R_exp as nat) as int, xv as int, L as int);\n                lemma_mul_mod_noop(y0_pow, xv as int, L as int);\n            }\n            (y0_pow * xv as int) % (L as int);\n        }\n    }\n}",
      "start_line": 2630,
      "end_line": 19,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn identity() -> (result: AffineNielsPoint)\n        ensures\n            result == identity_affine_niels(),\n    {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::ONE,\n            y_minus_x: FieldElement::ONE,\n            xy2d: FieldElement::ZERO,\n        }\n    }",
      "start_line": 270,
      "end_line": 16,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_to_le_bytes().",
      "display_name": "u16_to_le_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_to_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub fn u16_to_le_bytes(x: u16) -> (bytes: [u8; 2])\n    ensures\n        bytes_seq_to_nat(seq_from2(&bytes)) == x as nat,\n{\n    x.to_le_bytes()\n}",
      "start_line": 87,
      "end_line": 23,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#is_torsion_free().",
      "display_name": "is_torsion_free",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#is_torsion_free().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn is_torsion_free(&self) -> bool {\n        (self * constants::BASEPOINT_ORDER_PRIVATE).is_identity()\n    }",
      "start_line": 2362,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bound_scalar().",
      "display_name": "lemma_bound_scalar",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bound_scalar().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_bound_scalar(a: &Scalar52)\n    requires\n        limbs_bounded(a),\n    ensures\n        to_nat(&a.limbs) < pow2((52 * (5) as nat)),\n{\n    lemma_general_bound(a.limbs@);\n}",
      "start_line": 693,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_remainder_bound().",
      "display_name": "lemma_radix51_remainder_bound",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_remainder_bound().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_radix51_remainder_bound(r0: int, r1: int, r2: int, r3: int, r4: int)\n    requires\n        0 <= r0 < (pow2(51) as int),\n        0 <= r1 < (pow2(51) as int),\n        0 <= r2 < (pow2(51) as int),\n        0 <= r3 < (pow2(51) as int),\n        0 <= r4 < (pow2(51) as int),\n    ensures\n        r0 + r1 * (pow2(51) as int) + r2 * (pow2(102) as int) + r3 * (pow2(153) as int) + r4 * (\n        pow2(204) as int) < (pow2(255) as int),\n{\n    lemma_pow2_pos(51);\n    lemma_pow2_adds(51, 51);\n    lemma_pow2_adds(51, 102);\n    lemma_pow2_adds(51, 153);\n    lemma_pow2_adds(51, 204);\n\n    let sum = r0 + r1 * (pow2(51) as int) + r2 * (pow2(102) as int) + r3 * (pow2(153) as int) + r4\n        * (pow2(204) as int);\n\n    // Each term r_i * 2^(51*i) < 2^51 * 2^(51*i) = 2^(51*(i+1))\n\n    assert(r1 * pow2(51) <= pow2(102) - pow2(51)) by {\n        lemma_pow2_mul_bound_general(r1 as nat, 51, 51);\n    }\n\n    assert(r2 * pow2(102) <= pow2(153) - pow2(102)) by {\n        lemma_pow2_mul_bound_general(r2 as nat, 51, 102);\n    }\n\n    assert(r3 * pow2(153) <= pow2(204) - pow2(153)) by {\n        lemma_pow2_mul_bound_general(r3 as nat, 51, 153);\n    }\n\n    assert(r4 * pow2(204) <= pow2(255) - pow2(204)) by {\n        lemma_pow2_mul_bound_general(r4 as nat, 51, 204);\n    }\n\n}",
      "start_line": 249,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn zeroize(&mut self) {\n        self.limbs.zeroize();\n    }",
      "start_line": 80,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_geometric().",
      "display_name": "lemma_pow2_geometric",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_geometric().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_geometric(a: nat, b: nat)\n    ensures\n        (pow2(a) - 1) * pow2(b) + (pow2(b) - 1) == pow2(a + b) - 1,\n{\n    lemma2_to64();\n    lemma_pow2_adds(a, b);\n    // (2^a - 1) * 2^b + (2^b - 1)\n    // = 2^a * 2^b - 2^b + 2^b - 1\n    // = 2^(a+b) - 1\n    lemma_mul_is_distributive_sub(pow2(b) as int, pow2(a) as int, 1);\n}",
      "start_line": 884,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/slice128_to_nat().",
      "display_name": "slice128_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/slice128_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn slice128_to_nat(limbs: &[u128]) -> nat {\n    seq_to_nat(limbs@.map(|i, x| x as nat))\n}",
      "start_line": 21,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb1().",
      "display_name": "lemma_load8_at_limb1",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb1().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_load8_at_limb1(input: &[u8])\n    requires\n        6 + 7 < input.len(),\n    ensures\n        ((spec_load8_at(input, 6) as u64) >> 3) & mask51 == (input[6] as nat / pow2(3)) + (input[7]\n            * pow2((1 * 8 - 3) as nat)) + (input[8] * pow2((2 * 8 - 3) as nat)) + (input[9] * pow2(\n            (3 * 8 - 3) as nat,\n        )) + (input[10] * pow2((4 * 8 - 3) as nat)) + (input[11] * pow2((5 * 8 - 3) as nat)) + ((\n        input[12] as nat % pow2(6)) * pow2((6 * 8 - 3) as nat)),\n{\n    let i = 6;\n    let k = 3;\n\n    let j_div = 1;\n    let j_id = 6;\n    let j_shift = 7;\n\n    lemma_load8_at_limb_X(input, i, k, j_div, j_id, j_shift);\n\n    // Sanity check\n    assert((spec_load8_at(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n        / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n    pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64));\n}",
      "start_line": 872,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "display_name": "p",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn p() -> nat {\n    (pow2(255) - 19) as nat\n}",
      "start_line": 13,
      "end_line": 19,
      "is_libsignal": false,
      "caller_count": 139,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_inv_one().",
      "display_name": "lemma_field_inv_one",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_inv_one().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "file_name": "field_algebra_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_field_inv_one()\n    ensures math_field_inv(1) == 1,\n{\n    // Goal: inv(1) = 1\n    //\n    // From field_inv_property: 1 * inv(1) ≡ 1 (mod p)\n    // So inv(1) ≡ 1 (mod p)\n    // Since inv(1) < p, we have inv(1) = 1\n    \n    p_gt_2();\n    \n    // 1 % p = 1 (since 1 < p)\n    lemma_small_mod(1nat, p());\n    \n    // field_inv_property gives: (1 * inv(1)) % p = 1 and inv(1) < p\n    field_inv_property(1nat);\n    let inv = math_field_inv(1);\n    \n    // inv % p = 1, and since inv < p: inv = 1\n    lemma_small_mod(inv, p());\n}",
      "start_line": 40,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_neg_sqrt_m1_not_square().",
      "display_name": "axiom_neg_sqrt_m1_not_square",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_neg_sqrt_m1_not_square().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "file_name": "sqrt_ratio_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn axiom_neg_sqrt_m1_not_square()\n    ensures\n        !is_square_mod_p((p() - spec_sqrt_m1()) as nat),\n{\n    admit();\n}",
      "start_line": 112,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn zeroize(&mut self)\n        ensures\n    // All bytes are zero\n\n            forall|i: int| 0 <= i < 32 ==> #[trigger] self.0[i] == 0u8,\n            // The u-coordinate is 0 (identity point)\n            spec_montgomery(*self) == 0,\n    {\n        /* ORIGINAL CODE: self.0.zeroize(); */\n        crate::core_assumes::zeroize_bytes32(&mut self.0);\n        proof {\n            // After zeroizing, all bytes are 0, so the field element is 0\n            assume(spec_field_element_from_bytes(&self.0) == 0);\n        }\n    }",
      "start_line": 224,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#ConditionallySelectable#conditional_select().",
      "display_name": "conditional_select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#ConditionallySelectable#conditional_select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn conditional_select(\n        a: &RistrettoPoint,\n        b: &RistrettoPoint,\n        choice: Choice,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::conditional_select(&a.0, &b.0, choice))\n    }",
      "start_line": 1143,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_sub().",
      "display_name": "lemma_u64_5_as_nat_sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "file_name": "u64_5_as_nat_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_u64_5_as_nat_sub(a: [u64; 5], b: [u64; 5])\n    requires\n        forall|i: int| 0 <= i < 5 ==> b[i] <= a[i],\n    ensures\n        u64_5_as_nat(\n            [\n                (a[0] - b[0]) as u64,\n                (a[1] - b[1]) as u64,\n                (a[2] - b[2]) as u64,\n                (a[3] - b[3]) as u64,\n                (a[4] - b[4]) as u64,\n            ],\n        ) == u64_5_as_nat(a) - u64_5_as_nat(b),\n{\n    let c: [u64; 5] = [\n        (a[0] - b[0]) as u64,\n        (a[1] - b[1]) as u64,\n        (a[2] - b[2]) as u64,\n        (a[3] - b[3]) as u64,\n        (a[4] - b[4]) as u64,\n    ];\n    // distribute pow2\n    assert(u64_5_as_nat(c) == (a[0] - b[0]) + pow2(51) * a[1] - pow2(51) * b[1] + pow2(102) * a[2]\n        - pow2(102) * b[2] + pow2(153) * a[3] - pow2(153) * b[3] + pow2(204) * a[4] - pow2(204)\n        * b[4]) by {\n        lemma_mul_is_distributive_sub(pow2(1 * 51) as int, a[1] as int, b[1] as int);\n        lemma_mul_is_distributive_sub(pow2(2 * 51) as int, a[2] as int, b[2] as int);\n        lemma_mul_is_distributive_sub(pow2(3 * 51) as int, a[3] as int, b[3] as int);\n        lemma_mul_is_distributive_sub(pow2(4 * 51) as int, a[4] as int, b[4] as int);\n    }\n}",
      "start_line": 152,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "display_name": "lemma2_to64_rest",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "is_libsignal": false,
      "caller_count": 33,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_eq().",
      "display_name": "lemma_product_of_multiples_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_product_of_multiples_eq(a: nat, n: nat)\n    ensures\n        product_of_multiples(a, n) == pow(a as int, n) as nat * factorial(n),\n    decreases n,\n{\n    if n == 0 {\n        // Base case: product_of_multiples(a, 0) = 1 = a^0 * 0! = 1 * 1\n        assert(pow(a as int, 0) == 1) by {\n            reveal(pow);\n        };\n        assert(factorial(0) == 1);\n        assert(product_of_multiples(a, 0) == 1);\n    } else {\n        // Inductive case\n        lemma_product_of_multiples_eq(a, (n - 1) as nat);\n        // IH: product_of_multiples(a, n-1) == a^(n-1) * (n-1)!\n\n        let prev_prod = product_of_multiples(a, (n - 1) as nat);\n        let prev_pow = pow(a as int, (n - 1) as nat) as nat;\n        let prev_fact = factorial((n - 1) as nat);\n\n        // From definitions\n        assert(product_of_multiples(a, n) == (n * a) * prev_prod);\n        assert(factorial(n) == n * factorial((n - 1) as nat));\n        assert(factorial(n) == n * prev_fact);\n\n        // From IH\n        assert(prev_prod == prev_pow * prev_fact);\n\n        // Power expansion\n        assert(pow(a as int, n) == (a as int) * pow(a as int, (n - 1) as nat)) by {\n            reveal(pow);\n        };\n        let curr_pow = pow(a as int, n) as nat;\n\n        // curr_pow == a * prev_pow (as nats)\n        // We have: pow(a, n) = a * pow(a, n-1) = a * prev_pow\n        // So curr_pow = pow(a, n) as nat = a * prev_pow\n        assert(curr_pow == a * prev_pow) by {\n            // pow(a, n-1) >= 0 (powers are non-negative for non-negative base)\n            assert(pow(a as int, (n - 1) as nat) >= 0) by {\n                if a > 0 {\n                    lemma_pow_positive(a as int, (n - 1) as nat);\n                } else {\n                    // a == 0, so pow(0, n-1) = 0 for n-1 > 0, or pow(0, 0) = 1\n                    if (n - 1) as nat == 0 {\n                        reveal(pow);\n                    } else {\n                        lemma_pow0(a as int);\n                        reveal(pow);\n                    }\n                }\n            };\n            // a >= 0 (nat)\n            // so a * pow(a, n-1) >= 0\n            lemma_mul_nonnegative(a as int, pow(a as int, (n - 1) as nat));\n            // curr_pow = pow(a, n) as nat\n            //         = (a * pow(a, n-1)) as nat  (by power expansion)\n            //         = a * (pow(a, n-1) as nat)  (since product is non-negative)\n            //         = a * prev_pow\n        };\n\n        // We need: (n * a) * (prev_pow * prev_fact) == curr_pow * (n * prev_fact)\n        // = (a * prev_pow) * (n * prev_fact) = curr_pow * factorial(n)\n\n        // Show (n * a) * (prev_pow * prev_fact) == (a * prev_pow) * (n * prev_fact)\n        assert((n * a) * (prev_pow * prev_fact) == (a * prev_pow) * (n * prev_fact)) by {\n            lemma_mul_is_associative(n as int, a as int, (prev_pow * prev_fact) as int);\n            lemma_mul_is_associative(a as int, prev_pow as int, prev_fact as int);\n            lemma_mul_is_associative(n as int, (a * prev_pow) as int, prev_fact as int);\n            lemma_mul_is_commutative(n as int, (a * prev_pow) as int);\n            lemma_mul_is_associative((a * prev_pow) as int, n as int, prev_fact as int);\n        };\n\n        // Chain the equalities\n        // product_of_multiples(a, n)\n        // = (n * a) * prev_prod\n        // = (n * a) * (prev_pow * prev_fact)  (since prev_prod = prev_pow * prev_fact)\n        // = (a * prev_pow) * (n * prev_fact)  (proved above)\n        // = curr_pow * (n * prev_fact)        (since curr_pow = a * prev_pow)\n        // = curr_pow * factorial(n)           (since n * prev_fact = factorial(n))\n\n        assert((a * prev_pow) * (n * prev_fact) == curr_pow * (n * prev_fact)) by {\n            // since curr_pow == a * prev_pow\n        };\n\n        assert(curr_pow * (n * prev_fact) == curr_pow * factorial(n)) by {\n            // since factorial(n) == n * prev_fact\n        };\n\n        assert(product_of_multiples(a, n) == curr_pow * factorial(n));\n    }\n}",
      "start_line": 775,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "display_name": "lemma_neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/negate_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/negate_lemmas.rs",
      "file_name": "negate_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_neg(elem: &FieldElement51)\n    requires\n// negate postcondition\n\n        (u64_5_as_nat(spec_negate(elem.limbs)) + u64_5_as_nat(elem.limbs)) % p() == 0,\n    ensures\n        u64_5_as_nat(spec_negate(elem.limbs)) % p() == math_field_neg(spec_field_element(elem)),\n{\n    let x = spec_field_element(elem);\n    let y = u64_5_as_nat(spec_negate(elem.limbs)) % p();\n\n    assert(p() > 0) by {\n        pow255_gt_19();\n    }\n\n    assert(x < p()) by {\n        lemma_mod_bound(u64_5_as_nat(elem.limbs) as int, p() as int);\n    }\n    assert(y < p()) by {\n        lemma_mod_bound(u64_5_as_nat(spec_negate(elem.limbs)) as int, p() as int);\n    }\n\n    assert((y + x) % p() == 0) by {\n        lemma_add_mod_noop(\n            u64_5_as_nat(spec_negate(elem.limbs)) as int,\n            u64_5_as_nat(elem.limbs) as int,\n            p() as int,\n        );\n    }\n    assert(y == (p() - (x % p())) as nat % p()) by {\n        assert(p() - (x % p()) >= 0) by {\n            lemma_mod_bound(x as int, p() as int);\n        }\n        assert(x % p() == x) by {\n            lemma_mod_twice(spec_field_element_as_nat(elem) as int, p() as int);\n        }\n        if (x == 0) {\n            assert(y % p() == 0);  // follows from (y + x) % p == 0\n            assert(y == 0) by {\n                // contradiction proof\n                if (y > 0) {\n                    assert(y >= p()) by {\n                        lemma_mod_is_zero(y, p());\n                    }\n                }\n            }\n            assert(p() % p() == 0) by {\n                lemma_mod_self_0(p() as int);\n            }\n        } else {\n            // x > 0\n            // consequences:\n            assert(p() - (x % p()) < p());\n            assert(y + x > 0);\n\n            assert((p() - (x % p())) as nat % p() == p() - x) by {\n                lemma_small_mod((p() - (x % p())) as nat, p());\n            }\n\n            assert(y + x == p()) by {\n                let z = y + x;\n                assert(z == p() * (z / p())) by {\n                    // we know z % p == 0\n                    lemma_fundamental_div_mod(z as int, p() as int);\n                }\n                assert(z / p() == 1) by {\n                    assert(z / p() >= 1) by {\n                        assert(z >= p()) by {\n                            lemma_mod_is_zero(z, p());\n                        }\n                    }\n                    assert(z / p() < 2) by {\n                        assert(z <= 2 * p()) by {\n                            // known\n                            assert(x < p());\n                            assert(y < p());\n                        }\n                        assert(2 * p() / p() == 2) by {\n                            lemma_div_by_multiple(2, p() as int);\n                        }\n                        lemma_div_by_multiple_is_strongly_ordered(\n                            z as int,\n                            (2 * p()) as int,\n                            2,\n                            p() as int,\n                        );\n                    }\n                }\n            }\n\n        }\n    }\n}",
      "start_line": 130,
      "end_line": 23,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 16
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_le().",
      "display_name": "lemma_mul_le",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_le().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_mul_le(a1: nat, b1: nat, a2: nat, b2: nat)\n    requires\n        a1 <= b1,\n        a2 <= b2,\n    ensures\n        a1 * a2 <= b1 * b2,\n{\n    // a1 < b1 /\\ a2 > 0 ==> a1 * a2 < b1 * a2\n    lemma_mul_inequality(a1 as int, b1 as int, a2 as int);\n    // a2 < b2 /\\ b2 > 0 ==> a2 * b1 < b2 * b1\n    lemma_mul_inequality(a2 as int, b2 as int, b1 as int);\n}",
      "start_line": 29,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 9,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "display_name": "mul_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn mul_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n            is_canonical_scalar(self),\n    {\n        /* <ORIGINAL CODE>\n         *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n        /* <VERIFICATION NOTE>\n         In the modified code, we store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&old(self).bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        *self = result_unpacked.pack();\n        proof {\n            assert(to_nat(&result_unpacked.limbs) == to_nat(&result_unpacked.limbs) % pow2(256))\n                by {\n                assert(group_order() < pow2(256)) by {\n                    lemma_group_order_bound();\n                    lemma_pow2_strictly_increases(255, 256);\n                }\n                lemma_small_mod(to_nat(&result_unpacked.limbs), pow2(256));\n            }\n            assert(bytes_to_nat(&self.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n    }",
      "start_line": 472,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 12
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime().",
      "display_name": "lemma_euclid_prime",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_euclid_prime(a: nat, b: nat, p: nat)\n    requires\n        is_prime(p),\n        (a * b) % p == 0,\n    ensures\n        a % p == 0 || b % p == 0,\n{\n    // Proof by strong induction on a\n    // We use the fact that if p doesn't divide a, then gcd(a, p) = 1\n    // and we can use a cancellation argument\n    if a % p == 0 {\n        // Done\n    } else if b % p == 0 {\n        // Done\n    } else {\n        // Both a % p != 0 and b % p != 0\n        // But (a * b) % p == 0\n        // We'll derive a contradiction using properties of primes\n        // Key insight: since p is prime and a % p != 0,\n        // gcd(a, p) = 1 (a and p are coprime)\n        // This means there exist integers x, y such that ax + py = 1 (Bezout)\n        // Multiplying by b: abx + pby = b\n        // Since p | ab, we have p | abx, and p | pby\n        // So p | b, contradiction\n        // For now, we use a computational approach based on the definition\n        let a_mod = a % p;\n\n        // a % p is in range (0, p) since a % p != 0\n        assert(0 < a_mod) by {\n            // a % p != 0 (from the else branch)\n        };\n        assert(a_mod < p) by {\n            lemma_mod_bound(a as int, p as int);\n        };\n\n        // ((a % p) * b) % p == (a * b) % p == 0\n        assert((a_mod * b) % p == 0) by {\n            lemma_mul_mod_noop_left(a as int, b as int, p as int);\n            // (a * b) % p == ((a % p) * b) % p\n        };\n\n        lemma_euclid_prime_helper(a_mod, b, p);\n    }\n}",
      "start_line": 1055,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_nonincreasing().",
      "display_name": "lemma_shr_nonincreasing",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_nonincreasing().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_shr_nonincreasing(v: u64, a: nat, b: nat)\n    requires\n        a <= b <= 64,\n    ensures\n        v >> b <= v >> a,\n{\n    if (b == 64) {\n        assert(v >> 64 == 0) by (bit_vector);\n    } else {\n        let d = (b - a) as u64;\n        // v >> b = (v >> (b - a)) >> a\n        lemma_shr_by_sum(v, d as nat, a);\n        assert(v >> d <= v) by (bit_vector);\n        // a <= b => a >> x <= b >> x\n        lemma_shr_le_u64(v >> d, v, a);\n    }\n}",
      "start_line": 184,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo digest 0.10.7 digest/Digest#finalize().",
      "display_name": "finalize",
      "symbol": "rust-analyzer cargo digest 0.10.7 digest/Digest#finalize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/edwards_lemmas/lemmas/lemma_edwards_d_limbs_bounded_54().",
      "display_name": "lemma_edwards_d_limbs_bounded_54",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/edwards_lemmas/lemmas/lemma_edwards_d_limbs_bounded_54().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/constants_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/constants_lemmas.rs",
      "file_name": "constants_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub(crate) proof fn lemma_edwards_d_limbs_bounded_54()\n    ensures fe51_limbs_bounded(&EDWARDS_D, 54),\n{\n    // Goal: All EDWARDS_D limbs < 2^54\n    assert(fe51_limbs_bounded(&EDWARDS_D, 54)) by {\n        lemma_edwards_d_limbs_bounded();\n        assert((1u64 << 51) < (1u64 << 54)) by (bit_vector);\n    };\n}",
      "start_line": 62,
      "end_line": 53,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#MultiscalarMul#multiscalar_mul().",
      "display_name": "multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#MultiscalarMul#multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> RistrettoPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<RistrettoPoint>,\n    {\n        let extended_points = points.into_iter().map(|P| P.borrow().0);\n        RistrettoPoint(EdwardsPoint::multiscalar_mul(scalars, extended_points))\n    }",
      "start_line": 980,
      "end_line": 23,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pre_reduce_limbs().",
      "display_name": "pre_reduce_limbs",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pre_reduce_limbs().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn pre_reduce_limbs(limbs: [u64; 5]) -> [u64; 5] {\n    let r = [\n        (sixteen_p_vec[0] - limbs[0]) as u64,\n        (sixteen_p_vec[1] - limbs[1]) as u64,\n        (sixteen_p_vec[2] - limbs[2]) as u64,\n        (sixteen_p_vec[3] - limbs[3]) as u64,\n        (sixteen_p_vec[4] - limbs[4]) as u64,\n    ];\n    r\n}",
      "start_line": 114,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitwise_or_r_zero_is_id().",
      "display_name": "lemma_bitwise_or_r_zero_is_id",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitwise_or_r_zero_is_id().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/bit_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/bit_lemmas.rs",
      "file_name": "bit_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_bitwise_or_r_zero_is_id(a: u64)\n    ensures\n        a | 0 == a,\n{\n    assert(a | 0 == a) by (bit_vector);\n}",
      "start_line": 14,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_basic_div().",
      "display_name": "lemma_basic_div",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_basic_div().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/has_inv_mod_p().",
      "display_name": "has_inv_mod_p",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/has_inv_mod_p().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn has_inv_mod_p(v: nat) -> bool {\n    v % p() != 0 && exists|w: nat| (#[trigger] (v * w) % p()) == 1\n}",
      "start_line": 459,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MultiscalarMul#multiscalar_mul().",
      "display_name": "multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MultiscalarMul#multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<EdwardsPoint>,\n    {\n        // Sanity-check lengths of input iterators\n        let mut scalars = scalars.into_iter();\n        let mut points = points.into_iter();\n\n        // Lower and upper bounds on iterators\n        let (s_lo, s_hi) = scalars.by_ref().size_hint();\n        let (p_lo, p_hi) = points.by_ref().size_hint();\n\n        // They should all be equal\n        assert_eq!(s_lo, p_lo);\n        assert_eq!(s_hi, Some(s_lo));\n        assert_eq!(p_hi, Some(p_lo));\n\n        // Now we know there's a single size.  When we do\n        // size-dependent algorithm dispatch, use this as the hint.\n        let _size = s_lo;\n\n        crate::backend::straus_multiscalar_mul(scalars, points)\n    }",
      "start_line": 1802,
      "end_line": 23,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_assign_generic().",
      "display_name": "conditional_assign_generic",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_assign_generic().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn conditional_assign_generic<T>(a: &mut T, b: &T, choice: Choice) where\n    T: subtle::ConditionallySelectable,\n {\n    a.conditional_assign(b, choice)\n}",
      "start_line": 301,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "display_name": "mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs",
      "file_name": "vartime_double_base.rs",
      "parent_folder": "scalar_mul",
      "body": "pub fn mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> EdwardsPoint {\n    let a_naf = a.non_adjacent_form(5);\n\n    #[cfg(feature = \"precomputed-tables\")]\n    let b_naf = b.non_adjacent_form(8);\n    #[cfg(not(feature = \"precomputed-tables\"))]\n    let b_naf = b.non_adjacent_form(5);\n\n    // Find starting index\n    let mut i: usize = 255;\n    for j in (0..256).rev() {\n        i = j;\n        if a_naf[i] != 0 || b_naf[i] != 0 {\n            break;\n        }\n    }\n\n    let table_A = NafLookupTable5::<ProjectiveNielsPoint>::from(A);\n    #[cfg(feature = \"precomputed-tables\")]\n    let table_B = &constants::AFFINE_ODD_MULTIPLES_OF_BASEPOINT;\n    #[cfg(not(feature = \"precomputed-tables\"))]\n    let table_B =\n        &NafLookupTable5::<ProjectiveNielsPoint>::from(&constants::ED25519_BASEPOINT_POINT);\n\n    let mut r = ProjectivePoint::identity();\n    loop {\n        let mut t = r.double();\n\n        match a_naf[i].cmp(&0) {\n            Ordering::Greater => t = &t.as_extended() + &table_A.select(a_naf[i] as usize),\n            Ordering::Less => t = &t.as_extended() - &table_A.select(-a_naf[i] as usize),\n            Ordering::Equal => {}\n        }\n\n        match b_naf[i].cmp(&0) {\n            Ordering::Greater => t = &t.as_extended() + &table_B.select(b_naf[i] as usize),\n            Ordering::Less => t = &t.as_extended() - &table_B.select(-b_naf[i] as usize),\n            Ordering::Equal => {}\n        }\n\n        r = t.as_projective();\n\n        if i == 0 {\n            break;\n        }\n        i -= 1;\n    }\n\n    r.as_extended()\n}",
      "start_line": 23,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "display_name": "sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn sub(self, _rhs: &'b Scalar) -> (result:\n        Scalar)/* VERIFICATION NOTE: preconditions are added to the SpecImpl above\n    requires\n      is_canonical_scalar(self),\n      is_canonical_scalar(_rhs),\n    */\n\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        /* <ORIGINAL CODE>\n         UnpackedScalar::sub(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::sub requires: -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()\n        proof {\n            assume(-group_order() <= to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs));\n            assume(to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::sub(&self_unpacked, &rhs_unpacked);\n        proof {\n            // Postconditions from sub - need to strengthen, review connections\n            assume(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                - to_nat(&rhs_unpacked.limbs)) % (group_order() as int));\n            assume(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(to_nat(&result_unpacked.limbs) == to_nat(&result_unpacked.limbs) % pow2(256))\n                by {\n                assert(group_order() < pow2(256)) by {\n                    assume(false);\n                }\n                lemma_small_mod(to_nat(&result_unpacked.limbs), pow2(256));\n            }\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int));\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }",
      "start_line": 727,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_internal_correct().",
      "display_name": "lemma_square_internal_correct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_internal_correct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_square_internal_correct(a: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        z[0] == (a[0] * a[0]),\n        z[1] == (a[0] * a[1]) * 2,\n        z[2] == (a[0] * a[2]) * 2 + (a[1] * a[1]),\n        z[3] == (a[0] * a[3]) * 2 + (a[1] * a[2]) * 2,\n        z[4] == (a[0] * a[4]) * 2 + (a[1] * a[3]) * 2 + (a[2] * a[2]),\n        z[5] == (a[1] * a[4]) * 2 + (a[2] * a[3]) * 2,\n        z[6] == (a[2] * a[4]) * 2 + (a[3] * a[3]),\n        z[7] == (a[3] * a[4]) * 2,\n        z[8] == (a[4] * a[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(a),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*a) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n}",
      "start_line": 87,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_identity_projective_point_edwards().",
      "display_name": "spec_identity_projective_point_edwards",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_identity_projective_point_edwards().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_identity_projective_point_edwards() -> (nat, nat, nat) {\n    (0nat, 1nat, 1nat)\n}",
      "start_line": 312,
      "end_line": 56,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_double_neg_mod().",
      "display_name": "lemma_double_neg_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_double_neg_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_double_neg_mod(x: nat, m: nat)\n    requires \n        m > 1,\n        x < m,\n    ensures ((m - ((m - x) as nat) % m) as nat) % m == x,\n{\n    // (m - x) < m since 0 ≤ x < m implies 0 < m - x ≤ m\n    // Actually m - x could be m when x = 0, so (m - x) % m handles that\n    let neg_x = (m - x) as nat;\n    \n    if x == 0 {\n        // neg_x = m, so neg_x % m = 0\n        assert(neg_x % m == 0) by {\n            lemma_mod_self_0(m as int);\n        };\n        // (m - 0) % m = m % m = 0 = x\n        assert(((m - 0nat) as nat) % m == 0);\n    } else {\n        // 0 < x < m, so 0 < m - x < m, so (m - x) % m = m - x\n        assert(neg_x < m);\n        assert(neg_x % m == neg_x) by {\n            lemma_small_mod(neg_x, m);\n        };\n        // (m - neg_x) = (m - (m - x)) = x\n        assert((m - neg_x) as nat == x);\n        assert(((m - neg_x) as nat) % m == x) by {\n            lemma_small_mod(x, m);\n        };\n    }\n}",
      "start_line": 261,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "display_name": "is_valid_edwards_point",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_valid_edwards_point(point: crate::edwards::EdwardsPoint) -> bool {\n    let x = spec_field_element(&point.X);\n    let y = spec_field_element(&point.Y);\n    let z = spec_field_element(&point.Z);\n    let t = spec_field_element(&point.T);\n\n    // Z must be non-zero\n    z != 0 &&\n    // The affine coordinates (X/Z, Y/Z) must be on the curve\n    math_on_edwards_curve(\n        math_field_mul(x, math_field_inv(z)),\n        math_field_mul(y, math_field_inv(z)),\n    ) &&\n    // Extended coordinate must satisfy T = X*Y/Z\n    t == math_field_mul(math_field_mul(x, y), math_field_inv(z))\n}",
      "start_line": 221,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 13,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_mod_inverse().",
      "display_name": "spec_mod_inverse",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_mod_inverse().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub open spec fn spec_mod_inverse(a: nat, m: nat) -> nat\n    recommends\n        m > 1,\n        spec_gcd(a % m, m) == 1,\n{\n    if m <= 1 || spec_gcd(a % m, m) != 1 {\n        0  // Undefined case - return 0 by convention\n\n    } else {\n        let r = spec_extended_gcd(a % m, m);\n        // r.x might be negative, so normalize to [0, m)\n        (((r.x % (m as int)) + (m as int)) % (m as int)) as nat\n    }\n}",
      "start_line": 961,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_bridge_pow_as_nat_to_spec().",
      "display_name": "lemma_bridge_pow_as_nat_to_spec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_bridge_pow_as_nat_to_spec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "file_name": "u64_5_as_nat_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_bridge_pow_as_nat_to_spec(\n    result: &FieldElement51,\n    base: &FieldElement51,\n    exp: nat,\n)\n    requires\n        u64_5_as_nat(result.limbs) % p() == (pow(u64_5_as_nat(base.limbs) as int, exp) as nat)\n            % p(),\n    ensures\n        spec_field_element(result) == (pow(spec_field_element(base) as int, exp) as nat) % p(),\n{\n    // Prove p() > 0\n    pow255_gt_19();\n\n    // By definition: spec_field_element(result) == u64_5_as_nat(result.limbs) % p()\n    //                spec_field_element(base) == u64_5_as_nat(base.limbs) % p()\n    // The solver should unfold these automatically\n\n    // Apply lemma_pow_mod_noop: pow(b, e) % m == pow(b % m, e) % m\n    lemma_pow_mod_noop(u64_5_as_nat(base.limbs) as int, exp, p() as int);\n\n    // Let's use clear names for the key values\n    let x = u64_5_as_nat(base.limbs);\n    let y = spec_field_element(base);\n\n    // y == x % p() by definition\n    assert(y == x % p());\n\n    // From lemma_pow_mod_noop, in int arithmetic:\n    // pow(x as int, exp) % (p() as int) == pow((x % p()) as int, exp) % (p() as int)\n    assert(pow(x as int, exp) % (p() as int) == pow((x % p()) as int, exp) % (p() as int));\n\n    // Since y == x % p():\n    assert(pow(x as int, exp) % (p() as int) == pow(y as int, exp) % (p() as int));\n\n    assert(pow(x as int, exp) >= 0) by {\n        lemma_pow_nonnegative(x as int, exp);\n    }\n\n    assert(pow(y as int, exp) >= 0) by {\n        lemma_pow_nonnegative(y as int, exp);\n    }\n\n    // Now we have: pow(x, exp) % p() == pow(y, exp) % p()\n    // With type conversions: (pow(x, exp) as nat) % p() == (pow(y, exp) as nat) % p()\n    assert((pow(x as int, exp) as nat) % p() == (pow(y as int, exp) as nat) % p());\n}",
      "start_line": 71,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#ConstantTimeEq#ct_eq().",
      "display_name": "ct_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#ConstantTimeEq#ct_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn ct_eq(&self, other: &RistrettoPoint) -> Choice {\n        let X1Y2 = &self.0.X * &other.0.Y;\n        let Y1X2 = &self.0.Y * &other.0.X;\n        let X1X2 = &self.0.X * &other.0.X;\n        let Y1Y2 = &self.0.Y * &other.0.Y;\n\n        X1Y2.ct_eq(&Y1X2) | X1X2.ct_eq(&Y1Y2)\n    }",
      "start_line": 834,
      "end_line": 13,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field51_add().",
      "display_name": "lemma_field51_add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field51_add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/add_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/add_lemmas.rs",
      "file_name": "add_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_field51_add(lhs: &FieldElement51, rhs: &FieldElement51)\n    requires\n        sum_of_limbs_bounded(lhs, rhs, u64::MAX),\n    ensures\n        u64_5_as_nat(spec_add_fe51_limbs(lhs, rhs).limbs) == u64_5_as_nat(lhs.limbs) + u64_5_as_nat(\n            rhs.limbs,\n        ),\n        spec_field_element(&spec_add_fe51_limbs(lhs, rhs)) == math_field_add(\n            spec_field_element(lhs),\n            spec_field_element(rhs),\n        ),\n{\n    assert(u64_5_as_nat(spec_add_fe51_limbs(lhs, rhs).limbs) == u64_5_as_nat(lhs.limbs)\n        + u64_5_as_nat(rhs.limbs)) by {\n        lemma_u64_5_as_nat_add(lhs.limbs, rhs.limbs);\n    }\n\n    // trivial consequence: x = y + z => x % p = (y + z) % p\n    // Remains to show (y + z) % p = (y % p + z % p) % p\n\n    assert((u64_5_as_nat(lhs.limbs) + u64_5_as_nat(rhs.limbs)) % p() == (u64_5_as_nat(lhs.limbs)\n        % p() + u64_5_as_nat(rhs.limbs) % p()) % p()) by {\n        assert(p() > 0) by {\n            pow255_gt_19();\n        }\n        lemma_add_mod_noop(\n            u64_5_as_nat(lhs.limbs) as int,\n            u64_5_as_nat(rhs.limbs) as int,\n            p() as int,\n        );\n    }\n}",
      "start_line": 14,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/pow2_mul_div_mod_small_div_u8_t51_cond().",
      "display_name": "pow2_mul_div_mod_small_div_u8_t51_cond",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/pow2_mul_div_mod_small_div_u8_t51_cond().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn pow2_mul_div_mod_small_div_u8_t51_cond(k: nat, j: nat) -> bool {\n    (k <= j * 8) && (8 + j * 8 - k <= 51)\n}",
      "start_line": 716,
      "end_line": 56,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduce_cancels_r().",
      "display_name": "lemma_montgomery_reduce_cancels_r",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduce_cancels_r().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "file_name": "scalar_lemmas_extra.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_montgomery_reduce_cancels_r(\n    after_nat: nat,\n    before_nat: nat,\n    const_nat: nat,\n    extra_factor: nat,\n)\n    requires\n// const_nat is congruent to extra_factor * R mod L\n\n        const_nat % group_order() == (extra_factor * montgomery_radix()) % group_order(),\n        // From montgomery_reduce: (after * R) % L == (before * const_nat) % L\n        (after_nat * montgomery_radix()) % group_order() == (before_nat * const_nat)\n            % group_order(),\n    ensures\n        after_nat % group_order() == (before_nat * extra_factor) % group_order(),\n        // Also establish the intermediate form needed by Stage 5\n        (after_nat * montgomery_radix()) % group_order() == (before_nat * extra_factor\n            * montgomery_radix()) % group_order(),\n{\n    // Establish: (before * const_nat) % L == (before * extra_factor * R) % L\n    lemma_mul_factors_congruent_implies_products_congruent(\n        before_nat as int,\n        (extra_factor * montgomery_radix()) as int,\n        const_nat as int,\n        group_order() as int,\n    );\n    // Associativity: before * extra_factor * R\n    lemma_mul_is_associative(before_nat as int, extra_factor as int, montgomery_radix() as int);\n    // Cancel the R multiplication\n    lemma_cancel_mul_pow2_mod(after_nat, before_nat * extra_factor, montgomery_radix());\n}",
      "start_line": 548,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "display_name": "sum_of_limbs_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn sum_of_limbs_bounded(\n    fe1: &FieldElement51,\n    fe2: &FieldElement51,\n    bound: u64,\n) -> bool {\n    forall|i: int| 0 <= i < 5 ==> fe1.limbs[i] + fe2.limbs[i] < bound\n}",
      "start_line": 32,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 18,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_ed25519_basepoint().",
      "display_name": "spec_ed25519_basepoint",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_ed25519_basepoint().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_ed25519_basepoint() -> (nat, nat) {\n    (u64_5_as_nat(ED25519_BASEPOINT_POINT.X.limbs), u64_5_as_nat(ED25519_BASEPOINT_POINT.Y.limbs))\n}",
      "start_line": 58,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/all_neg_limbs_positive().",
      "display_name": "all_neg_limbs_positive",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/all_neg_limbs_positive().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/negate_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/negate_lemmas.rs",
      "file_name": "negate_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn all_neg_limbs_positive(limbs: [u64; 5]) -> bool {\n    &&& 36028797018963664u64 >= limbs[0]\n    &&& 36028797018963952u64 >= limbs[1]\n    &&& 36028797018963952u64 >= limbs[2]\n    &&& 36028797018963952u64 >= limbs[3]\n    &&& 36028797018963952u64 >= limbs[4]\n}",
      "start_line": 19,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_common_divisor_divides_gcd().",
      "display_name": "lemma_common_divisor_divides_gcd",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_common_divisor_divides_gcd().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_common_divisor_divides_gcd(a: nat, b: nat, d: nat)\n    requires\n        d > 0,\n        a % d == 0,\n        b % d == 0,\n    ensures\n        spec_gcd(a, b) % d == 0,\n    decreases b,\n{\n    if b == 0 {\n        // gcd(a, 0) = a, and d | a by assumption\n    } else {\n        let q = a / b;\n        let r = a % b;\n\n        lemma_fundamental_div_mod(a as int, b as int);\n\n        assert((b * q) % d == 0) by {\n            lemma_mul_mod_noop_right(q as int, b as int, d as int);\n            lemma_mul_is_commutative(q as int, b as int);\n        };\n\n        assert(r % d == 0) by {\n            lemma_sub_mod_noop(a as int, (b * q) as int, d as int);\n        };\n\n        lemma_common_divisor_divides_gcd(b, r, d);\n    }\n}",
      "start_line": 124,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#unwrap().",
      "display_name": "unwrap",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#unwrap().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_internal_no_overflow().",
      "display_name": "lemma_mul_internal_no_overflow",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_internal_no_overflow().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_mul_internal_no_overflow()\n    ensures\n        (1u128 << 104) + (1u128 << 104) == (1u128 << 105),\n        3u128 * (1u128 << 104) < (1u128 << 106),\n        4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104),\n        (1u128 << 2) * (1u128 << 104) == (1u128 << 106),\n        8u128 == (1u128 << 3),\n        (1u128 << 3) * (1u128 << 104) == (1u128 << 107),\n{\n    assert((1u128 << 104) + (1u128 << 104) == (1u128 << 105)) by (bit_vector);\n    assert(3u128 * (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert(4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104)) by (bit_vector);\n    assert((1u128 << 2) * (1u128 << 104) == (1u128 << 106)) by (bit_vector);\n    assert(8u128 == (1u128 << 3)) by (bit_vector);\n    assert((1u128 << 3) * (1u128 << 104) == (1u128 << 107)) by (bit_vector);\n}",
      "start_line": 121,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sign_bit_after_conditional_negate().",
      "display_name": "lemma_sign_bit_after_conditional_negate",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sign_bit_after_conditional_negate().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_sign_bit_after_conditional_negate(x: nat, sign_bit: u8)\n    requires\n        (x % p()) % 2 == 0,  // x is non-negative root (LSB = 0)\n        sign_bit == 0 || sign_bit == 1,\n        sign_bit == 1 ==> x % p() != 0,  // if asking for odd, x ≠ 0\n    ensures\n        ({\n            let result = if sign_bit == 1 { math_field_neg(x) } else { x % p() };\n            (result % 2) as u8 == sign_bit\n        }),",
      "start_line": 357,
      "end_line": 53,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "display_name": "lemma_as_bytes_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub proof fn lemma_as_bytes_52(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 52),\n        bytes_match_limbs_packing_52(limbs, bytes),\n    ensures\n        u8_32_as_nat(&bytes) == five_limbs_to_nat_aux(limbs) % pow2(256),\n{\n    // Connect the bit shift in the requires clause to pow2 for clarity\n    assert((1u64 << 52) == pow2(52)) by {\n        lemma_shift_is_pow2(52);\n    }\n\n    assert(five_limbs_to_nat_aux(limbs) % pow2(256) == (limbs[0] as nat) + pow2(52) * (\n    limbs[1] as nat) + pow2(104) * (limbs[2] as nat) + pow2(156) * (limbs[3] as nat) + (pow2(208)\n        * (limbs[4] as nat)) % pow2(256)) by {\n        assert(limbs[0] as nat <= pow2(52) - 1 < pow2(52) < pow2(256)) by {\n            lemma_pow2_strictly_increases(52, 256);\n        }\n        assert(pow2(52) * (limbs[1] as nat) <= pow2(104) - pow2(52) < pow2(104) < pow2(256)) by {\n            lemma_pow2_mul_bound_general(limbs[1] as nat, 52, 52);\n            lemma_pow2_pos(52);\n            lemma_pow2_strictly_increases(104, 256);\n        }\n        assert(pow2(104) * (limbs[2] as nat) <= pow2(156) - pow2(104) < pow2(156) < pow2(256)) by {\n            lemma_pow2_mul_bound_general(limbs[2] as nat, 52, 104);\n            lemma_pow2_pos(104);\n            lemma_pow2_strictly_increases(156, 256);\n        }\n        assert(pow2(156) * (limbs[3] as nat) <= pow2(208) - pow2(156) < pow2(208) < pow2(256)) by {\n            lemma_pow2_mul_bound_general(limbs[3] as nat, 52, 156);\n            lemma_pow2_pos(156);\n            lemma_pow2_strictly_increases(208, 256);\n        }\n        lemma_binary_sum_mod_decomposition(\n            (limbs[0] as nat) + pow2(52) * (limbs[1] as nat) + pow2(104) * (limbs[2] as nat) + pow2(\n                156,\n            ) * (limbs[3] as nat),\n            limbs[4] as nat,\n            208,\n            256,\n        );\n        lemma_binary_sum_mod_decomposition(\n            (limbs[0] as nat) + pow2(52) * (limbs[1] as nat) + pow2(104) * (limbs[2] as nat),\n            limbs[3] as nat,\n            156,\n            256,\n        );\n        lemma_binary_sum_mod_decomposition(\n            (limbs[0] as nat) + pow2(52) * (limbs[1] as nat),\n            limbs[2] as nat,\n            104,\n            256,\n        );\n        lemma_binary_sum_mod_decomposition(limbs[0] as nat, limbs[1] as nat, 52, 256);\n        assert((limbs[0] as nat) % pow2(256) == limbs[0] as nat) by {\n            lemma_small_mod(limbs[0] as nat, pow2(256));\n        }\n        assert((pow2(52) * (limbs[1] as nat)) % pow2(256) == pow2(52) * (limbs[1] as nat)) by {\n            lemma_small_mod(pow2(52) * (limbs[1] as nat), pow2(256))\n        }\n        assert((pow2(104) * (limbs[2] as nat)) % pow2(256) == pow2(104) * (limbs[2] as nat)) by {\n            lemma_small_mod(pow2(104) * (limbs[2] as nat), pow2(256))\n        }\n        assert((pow2(156) * (limbs[3] as nat)) % pow2(256) == pow2(156) * (limbs[3] as nat)) by {\n            lemma_small_mod(pow2(156) * (limbs[3] as nat), pow2(256))\n        }\n    }\n\n    assert((pow2(208) * (limbs[4] as nat)) % pow2(256) == ((limbs[4] as nat) % pow2(48)) * pow2(\n        208,\n    )) by {\n        lemma_mul_is_commutative(pow2(208) as int, limbs[4] as int);\n        lemma_pow2_mul_mod(limbs[4] as nat, 208, 256);\n    }\n\n    // Establish that each limb is bounded by pow2(52)\n    //assert(forall |i: int| 0 <= i < 5 ==> limbs[i] < pow2(52));\n\n    assert(u8_32_as_nat(&bytes) == limb0_byte_contribution_52(limbs, bytes)\n        + limb1_byte_contribution_52(limbs, bytes) + limb2_byte_contribution_52(limbs, bytes)\n        + limb3_byte_contribution_52(limbs, bytes) + limb4_byte_contribution_52(limbs, bytes)) by {\n        lemma_sum_equals_byte_nat_52(limbs, bytes);\n    }\n\n    assert((limbs[0] as nat) % pow2(52) == limbs[0]) by {\n        lemma_small_mod(limbs[0] as nat, pow2(52));\n    }\n    assert(u8_32_as_nat(&bytes) == five_limbs_to_nat_aux(limbs) % pow2(256)) by {\n        lemma_limb0_contribution_correctness_52(limbs, bytes);\n        lemma_limb1_contribution_correctness_52(limbs, bytes);\n        lemma_limb2_contribution_correctness_52(limbs, bytes);\n        lemma_limb3_contribution_correctness_52(limbs, bytes);\n        lemma_limb4_contribution_correctness_52(limbs, bytes);\n    }\n}",
      "start_line": 144,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 23
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_optional_multiscalar_mul().",
      "display_name": "straus_optional_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_optional_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "backend",
      "body": "pub fn straus_optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator<Item = Option<EdwardsPoint>>,\n{\n    use crate::traits::VartimeMultiscalarMul;\n\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 => {\n        //     vector::scalar_mul::straus::spec_avx2::Straus::optional_multiscalar_mul::<I, J>(\n        //         scalars, points,\n        //     )\n        // }\n        // #[cfg(all(curve25519_dalek_backend = \"simd\", nightly))]\n        // BackendKind::Avx512 => {\n        //     vector::scalar_mul::straus::spec_avx512ifma_avx512vl::Straus::optional_multiscalar_mul::<\n        //         I,\n        //         J,\n        //     >(scalars, points)\n        // }\n        BackendKind::Serial => {\n            serial::scalar_mul::straus::Straus::optional_multiscalar_mul::<I, J>(scalars, points)\n        }\n    }\n}",
      "start_line": 215,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_to_le_bytes().",
      "display_name": "u128_to_le_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_to_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub fn u128_to_le_bytes(x: u128) -> (bytes: [u8; 16])\n    ensures\n        bytes_seq_to_nat(seq_from16(&bytes)) == x as nat,\n{\n    x.to_le_bytes()\n}",
      "start_line": 111,
      "end_line": 24,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_power_chain().",
      "display_name": "lemma_invert_power_chain",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_power_chain().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "file_name": "invert_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_invert_power_chain(\n    self_fe: &FieldElement51,\n    t19: &FieldElement51,\n    t20: &FieldElement51,\n    t3: &FieldElement51,\n    t21: &FieldElement51,\n)\n    requires\n// From pow22501 postcondition\n\n        spec_field_element(t19) == (pow(\n            spec_field_element(self_fe) as int,\n            (pow2(250) - 1) as nat,\n        ) as nat) % p(),\n        spec_field_element(t3) == (pow(spec_field_element(self_fe) as int, 11) as nat) % p(),\n        // From pow2k postcondition (using limb-level form as provided by pow2k)\n        u64_5_as_nat(t20.limbs) % p() == (pow(u64_5_as_nat(t19.limbs) as int, pow2(5)) as nat)\n            % p(),\n        // From mul postcondition\n        spec_field_element(t21) == math_field_mul(spec_field_element(t20), spec_field_element(t3)),\n    ensures\n// Power expression form for t20\n\n        spec_field_element(t20) == (pow(\n            spec_field_element(self_fe) as int,\n            (pow2(255) - 32) as nat,\n        ) as nat) % p(),\n        // Simple form for t21 using math_field_mul expansion\n        spec_field_element(t21) == (spec_field_element(t20) * spec_field_element(t3)) % p(),\n{\n    // PART 1: Establish spec_field_element(t20) through the chain of lemmas\n    // Chain: spec_field_element(t20) [lifting lemma]\n    //     == (pow(spec_field_element(t19), 2^5) as nat) % p() [composition lemma]\n    //     == (pow(x, (2^250 - 1) * 2^5) as nat) % p() [arithmetic]\n    //     == (pow(x, 2^255 - 32) as nat) % p()\n    // Step 1: Lift from limb-level to field-level using the lifting lemma\n    assert(spec_field_element(t20) == (pow(spec_field_element(t19) as int, pow2(5)) as nat) % p())\n        by {\n        // pow2(5) > 0, required by the lifting lemma\n        assert(pow2(5) > 0) by {\n            lemma_pow2_pos(5);\n        }\n        // The lifting lemma derives field-level postcondition from pow2k's limb-level postcondition\n        lemma_pow2k_to_field_element(t19, t20, pow2(5) as nat);\n    }\n\n    // Step 2: Apply composition lemma to combine powers\n    let x = spec_field_element(self_fe);\n    assert((pow(spec_field_element(t19) as int, pow2(5)) as nat) % p() == (pow(\n        x as int,\n        ((pow2(250) - 1) * pow2(5)) as nat,\n    ) as nat) % p()) by {\n        // Establish preconditions for the composition lemma\n        assert((pow2(250) - 1) > 0) by {\n            lemma_pow2_pos(250);\n            assert(pow2(250) > 1) by {\n                lemma2_to64();\n                lemma_pow2_strictly_increases(0, 250);\n            }\n        }\n        assert(pow2(5) > 0) by {\n            lemma_pow2_pos(5);\n        }\n        assert(p() > 0) by {\n            pow255_gt_19();\n        }\n\n        // Apply the composition lemma\n        lemma_pow_mod_composition(x, (pow2(250) - 1) as nat, pow2(5) as nat, p());\n    }\n\n    // Step 3: Use arithmetic fact: (2^250 - 1) * 2^5 = 2^255 - 32\n    assert((pow(x as int, ((pow2(250) - 1) * pow2(5)) as nat) as nat) % p() == (pow(\n        x as int,\n        (pow2(255) - 32) as nat,\n    ) as nat) % p()) by {\n        assert((pow2(250) - 1) * pow2(5) == pow2(255) - 32) by {\n            lemma_invert_exponent_arithmetic();\n        };\n    }\n}",
      "start_line": 146,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 13
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/group_order_exec().",
      "display_name": "group_order_exec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/group_order_exec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn group_order_exec() -> BigUint {\n        // L = 2^252 + 27742317777372353535851937790883648493\n        let base = BigUint::one() << 252;\n        let offset = BigUint::parse_bytes(b\"27742317777372353535851937790883648493\", 10).unwrap();\n        base + offset\n    }",
      "start_line": 1243,
      "end_line": 28,
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "display_name": "lemma_product_of_multiples_mod_eq_factorial",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_product_of_multiples_mod_eq_factorial(a: nat, p: nat)\n    requires\n        is_prime(p),\n        a % p != 0,\n    ensures\n        (product_of_multiples(a, (p - 1) as nat)) % p == factorial((p - 1) as nat) % p,\n{\n    let n = (p - 1) as nat;\n\n    // Base case: p = 2\n    if p == 2 {\n        assert(product_of_multiples(a, 1) == 1 * a * product_of_multiples(a, 0));\n        assert(product_of_multiples(a, 0) == 1);\n        assert(product_of_multiples(a, 1) == a) by {\n            lemma_mul_basics(a as int);\n        };\n        assert(factorial(1) == 1) by {\n            assert(factorial(1) == 1 * factorial(0));\n            assert(factorial(0) == 1);\n            lemma_mul_basics(1int);\n        };\n        // a % 2 != 0 and a % 2 < 2, so a % 2 == 1\n        lemma_mod_bound(a as int, 2);\n        lemma_small_mod(1nat, 2nat);\n        return ;\n    }\n    // For p > 2, we use the bijection argument combined with Fermat's Little Theorem\n    // product_of_multiples(a, n) = a^n * n! by lemma_product_of_multiples_eq\n\n    lemma_product_of_multiples_eq(a, n);\n\n    // We need to show (a^n * n!) % p == n! % p\n    // This is equivalent to showing a^n ≡ 1 (mod p)\n\n    // Reduce a mod p\n    let a_red = a % p;\n    assert(a_red < p) by {\n        lemma_mod_bound(a as int, p as int);\n    };\n    assert(a_red != 0);\n\n    // Prove a_red^p ≡ a_red (mod p) using induction\n    lemma_fermat_strong(a_red, p);\n\n    // pow(a_red, p) = a_red * pow(a_red, p-1)\n    assert(pow(a_red as int, p) == (a_red as int) * pow(a_red as int, n)) by {\n        reveal(pow);\n        assert(p == n + 1);\n    };\n\n    // Since a_red < p, a_red % p == a_red\n    assert(a_red % p == a_red) by {\n        lemma_small_mod(a_red, p);\n    };\n\n    // Show that a_red * pow(a_red, n) > 0\n    assert(a_red > 0);\n    lemma_pow_positive(a_red as int, n);\n    assert(pow(a_red as int, n) >= 1);\n    lemma_mul_strictly_positive(a_red as int, pow(a_red as int, n));\n\n    let product = (a_red as int) * pow(a_red as int, n);\n    assert(product > 0);\n    assert((product as nat) % p == a_red);\n    assert(product % (p as int) == (a_red as int));\n    assert(((a_red as int) * pow(a_red as int, n)) % (p as int) == (a_red as int));\n\n    // Show pow(a_red, n) >= 0\n    assert(pow(a_red as int, n) >= 0) by {\n        lemma_pow_positive(a_red as int, n);\n    };\n\n    // Use the multiplicative cancellation lemma to get pow(a_red, n) % p == 1\n    lemma_fermat_cancellation(a_red, n, p);\n\n    // pow(a, n) % p == pow(a_red, n) % p == 1\n    lemma_pow_mod_noop(a as int, n, p as int);\n    lemma_pow_nonnegative(a as int, n);\n\n    let pow_a_red_n = pow(a_red as int, n);\n    let pow_a_n = pow(a as int, n);\n\n    assert(pow_a_red_n % (p as int) == 1);\n    assert(pow_a_n % (p as int) == 1);\n    assert((pow(a as int, n) as nat) % p == 1);\n\n    // Now for the product equality:\n    // product_of_multiples(a, n) = a^n * n!\n    // (a^n * n!) % p == ((a^n % p) * (n! % p)) % p == (1 * (n! % p)) % p == n! % p\n    let pow_a_n = pow(a as int, n) as nat;\n    let fact_n = factorial(n);\n\n    assert((pow_a_n * fact_n) % p == fact_n % p) by {\n        assert(pow_a_n % p == 1);\n        lemma_mul_mod_noop_general(pow_a_n as int, fact_n as int, p as int);\n        lemma_mul_basics((fact_n % p) as int);\n        lemma_mod_bound(fact_n as int, p as int);\n    };\n}",
      "start_line": 1356,
      "end_line": 57,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 16
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_to_nat_gen_u64().",
      "display_name": "words_to_nat_gen_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_to_nat_gen_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn words_to_nat_gen_u64(words: &[u64], num_words: int, bits_per_word: int) -> nat\n    decreases num_words,\n{\n    if num_words <= 0 {\n        0\n    } else {\n        let word_value = (words[num_words - 1] as nat) * pow2(\n            ((num_words - 1) * bits_per_word) as nat,\n        );\n        word_value + words_to_nat_gen_u64(words, num_words - 1, bits_per_word)\n    }\n}",
      "start_line": 105,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_sum_simplify().",
      "display_name": "lemma_add_sum_simplify",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_sum_simplify().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_add_sum_simplify(a: &Scalar52, b: &Scalar52, sum: &Scalar52, carry: u64)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        to_nat(&a.limbs) < group_order(),\n        to_nat(&b.limbs) < group_order(),\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n        (carry >> 52) < 2,\n        seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) + (carry >> 52) as nat * pow2(\n            (52 * (5) as nat),\n        ),\n    ensures\n        to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs),\n{\n    // First establish the relationship between the different representations\n    assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs)) by {\n        assert(a.limbs@ == a.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(a.limbs@) == to_nat(&a.limbs));\n    }\n    assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs)) by {\n        assert(b.limbs@ == b.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(b.limbs@) == to_nat(&b.limbs));\n    }\n    assert(seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) == to_nat(&sum.limbs)) by {\n        assert(sum.limbs@ == sum.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(sum.limbs@) == to_nat(&sum.limbs));\n    }\n\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs) + (carry >> 52) * pow2(\n        (52 * (5) as nat),\n    ));\n\n    // From the loop invariant, we have: a + b == sum + (carry >> 52) * 2^260\n    assert(52 * 5 == 260) by (compute);\n    assert(pow2((52 * 5) as nat) == pow2(260));\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(\n        260,\n    ));\n\n    // Since a < group_order() and b < group_order(), we have a + b < 2 * group_order()\n    // This is just basic arithmetic: if x < A and y < A, then x + y < A + A = 2*A\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) < group_order() + group_order());\n    assert(group_order() + group_order() == 2 * group_order());\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) < 2 * group_order());\n\n    // Therefore: sum + (carry >> 52) * 2^260 < 2 * group_order()\n    assert(to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260) < 2 * group_order());\n\n    // Prove a contradiction if carry is nonzero\n    assert((carry >> 52) as nat * pow2(260) < 2 * group_order());\n    if carry >> 52 == 1 {\n        lemma_pow2_260_greater_than_2_group_order();\n        assert(1 as nat * pow2(260) < 2 * group_order());\n        assert(false);\n    }\n    assert(carry >> 52 == 0);\n\n    // Since carry >> 52 >= 0 and pow2(260) > 0, we have (carry >> 52) * pow2(260) >= 0\n    // Therefore sum < sum + (carry >> 52) * pow2(260) < 2 * group_order()\n    lemma_pow2_pos(260);\n    assert(pow2(260) > 0);\n    assert((carry >> 52) as nat * pow2(260) >= 0);\n    assert(to_nat(&sum.limbs) <= to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260));\n    assert(to_nat(&sum.limbs) < 2 * group_order());\n}",
      "start_line": 1517,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "display_name": "from_bytes_wide",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn from_bytes_wide(bytes: &[u8; 64]) -> (s: Scalar52)\n        ensures\n            limbs_bounded(&s),\n            to_nat(&s.limbs) % group_order() == bytes_wide_to_nat(bytes) % group_order(),\n            // VERIFICATION NOTE: Result is canonical\n            to_nat(&s.limbs) < group_order(),\n    {\n        let ghost wide_input = bytes_wide_to_nat(bytes);\n\n        // Stage 1 assumption: the byte-to-word packing yields the expected little-endian value.\n        let mut words = [0u64;8];\n        for i in 0..8\n            invariant\n                forall|k: int|\n                    #![auto]\n                    0 <= k < i ==> words@[k] as nat == word_from_bytes(bytes, k),\n                words_from_bytes_to_nat(bytes, i as int) + bytes_wide_to_nat_rec(\n                    bytes,\n                    (i as int) * 8,\n                ) == bytes_wide_to_nat(bytes),\n                forall|k: int| i <= k < 8 ==> words@[k] == 0,\n        {\n            let offset = i * 8;\n            let _offset_end = offset + 7usize;\n            proof {\n                // offset + 7 = i*8 + 7 <= 7*8 + 7 = 63 < 64 = bytes.len()\n                assert(_offset_end < 64);\n            }\n            let chunk = load8_at(bytes, offset);\n            words[i] = chunk;\n\n            proof {\n                let i_int = i as int;\n                // spec_load8_at uses pow2(k*8) * byte, word_from_bytes uses byte * pow2(k*8)\n                assert(spec_load8_at(bytes, (i_int * 8) as usize) == word_from_bytes(bytes, i_int))\n                    by {\n                    broadcast use lemma_mul_is_commutative;\n\n                };\n                assert forall|k: int| i + 1 <= k < 8 implies words@[k] == 0 by {\n                    assert(words@[#[trigger] k] == 0);\n                };\n                reveal_with_fuel(words_from_bytes_to_nat, 9);\n                assert(bytes_wide_to_nat_rec(bytes, i_int * 8) == word_from_bytes(bytes, i_int)\n                    * pow2((i_int * 64) as nat) + bytes_wide_to_nat_rec(bytes, (i_int + 1) * 8))\n                    by {\n                    lemma_bytes_wide_to_nat_rec_matches_word_partial(bytes, i_int, 8);\n                    broadcast use lemma_mul_is_commutative;\n\n                };\n            }\n        }\n\n        proof {\n            lemma_words_to_nat_gen_u64_prefix_matches_bytes(&words, bytes, 8);\n        }\n\n        // Stage 2 word bounds: every assembled chunk fits in 64 bits.\n        assert forall|k: int| 0 <= k < 8 implies words[k] < pow2(64) by {\n            let idx = (k * 8) as usize;\n            lemma_spec_load8_at_fits_u64(bytes, idx);\n            // spec_load8_at uses pow2(k*8) * byte, word_from_bytes uses byte * pow2(k*8)\n            assert(spec_load8_at(bytes, idx) == word_from_bytes(bytes, k)) by {\n                broadcast use lemma_mul_is_commutative;\n\n            };\n            lemma2_to64_rest();  // u64::MAX == pow2(64) - 1\n        };\n\n        proof {\n            assert(1u64 << 52 > 0) by (bit_vector);\n        }\n        let mask = (1u64 << 52) - 1;\n        let mut lo = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        let mut hi = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n\n        lo.limbs[0] = words[0] & mask;\n        lo.limbs[1] = ((words[0] >> 52) | (words[1] << 12)) & mask;\n        lo.limbs[2] = ((words[1] >> 40) | (words[2] << 24)) & mask;\n        lo.limbs[3] = ((words[2] >> 28) | (words[3] << 36)) & mask;\n        lo.limbs[4] = ((words[3] >> 16) | (words[4] << 48)) & mask;\n        hi.limbs[0] = (words[4] >> 4) & mask;\n        hi.limbs[1] = ((words[4] >> 56) | (words[5] << 8)) & mask;\n        hi.limbs[2] = ((words[5] >> 44) | (words[6] << 20)) & mask;\n        hi.limbs[3] = ((words[6] >> 32) | (words[7] << 32)) & mask;\n        hi.limbs[4] = words[7] >> 20;\n\n        // Stage 3: the masked limbs contributed by each 64-bit word remain below 2^52.\n        let ghost lo_raw = lo;\n        let ghost hi_raw = hi;\n\n        proof {\n            lemma_lo_limbs_bounded(&lo_raw, &words, mask);\n            lemma_hi_limbs_bounded(&hi_raw, &words, mask);\n        }\n\n        let ghost pow2_260 = pow2(260);\n        let ghost low_expr = (words[0] as nat) + pow2(64) * (words[1] as nat) + pow2(128) * (\n        words[2] as nat) + pow2(192) * (words[3] as nat) + pow2(256) * ((words[4] & 0xf) as nat);\n\n        let ghost high_expr = (words[4] >> 4) as nat + pow2(60) * (words[5] as nat) + pow2(124) * (\n        words[6] as nat) + pow2(188) * (words[7] as nat);\n\n        let ghost wide_sum = (words[0] as nat) + pow2(64) * (words[1] as nat) + pow2(128) * (\n        words[2] as nat) + pow2(192) * (words[3] as nat) + pow2(256) * (words[4] as nat) + pow2(320)\n            * (words[5] as nat) + pow2(384) * (words[6] as nat) + pow2(448) * (words[7] as nat);\n\n        proof {\n            // Reading the five 52-bit limbs in radix 2^52 reproduces the low chunk reconstructed from the 64-bit words.\n            lemma_low_limbs_encode_low_expr(&lo_raw.limbs, &words, mask);\n            lemma_five_limbs_equals_to_nat(&lo_raw.limbs);\n            // Reading the five 52-bit limbs in radix 2^52 reproduces the high chunk reconstructed from the 64-bit words.\n            lemma_high_limbs_encode_high_expr(&hi_raw.limbs, &words, mask);\n            lemma_five_limbs_equals_to_nat(&hi_raw.limbs);\n        }\n        assert(to_nat(&hi_raw.limbs) == high_expr);\n\n        // Assumption [L2]: The 512-bit input splits as `pow2(260) * high_expr + low_expr`.\n        // WideSum-Expansion: converting the eight 64-bit words back into a natural number matches the explicit little-endian sum of their weighted contributions.\n        proof {\n            lemma_words_from_bytes_to_nat_wide(bytes);\n        }\n\n        // HighLow-Recombine: Combining the high and low chunks at the 2^260 boundary reproduces the weighted word sum.\n        // Bridge bit operations to arithmetic operations for word4\n        let ghost word4 = words[4];\n        let ghost word4_high_nat = (word4 >> 4) as nat;\n        let ghost word4_low_nat = (word4 & 0xf) as nat;\n        // word4 >> 4 == word4 / 16 and word4 & 0xf == word4 % 16 (for u64)\n        assert(word4_high_nat == (word4 as nat) / 16 && word4_low_nat == (word4 as nat) % 16) by {\n            assert(word4 >> 4 == word4 / 16 && word4 & 0xf == word4 % 16) by (bit_vector)\n                requires\n                    word4 == word4,\n            ;\n        };\n        proof {\n            lemma_high_low_recombine(\n                words[0] as nat,\n                words[1] as nat,\n                words[2] as nat,\n                words[3] as nat,\n                word4 as nat,\n                words[5] as nat,\n                words[6] as nat,\n                words[7] as nat,\n                word4_low_nat,\n                word4_high_nat,\n            );\n        }\n\n        assert(wide_input == pow2_260 * high_expr + low_expr);\n        // L3: The lower chunk has value strictly below 2^260.\n        proof {\n            lemma_bound_scalar(&lo_raw);\n        }\n        assert(low_expr < pow2_260);\n\n        // Assumption: The lower bits of the wide input, modulo 2^260, match the natural value encoded by `lo_raw`.\n        assert(to_nat(&lo_raw.limbs) == wide_input % pow2(260)) by {\n            lemma_mod_multiples_vanish(high_expr as int, low_expr as int, pow2_260 as int);\n            lemma_small_mod(low_expr, pow2_260);\n        };\n        // Assumption: The upper bits of the wide input, divided by 2^260, match the natural value encoded by `hi_raw`.\n        assert(to_nat(&hi_raw.limbs) == wide_input / pow2(260)) by {\n            lemma_fundamental_div_mod_converse(\n                wide_input as int,\n                pow2_260 as int,\n                high_expr as int,\n                low_expr as int,\n            );\n        };\n        // Recombining quotient and remainder at the 2^260 radix recreates the original wide input.\n        assert(high_expr < pow2(252)) by {\n            lemma_words_to_nat_gen_u64_bound_le(&words, 8);\n            lemma_pow2_adds(260, 252);\n            assert(pow2_260 * pow2(252) == pow2(512));\n            lemma_multiply_divide_lt(wide_input as int, pow2_260 as int, pow2(252) as int);\n        };\n\n        // Stage 4 assumption: Montgomery reductions behave as expected for these operands.\n        proof {\n            lemma_r_limbs_bounded();  // had to write this one manually due to crashes\n            lemma_rr_limbs_bounded();\n        }\n\n        let lo_product = Scalar52::mul_internal(&lo, &constants::R);\n        lo = Scalar52::montgomery_reduce(&lo_product);  // (lo * R) / R = lo\n        let hi_product = Scalar52::mul_internal(&hi, &constants::RR);\n        hi = Scalar52::montgomery_reduce(&hi_product);  // (hi * R^2) / R = hi * R\n\n        proof {\n            let ghost lo_before_nat = to_nat(&lo_raw.limbs);\n            let ghost lo_after_nat = to_nat(&lo.limbs);\n            let ghost r_nat = to_nat(&constants::R.limbs);\n            lemma_r_equals_spec(constants::R);\n            // lo: multiply by R, reduce => extra_factor = 1\n            lemma_montgomery_reduce_cancels_r(lo_after_nat, lo_before_nat, r_nat, 1);\n\n            let ghost hi_before_nat = to_nat(&hi_raw.limbs);\n            let ghost hi_after_nat = to_nat(&hi.limbs);\n            let ghost rr_nat = to_nat(&constants::RR.limbs);\n            lemma_rr_equals_spec(constants::RR);\n            // hi: multiply by R², reduce => extra_factor = R\n            lemma_montgomery_reduce_cancels_r(\n                hi_after_nat,\n                hi_before_nat,\n                rr_nat,\n                montgomery_radix(),\n            );\n        }\n\n        let result = Scalar52::add(&hi, &lo);\n\n        // Stage 5 assumption: combining the reduced pieces matches the wide scalar modulo L.\n        proof {\n            lemma_montgomery_reduced_sum_congruent(\n                to_nat(&result.limbs),\n                to_nat(&hi.limbs),\n                to_nat(&lo.limbs),\n                to_nat(&hi_raw.limbs),\n                to_nat(&lo_raw.limbs),\n                wide_input,\n            );\n\n            lemma_cancel_mul_pow2_mod(to_nat(&result.limbs), wide_input, montgomery_radix());\n        }\n\n        result\n    }",
      "start_line": 181,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 39
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/wrapping_mul().",
      "display_name": "wrapping_mul",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/wrapping_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "display_name": "lemma_load8_shift_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_load8_shift_mod(input: &[u8], i: usize, s64: u64, t: nat)\n    requires\n        i + 7 < input.len(),\n        s64 < 64,\n        t < 64,\n    ensures\n        (spec_load8_at(input, i) as u64 >> s64) & (low_bits_mask(t) as u64) == ((pow2(0 * 8)\n            * input[i + 0]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(1 * 8)\n            * input[i + 1]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(2 * 8)\n            * input[i + 2]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(3 * 8)\n            * input[i + 3]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(4 * 8)\n            * input[i + 4]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(5 * 8)\n            * input[i + 5]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(6 * 8)\n            * input[i + 6]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(7 * 8)\n            * input[i + 7]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64),\n{\n    let x = spec_load8_at(input, i) as u64;\n    let y = load8_at_plus_version_rec(input, i, 7);\n    let s = s64 as nat;\n    let ps64 = pow2(s) as u64;\n\n    assert(0 < pow2(s) <= u64::MAX) by {\n        lemma_pow2_pos(s);\n        lemma_pow2_le_max64(s);\n    }\n\n    assert(x >> s64 == x / ps64) by {\n        lemma_u64_shr_is_div(x, s64);\n    }\n\n    assert(x == y) by {\n        lemma_load8_at_plus_version_is_spec(input, i);\n    }\n\n    assert forall|j: nat| j <= 7 implies #[trigger] pow2(j * 8) * input[i + j] <= u64::MAX by {\n        assert(pow2(j * 8) * input[i + j] == input[i + j] * pow2(j * 8));\n        lemma_u8_times_pow2_fits_u64(input[i + j], j * 8);\n    }\n\n    assert(y / ps64 == (pow2(0 * 8) * input[i + 0]) as u64 / ps64 + (pow2(1 * 8) * input[i\n        + 1]) as u64 / ps64 + (pow2(2 * 8) * input[i + 2]) as u64 / ps64 + (pow2(3 * 8) * input[i\n        + 3]) as u64 / ps64 + (pow2(4 * 8) * input[i + 4]) as u64 / ps64 + (pow2(5 * 8) * input[i\n        + 5]) as u64 / ps64 + (pow2(6 * 8) * input[i + 6]) as u64 / ps64 + (pow2(7 * 8) * input[i\n        + 7]) as u64 / ps64) by {\n        lemma_load8_plus_ver_div_mod(input, i, 7, s);\n        lemma_load8_plus_ver_div_mod(input, i, 6, s);\n        lemma_load8_plus_ver_div_mod(input, i, 5, s);\n        lemma_load8_plus_ver_div_mod(input, i, 4, s);\n        lemma_load8_plus_ver_div_mod(input, i, 3, s);\n        lemma_load8_plus_ver_div_mod(input, i, 2, s);\n        lemma_load8_plus_ver_div_mod(input, i, 1, s);\n\n        assert(load8_at_plus_version_rec(input, i, 0) == (pow2(0 * 8) * input[i + 0]) as u64) by {\n            assert(load8_at_plus_version_rec(input, i, 0) == (input[i as int] as u64));\n            assert(pow2(0 * 8) == 1) by {\n                lemma2_to64();\n            }\n            assert((pow2(0 * 8) * input[i + 0]) as u64 == (input[i as int] as u64)) by {\n                lemma_mul_basics_4(input[i as int] as int);  // 1 * x = x\n            }\n        }\n    }\n\n    let pt64 = pow2(t) as u64;\n    let z = y / ps64;\n\n    assert(low_bits_mask(t) <= u64::MAX) by {\n        lemma_low_bits_masks_fit_u64(t);\n    }\n\n    assert(z & (low_bits_mask(t) as u64) == z % pt64) by {\n        lemma_u64_low_bits_mask_is_mod(z, t);\n    }\n\n    assert forall|j: nat| 0 <= j <= 7 implies #[trigger] pow2(j * 8) > 0 by {\n        lemma_pow2_pos(j * 8);\n    }\n\n    assert forall|j: nat| 0 <= j <= 7 implies #[trigger] (pow2(j * 8) * input[i + j]) <= pow2(\n        (j + 1) * 8,\n    ) - pow2(j * 8) by {\n        assert(j * 8 + 8 == (j + 1) * 8) by {\n            lemma_mul_is_distributive_add_other_way(8, j as int, 1);\n        }\n        lemma_pow2_mul_bound_u8(input[i + j], j * 8);\n    }\n\n    // pow2(_) values;\n    lemma2_to64();\n    lemma2_to64_rest();\n    assert(0 < pow2(t) <= u64::MAX) by {\n        lemma_pow2_pos(t);\n        lemma_pow2_le_max64(t);\n    }\n\n    // ---- lemmas about X * pow2\n    assert forall|j: nat| 0 <= j <= 7 implies #[trigger] pow2(j * 8) * input[i + j]\n        == #[trigger] input[i + j] * pow2(j * 8) by {\n        lemma_mul_is_commutative(pow2(j * 8) as int, input[i + j] as int);\n    }\n\n    assert forall|j: nat| 0 <= j <= 7 implies #[trigger] (pow2(j * 8) * input[i + j]) <= pow2(\n        (j + 1) * 8,\n    ) - pow2(j * 8) && pow2((j + 1) * 8) > pow2(j * 8) by {\n        assert(j * 8 + 8 == (j + 1) * 8) by {\n            lemma_mul_is_distributive_add_other_way(8, j as int, 1);\n        }\n        lemma_pow2_mul_bound_u8(input[i + j], j * 8);\n        assert(pow2((j + 1) * 8) > pow2(j * 8)) by {\n            lemma_pow2_strictly_increases(j * 8, j * 8 + 8);\n        }\n    }\n    // ---- lemmas about X * pow2 <END>\n\n    let a0 = (pow2(0 * 8) * input[i + 0]) as u64;\n    let a1 = (pow2(1 * 8) * input[i + 1]) as u64;\n    let a2 = (pow2(2 * 8) * input[i + 2]) as u64;\n    let a3 = (pow2(3 * 8) * input[i + 3]) as u64;\n    let a4 = (pow2(4 * 8) * input[i + 4]) as u64;\n    let a5 = (pow2(5 * 8) * input[i + 5]) as u64;\n    let a6 = (pow2(6 * 8) * input[i + 6]) as u64;\n    let a7 = (pow2(7 * 8) * input[i + 7]) as u64;\n\n    // Trigger the forall-s\n    assert(a0 == input[i + 0] * pow2(0));\n    assert(a1 == input[i + 1] * pow2(8));\n    assert(a2 == input[i + 2] * pow2(16));\n    assert(a3 == input[i + 3] * pow2(24));\n    assert(a4 == input[i + 4] * pow2(32));\n    assert(a5 == input[i + 5] * pow2(40));\n    assert(a6 == input[i + 6] * pow2(48));\n    assert(a7 == input[i + 7] * pow2(56));\n\n    let s0_0 = a0;\n    let s0 = s0_0 / ps64;\n\n    assert(s0_0 < pow2(1 * 8));\n    assert(s0_0 + a1 <= u64::MAX);\n\n    let s1_0 = (s0_0 + a1) as u64;\n    let s1 = s1_0 / ps64;\n\n    assert(s1_0 < pow2(2 * 8));\n    assert(s1 == s0_0 / ps64 + a1 / ps64) by {\n        lemma_bitops_lifted(s0_0, input[i + 1] as u64, 1 * 8, s);\n    }\n    assert(s1_0 + a2 <= u64::MAX);\n\n    let s2_0 = (s1_0 + a2) as u64;\n    let s2 = s2_0 / ps64;\n\n    assert(s2_0 < pow2(3 * 8));\n    assert(s2 == s1_0 / ps64 + a2 / ps64) by {\n        lemma_bitops_lifted(s1_0, input[i + 2] as u64, 2 * 8, s);\n    }\n    assert(s2_0 + a3 <= u64::MAX);\n\n    let s3_0 = (s2_0 + a3) as u64;\n    let s3 = s3_0 / ps64;\n\n    assert(s3_0 < pow2(4 * 8));\n    assert(s3 == s2_0 / ps64 + a3 / ps64) by {\n        lemma_bitops_lifted(s2_0, input[i + 3] as u64, 3 * 8, s);\n    }\n    assert(s3_0 + a4 <= u64::MAX);\n\n    let s4_0 = (s3_0 + a4) as u64;\n    let s4 = s4_0 / ps64;\n\n    assert(s4_0 < pow2(5 * 8));\n    assert(s4 == s3_0 / ps64 + a4 / ps64) by {\n        lemma_bitops_lifted(s3_0, input[i + 4] as u64, 4 * 8, s);\n    }\n    assert(s4_0 + a5 <= u64::MAX);\n\n    let s5_0 = (s4_0 + a5) as u64;\n    let s5 = s5_0 / ps64;\n\n    assert(s5_0 < pow2(6 * 8));\n    assert(s5 == s4_0 / ps64 + a5 / ps64) by {\n        lemma_bitops_lifted(s4_0, input[i + 5] as u64, 5 * 8, s);\n    }\n    assert(s5_0 + a6 <= u64::MAX);\n\n    let s6_0 = (s5_0 + a6) as u64;\n    let s6 = s6_0 / ps64;\n\n    assert(s6_0 < pow2(7 * 8));\n    assert(s6 == s5_0 / ps64 + a6 / ps64) by {\n        lemma_bitops_lifted(s5_0, input[i + 6] as u64, 6 * 8, s);\n    }\n    assert(s6_0 + a7 <= u64::MAX);\n\n    let s7_0 = (s6_0 + a7) as u64;\n    let s7 = s7_0 / ps64;\n\n    assert(s7 == s6_0 / ps64 + a7 / ps64) by {\n        lemma_bitops_lifted(s6_0, input[i + 7] as u64, 7 * 8, s);\n    }\n\n    assert(s7 == z);\n\n    assert(s6_0 <= pow2(7 * 8) - 1);\n    assert(s5_0 <= pow2(6 * 8) - 1);\n    assert(s4_0 <= pow2(5 * 8) - 1);\n    assert(s3_0 <= pow2(4 * 8) - 1);\n    assert(s2_0 <= pow2(3 * 8) - 1);\n    assert(s1_0 <= pow2(2 * 8) - 1);\n    assert(s0_0 <= pow2(1 * 8) - 1);\n\n    assert(z % pt64 == ((pow2(0 * 8) * input[i + 0]) as u64 / ps64) % pt64 + ((pow2(1 * 8) * input[i\n        + 1]) as u64 / ps64) % pt64 + ((pow2(2 * 8) * input[i + 2]) as u64 / ps64) % pt64 + ((pow2(\n        3 * 8,\n    ) * input[i + 3]) as u64 / ps64) % pt64 + ((pow2(4 * 8) * input[i + 4]) as u64 / ps64) % pt64\n        + ((pow2(5 * 8) * input[i + 5]) as u64 / ps64) % pt64 + ((pow2(6 * 8) * input[i + 6]) as u64\n        / ps64) % pt64 + ((pow2(7 * 8) * input[i + 7]) as u64 / ps64) % pt64) by {\n        lemma_load8_shift_mod_aux(s7_0, s6_0, a7, input[i + 7], 7, s, t);\n        lemma_load8_shift_mod_aux(s6_0, s5_0, a6, input[i + 6], 6, s, t);\n        lemma_load8_shift_mod_aux(s5_0, s4_0, a5, input[i + 5], 5, s, t);\n        lemma_load8_shift_mod_aux(s4_0, s3_0, a4, input[i + 4], 4, s, t);\n        lemma_load8_shift_mod_aux(s3_0, s2_0, a3, input[i + 3], 3, s, t);\n        lemma_load8_shift_mod_aux(s2_0, s1_0, a2, input[i + 2], 2, s, t);\n        lemma_load8_shift_mod_aux(s1_0, s0_0, a1, input[i + 1], 1, s, t);\n    }\n}",
      "start_line": 436,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 19
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_multiply_divide_lt().",
      "display_name": "lemma_multiply_divide_lt",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_multiply_divide_lt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_mul_distributes_over_add().",
      "display_name": "lemma_field_mul_distributes_over_add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_mul_distributes_over_add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "file_name": "field_algebra_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_field_mul_distributes_over_add(a: nat, b: nat, c: nat)\n    ensures\n        math_field_mul(a, math_field_add(b, c)) == math_field_add(math_field_mul(a, b), math_field_mul(a, c)),\n{\n    let p = p();\n    p_gt_2();\n    \n    // Goal: a · (b + c) = a·b + a·c in the field\n    assert(math_field_mul(a, math_field_add(b, c)) == math_field_add(math_field_mul(a, b), math_field_mul(a, c))) by {\n        // Step 1: a * ((b+c) % p) ≡ a * (b+c) (mod p)\n        lemma_mul_mod_noop_right(a as int, (b + c) as int, p as int);\n        \n        // Step 2: a * (b+c) = a*b + a*c (integer distributivity)\n        lemma_mul_is_distributive_add(a as int, b as int, c as int);\n        \n        // Step 3: (a*b + a*c) % p = ((a*b)%p + (a*c)%p) % p\n        lemma_add_mod_noop((a * b) as int, (a * c) as int, p as int);\n    };\n}",
      "start_line": 101,
      "end_line": 50,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_le_implies_div_le().",
      "display_name": "lemma_mul_le_implies_div_le",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_le_implies_div_le().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_mul_le_implies_div_le(a: nat, b: nat, c: nat)\n    requires\n        b > 0,\n        a * b <= c,\n    ensures\n        a <= c / b,\n{\n    lemma_div_is_ordered((a * b) as int, c as int, b as int);\n    lemma_div_by_multiple(a as int, b as int);\n}",
      "start_line": 112,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/axiom_binomial_theorem().",
      "display_name": "axiom_binomial_theorem",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/axiom_binomial_theorem().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "proof fn axiom_binomial_theorem(a: nat, n: nat)\n    ensures\n        binomial_sum(a, n, n) == pow((a + 1) as int, n) as nat,\n{\n    admit();\n}",
      "start_line": 517,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_congruent_nat().",
      "display_name": "scalar_congruent_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_congruent_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn scalar_congruent_nat(s: &Scalar, n: nat) -> bool {\n    bytes_to_nat(&s.bytes) % group_order() == n % group_order()\n}",
      "start_line": 85,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_left_inequality().",
      "display_name": "lemma_mul_left_inequality",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_left_inequality().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "display_name": "lemma_binary_sum_mod_decomposition",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_binary_sum_mod_decomposition(a: nat, b: nat, s: nat, k: nat)\n    requires\n        a < pow2(s),\n    ensures\n        (a + b * pow2(s)) % pow2(k) == a % pow2(k) + (b * pow2(s)) % pow2(k),\n{\n    let ps = pow2(s);\n    let pk = pow2(k);\n    let x = a;\n    let y = b * ps;\n\n    assert(pk > 0) by {\n        lemma_pow2_pos(k);\n    }\n\n    assert((x + y) % pk == ((x % pk) + (y % pk)) % pk) by {\n        lemma_add_mod_noop(x as int, y as int, pk as int);\n    }\n\n    if (s >= k) {\n        let d = (s - k) as nat;\n        assert(y % pk == 0) by {\n            assert(y == (b * pow2(d)) * pk) by {\n                lemma_pow2_adds(d, k);\n                lemma_mul_is_associative(b as int, pow2(d) as int, pk as int);\n            }\n            assert(y % pk == 0) by {\n                lemma_mod_multiples_basic((b * pow2(d)) as int, pk as int);\n            }\n        }\n\n        assert((x % pk) % pk == x % pk) by {\n            lemma_mod_twice(x as int, pk as int);\n        }\n\n    } else {\n        // s < k\n        let d = (k - s) as nat;\n\n        assert(pow2(d) > 0) by {\n            lemma_pow2_pos(d);\n        }\n\n        let z = b % pow2(d);\n\n        assert(y % pk == z * ps) by {\n            lemma_pow2_mul_mod(b, s, k);\n        }\n\n        assert(x % pk == x) by {\n            assert(ps < pk) by {\n                lemma_pow2_strictly_increases(s, k);\n            }\n            lemma_small_mod(x, pk);\n        }\n\n        assert((x + z * ps) % pk == x + z * ps) by {\n            assert(x + z * ps < pk) by {\n                assert(z * ps <= pk - ps) by {\n                    assert(z < pow2(d)) by {\n                        lemma_small_mod(z, pow2(d));\n                    }\n                    lemma_pow2_mul_bound_general(z, d, s);\n                }\n            }\n\n            lemma_small_mod(x + z * ps, pk);\n        }\n    }\n}",
      "start_line": 178,
      "end_line": 48,
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_stage_division_theorem().",
      "display_name": "lemma_stage_division_theorem",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_stage_division_theorem().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_stage_division_theorem(limb: u64, carry_in: int, carry_out: int) -> (r: int)\n    requires\n        limb < (1u64 << 52),\n        carry_out == (limb as int + carry_in) / pow2(51) as int,\n    ensures\n        (limb as int + carry_in) == carry_out * pow2(51) as int + r,\n        0 <= r < pow2(51) as int,\n{\n    assert(pow2(51) > 0) by {\n        lemma_pow2_pos(51);\n    }\n    lemma_fundamental_div_mod((limb as int + carry_in), pow2(51) as int);\n    let r = (limb as int + carry_in) % pow2(51) as int;\n    lemma_mod_bound((limb as int + carry_in), pow2(51) as int);\n    r\n}",
      "start_line": 346,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_even_nonnegative().",
      "display_name": "lemma_pow_even_nonnegative",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_even_nonnegative().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow_even_nonnegative(x: int, k: nat)\n    ensures\n        pow(x, 2 * k) >= 0,\n{\n    assert(pow(x, 2 * k) == pow(x, k) * pow(x, k)) by {\n        lemma_pow_adds(x, k, k);\n    }\n    let y = pow(x, k);\n    if (y >= 0) {\n        lemma_mul_nonnegative(y, y);\n    } else {\n        lemma_mul_nonnegative(-y, -y);\n        lemma_mul_cancels_negatives(y, y)\n    }\n}",
      "start_line": 945,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/five_limbs_to_nat_aux().",
      "display_name": "five_limbs_to_nat_aux",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/five_limbs_to_nat_aux().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn five_limbs_to_nat_aux(limbs: [u64; 5]) -> nat {\n                (limbs[0] as nat) +\n    pow2( 52) * (limbs[1] as nat) +\n    pow2(104) * (limbs[2] as nat) +\n    pow2(156) * (limbs[3] as nat) +\n    pow2(208) * (limbs[4] as nat)\n}",
      "start_line": 47,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 10,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/BasepointTable#mul_base_clamped().",
      "display_name": "mul_base_clamped",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/BasepointTable#mul_base_clamped().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "curve25519-dalek/src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn mul_base_clamped(&self, bytes: [u8; 32]) -> Self::Point {\n        // Basepoint multiplication is defined for all values of `bytes` up to and including\n        // 2^255 - 1. The limit comes from the fact that scalar.as_radix_16() doesn't work for\n        // most scalars larger than 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        self.mul_base(&s)\n    }",
      "start_line": 67,
      "end_line": 24,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "display_name": "unpack",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn unpack(&self) -> (result:\n        UnpackedScalar)\n    // VERIFICATION NOTE: VERIFIED (changed pub(crate) to pub)\n\n        ensures\n            limbs_bounded(&result),\n            to_nat(&result.limbs) == bytes_to_nat(&self.bytes),\n    {\n        UnpackedScalar::from_bytes(&self.bytes)\n    }",
      "start_line": 2527,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_bytes().",
      "display_name": "to_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    pub const fn to_bytes(&self) -> (result: [u8; 32])\n        ensures\n            result == self.0,\n    {\n        self.0\n    }",
      "start_line": 457,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_extended_gcd_is_gcd().",
      "display_name": "lemma_extended_gcd_is_gcd",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_extended_gcd_is_gcd().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_extended_gcd_is_gcd(a: nat, b: nat)\n    ensures\n        spec_extended_gcd(a, b).gcd == spec_gcd(a, b),\n    decreases b,\n{\n    if b == 0 {\n        // Base case: both return a\n    } else {\n        // Inductive case\n        lemma_extended_gcd_is_gcd(b, a % b);\n    }\n}",
      "start_line": 901,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "display_name": "math_field_square",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn math_field_square(a: nat) -> nat {\n    (a * a) % p()\n}",
      "start_line": 114,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 27,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#TryFrom#try_from().",
      "display_name": "try_from",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#TryFrom#try_from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn try_from(slice: &[u8]) -> (result: Result<CompressedEdwardsY, TryFromSliceError>)\n        ensures\n            match result {\n                Ok(point) => point.0@ == slice@,\n                Err(_) => true,\n            },",
      "start_line": 570,
      "end_line": 16,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_u_coordinate().",
      "display_name": "is_valid_u_coordinate",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_u_coordinate().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_valid_u_coordinate(u: nat) -> bool {\n    math_is_square(montgomery_rhs(u))\n}",
      "start_line": 75,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo digest 0.10.7 digest/Digest#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo digest 0.10.7 digest/Digest#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/VartimeEdwardsPrecomputation#VartimePrecomputedMultiscalarMul#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/VartimeEdwardsPrecomputation#VartimePrecomputedMultiscalarMul#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self(crate::backend::VartimePrecomputedStraus::new(static_points))\n    }",
      "start_line": 1876,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#xcoset4().",
      "display_name": "xcoset4",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#xcoset4().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    pub fn xcoset4(&self) -> [EdwardsPoint; 4] {\n        [\n            self.0,\n            self.0 + constants::EIGHT_TORSION[2],\n            self.0 + constants::EIGHT_TORSION[4],\n            self.0 + constants::EIGHT_TORSION[6],\n        ]\n    }",
      "start_line": 97,
      "end_line": 19,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_to_nat_gen_u64_bound_le().",
      "display_name": "lemma_words_to_nat_gen_u64_bound_le",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_to_nat_gen_u64_bound_le().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "file_name": "scalar_lemmas_extra.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_words_to_nat_gen_u64_bound_le(words: &[u64; 8], count: int)\n    requires\n        0 <= count <= 8,\n        forall|k: int| 0 <= k < 8 ==> words[k] < pow2(64),\n    ensures\n        words_to_nat_gen_u64(words, count, 64) <= pow2((count * 64) as nat) - 1,\n    decreases count,\n{\n    reveal_with_fuel(words_to_nat_gen_u64, 9);\n\n    if count == 0 {\n        lemma2_to64();\n    } else {\n        let idx = count - 1;\n        lemma_words_to_nat_gen_u64_bound_le(words, idx);\n        let word_val = words[idx] as nat;\n\n        lemma_mul_upper_bound(\n            word_val as int,\n            (pow2(64) - 1) as int,\n            pow2((idx * 64) as nat) as int,\n            pow2((idx * 64) as nat) as int,\n        );\n\n        assert(words_to_nat_gen_u64(words, count, 64) <= pow2((count * 64) as nat) - 1) by {\n            let pow_prefix = pow2((idx * 64) as nat) as int;\n            let pow64 = pow2(64) as int;\n            let word_i = word_val as int;\n            let prefix_i = words_to_nat_gen_u64(words, idx, 64) as int;\n\n            lemma_pow2_adds((idx * 64) as nat, 64);\n            lemma_mul_is_distributive_sub(pow_prefix, pow64, word_i);\n            lemma_mul_is_distributive_add(pow_prefix, pow64 - 1 - word_i, 1 as int);\n        };\n    }\n}",
      "start_line": 223,
      "end_line": 49,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2().",
      "display_name": "lemma_pow2",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_bezout_identity().",
      "display_name": "lemma_bezout_identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_bezout_identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_bezout_identity(a: nat, b: nat)\n    ensures\n        ({\n            let r = spec_extended_gcd(a, b);\n            a as int * r.x + b as int * r.y == r.gcd as int\n        }),",
      "start_line": 915,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_k().",
      "display_name": "lemma_u64_5_as_nat_k",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_k().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "file_name": "u64_5_as_nat_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_u64_5_as_nat_k(a: [u64; 5], k: u64)\n    requires\n        forall|i: int| 0 <= i < 5 ==> (k * a[i]) <= u64::MAX,\n    ensures\n        u64_5_as_nat(\n            [\n                (k * a[0]) as u64,\n                (k * a[1]) as u64,\n                (k * a[2]) as u64,\n                (k * a[3]) as u64,\n                (k * a[4]) as u64,\n            ],\n        ) == k * u64_5_as_nat(a),\n{\n    let ka = [\n        (k * a[0]) as u64,\n        (k * a[1]) as u64,\n        (k * a[2]) as u64,\n        (k * a[3]) as u64,\n        (k * a[4]) as u64,\n    ];\n\n    assert(u64_5_as_nat(ka) == k * a[0] + k * (pow2(51) * a[1]) + k * (pow2(102) * a[2]) + k * (\n    pow2(153) * a[3]) + k * (pow2(204) * a[4])) by {\n        lemma_mul_is_associative(pow2(51) as int, a[1] as int, k as int);\n        lemma_mul_is_associative(pow2(102) as int, a[2] as int, k as int);\n        lemma_mul_is_associative(pow2(153) as int, a[3] as int, k as int);\n        lemma_mul_is_associative(pow2(204) as int, a[4] as int, k as int);\n    }\n\n    assert(k * a[0] + k * (pow2(51) * a[1]) + k * (pow2(102) * a[2]) + k * (pow2(153) * a[3]) + k\n        * (pow2(204) * a[4]) == k * (a[0] + (pow2(51) * a[1]) + (pow2(102) * a[2]) + (pow2(153)\n        * a[3]) + (pow2(204) * a[4]))) by {\n        lemma_mul_is_distributive_add(k as int, a[0] as int, pow2(51) * a[1]);\n        lemma_mul_is_distributive_add(k as int, a[0] + pow2(51) * a[1], pow2(102) * a[2]);\n        lemma_mul_is_distributive_add(\n            k as int,\n            a[0] + pow2(51) * a[1] + pow2(102) * a[2],\n            pow2(153) * a[3],\n        );\n        lemma_mul_is_distributive_add(\n            k as int,\n            a[0] + pow2(51) * a[1] + pow2(102) * a[2] + pow2(153) * a[3],\n            (pow2(204) * a[4]),\n        );\n    }\n}",
      "start_line": 516,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_reduce().",
      "display_name": "spec_reduce",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_reduce().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_reduce(limbs: [u64; 5]) -> (r: [u64; 5]) {\n    let r = [\n        ((limbs[0] & mask51) + (limbs[4] >> 51) * 19) as u64,\n        ((limbs[1] & mask51) + (limbs[0] >> 51)) as u64,\n        ((limbs[2] & mask51) + (limbs[1] >> 51)) as u64,\n        ((limbs[3] & mask51) + (limbs[2] >> 51)) as u64,\n        ((limbs[4] & mask51) + (limbs[3] >> 51)) as u64,\n    ];\n    r\n}",
      "start_line": 94,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 11,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "display_name": "compress",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn compress(&self) -> CompressedRistretto {\n        let mut X = self.0.X;\n        let mut Y = self.0.Y;\n        let Z = &self.0.Z;\n        let T = &self.0.T;\n\n        let u1 = &(Z + &Y) * &(Z - &Y);\n        let u2 = &X * &Y;\n        // Ignore return value since this is always square\n        let (_, invsqrt) = (&u1 * &u2.square()).invsqrt();\n        let i1 = &invsqrt * &u1;\n        let i2 = &invsqrt * &u2;\n        let z_inv = &i1 * &(&i2 * T);\n        let mut den_inv = i2;\n\n        let iX = &X * &constants::SQRT_M1;\n        let iY = &Y * &constants::SQRT_M1;\n        let ristretto_magic = &constants::INVSQRT_A_MINUS_D;\n        let enchanted_denominator = &i1 * ristretto_magic;\n\n        let rotate = (T * &z_inv).is_negative();\n\n        X.conditional_assign(&iY, rotate);\n        Y.conditional_assign(&iX, rotate);\n        den_inv.conditional_assign(&enchanted_denominator, rotate);\n\n        Y.conditional_negate((&X * &z_inv).is_negative());\n\n        let mut s = &den_inv * &(Z - &Y);\n        let s_is_negative = s.is_negative();\n        s.conditional_negate(s_is_negative);\n\n        CompressedRistretto(s.as_bytes())\n    }",
      "start_line": 488,
      "end_line": 20,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_mixed_multiscalar_mul().",
      "display_name": "vartime_mixed_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_mixed_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "curve25519-dalek/src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn vartime_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator,\n        K::Item: Borrow<Self::Point>,\n    {\n        Self::optional_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            dynamic_scalars,\n            dynamic_points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }",
      "start_line": 348,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/montgomery_radix_exec().",
      "display_name": "montgomery_radix_exec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/montgomery_radix_exec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn montgomery_radix_exec() -> BigUint {\n        BigUint::one() << 260\n    }",
      "start_line": 1252,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_carry_out_equals_q().",
      "display_name": "lemma_carry_out_equals_q",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_carry_out_equals_q().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_carry_out_equals_q(input_limbs: [u64; 5], q: u64)\n    requires\n        forall|i: int| 0 <= i < 5 ==> input_limbs[i] < (1u64 << 52),\n        q == 0 || q == 1,\n        u64_5_as_nat(input_limbs) >= p() <==> q == 1,\n        u64_5_as_nat(input_limbs) < 2 * p(),  // From reduce()'s postcondition\n\n    ensures\n        ({\n            let l0 = (input_limbs[0] + 19 * q) as u64;\n            let l1 = (input_limbs[1] + (l0 >> 51)) as u64;\n            let l2 = (input_limbs[2] + (l1 >> 51)) as u64;\n            let l3 = (input_limbs[3] + (l2 >> 51)) as u64;\n            let l4 = (input_limbs[4] + (l3 >> 51)) as u64;\n            (l4 >> 51) == q\n        }),",
      "start_line": 451,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "display_name": "montgomery_invert",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn montgomery_invert(&self) -> (result:\n        UnpackedScalar)/* VERIFICATION NOTE:\n    PROOF BYPASS\n    */\n\n        requires\n            limbs_bounded(&self),\n        ensures\n            limbs_bounded(&result),\n            (to_nat(&result.limbs) * to_nat(&self.limbs)) % group_order() == (montgomery_radix()\n                * montgomery_radix())\n                % group_order(),\n    // Equivalent to: from_montgomery(result) * from_montgomery(self) ≡ 1 (mod L)\n    // Expressed in Montgomery form: (result/R) * (self/R) ≡ 1, i.e., result * self ≡ R² (mod L)\n\n    {\n        // Uses the addition chain from\n        // https://briansmith.org/ecc-inversion-addition-chains-01#curve25519_scalar_inversion\n        let _1 = *self;\n        assume(limbs_bounded(&_1));\n        let _10 = _1.montgomery_square();\n        assume(limbs_bounded(&_10));\n        let _100 = _10.montgomery_square();\n        assume(limbs_bounded(&_100));\n        let _11 = UnpackedScalar::montgomery_mul(&_10, &_1);\n        assume(limbs_bounded(&_11));\n        let _101 = UnpackedScalar::montgomery_mul(&_10, &_11);\n        assume(limbs_bounded(&_101));\n        let _111 = UnpackedScalar::montgomery_mul(&_10, &_101);\n        assume(limbs_bounded(&_111));\n        let _1001 = UnpackedScalar::montgomery_mul(&_10, &_111);\n        assume(limbs_bounded(&_1001));\n        let _1011 = UnpackedScalar::montgomery_mul(&_10, &_1001);\n        assume(limbs_bounded(&_1011));\n        let _1111 = UnpackedScalar::montgomery_mul(&_100, &_1011);\n        assume(limbs_bounded(&_1111));\n\n        // _10000\n        let mut y = UnpackedScalar::montgomery_mul(&_1111, &_1);\n        assume(limbs_bounded(&y));\n\n        square_multiply(&mut y, 123 + 3, &_101);\n        square_multiply(&mut y, 2 + 2, &_11);\n        square_multiply(&mut y, 1 + 4, &_1111);\n        square_multiply(&mut y, 1 + 4, &_1111);\n        square_multiply(&mut y, 4, &_1001);\n        square_multiply(&mut y, 2, &_11);\n        square_multiply(&mut y, 1 + 4, &_1111);\n        square_multiply(&mut y, 1 + 3, &_101);\n        square_multiply(&mut y, 3 + 3, &_101);\n        square_multiply(&mut y, 3, &_111);\n        square_multiply(&mut y, 1 + 4, &_1111);\n        square_multiply(&mut y, 2 + 3, &_111);\n        square_multiply(&mut y, 2 + 2, &_11);\n        square_multiply(&mut y, 1 + 4, &_1011);\n        square_multiply(&mut y, 2 + 4, &_1011);\n        square_multiply(&mut y, 6 + 4, &_1001);\n        square_multiply(&mut y, 2 + 2, &_11);\n        square_multiply(&mut y, 3 + 2, &_11);\n        square_multiply(&mut y, 3 + 2, &_11);\n        square_multiply(&mut y, 1 + 4, &_1001);\n        square_multiply(&mut y, 1 + 3, &_111);\n        square_multiply(&mut y, 2 + 4, &_1111);\n        square_multiply(&mut y, 1 + 4, &_1011);\n        square_multiply(&mut y, 3, &_101);\n        square_multiply(&mut y, 2 + 4, &_1111);\n        square_multiply(&mut y, 3, &_101);\n        square_multiply(&mut y, 1 + 2, &_11);\n\n        proof {\n            assume(limbs_bounded(&y));\n            assume((to_nat(&y.limbs) * to_nat(&self.limbs)) % group_order() == (montgomery_radix()\n                * montgomery_radix()) % group_order());\n        }\n\n        y\n    }",
      "start_line": 2823,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select().",
      "display_name": "select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn select(a: &u64, b: &u64, c: Choice) -> (res: u64)\n    ensures\n        !choice_is_true(c) ==> res == *a,\n        choice_is_true(c) ==> res == *b,\n{\n    u64::conditional_select(a, b, c)\n}",
      "start_line": 56,
      "end_line": 14,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#Zero#zero().",
      "display_name": "zero",
      "symbol": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#Zero#zero().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "display_name": "len",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 11,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_inverse_of_nat().",
      "display_name": "is_inverse_of_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_inverse_of_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_inverse_of_nat(s: &Scalar, n: nat) -> bool {\n    (bytes_to_nat(&s.bytes) * n) % group_order() == 1\n}",
      "start_line": 90,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "display_name": "test_lizard_encode_helper",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    fn test_lizard_encode_helper(data: &[u8; 16], result: &[u8; 32]) {\n        let p = RistrettoPoint::lizard_encode::<Sha256>(data);\n        let p_bytes = p.compress().to_bytes();\n        assert!(&p_bytes == result);\n        let p = CompressedRistretto::from_slice(&p_bytes)\n            .unwrap()\n            .decompress()\n            .unwrap();\n        let data_out = p.lizard_decode::<Sha256>().unwrap();\n        assert!(&data_out == data);\n    }",
      "start_line": 248,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "display_name": "as_montgomery",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn as_montgomery(&self) -> (result: Scalar52)\n        requires\n            limbs_bounded(self),\n        ensures\n            limbs_bounded(&result),\n            #[trigger] (to_nat(&result.limbs) % group_order()) == #[trigger] ((to_nat(&self.limbs)\n                * montgomery_radix()) % group_order()),\n    {\n        proof {\n            lemma_rr_limbs_bounded();\n            assert(group_order() > 0);\n        }\n        let result = Scalar52::montgomery_mul(self, &constants::RR);\n        proof {\n            // From montgomery_mul's ensures clause:\n            // (to_nat(&result.limbs) * montgomery_radix()) % group_order() ==\n            // (to_nat(&self.limbs) * to_nat(&constants::RR.limbs)) % group_order()\n            // Prove that RR = R² mod L\n            lemma_rr_equals_radix_squared();\n\n            // Now we can apply the cancellation lemma\n            lemma_cancel_mul_montgomery_mod(\n                to_nat(&result.limbs),\n                to_nat(&self.limbs),\n                to_nat(&constants::RR.limbs),\n            );\n        }\n        result\n    }",
      "start_line": 1148,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_is_canonical_correctness().",
      "display_name": "lemma_is_canonical_correctness",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_is_canonical_correctness().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_is_canonical_correctness(self_bytes: &[u8; 32], reduced_bytes: &[u8; 32])\n    requires\n// reduced is canonical\n\n        bytes_to_nat(reduced_bytes) < group_order(),\n        // reduced has the same value mod group_order as self\n        bytes_to_nat(reduced_bytes) % group_order() == bytes_to_nat(self_bytes) % group_order(),\n    ensures\n// Bytes are equal iff self is canonical\n\n        (self_bytes == reduced_bytes) == (bytes_to_nat(self_bytes) < group_order()),\n{\n    if self_bytes == reduced_bytes {\n        // Case 1: Bytes are equal\n        // Then nat values are equal and self is canonical\n        assert(bytes_to_nat(self_bytes) == bytes_to_nat(reduced_bytes));\n        assert(bytes_to_nat(self_bytes) < group_order());\n    } else {\n        // Case 2: Bytes differ\n        // Step 1: Different bytes imply different nat values (by injectivity)\n        assert(bytes_to_nat(reduced_bytes) != bytes_to_nat(self_bytes)) by {\n            if bytes_to_nat(reduced_bytes) == bytes_to_nat(self_bytes) {\n                lemma_canonical_bytes_equal(reduced_bytes, self_bytes);\n                assert(reduced_bytes =~= self_bytes);  // contradiction\n            }\n        }\n\n        // Step 2: Canonical value equals itself mod group_order\n        assert(bytes_to_nat(reduced_bytes) == bytes_to_nat(reduced_bytes) % group_order()) by {\n            lemma_fundamental_div_mod_converse_mod(\n                bytes_to_nat(reduced_bytes) as int,\n                group_order() as int,\n                0int,\n                bytes_to_nat(reduced_bytes) as int,\n            );\n        }\n\n        // Step 3: From Step 1, Step 2, and requires, deduce self_bytes differs from its mod\n        // reduced == reduced % L (Step 2) and reduced % L == self % L (requires)\n        // implies reduced == self % L, but reduced != self (Step 1)\n        // therefore self % L != self\n        assert(bytes_to_nat(self_bytes) % group_order() != bytes_to_nat(self_bytes));\n\n        // Step 4: By contradiction - if self_bytes < group_order, it would equal itself mod group_order\n        assert(!(bytes_to_nat(self_bytes) < group_order())) by {\n            if bytes_to_nat(self_bytes) < group_order() {\n                assert(bytes_to_nat(self_bytes) % group_order() == bytes_to_nat(self_bytes)) by {\n                    lemma_small_mod(bytes_to_nat(self_bytes), group_order());\n                }\n            }\n        }\n        // Therefore self_bytes >= group_order, so it's not canonical\n    }\n}",
      "start_line": 1882,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 Choice#From#from().",
      "display_name": "from",
      "symbol": "rust-analyzer cargo subtle 2.6.1 Choice#From#from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_distributes().",
      "display_name": "lemma_pow_distributes",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_distributes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduced_sum_congruent().",
      "display_name": "lemma_montgomery_reduced_sum_congruent",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduced_sum_congruent().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "file_name": "scalar_lemmas_extra.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_montgomery_reduced_sum_congruent(\n    result_nat: nat,\n    hi_nat: nat,\n    lo_nat: nat,\n    hi_raw_nat: nat,\n    lo_raw_nat: nat,\n    wide_input: nat,\n)\n    requires\n// result comes from Scalar52::add\n\n        result_nat == (hi_nat + lo_nat) % group_order(),\n        // From Stage 4 Montgomery reductions\n        (hi_nat * montgomery_radix()) % group_order() == (hi_raw_nat * montgomery_radix()\n            * montgomery_radix()) % group_order(),\n        (lo_nat * montgomery_radix()) % group_order() == (lo_raw_nat * montgomery_radix())\n            % group_order(),\n        // hi_raw and lo_raw come from dividing wide_input at the Montgomery radix boundary\n        hi_raw_nat == wide_input / montgomery_radix(),\n        lo_raw_nat == wide_input % montgomery_radix(),\n    ensures\n        (result_nat * montgomery_radix()) % group_order() == (wide_input * montgomery_radix())\n            % group_order(),\n{\n    let r_nat = montgomery_radix();\n    let group_int = group_order() as int;\n\n    // Prove the key relationship from div/mod properties\n    lemma_pow2_pos(260);\n    lemma_fundamental_div_mod(wide_input as int, r_nat as int);\n\n    // hi_raw_nat * r^2 + lo_raw_nat * r == r * (hi_raw_nat * r + lo_raw_nat) == r * wide_input\n    assert(hi_raw_nat * r_nat * r_nat + lo_raw_nat * r_nat == wide_input * r_nat) by {\n        lemma_mul_is_commutative(hi_raw_nat as int, r_nat as int);\n        lemma_mul_is_distributive_add_other_way(\n            r_nat as int,\n            (hi_raw_nat * r_nat) as int,\n            lo_raw_nat as int,\n        );\n    };\n\n    lemma_small_mod(((hi_nat + lo_nat) % group_order()) as nat, group_order());\n    lemma_mul_factors_congruent_implies_products_congruent(\n        r_nat as int,\n        ((hi_nat + lo_nat) % group_order()) as int,\n        (hi_nat + lo_nat) as int,\n        group_int,\n    );\n    lemma_mul_is_distributive_add(r_nat as int, hi_nat as int, lo_nat as int);\n    lemma_add_mod_noop((r_nat * hi_nat) as int, (r_nat * lo_nat) as int, group_int);\n    lemma_add_mod_noop((hi_raw_nat * r_nat * r_nat) as int, (lo_raw_nat * r_nat) as int, group_int);\n}",
      "start_line": 646,
      "end_line": 52,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics_4().",
      "display_name": "lemma_mul_basics_4",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics_4().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_constants/lizard/field_element().",
      "display_name": "field_element",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_constants/lizard/field_element().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/u64_constants.rs",
      "relative_path": "curve25519-dalek/src/lizard/u64_constants.rs",
      "file_name": "u64_constants.rs",
      "parent_folder": "lizard",
      "body": "const fn field_element(element: [u64; 5]) -> FieldElement51 {\n    FieldElement51 { limbs: element }\n}",
      "start_line": 3,
      "end_line": 23,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_montgomery_inverse().",
      "display_name": "lemma_montgomery_inverse",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_montgomery_inverse().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_montgomery_inverse()\n    ensures\n// r * r_inv ≡ 1 (mod n)\n\n        (montgomery_radix() * inv_montgomery_radix()) % group_order() == 1,\n{\n    lemma2_to64();\n    lemma2_to64_rest();\n\n    lemma_pow2_adds(64, 64);  // prove pow2(128) in nat\n    lemma_pow2_adds(128, 64);  // prove pow2(192) in nat\n    lemma_pow2_adds(192, 60);  // prove pow2(252) in nat\n    lemma_pow2_adds(252, 8);  // prove pow2(260) in nat\n\n    calc! {\n        (==)\n        (montgomery_radix() * inv_montgomery_radix()) % group_order(); {}\n        (1852673427797059126777135760139006525652319754650249024631321344126610074238976_nat\n            * 5706410653605570882457795059301885719620630590890452783038400561109479083972_nat)\n            % 7237005577332262213973186563042994240857116359379907606001950938285454250989_nat; {}\n        1;\n    }\n\n}",
      "start_line": 465,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#random().",
      "display_name": "random",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#random().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn random<R: CryptoRngCore + ?Sized>(rng: &mut R) -> (result: Self)\n        ensures\n            is_random_scalar(&result),\n            is_canonical_scalar(&result),\n    {\n        let mut scalar_bytes = [0u8;64];\n        rng.fill_bytes(&mut scalar_bytes);\n        Scalar::from_bytes_mod_order_wide(&scalar_bytes)\n    }",
      "start_line": 1315,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul().",
      "display_name": "edwards_scalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn edwards_scalar_mul(point_affine: (nat, nat), n: nat) -> (nat, nat)\n    decreases n,\n{\n    if n == 0 {\n        math_edwards_identity()  // (0, 1)\n\n    } else {\n        let prev = edwards_scalar_mul(point_affine, (n - 1) as nat);\n        edwards_add(prev.0, prev.1, point_affine.0, point_affine.1)\n    }\n}",
      "start_line": 721,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 10,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Sum#sum().",
      "display_name": "sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Sum#sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn sum<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }/* <MODIFIED CODE> - if needed in for verification in the future",
      "start_line": 958,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_cast_then_mask_51().",
      "display_name": "lemma_cast_then_mask_51",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_cast_then_mask_51().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub broadcast proof fn lemma_cast_then_mask_51(x: u128)\n    ensures\n        #![trigger (x as u64) & mask51]\n        (x as u64) & mask51 == x & (mask51 as u128),\n{\n    assert((x as u64) & 2251799813685247u64 == x & (2251799813685247u64 as u128)) by (bit_vector);\n}",
      "start_line": 126,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Sum#sum().",
      "display_name": "sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Sum#sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(EdwardsPoint::identity(), |acc, item| acc + item.borrow())\n    }",
      "start_line": 1547,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_to_bytes().",
      "display_name": "spec_fe51_to_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_to_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_fe51_to_bytes(fe: &FieldElement51) -> Seq<u8> {\n    // Step 1: Basic reduction to ensure h < 2*p\n    let limbs = spec_reduce(fe.limbs);\n\n    // Step 2: Compute q (quotient) to detect if limbs >= p\n    // q = 0 if h < p, q = 1 if h >= p\n    // This works because h >= p <==> h + 19 >= 2^255\n    let q0 = ((limbs[0] + 19) as u64) >> 51;\n    let q1 = ((limbs[1] + q0) as u64) >> 51;\n    let q2 = ((limbs[2] + q1) as u64) >> 51;\n    let q3 = ((limbs[3] + q2) as u64) >> 51;\n    let q = ((limbs[4] + q3) as u64) >> 51;\n\n    // Step 3: Compute r = h - pq = h + 19q - 2^255q\n    // Add 19*q to limbs[0]\n    let limbs0_adj = (limbs[0] + 19 * q) as u64;\n\n    // Step 4: Propagate carries and mask to 51 bits (this subtracts 2^255q implicitly)\n    let limbs1_adj = (limbs[1] + (limbs0_adj >> 51)) as u64;\n    let limbs0_canon = (limbs0_adj & mask51) as u64;\n    let limbs2_adj = (limbs[2] + (limbs1_adj >> 51)) as u64;\n    let limbs1_canon = (limbs1_adj & mask51) as u64;\n    let limbs3_adj = (limbs[3] + (limbs2_adj >> 51)) as u64;\n    let limbs2_canon = (limbs2_adj & mask51) as u64;\n    let limbs4_adj = (limbs[4] + (limbs3_adj >> 51)) as u64;\n    let limbs3_canon = (limbs3_adj & mask51) as u64;\n    // Discard carry from limbs[4], which subtracts 2^255q\n    let limbs4_canon = (limbs4_adj & mask51) as u64;\n\n    // Step 5: Pack canonical limbs into 32 bytes (little-endian)\n    seq![\n        limbs0_canon as u8,\n        (limbs0_canon >> 8) as u8,\n        (limbs0_canon >> 16) as u8,\n        (limbs0_canon >> 24) as u8,\n        (limbs0_canon >> 32) as u8,\n        (limbs0_canon >> 40) as u8,\n        ((limbs0_canon >> 48) | (limbs1_canon << 3)) as u8,\n        (limbs1_canon >> 5) as u8,\n        (limbs1_canon >> 13) as u8,\n        (limbs1_canon >> 21) as u8,\n        (limbs1_canon >> 29) as u8,\n        (limbs1_canon >> 37) as u8,\n        ((limbs1_canon >> 45) | (limbs2_canon << 6)) as u8,\n        (limbs2_canon >> 2) as u8,\n        (limbs2_canon >> 10) as u8,\n        (limbs2_canon >> 18) as u8,\n        (limbs2_canon >> 26) as u8,\n        (limbs2_canon >> 34) as u8,\n        (limbs2_canon >> 42) as u8,\n        ((limbs2_canon >> 50) | (limbs3_canon << 1)) as u8,\n        (limbs3_canon >> 7) as u8,\n        (limbs3_canon >> 15) as u8,\n        (limbs3_canon >> 23) as u8,\n        (limbs3_canon >> 31) as u8,\n        (limbs3_canon >> 39) as u8,\n        ((limbs3_canon >> 47) | (limbs4_canon << 4)) as u8,\n        (limbs4_canon >> 4) as u8,\n        (limbs4_canon >> 12) as u8,\n        (limbs4_canon >> 20) as u8,\n        (limbs4_canon >> 28) as u8,\n        (limbs4_canon >> 36) as u8,\n        (limbs4_canon >> 44) as u8,\n    ]\n}",
      "start_line": 343,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 9,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb0_byte_contribution().",
      "display_name": "limb0_byte_contribution",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb0_byte_contribution().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "spec fn limb0_byte_contribution(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    bytes[0] as nat * pow2(0 * 8) + bytes[1] as nat * pow2(1 * 8) + bytes[2] as nat * pow2(2 * 8)\n        + bytes[3] as nat * pow2(3 * 8) + bytes[4] as nat * pow2(4 * 8) + bytes[5] as nat * pow2(\n        5 * 8,\n    )\n        +\n    // Byte 6 is a boundary byte - limb 0 contributes only the low 3 bits\n    // These 3 bits represent limbs[0]'s bits 48-50\n    ((limbs[0] as nat / pow2(48)) % 8) * pow2(6 * 8)\n}",
      "start_line": 159,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb2_byte_contribution_52().",
      "display_name": "limb2_byte_contribution_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb2_byte_contribution_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub open spec fn limb2_byte_contribution_52(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    bytes[13] as nat * pow2(13 * 8) +\n    bytes[14] as nat * pow2(14 * 8) +\n    bytes[15] as nat * pow2(15 * 8) +\n    bytes[16] as nat * pow2(16 * 8) +\n    bytes[17] as nat * pow2(17 * 8) +\n    bytes[18] as nat * pow2(18 * 8) +\n    // Byte 19 is a boundary byte - limb 2 contributes only the low 4 bits\n    ((limbs[2] as nat / pow2(48)) % 16) * pow2(19 * 8)\n}",
      "start_line": 99,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn identity() -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::identity())\n    }",
      "start_line": 806,
      "end_line": 16,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ai_val_boundaries().",
      "display_name": "ai_val_boundaries",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ai_val_boundaries().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn ai_val_boundaries(a: [u64; 5]) -> bool {\n    &&& a0_0_val(a) < 1u64 << 51\n    &&& a1_0_val(a) < 1u64 << 51\n    &&& a2_0_val(a) < 1u64 << 51\n    &&& a3_0_val(a) < 1u64 << 51\n    &&& a4_0_val(a) < 1u64 << 51\n    &&& carry_val(a) < 724618875532318195u64  // ceil(2^59.33)\n    &&& a0_0_val(a) + carry_val(a) * 19 < u64::MAX\n    &&& a1_0_val(a) + (a0_1_val(a) >> 51) < 1u64 << 52\n    &&& a0_2_val(a) < 1u64 << 51\n}",
      "start_line": 199,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_bit_partitioning().",
      "display_name": "lemma_modular_bit_partitioning",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_bit_partitioning().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_modular_bit_partitioning(a: nat, b: nat, k: nat, n: nat)\n    requires\n        k <= n,\n        a < pow2(k),\n    ensures\n        (a + b * pow2(k)) % pow2(n) == (a % pow2(k)) + ((b % pow2((n - k) as nat)) * pow2(k)),\n{\n    assert((a + b * pow2(k)) % pow2(n) == a % pow2(n) + (b * pow2(k)) % pow2(n)) by {\n        lemma_binary_sum_mod_decomposition(a, b, k, n);\n    }\n\n    assert((b * pow2(k)) % pow2(n) == (b % pow2((n - k) as nat)) * pow2(k)) by {\n        lemma_pow2_mul_mod(b, k, n);\n    }\n\n    assert(a % pow2(k) == a == a % pow2(n)) by {\n        assert(pow2(k) <= pow2(n)) by {\n            if (k < n) {\n                lemma_pow2_strictly_increases(k, n);\n            }\n        }\n        lemma_small_mod(a, pow2(k));\n        lemma_small_mod(a, pow2(n));\n    }\n}",
      "start_line": 778,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/load8_at_plus_version_rec().",
      "display_name": "load8_at_plus_version_rec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/load8_at_plus_version_rec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn load8_at_plus_version_rec(input: &[u8], i: usize, k: nat) -> u64\n    decreases k,\n{\n    if (k == 0) {\n        (input[i as int] as u64)\n    } else {\n        // k > 0\n        (load8_at_plus_version_rec(input, i, (k - 1) as nat) + ((input[i + k] as u64) << k\n            * 8)) as u64\n    }\n}",
      "start_line": 47,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_return().",
      "display_name": "pow2k_loop_return",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_return().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn pow2k_loop_return(a: [u64; 5]) -> [u64; 5] {\n    let a0 = a0_2_val(a);\n    let a1 = a1_1_val(a);\n    let a2 = a2_0_val(a);\n    let a3 = a3_0_val(a);\n    let a4 = a4_0_val(a);\n\n    let r = [a0, a1, a2, a3, a4];\n    r\n}",
      "start_line": 211,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_shr_51_fits_u64().",
      "display_name": "lemma_shr_51_fits_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_shr_51_fits_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_shr_51_fits_u64(a: u128)\n    requires\n        a <= (u64::MAX as u128) << 51,\n    ensures\n        (a >> 51) <= (u64::MAX as u128),\n{\n    assert(((u64::MAX as u128) << 51) >> 51 == (u64::MAX as u128)) by (compute);\n    lemma_shr_51_le(a, (u64::MAX as u128) << 51);\n}",
      "start_line": 66,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#ConditionallySelectable#conditional_assign().",
      "display_name": "conditional_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#ConditionallySelectable#conditional_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.Y_plus_X.conditional_assign(&other.Y_plus_X, choice);\n        self.Y_minus_X.conditional_assign(&other.Y_minus_X, choice);\n        self.Z.conditional_assign(&other.Z, choice);\n        self.T2d.conditional_assign(&other.T2d, choice);\n    }",
      "start_line": 373,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "display_name": "mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n        requires\n            limbs_bounded(a),\n            limbs_bounded(b),\n        ensures\n            to_nat(&result.limbs) % group_order() == (to_nat(&a.limbs) * to_nat(&b.limbs))\n                % group_order(),\n            // VER NOTE: Result has bounded limbs from montgomery_reduce\n            limbs_bounded(&result),\n            // VER NOTE: Result is canonical from montgomery_reduce\n            to_nat(&result.limbs) < group_order(),\n    {\n        proof {\n            lemma_rr_limbs_bounded();\n        }\n\n        // First montgomery_reduce: ab*R ≡ a*b (mod L)\n        let ab = Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b));\n\n        assert((to_nat(&ab.limbs) * montgomery_radix()) % group_order() == (to_nat(&a.limbs)\n            * to_nat(&b.limbs)) % group_order());\n\n        // Second montgomery_reduce: result*R ≡ ab*RR (mod L)\n        // Since RR < group_order, this triggers the stronger postcondition\n        let result = Scalar52::montgomery_reduce(&Scalar52::mul_internal(&ab, &constants::RR));\n\n        assert((to_nat(&result.limbs) * montgomery_radix()) % group_order() == (to_nat(&ab.limbs)\n            * to_nat(&constants::RR.limbs)) % group_order());\n\n        proof {\n            // 1. Prove RR ≡ R² (mod L)\n            lemma_rr_equals_spec(constants::RR);\n\n            // 2. Apply cancellation lemma to get: result ≡ ab*R (mod L)\n            //    Combined with ab*R ≡ a*b (mod L), we get result ≡ a*b (mod L)\n            lemma_cancel_mul_montgomery_mod(\n                to_nat(&result.limbs),\n                to_nat(&ab.limbs),\n                to_nat(&constants::RR.limbs),\n            );\n\n            // 3. Since result < group_order (from montgomery_reduce), result % L == result\n            lemma_small_mod(to_nat(&result.limbs), group_order());\n        }\n\n        result\n    }",
      "start_line": 1018,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#product_of_slice().",
      "display_name": "product_of_slice",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#product_of_slice().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar_helpers.rs",
      "relative_path": "curve25519-dalek/src/scalar_helpers.rs",
      "file_name": "scalar_helpers.rs",
      "parent_folder": "src",
      "body": "    pub fn product_of_slice(scalars: &[Scalar]) -> (result: Scalar)\n        ensures\n    // Result is a valid scalar (bytes represent a value < group_order)\n\n            scalar_to_nat(&result) < group_order(),\n            // Result represents the product of all scalars in the slice (mod group_order)\n            scalar_congruent_nat(&result, product_of_scalars(scalars@)),\n    {\n        let n = scalars.len();\n        let mut acc = Scalar::ONE;\n\n        proof {\n            // Assume properties of Scalar::ONE\n            assume(scalar_to_nat(&acc) < group_order());\n            assume(scalar_to_nat(&acc) == 1);\n            assume(scalar_congruent_nat(&acc, product_of_scalars(scalars@.subrange(0, 0))));\n        }\n\n        for i in 0..n\n            invariant\n                n == scalars.len(),\n                scalar_to_nat(&acc) < group_order(),\n                // acc represents the product of scalars[0..i]\n                scalar_congruent_nat(&acc, product_of_scalars(scalars@.subrange(0, i as int))),\n        {\n            proof {\n                // Assume preconditions for multiplication are satisfied\n                assume(false);\n            }\n            acc = &acc * &scalars[i];\n\n            proof {\n                // Assume the result maintains the invariant\n                assume(scalar_to_nat(&acc) < group_order());\n                assume(scalar_congruent_nat(\n                    &acc,\n                    product_of_scalars(scalars@.subrange(0, (i + 1) as int)),\n                ));\n            }\n        }\n\n        proof {\n            // At this point, acc is the product of all scalars\n            assert(scalars@.subrange(0, n as int) =~= scalars@);\n        }\n\n        acc\n    }",
      "start_line": 34,
      "end_line": 28,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "display_name": "conditional_add_l",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub(crate) fn conditional_add_l(&mut self, condition: Choice) -> (carry: u64)\n        requires\n            limbs_bounded(&old(self)),\n            to_nat(&old(self).limbs) + group_order() < pow2(260),\n        ensures\n    // The mathematical value modulo group_order doesn't change (since L = group_order)\n\n            to_nat(&self.limbs) % group_order() == to_nat(&old(self).limbs) % group_order(),\n            // VERIFICATION NOTE: expression below unsupported by Verus\n            //limbs_bounded(&self),\n            // Meaning of conditional addition\n            super::subtle_assumes::choice_is_true(condition) ==> to_nat(&self.limbs) == to_nat(\n                &old(self).limbs,\n            ) + group_order(),\n            !super::subtle_assumes::choice_is_true(condition) ==> to_nat(&self.limbs) == to_nat(\n                &old(self).limbs,\n            ),\n    {\n        let mut carry: u64 = 0;\n\n        proof {\n            assert(1u64 << 52 > 0) by (bit_vector);\n        }\n        let mask = (1u64 << 52) - 1;\n\n        for i in 0..5\n            invariant\n                mask == (1u64 << 52) - 1,\n                forall|j: int| 0 <= j < i ==> self.limbs[j] < (1u64 << 52),\n                forall|j: int| i <= j < 5 ==> self.limbs[j] == old(self).limbs[j],\n                forall|j: int| i <= j < 5 ==> self.limbs[j] < (1u64 << 52),\n                i == 0 ==> carry == 0,\n                i >= 1 ==> (carry >> 52) < 2,\n        {\n            /* <VERIFICATION NOTE> Using wrapper function for Verus compatibility instead of direct call to conditional_select */\n            let addend = select(&0, &constants::L.limbs[i], condition);\n            /* <ORIGINAL CODE>\n             let addend = u64::conditional_select(&0, &constants::L[i], condition);\n             <ORIGINAL CODE>*/\n\n            // Prove no overflow using the same lemma as in sub()\n            proof {\n                lemma_scalar_subtract_no_overflow(\n                    carry,\n                    self.limbs[i as int],\n                    addend,\n                    i as u32,\n                    &constants::L,\n                );\n            }\n\n            carry = (carry >> 52) + self.limbs[i] + addend;\n            self.limbs[i] = carry & mask;\n\n            proof {\n                lemma_carry_bounded_after_mask(carry, mask);\n            }\n        }\n\n        proof {\n            // TODO: Prove the postconditions\n            assume(to_nat(&self.limbs) % group_order() == to_nat(&old(self).limbs) % group_order());\n            //   assume(limbs_bounded(&self));\n            assume(super::subtle_assumes::choice_is_true(condition) ==> to_nat(&self.limbs)\n                == to_nat(&old(self).limbs) + group_order());\n            assume(!super::subtle_assumes::choice_is_true(condition) ==> to_nat(&self.limbs)\n                == to_nat(&old(self).limbs));\n        }\n\n        carry\n    }",
      "start_line": 582,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_add_fe51_limbs().",
      "display_name": "spec_add_fe51_limbs",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_add_fe51_limbs().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_add_fe51_limbs(a: &FieldElement51, b: &FieldElement51) -> FieldElement51 {\n    FieldElement51 {\n        limbs: [\n            (a.limbs[0] + b.limbs[0]) as u64,\n            (a.limbs[1] + b.limbs[1]) as u64,\n            (a.limbs[2] + b.limbs[2]) as u64,\n            (a.limbs[3] + b.limbs[3]) as u64,\n            (a.limbs[4] + b.limbs[4]) as u64,\n        ],\n    }\n}",
      "start_line": 41,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "display_name": "lemma_pow2_strictly_increases",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 36,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "display_name": "limbs_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn limbs_bounded(s: &Scalar52) -> bool {\n    forall|i: int| 0 <= i < 5 ==> s.limbs[i] < (1u64 << 52)\n}",
      "start_line": 208,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 36,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_shr_51_le().",
      "display_name": "lemma_shr_51_le",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_shr_51_le().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_shr_51_le(a: u128, b: u128)\n    requires\n        a <= b,\n    ensures\n        (a >> 51) <= (b >> 51),\n{\n    lemma_pow2_pos(51);\n    lemma2_to64_rest();  // pow2(51) value\n    lemma_u128_shr_is_div(a, 51);\n    lemma_u128_shr_is_div(b, 51);\n    lemma_div_is_ordered(a as int, b as int, 51);\n}",
      "start_line": 52,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c2_0_val().",
      "display_name": "c2_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c2_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn c2_0_val(a: [u64; 5]) -> u128 {\n    (a[1] * a[1] + 2 * (a[0] * a[2] + a[4] * (19 * a[3]))) as u128\n}",
      "start_line": 44,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn default() -> CompressedRistretto {\n        CompressedRistretto::identity()\n    }",
      "start_line": 342,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_to_nat().",
      "display_name": "scalar_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn scalar_to_nat(s: &Scalar) -> nat {\n    bytes_to_nat(&s.bytes)\n}",
      "start_line": 33,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 14,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_sub_eq().",
      "display_name": "lemma_mod_sub_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_sub_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "proof fn lemma_mod_sub_eq(a: nat, b: nat, m: nat)\n    requires\n        m > 0,\n        a >= b,\n        a % m == b % m,\n    ensures\n        ((a - b) as nat) % m == 0,\n{\n    // a = q1 * m + r, b = q2 * m + r (same remainder r)\n    // a - b = (q1 - q2) * m, which is divisible by m\n    let r = a % m;\n    let q1: int = (a / m) as int;\n    let q2: int = (b / m) as int;\n\n    assert(a as int == q1 * (m as int) + (r as int)) by {\n        lemma_fundamental_div_mod(a as int, m as int);\n    };\n    assert(b as int == q2 * (m as int) + (r as int)) by {\n        lemma_fundamental_div_mod(b as int, m as int);\n    };\n\n    // Derive a - b = (q1 - q2) * m\n    assert((a as int) - (b as int) == (q1 - q2) * (m as int)) by {\n        // a = q1 * m + r, b = q2 * m + r\n        // a - b = (q1 * m + r) - (q2 * m + r) = q1 * m - q2 * m = (q1 - q2) * m\n        lemma_mul_is_distributive_sub_other_way(m as int, q1, q2);\n    };\n\n    // Since a >= b and same remainder, q1 >= q2\n    assert(q1 >= q2) by {\n        // Since a >= b, (a - b) >= 0\n        // (a - b) = (q1 - q2) * m\n        // Since m > 0, (q1 - q2) >= 0 iff (q1 - q2) * m >= 0\n        assert((a as int) - (b as int) >= 0);\n        // If q1 < q2, then q1 - q2 < 0, so (q1 - q2) * m < 0 (since m > 0)\n        // But (a - b) >= 0, contradiction\n        if q1 < q2 {\n            // q1 < q2 means q2 - q1 > 0\n            assert(q2 - q1 > 0);\n            // Since q2 - q1 > 0 and m > 0, (q2 - q1) * m > 0\n            lemma_mul_strictly_positive(q2 - q1, m as int);\n            assert((q2 - q1) * (m as int) > 0);\n            // (q1 - q2) = -(q2 - q1), so (q1 - q2) * m = -((q2 - q1) * m) < 0\n            assert((q1 - q2) * (m as int) == -((q2 - q1) * (m as int))) by {\n                lemma_mul_unary_negation(q2 - q1, m as int);\n            };\n            assert((q1 - q2) * (m as int) < 0);\n            // But (a - b) = (q1 - q2) * m, and (a - b) >= 0, contradiction\n        }\n    };\n\n    // a - b = (q1 - q2) * m\n    assert((a - b) as int == (q1 - q2) * (m as int)) by {\n        assert((a as int) - (b as int) == (q1 * (m as int) + (r as int)) - (q2 * (m as int) + (\n        r as int)));\n        lemma_mul_is_distributive_sub_other_way(m as int, q1, q2);\n    };\n\n    // (q1 - q2) * m is divisible by m\n    lemma_mod_multiples_basic(q1 - q2, m as int);\n}",
      "start_line": 1265,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "display_name": "math_field_neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn math_field_neg(a: nat) -> nat {\n    (p() - (a % p())) as nat % p()\n}",
      "start_line": 109,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 20,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/read_le_u64_into().",
      "display_name": "read_le_u64_into",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/read_le_u64_into().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "fn read_le_u64_into(src: &[u8], dst: &mut [u64])/* VERIFICATION NOTE:\nPROOF BYPASS\n*/\n\n    requires\n        src.len() == 8 * old(dst).len(),\n    ensures\n        dst.len() == old(dst).len(),\n        forall|i: int|\n            0 <= i < dst.len() ==> {\n                let byte_seq = Seq::new(8, |j: int| src[i * 8 + j] as u8);\n                #[trigger] dst[i] as nat == bytes_seq_to_nat(byte_seq)\n            },",
      "start_line": 3069,
      "end_line": 20,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#ValidityCheck#is_valid().",
      "display_name": "is_valid",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#ValidityCheck#is_valid().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn is_valid(&self) -> (result: bool)\n        requires\n            fe51_limbs_bounded(&self.X, 54),\n            fe51_limbs_bounded(&self.Y, 54),\n            fe51_limbs_bounded(&self.Z, 54),\n        ensures\n            result == math_on_edwards_curve_projective(\n                spec_field_element(&self.X),\n                spec_field_element(&self.Y),\n                spec_field_element(&self.Z),\n            ),\n    {\n        // Curve equation is    -x^2 + y^2 = 1 + d*x^2*y^2,\n        // homogenized as (-X^2 + Y^2)*Z^2 = Z^4 + d*X^2*Y^2\n        let XX = self.X.square();\n        let YY = self.Y.square();\n        let ZZ = self.Z.square();\n        proof {\n            assume(fe51_limbs_bounded(&ZZ, 54));  // for ZZZZ = ZZ.square()\n            assume(fe51_limbs_bounded(&YY, 54) && fe51_limbs_bounded(&XX, 54));  // for yy_minus_xx = &YY - &XX and\n        }\n        let ZZZZ = ZZ.square();\n\n        /* ORIGINAL CODE: refactor for assumptions on intermediate results\n        let lhs = &(&YY - &XX) * &ZZ;\n        let rhs = &ZZZZ + &(&constants::EDWARDS_D * &(&XX * &YY));\n        lhs == rhs\n        */\n\n        let yy_minus_xx = &YY - &XX;\n        proof {\n            assume(fe51_limbs_bounded(&yy_minus_xx, 54) && fe51_limbs_bounded(&ZZ, 54));  // for lhs = &yy_minus_xx * &ZZ\n        }\n        let lhs = &yy_minus_xx * &ZZ;\n\n        let xx_times_yy = &XX * &YY;\n        proof {\n            assume(fe51_limbs_bounded(&constants::EDWARDS_D, 54) && fe51_limbs_bounded(\n                &xx_times_yy,\n                54,\n            ));  // for d_times_xxyy = &constants::EDWARDS_D * &xx_times_yy\n        }\n        let d_times_xxyy = &constants::EDWARDS_D * &xx_times_yy;\n        proof {\n            assume(sum_of_limbs_bounded(&ZZZZ, &d_times_xxyy, u64::MAX));  // for rhs = &ZZZZ + &d_times_xxyy\n        }\n        let rhs = &ZZZZ + &d_times_xxyy;\n\n        let result = lhs == rhs;\n        proof {\n            // postcondition\n            assume(result == math_on_edwards_curve_projective(\n                spec_field_element(&self.X),\n                spec_field_element(&self.Y),\n                spec_field_element(&self.Z),\n            ));\n        }\n        result\n    }",
      "start_line": 298,
      "end_line": 16,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/low_bits_mask().",
      "display_name": "low_bits_mask",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/low_bits_mask().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "is_libsignal": false,
      "caller_count": 11,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_loop1_invariant().",
      "display_name": "lemma_sub_loop1_invariant",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_loop1_invariant().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_sub_loop1_invariant(\n    difference: Scalar52,\n    borrow: u64,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    old_borrow: u64,\n    mask: u64,\n    difference_loop1_start: Scalar52,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> difference.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) == seq_u64_to_nat(difference_loop1_start.limbs@.subrange(0, i as int)) - (old_borrow\n            >> 63) * pow2((52 * (i) as nat)),\n        difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(\n            0,\n            i as int,\n        ),\n        difference.limbs[i as int] == borrow & mask,\n        borrow == a.limbs[i as int].wrapping_sub((b.limbs[i as int] + (old_borrow >> 63)) as u64),\n    ensures\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n            (52 * (i + 1) as nat),\n        ) == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i + 1),\n        ),\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] * pow2(52 * i as nat) - (\n        seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] * pow2(52 * i as nat)); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) + (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            assert(difference_loop1_start.limbs@.subrange(0, i as int)\n                == difference.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) - (old_borrow >> 63) * pow2(\n            52 * i as nat,\n        ) + (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n            - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n            assert(borrow == a.limbs[i as int].wrapping_sub(\n                (b.limbs[i as int] + (old_borrow >> 63)) as u64,\n            ));\n            assert(difference.limbs[i as int] == borrow & mask);\n            // Expand wrapping sub\n            if a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) < 0 {\n                assert(borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52)) by {\n                    assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    assert(b.limbs[i as int] <= (1u64 << 52) - 1);\n                    assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                        >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                    assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 <= 1u64 << 52);\n                    assert(borrow >= (a.limbs[i as int] - (1u64 << 52)\n                        + 0x1_0000_0000_0000_0000) as u64);\n                };\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n                        - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                            >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow\n                        - 0x1_0000_0000_0000_0000) * pow2(52 * i as nat); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((borrow >> 52)\n                        * pow2(52) + difference.limbs[i as int] - 0x1_0000_0000_0000_0000) * pow2(\n                        52 * i as nat,\n                    ); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                            broadcast use lemma_pow2_adds;\n\n                        };\n                        assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n                        broadcast use lemma_mul_is_distributive_sub_other_way;\n\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow\n                            >> 52) as nat * pow2(52 * (i + 1) as nat)) by {\n                            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                            lemma_mul_is_associative(\n                                (borrow >> 52) as int,\n                                pow2(52) as int,\n                                pow2(52 * i as nat) as int,\n                            );\n                        };\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) + difference.limbs[i as int] * pow2(52 * i as nat) - 0x1_0000_0000_0000_0000\n                        * pow2(52 * i as nat); {\n                        lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) - 0x1_0000_0000_0000_0000 * pow2(52 * i as nat); {\n                        assert(borrow >> 52 == (1u64 << 12) - 1) by (bit_vector)\n                            requires\n                                borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52),\n                        ;\n                        assert(0x1_0000_0000_0000_0000 * pow2(52 * i as nat) == (1u64 << 12) * pow2(\n                            52 * (i + 1) as nat,\n                        )) by {\n                            lemma2_to64();\n                            assert(0x1_0000_0000_0000_0000 == pow2(64));\n                            assert(1u64 << 12 == pow2(12)) by (compute);\n                            lemma_pow2_adds(64, 52 * i as nat);\n                            lemma_pow2_adds(12, 52 * (i + 1) as nat);\n                            assert(64 + 52 * i as nat == 12 + 52 * (i + 1) as nat);\n                        }\n                        lemma_mul_is_distributive_sub_other_way(\n                            pow2(52 * (i + 1) as nat) as int,\n                            (1u64 << 12) - 1,\n                            (1u64 << 12) as int,\n                        );\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (-1) * pow2(\n                        52 * (i + 1) as nat,\n                    ); {\n                        assert(borrow >> 63 == 1) by (bit_vector)\n                            requires\n                                borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52),\n                        ;\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n                        (52 * (i + 1) as nat),\n                    );\n                }\n            } else {\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n                        - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                            >> 63)) as u64)) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow) * pow2(\n                        52 * i as nat,\n                    ); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((borrow >> 52)\n                        * pow2(52) + difference.limbs[i as int]) * pow2(52 * i as nat); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                            broadcast use lemma_pow2_adds;\n\n                        };\n                        assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow\n                            >> 52) as nat * pow2(52 * (i + 1) as nat)) by {\n                            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                            lemma_mul_is_associative(\n                                (borrow >> 52) as int,\n                                pow2(52) as int,\n                                pow2(52 * i as nat) as int,\n                            );\n                        };\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) + difference.limbs[i as int] * pow2(52 * i as nat); {\n                        lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                        assert(borrow < 1u64 << 52) by {\n                            assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                                >> 63)) as u64)) as u64);\n                            assert(a.limbs[i as int] < (1u64 << 52));\n                            assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 >= 0);\n                        }\n                        assert(borrow >> 52 == 0) by (bit_vector)\n                            requires\n                                borrow < 1u64 << 52,\n                        ;\n                        assert(borrow >> 63 == 0) by (bit_vector)\n                            requires\n                                borrow < 1u64 << 52,\n                        ;\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n                        (52 * (i + 1) as nat),\n                    );\n                }\n            }\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n            (52 * (i + 1) as nat),\n        );\n    }\n}",
      "start_line": 818,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "display_name": "lemma_inv_of_product",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "file_name": "field_algebra_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_inv_of_product(a: nat, b: nat)\n    requires\n        a % p() != 0,\n        b % p() != 0,\n    ensures\n        math_field_inv(math_field_mul(a, b)) == math_field_mul(math_field_inv(a), math_field_inv(b)),\n{\n    let p = p();\n    p_gt_2();\n    \n    let ab = math_field_mul(a, b);\n    let inv_a = math_field_inv(a);\n    let inv_b = math_field_inv(b);\n    let inv_a_inv_b = math_field_mul(inv_a, inv_b);\n    \n    // Step 1: Get that inv(a) and inv(b) exist and satisfy inverse property\n    field_inv_property(a);\n    field_inv_property(b);\n    \n    // inv_a < p and inv_b < p\n    assert(inv_a < p && inv_b < p);\n    \n    // (a % p) * inv_a % p = 1 and (b % p) * inv_b % p = 1\n    assert(((a % p) * inv_a) % p == 1);\n    assert(((b % p) * inv_b) % p == 1);\n    \n    // Step 2: Show ab % p != 0 (product of non-zero elements is non-zero)\n    // This follows from p being prime\n    assert(ab % p != 0) by {\n        // ab = (a * b) % p\n        // If ab % p == 0, then (a * b) % p == 0, so p | (a * b)\n        // By Euclid's lemma (p prime), p | a or p | b\n        // But a % p != 0 and b % p != 0\n        if ab % p == 0 {\n            // ab = (a * b) % p, so ab % p = (a * b) % p % p = (a * b) % p\n            lemma_mod_twice((a * b) as int, p as int);\n            assert((a * b) % p == 0);\n            \n            axiom_p_is_prime();\n            lemma_euclid_prime(a, b, p);\n            // This gives a % p == 0 or b % p == 0\n            // Both contradict our preconditions\n            assert(false);\n        }\n    };\n    \n    // Step 3: Show that inv_a * inv_b is the inverse of ab\n    // Need to prove: (ab % p) * inv_a_inv_b % p == 1\n    // Note: ab = (a * b) % p, so ab % p = ab\n    \n    // First prove the integer equality: (a*b)*(inv_a*inv_b) = (a*inv_a)*(b*inv_b)\n    // Using step-by-step intermediate assertions\n    let step1 = (a * b) * (inv_a * inv_b);\n    let step2 = ((a * b) * inv_a) * inv_b;\n    let step3 = (a * (b * inv_a)) * inv_b;\n    let step4 = (a * (inv_a * b)) * inv_b;\n    let step5 = ((a * inv_a) * b) * inv_b;\n    let step6 = (a * inv_a) * (b * inv_b);\n    \n    assert(step1 == step2) by { lemma_mul_is_associative((a * b) as int, inv_a as int, inv_b as int); };\n    assert(step2 == step3) by { lemma_mul_is_associative(a as int, b as int, inv_a as int); };\n    assert(step3 == step4) by { lemma_mul_is_commutative(b as int, inv_a as int); };\n    assert(step4 == step5) by { lemma_mul_is_associative(a as int, inv_a as int, b as int); };\n    assert(step5 == step6) by { lemma_mul_is_associative((a * inv_a) as int, b as int, inv_b as int); };\n    \n    // Chain the equalities\n    assert(step1 == step6);\n    assert((a * b) * (inv_a * inv_b) == (a * inv_a) * (b * inv_b));\n    \n    // Now prove (a * inv_a) % p = 1 and (b * inv_b) % p = 1\n    assert((a * inv_a) % p == 1) by {\n        lemma_mul_mod_noop_left(a as int, inv_a as int, p as int);\n    };\n    assert((b * inv_b) % p == 1) by {\n        lemma_mul_mod_noop_left(b as int, inv_b as int, p as int);\n    };\n    \n    // Therefore ((a*inv_a) * (b*inv_b)) % p = 1\n    assert(((a * inv_a) * (b * inv_b)) % p == 1) by {\n        lemma_mul_mod_noop((a * inv_a) as int, (b * inv_b) as int, p as int);\n        lemma_small_mod(1nat, p);\n    };\n    \n    // And so ((a*b) * (inv_a*inv_b)) % p = 1\n    assert(((a * b) * (inv_a * inv_b)) % p == 1);\n    \n    // Finally connect to ab and inv_a_inv_b\n    assert(((ab % p) * inv_a_inv_b) % p == 1) by {\n        // ab % p = ab (since ab < p)\n        lemma_mod_bound((a * b) as int, p as int);\n        lemma_small_mod(ab, p);\n        \n        // inv_a_inv_b = (inv_a * inv_b) % p, so inv_a_inv_b < p\n        lemma_mod_bound((inv_a * inv_b) as int, p as int);\n        \n        // (ab * inv_a_inv_b) % p = ((a*b) % p * (inv_a*inv_b) % p) % p = ((a*b)*(inv_a*inv_b)) % p\n        lemma_mul_mod_noop((a * b) as int, (inv_a * inv_b) as int, p as int);\n    };\n    \n    // Step 4: inv_a_inv_b < p (since it's a field element)\n    assert(inv_a_inv_b < p) by {\n        lemma_mod_bound((inv_a * inv_b) as int, p as int);\n    };\n    \n    // Step 5: By uniqueness of inverse\n    field_inv_unique(ab, inv_a_inv_b);\n}",
      "start_line": 195,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_carry_propagation_is_division().",
      "display_name": "lemma_reduction_carry_propagation_is_division",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_carry_propagation_is_division().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_reduction_carry_propagation_is_division(input_limbs: [u64; 5], q: u64, c4: u64)\n    requires\n        forall|i: int| 0 <= i < 5 ==> input_limbs[i] < (1u64 << 52),\n        q == 0 || q == 1,\n        c4 == ({\n            let l0 = (input_limbs[0] + 19 * q) as u64;\n            let l1 = (input_limbs[1] + (l0 >> 51)) as u64;\n            let l2 = (input_limbs[2] + (l1 >> 51)) as u64;\n            let l3 = (input_limbs[3] + (l2 >> 51)) as u64;\n            let l4 = (input_limbs[4] + (l3 >> 51)) as u64;\n            l4 >> 51\n        }),",
      "start_line": 349,
      "end_line": 59,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo rustc_version 0.4.1 version_meta().",
      "display_name": "version_meta",
      "symbol": "rust-analyzer cargo rustc_version 0.4.1 version_meta().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "curve25519-dalek/build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "display_name": "double",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn double(&self) -> (result: EdwardsPoint)\n        requires\n            is_valid_edwards_point(*self),  // self is a valid extended Edwards point\n            edwards_point_limbs_bounded(*self),\n        ensures\n            is_valid_edwards_point(result),  // result is also a valid Edwards point\n            // Result equals the affine doubling of the input.\n            edwards_point_as_affine(result) == edwards_double(\n                edwards_point_as_affine(*self).0,\n                edwards_point_as_affine(*self).1,\n            ),\n    {\n        /* ORIGINAL CODE\n        self.as_projective().double().as_extended()\n        */\n        let proj = self.as_projective();\n        proof {\n            assert(is_valid_projective_point(proj));\n            // preconditions for projective double()\n            assert(fe51_limbs_bounded(&proj.X, 54) && fe51_limbs_bounded(&proj.Y, 54)\n                && fe51_limbs_bounded(&proj.Z, 54));\n            assume(sum_of_limbs_bounded(&proj.X, &proj.Y, u64::MAX));\n        }\n\n        let doubled = proj.double();\n        proof {\n            // projective double() spec guarantees this\n            assert(is_valid_completed_point(doubled));\n        }\n\n        let result = doubled.as_extended();\n\n        proof {\n            // completed → extended conversion preserves affine meaning\n            assert(edwards_point_as_affine(result) == completed_point_as_affine_edwards(doubled));\n\n            // And from the lower-level double() spec:\n            assert(completed_point_as_affine_edwards(doubled) == edwards_double(\n                edwards_point_as_affine(*self).0,\n                edwards_point_as_affine(*self).1,\n            ));\n        }\n\n        result\n    }",
      "start_line": 1281,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 13
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_success_means_valid_y().",
      "display_name": "lemma_sqrt_ratio_success_means_valid_y",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_success_means_valid_y().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_sqrt_ratio_success_means_valid_y(y: nat, u: nat, v: nat, r: nat)\n    requires\n        u == math_field_sub(math_field_square(y), 1),  // u = y² - 1\n        v == math_field_add(math_field_mul(spec_field_element(&EDWARDS_D), math_field_square(y)), 1),  // v = d·y² + 1\n        v != 0,\n        math_field_mul(math_field_square(r), v) == u % p(),  // r² · v = u\n    ensures\n        math_is_valid_y_coordinate(y),\n{\n    // Goal: math_is_valid_y_coordinate(y)\n    //\n    // The spec has three cases:\n    //   1. u % p == 0 → true\n    //   2. v % p == 0 → false (but we have v ≠ 0)\n    //   3. ∃ r < p: r² · v = u → true (we have witness r)\n    \n    p_gt_2();\n    let p = p();\n    let d = spec_field_element(&EDWARDS_D);\n    let y2 = math_field_square(y);\n    \n    // Show u < p and v < p (field operations return reduced values)\n    assert(u < p) by {\n        lemma_mod_bound((((y2 % p) + p) - (1nat % p)) as int, p as int);\n    };\n    assert(v < p) by {\n        lemma_mod_bound(((d * y2) % p + 1nat) as int, p as int);\n    };\n    \n    // Since u < p: u % p = u\n    lemma_small_mod(u, p);\n    \n    // Since v < p and v ≠ 0: v % p ≠ 0\n    lemma_small_mod(v, p);\n    assert(v % p != 0);\n    \n    // Construct witness r' = r % p\n    let r_prime = r % p;\n    \n    // r' < p\n    lemma_mod_bound(r as int, p as int);\n    assert(r_prime < p);\n    \n    // r'² = r² (squaring absorbs mod p)\n    lemma_square_mod_noop(r);\n    assert(math_field_square(r_prime) == math_field_square(r));\n    \n    // r'² · v = u (connecting to the existential)\n    assert(math_field_mul(math_field_square(r_prime), v) == u % p);\n    \n    // Now trigger the spec's existential\n    assert(math_is_valid_y_coordinate(y)) by {\n        if u % p != 0 {\n            // In the else branch - need existential witness\n            assert(r_prime < p);\n            assert(math_field_mul(math_field_square(r_prime), v) == u % p);\n        }\n    };\n}",
      "start_line": 281,
      "end_line": 52,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes().",
      "display_name": "hash_from_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn hash_from_bytes<D>(input: &[u8]) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64> + Default,\n\n        ensures\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        Scalar::from_hash(hash)\n    }",
      "start_line": 1349,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_property().",
      "display_name": "field_inv_property",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_property().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub proof fn field_inv_property(a: nat)\n    requires\n        a % p() != 0,\n    ensures\n        math_field_inv(a) < p(),\n        ((a % p()) * math_field_inv(a)) % p() == 1,\n{\n    assert(p() > 1) by {\n        pow255_gt_19();\n    }\n    axiom_p_is_prime();\n    lemma_gcd_with_prime(a, p());\n    lemma_mod_inverse_correct(a, p());\n\n    // lemma_mod_inverse_correct ensures (a * spec_mod_inverse(a, p())) % p() == 1\n    // We need ((a % p()) * spec_mod_inverse(a, p())) % p() == 1\n    let inv = spec_mod_inverse(a, p());\n    assert(((a % p()) * inv) % p() == 1) by {\n        lemma_mul_mod_noop_left(a as int, inv as int, p() as int);\n    };\n}",
      "start_line": 137,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn identity() -> CompressedRistretto {\n        CompressedRistretto([0u8; 32])\n    }",
      "start_line": 336,
      "end_line": 16,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_is_square().",
      "display_name": "math_is_square",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_is_square().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn math_is_square(a: nat) -> bool {\n    exists|y: nat| (#[trigger] (y * y) % p()) == (a % p())\n}",
      "start_line": 303,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve_projective().",
      "display_name": "math_on_edwards_curve_projective",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve_projective().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn math_on_edwards_curve_projective(x: nat, y: nat, z: nat) -> bool {\n    let d = spec_field_element(&EDWARDS_D);\n\n    // Compute X², Y², Z²\n    let x2 = math_field_square(x);\n    let y2 = math_field_square(y);\n    let z2 = math_field_square(z);\n    let z4 = math_field_square(z2);\n\n    // LHS: (-X² + Y²)·Z² = (Y² - X²)·Z²\n    let lhs = math_field_mul(math_field_sub(y2, x2), z2);\n\n    // RHS: Z⁴ + d·X²·Y²\n    let rhs = math_field_add(z4, math_field_mul(d, math_field_mul(x2, y2)));\n\n    lhs == rhs\n}",
      "start_line": 141,
      "end_line": 50,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_equals_spec().",
      "display_name": "lemma_rr_equals_spec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_equals_spec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub(crate) proof fn lemma_rr_equals_spec(rr: Scalar52)\n    requires\n        rr == (Scalar52 {\n            limbs: [\n                0x0009d265e952d13b,\n                0x000d63c715bea69f,\n                0x0005be65cb687604,\n                0x0003dceec73d217f,\n                0x000009411b7c309a,\n            ],\n        }),",
      "start_line": 528,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_completed_point().",
      "display_name": "is_valid_completed_point",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_completed_point().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_valid_completed_point(\n    point: crate::backend::serial::curve_models::CompletedPoint,\n) -> bool {\n    let (x_abs, y_abs, z_abs, t_abs) = spec_completed_point(point);\n\n    // Z and T must be non-zero\n    z_abs != 0 && t_abs != 0\n        &&\n    // The affine coordinates (X/Z, Y/T) must be on the curve\n    math_on_edwards_curve(\n        math_field_mul(x_abs, math_field_inv(z_abs)),\n        math_field_mul(y_abs, math_field_inv(t_abs)),\n    )\n}",
      "start_line": 655,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_u8_cast_is_mod_256().",
      "display_name": "lemma_u8_cast_is_mod_256",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_u8_cast_is_mod_256().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_u8_cast_is_mod_256(x: u64)\n    ensures\n        (x as u8) == (x as nat) % 256,\n{\n    assert(x as nat % 256 == x % 256);\n    assert((x as u8) == x % 256) by (bit_vector);\n}",
      "start_line": 123,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics_3().",
      "display_name": "lemma_mul_basics_3",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics_3().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01().",
      "display_name": "lemma_from_bytes_as_nat_01",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_from_bytes_as_nat_01(bytes: &[u8; 32])\n    ensures\n        (spec_load8_at(bytes, 0) as u64 & mask51) + pow2(51) * ((spec_load8_at(bytes, 6) as u64\n            >> 3) & mask51) == (bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (bytes[2]\n            * pow2(2 * 8)) + (bytes[3] * pow2(3 * 8)) + (bytes[4] * pow2(4 * 8)) + (bytes[5] * pow2(\n            5 * 8,\n        )) + (bytes[6] * pow2(6 * 8)) + (bytes[7] * pow2(7 * 8)) + (bytes[8] * pow2(8 * 8)) + (\n        bytes[9] * pow2(9 * 8)) + (bytes[10] * pow2(10 * 8)) + (bytes[11] * pow2(11 * 8)) + ((\n        bytes[12] as nat % pow2(6)) * pow2((12 * 8) as nat)),\n{\n    assert((spec_load8_at(bytes, 0) as u64) & mask51 == (bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(\n        1 * 8,\n    )) + (bytes[2] * pow2(2 * 8)) + (bytes[3] * pow2(3 * 8)) + (bytes[4] * pow2(4 * 8)) + (bytes[5]\n        * pow2(5 * 8)) + ((bytes[6] as nat % pow2(3)) * pow2(6 * 8))) by {\n        lemma_load8_at_limb0(bytes);\n    }\n\n    assert(((spec_load8_at(bytes, 6) as u64) >> 3) & mask51 == (bytes[6] as nat / pow2(3)) + (\n    bytes[7] * pow2((1 * 8 - 3) as nat)) + (bytes[8] * pow2((2 * 8 - 3) as nat)) + (bytes[9] * pow2(\n        (3 * 8 - 3) as nat,\n    )) + (bytes[10] * pow2((4 * 8 - 3) as nat)) + (bytes[11] * pow2((5 * 8 - 3) as nat)) + ((\n    bytes[12] as nat % pow2(6)) * pow2((6 * 8 - 3) as nat))) by {\n        lemma_load8_at_limb1(bytes);\n    }\n\n    assert(pow2(51) * ((spec_load8_at(bytes, 6) as u64 >> 3) & mask51) == pow2(51) * (\n    bytes[6] as nat / pow2(3)) + pow2(51) * (bytes[7] * pow2((1 * 8 - 3) as nat)) + pow2(51) * (\n    bytes[8] * pow2((2 * 8 - 3) as nat)) + pow2(51) * (bytes[9] * pow2((3 * 8 - 3) as nat)) + pow2(\n        51,\n    ) * (bytes[10] * pow2((4 * 8 - 3) as nat)) + pow2(51) * (bytes[11] * pow2((5 * 8 - 3) as nat))\n        + pow2(51) * ((bytes[12] as nat % pow2(6)) * pow2((6 * 8 - 3) as nat))) by {\n        lemma_mul_distributive_7_terms(\n            pow2(51) as int,\n            (bytes[6] as nat / pow2(3)) as int,\n            (bytes[7] * pow2((1 * 8 - 3) as nat)) as int,\n            (bytes[8] * pow2((2 * 8 - 3) as nat)) as int,\n            (bytes[9] * pow2((3 * 8 - 3) as nat)) as int,\n            (bytes[10] * pow2((4 * 8 - 3) as nat)) as int,\n            (bytes[11] * pow2((5 * 8 - 3) as nat)) as int,\n            ((bytes[12] as nat % pow2(6)) * pow2((6 * 8 - 3) as nat)) as int,\n        );\n    }\n\n    assert(((bytes[6] as nat % pow2(3)) * pow2(6 * 8)) + pow2(51) * (bytes[6] as nat / pow2(3))\n        == bytes[6] * pow2(6 * 8)) by {\n        lemma_assemble_mod_div(bytes[6] as nat, 3, 6 * 8);\n    }\n\n    assert(pow2(51) * (bytes[7] * pow2((1 * 8 - 3) as nat)) + pow2(51) * (bytes[8] * pow2(\n        (2 * 8 - 3) as nat,\n    )) + pow2(51) * (bytes[9] * pow2((3 * 8 - 3) as nat)) + pow2(51) * (bytes[10] * pow2(\n        (4 * 8 - 3) as nat,\n    )) + pow2(51) * (bytes[11] * pow2((5 * 8 - 3) as nat)) + pow2(51) * ((bytes[12] as nat % pow2(\n        6,\n    )) * pow2((6 * 8 - 3) as nat)) == (bytes[7] * pow2(7 * 8)) + (bytes[8] * pow2(8 * 8)) + (\n    bytes[9] * pow2(9 * 8)) + (bytes[10] * pow2(10 * 8)) + (bytes[11] * pow2(11 * 8)) + ((\n    bytes[12] as nat % pow2(6)) * pow2((12 * 8) as nat))) by {\n        lemma_assemble_pow_a_pow(bytes[7] as nat, 6, 1, 3);\n        lemma_assemble_pow_a_pow(bytes[8] as nat, 6, 2, 3);\n        lemma_assemble_pow_a_pow(bytes[9] as nat, 6, 3, 3);\n        lemma_assemble_pow_a_pow(bytes[10] as nat, 6, 4, 3);\n        lemma_assemble_pow_a_pow(bytes[11] as nat, 6, 5, 3);\n        lemma_assemble_pow_a_pow(bytes[12] as nat % pow2(6), 6, 6, 3);\n    }\n}",
      "start_line": 81,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_is_odd().",
      "display_name": "lemma_group_order_is_odd",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_is_odd().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_group_order_is_odd()\n    ensures\n        group_order() % 2 == 1,\n{\n    assert(group_order() == pow2(252) + 27742317777372353535851937790883648493nat);\n\n    lemma_pow2_even(252);\n    assert((pow2(252) as int) % 2 == 0);\n\n    // Reduce the sum modulo 2: (A + B) % 2 == ((A % 2) + (B % 2)) % 2\n    lemma_add_mod_noop(\n        pow2(252) as int,\n        27742317777372353535851937790883648493nat as int,\n        2 as int,\n    );\n\n    assert((27742317777372353535851937790883648493nat as int) % 2 == 1);\n    assert(group_order() % 2 == 1);\n}",
      "start_line": 1684,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple().",
      "display_name": "lemma_div_by_multiple",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_pow2k_step().",
      "display_name": "lemma_prove_pow2k_step",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_pow2k_step().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow_chain_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow_chain_lemmas.rs",
      "file_name": "pow_chain_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_prove_pow2k_step(\n    base: int,\n    val_in: nat,\n    val_out: nat,\n    exp_in: nat,\n    exp_power: nat,\n)\n    requires\n        base >= 0,\n        p() > 0,\n        exp_power > 0,\n        val_in % p() == pow(base, exp_in) as nat % p(),\n        val_out % p() == pow(val_in as int, exp_power) as nat % p(),\n    ensures\n        val_out % p() == pow(base, (exp_in * exp_power) as nat) as nat % p(),\n{\n    // Prove pow(base, exp_in) >= 0 to bridge nat and int modulo\n    assert(pow(base, exp_in) >= 0) by {\n        lemma_pow_nonnegative(base, exp_in);\n    }\n\n    // Use power congruence: if a ≡ b (mod p), then a^n ≡ b^n (mod p)\n    assert(val_in as int % (p() as int) == pow(base, exp_in) % (p() as int));\n    assert((pow(val_in as int, exp_power) % (p() as int)) as nat == (pow(\n        pow(base, exp_in),\n        exp_power,\n    ) % (p() as int)) as nat) by {\n        lemma_pow_mod_congruent(val_in as int, pow(base, exp_in), exp_power, p() as int);\n    }\n\n    // Apply power-of-power rule: (x^a)^b = x^(a*b)\n    assert(pow(pow(base, exp_in), exp_power) == pow(base, exp_in * exp_power)) by {\n        lemma_pow_multiplies(base, exp_in, exp_power);\n    }\n\n    // Prove pow(base, exp_in * exp_power) >= 0\n    assert(pow(base, exp_in * exp_power) >= 0) by {\n        lemma_pow_nonnegative(base, exp_in * exp_power);\n    }\n\n    // Prove pow(val_in as int, exp_power) >= 0 to bridge the conversion\n    assert(pow(val_in as int, exp_power) >= 0) by {\n        lemma_pow_nonnegative(val_in as int, exp_power);\n    }\n\n    // Chain the equalities to prove the postcondition\n    // val_out % p() == pow(val_in as int, exp_power) as nat % p() (from precondition)\n    // Now we can convert: pow(val_in as int, exp_power) as nat % p() == (pow(val_in as int, exp_power) % (p() as int)) as nat\n    assert(val_out % p() == (pow(val_in as int, exp_power) % (p() as int)) as nat);\n\n    // (pow(val_in as int, exp_power) % (p() as int)) as nat == (pow(pow(base, exp_in), exp_power) % (p() as int)) as nat (proved above)\n    // pow(pow(base, exp_in), exp_power) == pow(base, exp_in * exp_power) (proved above)\n    // Therefore: (pow(base, exp_in * exp_power) % (p() as int)) as nat == pow(base, (exp_in * exp_power) as nat) as nat % p()\n\n    assert((pow(base, exp_in * exp_power) % (p() as int)) as nat == pow(\n        base,\n        (exp_in * exp_power) as nat,\n    ) as nat % p());\n    assert(val_out % p() == pow(base, (exp_in * exp_power) as nat) as nat % p());\n}",
      "start_line": 26,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "display_name": "reduce",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn reduce(&self) -> (result: Scalar)\n        ensures\n    // Result is equivalent to input modulo the group order\n\n            bytes_to_nat(&result.bytes) % group_order() == bytes_to_nat(&self.bytes)\n                % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        let x = self.unpack();\n\n        assert(limbs_bounded(&constants::R)) by {\n            lemma_r_bounded(constants::R);\n\n        }\n\n        assert(to_nat(&constants::R.limbs) < group_order()) by {\n            lemma_r_equals_spec(constants::R);\n        };\n\n        let xR = UnpackedScalar::mul_internal(&x, &constants::R);\n        let x_mod_l = UnpackedScalar::montgomery_reduce(&xR);\n        let result = x_mod_l.pack();\n\n        proof {\n            assert(slice128_to_nat(&xR) == to_nat(&x.limbs) * to_nat(&constants::R.limbs));\n\n            // montgomery_reduce ensures:\n            assert((to_nat(&x_mod_l.limbs) * montgomery_radix()) % group_order() == slice128_to_nat(\n                &xR,\n            ) % group_order());\n\n            assert((to_nat(&x_mod_l.limbs) * montgomery_radix()) % group_order() == (to_nat(\n                &x.limbs,\n            ) * to_nat(&constants::R.limbs)) % group_order());\n\n            lemma_r_equals_spec(constants::R);\n\n            lemma_mul_factors_congruent_implies_products_congruent(\n                to_nat(&x.limbs) as int,\n                montgomery_radix() as int,\n                to_nat(&constants::R.limbs) as int,\n                group_order() as int,\n            );\n\n            assert((to_nat(&x_mod_l.limbs) * montgomery_radix()) % group_order() == (to_nat(\n                &x.limbs,\n            ) * montgomery_radix()) % group_order());\n\n            lemma_cancel_mul_pow2_mod(to_nat(&x_mod_l.limbs), to_nat(&x.limbs), montgomery_radix());\n\n            assert(to_nat(&x_mod_l.limbs) % group_order() == to_nat(&x.limbs) % group_order());\n\n            assert(bytes_to_nat(&result.bytes) == to_nat(&x_mod_l.limbs) % pow2(256));\n            assert(to_nat(&x_mod_l.limbs) < group_order());\n\n            assert(group_order() < pow2(256)) by { lemma_group_order_smaller_than_pow256() };\n\n            assert(to_nat(&x_mod_l.limbs) < pow2(256));\n            lemma_small_mod(to_nat(&x_mod_l.limbs), pow2(256));\n            assert(bytes_to_nat(&result.bytes) == to_nat(&x_mod_l.limbs));\n        }\n\n        result\n    }",
      "start_line": 2540,
      "end_line": 14,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 18
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg_no_underflow().",
      "display_name": "lemma_neg_no_underflow",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg_no_underflow().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/negate_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/negate_lemmas.rs",
      "file_name": "negate_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_neg_no_underflow(limbs: [u64; 5])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51),\n    ensures\n        all_neg_limbs_positive(limbs),\n{\n    lemma2_to64_rest();  // pow2(51)\n    assert forall|i: int| 0 <= i < 5 implies limbs[i] < 16 * (pow2(51) - 19) by {\n        lemma_shift_is_pow2(51);\n    }\n}",
      "start_line": 27,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_gcd().",
      "display_name": "spec_gcd",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_gcd().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub open spec fn spec_gcd(a: nat, b: nat) -> nat\n    decreases b,\n{\n    if b == 0 {\n        a\n    } else {\n        spec_gcd(b, a % b)\n    }\n}",
      "start_line": 27,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb4_byte_contribution().",
      "display_name": "limb4_byte_contribution",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb4_byte_contribution().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "spec fn limb4_byte_contribution(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    // Byte 25 high 4 bits (limbs[4]'s bits 0-3)\n    ((limbs[4] as nat % pow2(4)) * pow2(4)) * pow2(25 * 8) + bytes[26] as nat * pow2(26 * 8)\n        + bytes[27] as nat * pow2(27 * 8) + bytes[28] as nat * pow2(28 * 8) + bytes[29] as nat\n        * pow2(29 * 8) + bytes[30] as nat * pow2(30 * 8) + bytes[31] as nat * pow2(31 * 8)\n}",
      "start_line": 209,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_p_radix_representation().",
      "display_name": "lemma_p_radix_representation",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_p_radix_representation().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_p_radix_representation()\n    ensures\n        (pow2(51) - 19) + pow2(51) * (pow2(51) - 1) + pow2(102) * (pow2(51) - 1) + pow2(153) * (\n        pow2(51) - 1) + pow2(204) * (pow2(51) - 1) == p(),\n{\n    let r1 = pow2(51);\n    let r2 = pow2(102);\n    let r3 = pow2(153);\n    let r4 = pow2(204);\n    let r5 = pow2(255);\n\n    assert(pow2(51) * (pow2(51) - 1) == r2 - r1) by {\n        calc! {\n            (==)\n            r1 * (r1 - 1); {\n                lemma_mul_is_commutative(r1 as int, (r1 - 1) as int);\n            }\n            (r1 - 1) * r1; {\n                lemma_mul_is_distributive_sub(r1 as int, r1 as int, 1);\n            }\n            r1 * r1 - r1 * 1; {\n                lemma_pow2_adds(51, 51);\n                lemma_mul_basics(r1 as int);\n                assert(r1 * r1 == r2);\n                assert(r1 * 1 == r1);\n            }\n            r2 - r1;\n        }\n    }\n\n    assert(pow2(102) * (pow2(51) - 1) == r3 - r2) by {\n        calc! {\n            (==)\n            r2 * (r1 - 1); {\n                lemma_mul_is_distributive_sub(r2 as int, r1 as int, 1);\n            }\n            r2 * r1 - r2 * 1; {\n                lemma_pow2_adds(102, 51);\n                lemma_mul_is_commutative(r2 as int, r1 as int);\n                lemma_mul_basics(r2 as int);\n                assert(r2 * r1 == r3);\n                assert(r2 * 1 == r2);\n            }\n            r3 - r2;\n        }\n    }\n\n    assert(pow2(153) * (pow2(51) - 1) == r4 - r3) by {\n        calc! {\n            (==)\n            r3 * (r1 - 1); {\n                lemma_mul_is_distributive_sub(r3 as int, r1 as int, 1);\n            }\n            r3 * r1 - r3 * 1; {\n                lemma_pow2_adds(153, 51);\n                lemma_mul_is_commutative(r3 as int, r1 as int);\n                lemma_mul_basics(r3 as int);\n                assert(r3 * r1 == r4);\n                assert(r3 * 1 == r3);\n            }\n            r4 - r3;\n        }\n    }\n\n    assert(pow2(204) * (pow2(51) - 1) == r5 - r4) by {\n        calc! {\n            (==)\n            r4 * (r1 - 1); {\n                lemma_mul_is_distributive_sub(r4 as int, r1 as int, 1);\n            }\n            r4 * r1 - r4 * 1; {\n                lemma_pow2_adds(204, 51);\n                lemma_mul_is_commutative(r4 as int, r1 as int);\n                lemma_mul_basics(r4 as int);\n                assert(r4 * r1 == r5);\n                assert(r4 * 1 == r4);\n            }\n            r5 - r4;\n        }\n    }\n\n    calc! {\n        (==)\n        (pow2(51) - 19) + pow2(51) * (pow2(51) - 1) + pow2(102) * (pow2(51) - 1) + pow2(153) * (\n        pow2(51) - 1) + pow2(204) * (pow2(51) - 1); {}\n        (r1 - 19) + (r2 - r1) + (r3 - r2) + (r4 - r3) + (r5 - r4); {\n            assert(pow2(51) * (pow2(51) - 1) == r2 - r1);\n            assert(pow2(102) * (pow2(51) - 1) == r3 - r2);\n            assert(pow2(153) * (pow2(51) - 1) == r4 - r3);\n            assert(pow2(204) * (pow2(51) - 1) == r5 - r4);\n        }\n        r5 - 19;\n    }\n\n    assert(r5 - 19 == p()) by {\n        assert(r5 == pow2(255));\n        pow255_gt_19();\n        assert(pow2(255) >= 19) by {\n            assert(pow2(255) > 19);\n        }\n        assert(pow2(255) - 19 == p()) by {\n            assert(pow2(255) - 19 == (pow2(255) - 19) as nat) by {\n                assert(pow2(255) - 19 >= 0) by {\n                    assert(pow2(255) >= 19);\n                }\n            }\n            assert(p() == (pow2(255) - 19) as nat);\n        }\n        assert(r5 - 19 == pow2(255) - 19) by {\n            assert(r5 == pow2(255));\n        }\n    }\n}",
      "start_line": 747,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_q_spec().",
      "display_name": "compute_q_spec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_q_spec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn compute_q_spec(limbs: [u64; 5]) -> u64 {\n    compute_q_arr(limbs)[4]\n}",
      "start_line": 140,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_from_le_bytes().",
      "display_name": "u128_from_le_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_from_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub fn u128_from_le_bytes(bytes: [u8; 16]) -> (x: u128)\n    ensures\n        x as nat == bytes_seq_to_nat(seq_from16(&bytes)),\n{\n    u128::from_le_bytes(bytes)\n}",
      "start_line": 143,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_some().",
      "display_name": "ct_option_is_some",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_some().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn ct_option_is_some<T>(opt: &CtOption<T>) -> (c: Choice)\n    ensures\n        choice_is_true(c) == ct_option_has_value(*opt),\n{\n    opt.is_some()\n}",
      "start_line": 169,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "display_name": "invert",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "curve25519-dalek/src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn invert(&self) -> (result:\n        FieldElement)/* VERIFICATION NOTE:\n    - Computes self^(p-2) using Fermat's Little Theorem: a^(p-1) ≡ 1 (mod p) => a^(p-2) * a ≡ 1 (mod p)\n    - p-2 = 2^255 - 21 = (2^250 - 1) * 2^5 + 11\n    */\n\n        requires\n            fe51_limbs_bounded(self, 54),\n        ensures\n    // If self is non-zero, result is the multiplicative inverse: result * self ≡ 1 (mod p)\n\n            spec_field_element(self) != 0 ==> (spec_field_element(&result) * spec_field_element(\n                self,\n            )) % p() == 1,\n            // If self is zero, result is zero\n            spec_field_element(self) == 0 ==> spec_field_element(&result) == 0,\n            spec_field_element(&result) == math_field_inv(spec_field_element(self)),\n            fe51_limbs_bounded(&result, 54),\n    {\n        // The bits of p-2 = 2^255 -19 -2 are 11010111111...11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, t3) = self.pow22501();  // t19: 249..0 ; t3: 3,1,0\n        let t20 = t19.pow2k(5);  // 254..5\n        let t21 = &t20 * &t3;  // 254..5,3,1,0\n\n        proof {\n            lemma_invert_correctness(self, &t19, &t3, &t20, &t21);\n        }\n\n        t21\n    }",
      "start_line": 676,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/bytes_to_nat_exec().",
      "display_name": "bytes_to_nat_exec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/bytes_to_nat_exec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn bytes_to_nat_exec(bytes: &[u8; 32]) -> BigUint {\n        let mut result = BigUint::zero();\n        let radix = BigUint::from(256u32);\n        for i in (0..32).rev() {\n            result = result * &radix + BigUint::from(bytes[i]);\n        }\n        result\n    }",
      "start_line": 1438,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_negate().",
      "display_name": "spec_negate",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_negate().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_negate(limbs: [u64; 5]) -> [u64; 5] {\n    let r = spec_reduce(pre_reduce_limbs(limbs));\n    r\n}",
      "start_line": 125,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sqrt_ratio_exponent().",
      "display_name": "sqrt_ratio_exponent",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sqrt_ratio_exponent().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn sqrt_ratio_exponent() -> nat {\n    ((p() - 5) / 8) as nat\n}",
      "start_line": 500,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "display_name": "lemma_mul_is_distributive_add",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 28,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_multiples_vanish_fancy().",
      "display_name": "lemma_div_multiples_vanish_fancy",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_multiples_vanish_fancy().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/lemma_inverse_unique_core().",
      "display_name": "lemma_inverse_unique_core",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/lemma_inverse_unique_core().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "proof fn lemma_inverse_unique_core(a: nat, w: nat, z: nat, p: nat)\n    requires\n        p > 0,\n        a % p != 0,\n        w < p,\n        z < p,\n        (a * w) % p == 1,\n        (a * z) % p == 1,\n    ensures\n        w == z,\n{\n    // Step 1: Since w < p and z < p, they are their own remainders mod p\n    assert(w % p == w) by {\n        lemma_small_mod(w, p);\n    };\n    assert(z % p == z) by {\n        lemma_small_mod(z, p);\n    };\n\n    // Step 2: Compute (a * w * z) % p by multiplying first equation by z\n    // From (a * w) % p == 1, we get ((a * w) % p * z) % p == z\n    assert((a * w * z) % p == z) by {\n        lemma_mul_mod_noop_general((a * w) as int, z as int, p as int);\n        // This gives us: ((a * w) % p * z) % p == (a * w * z) % p\n        assert(((a * w) % p * z) % p == (a * w * z) % p);\n        // Since (a * w) % p == 1, we have: (1 * z) % p == (a * w * z) % p\n        assert(((a * w) % p * z) % p == (1 * z) % p);\n        // And (1 * z) % p == z since z < p\n        assert((1 * z) % p == z);\n    };\n\n    // Step 3: Compute (a * z * w) % p by multiplying second equation by w\n    // From (a * z) % p == 1, we get ((a * z) % p * w) % p == w\n    assert((a * z * w) % p == w) by {\n        lemma_mul_mod_noop_general((a * z) as int, w as int, p as int);\n        // This gives us: ((a * z) % p * w) % p == (a * z * w) % p\n        assert(((a * z) % p * w) % p == (a * z * w) % p);\n        // Since (a * z) % p == 1, we have: (1 * w) % p == (a * z * w) % p\n        assert(((a * z) % p * w) % p == (1 * w) % p);\n        // And (1 * w) % p == w since w < p\n        assert((1 * w) % p == w);\n    };\n\n    // Step 4: Show a * w * z == a * z * w by commutativity\n    assert(a * w * z == a * z * w) by {\n        lemma_mul_is_associative(a as int, w as int, z as int);\n        lemma_mul_is_associative(a as int, z as int, w as int);\n        // a * w * z = a * (w * z) = a * (z * w) = a * z * w\n        assert(a * w * z == a * (w * z));\n        assert(w * z == z * w);\n        assert(a * (w * z) == a * (z * w));\n        assert(a * (z * w) == a * z * w);\n    };\n\n    // Step 5: Conclude w == z\n    // We have: z == (a * w * z) % p == (a * z * w) % p == w\n    assert(w == z);\n}",
      "start_line": 164,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_and_mod().",
      "display_name": "lemma_div_and_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_and_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_div_and_mod(ai: u64, bi: u64, v: u64, k: nat)\n    requires\n        k < 64,\n        ai == v >> k,\n        bi == v & (low_bits_mask(k) as u64),\n    ensures\n        ai == v / (pow2(k) as u64),\n        bi == v % (pow2(k) as u64),\n        v == ai * pow2(k) + bi,\n{\n    lemma2_to64();\n    lemma2_to64_rest();  // pow2(63) = 0x8000000000000000\n\n    // v >> k = v / pow2(k);\n    lemma_u64_shr_is_div(v, k as u64);\n\n    // v & low_bits_mask(k) = v % pow2(k);\n    lemma_u64_low_bits_mask_is_mod(v, k);\n\n    // 0 < pow2(k) <= u64::MAX\n    lemma_pow2_pos(k);\n    assert(pow2(k) <= u64::MAX) by {\n        if (k < 63) {\n            lemma_pow2_strictly_increases(k, 63);\n        }\n    }\n\n    // v = (pow2(k) * (v / pow2(k)) + (v % pow2(k)))\n    lemma_fundamental_div_mod(v as int, pow2(k) as int);\n}",
      "start_line": 10,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_five_limbs_equals_to_nat().",
      "display_name": "lemma_five_limbs_equals_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_five_limbs_equals_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_five_limbs_equals_to_nat(limbs: &[u64; 5])\n    ensures\n        five_limbs_to_nat_aux(*limbs) == to_nat(limbs),\n{\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        to_nat(limbs); {}\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 6);\n        }\n        (limbs[0] as nat) + ((limbs[1] as nat) + ((limbs[2] as nat) + ((limbs[3] as nat) + (\n        limbs[4] as nat) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52); {\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(104, 52);\n            lemma_pow2_adds(156, 52);\n            broadcast use group_mul_is_distributive;\n            broadcast use lemma_mul_is_associative;\n\n        }\n        (limbs[0] as nat) + pow2(52) * (limbs[1] as nat) + pow2(104) * (limbs[2] as nat) + pow2(156)\n            * (limbs[3] as nat) + pow2(208) * (limbs[4] as nat); {}\n        five_limbs_to_nat_aux(*limbs);\n    }\n}",
      "start_line": 205,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 10,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strict_inequality_converse().",
      "display_name": "lemma_mul_strict_inequality_converse",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strict_inequality_converse().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "display_name": "spec_sqrt_m1",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_sqrt_m1() -> nat {\n    spec_field_element(&constants::SQRT_M1)\n}",
      "start_line": 474,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 15,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a3_0_val().",
      "display_name": "a3_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a3_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn a3_0_val(a: [u64; 5]) -> u64 {\n    (c3_val(a) as u64) & mask51\n}",
      "start_line": 92,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_valid_radix_2w().",
      "display_name": "is_valid_radix_2w",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_valid_radix_2w().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_valid_radix_2w(digits: &[i8; 64], w: nat, digits_count: nat) -> bool {\n    4 <= w <= 8 && digits_count <= 64 && forall|i: int|\n        0 <= i < digits_count ==> {\n            let bound = pow2((w - 1) as nat) as int;\n            if i < digits_count - 1 {\n                -bound <= (#[trigger] digits[i]) && (#[trigger] digits[i]) < bound\n            } else {\n                -bound <= (#[trigger] digits[i]) && (#[trigger] digits[i]) <= bound\n            }\n        }\n}",
      "start_line": 204,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_mod_noop().",
      "display_name": "lemma_pow_mod_noop",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_mod_noop().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "curve25519-dalek/src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 Choice#BitAnd#bitand().",
      "display_name": "bitand",
      "symbol": "rust-analyzer cargo subtle 2.6.1 Choice#BitAnd#bitand().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "display_name": "lemma_limb2_contribution_correctness",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_limb2_contribution_correctness(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[1] < pow2(51),  // Need limb 1 for boundary byte 12\n        limbs[2] < pow2(51),\n        bytes_match_limbs_packing(limbs, bytes),\n    ensures\n        limb2_byte_contribution(limbs, bytes) == limbs[2] as nat * pow2(102),\n{\n    // Limb 2 stored in bytes 12-19, positioned at 2^102\n    // - Byte 12 (high 2 bits): limbs[2]'s bits 0-1\n    // - Bytes 13-18: limbs[2]'s bits 2-49 (48 bits)\n    // - Byte 19 (low 1 bit): limbs[2]'s bit 50\n    // Total: 2 + 48 + 1 = 51 bits\n    lemma2_to64();\n    lemma_pow2_adds(96, 6);  // 2^102 = 2^96 * 2^6\n    assert(pow2(102) == pow2(96) * 64);\n\n    // Stabilization placeholders\n    assert(pow2(0) == pow2(0 * 8));\n    assert(pow2(8) == pow2(1 * 8));\n    assert(pow2(16) == pow2(2 * 8));\n    assert(pow2(24) == pow2(3 * 8));\n    assert(pow2(32) == pow2(4 * 8));\n\n    // KEY INSIGHT: From bytes_match_limbs_packing:\n    // bytes[13] = (limbs[2] >> 2) as u8\n    // bytes[14] = (limbs[2] >> 10) as u8\n    // ... and so on\n    //\n    // So limb2_byte_contribution is:\n    //   (limbs[2] % 2^2) * 64 * 2^96 +             // Low 2 bits at position 2^102\n    //   (limbs[2] >> 2 ... >> 42) * positions +    // Middle 48 bits at position 2^104\n    //   (limbs[2] / 2^50) % 2 * 2^152              // High 1 bit at position 2^152\n    //\n    // This is limbs[2] * 2^102!\n\n    // Step 1: Extract arithmetic values for bytes 13-18\n    // These bytes come from limbs[2] >> 2, 10, 18, 26, 34, 42\n    lemma_byte_from_limb_shift(limbs[2], 2, bytes[13]);\n\n    lemma_byte_from_limb_shift(limbs[2], 10, bytes[14]);\n    assert(bytes[14] as nat == (limbs[2] as nat / pow2(10)) % 256);\n\n    lemma_byte_from_limb_shift(limbs[2], 18, bytes[15]);\n\n    lemma_byte_from_limb_shift(limbs[2], 26, bytes[16]);\n\n    lemma_byte_from_limb_shift(limbs[2], 34, bytes[17]);\n\n    lemma_byte_from_limb_shift(limbs[2], 42, bytes[18]);\n\n    // Step 2: Prove that bytes[13-18] reconstruct ((limbs[2] / 2^2) % 2^48) at position 2^104\n    //\n    // From lemma_byte_from_limb_shift, we have:\n    // bytes[13] as nat == (limbs[2] / pow2(2)) % 256\n    // bytes[14] as nat == (limbs[2] / pow2(10)) % 256\n    // bytes[15] as nat == (limbs[2] / pow2(18)) % 256\n    // bytes[16] as nat == (limbs[2] / pow2(26)) % 256\n    // bytes[17] as nat == (limbs[2] / pow2(34)) % 256\n    // bytes[18] as nat == (limbs[2] / pow2(42)) % 256\n    //\n    // The key insight: these bytes extract consecutive 8-bit chunks from (limbs[2] / 2^2)\n\n    // First, rewrite the byte extractions in terms of (limbs[2] / 2^2)\n    // bytes[13] == (limbs[2] / 2^2) / 2^0 % 256\n    lemma_pow2_adds(0, 2);\n    lemma_div_denominator(limbs[2] as int, pow2(2) as int, pow2(0) as int);\n\n    // bytes[14] == (limbs[2] / 2^10) % 256 == (limbs[2] / 2^2) / 2^8 % 256\n    lemma_pow2_adds(2, 8);\n    lemma_div_denominator(limbs[2] as int, pow2(2) as int, pow2(8) as int);\n\n    // bytes[15] == (limbs[2] / 2^18) % 256 == (limbs[2] / 2^2) / 2^16 % 256\n    lemma_pow2_adds(2, 16);\n    assert(pow2(2) * pow2(16) == pow2(18));\n    lemma_div_denominator(limbs[2] as int, pow2(2) as int, pow2(16) as int);\n\n    // bytes[16] == (limbs[2] / 2^26) % 256 == (limbs[2] / 2^2) / 2^24 % 256\n    lemma_pow2_adds(2, 24);\n    lemma_div_denominator(limbs[2] as int, pow2(2) as int, pow2(24) as int);\n\n    // bytes[17] == (limbs[2] / 2^34) % 256 == (limbs[2] / 2^2) / 2^32 % 256\n    lemma_pow2_adds(2, 32);\n    lemma_div_denominator(limbs[2] as int, pow2(2) as int, pow2(32) as int);\n\n    // bytes[18] == (limbs[2] / 2^42) % 256 == (limbs[2] / 2^2) / 2^40 % 256\n    lemma_pow2_adds(2, 40);\n    lemma_pow2_pos(40);\n    lemma_div_denominator(limbs[2] as int, pow2(2) as int, pow2(40) as int);\n\n    // Now handle the % 2^48 truncation\n    // Since limbs[2] < 2^51, we have limbs[2] / 2^2 < 2^49\n    lemma_div_bound(limbs[2] as nat, 2, 51);\n\n    // The bytes extract bits at positions [0..8), [8..16), [16..24), [24..32), [32..40), [40..48)\n    // from (limbs[2] / 2^2). Since all these bit positions are < 48, taking % 2^48\n    // doesn't change the extracted bytes (same argument as limb 1).\n\n    let middle_value = (limbs[2] as nat / pow2(2)) % pow2(48);\n\n    // Prove middle_value < 2^48 (trivial by definition of %)\n    lemma_pow2_pos(48);\n    lemma_mod_bound(middle_value as int, pow2(48) as int);\n\n    // Now prove that the bytes extract from middle_value\n    let v = limbs[2] as nat / pow2(2);\n    assert(bytes[13] as nat == v / pow2(0) % 256);\n\n    // Use lemma_byte_extraction_commutes_with_mod to show extraction commutes with % 2^48\n    // For byte at position k, we need k*8 + 8 <= 48\n    lemma_byte_extraction_commutes_with_mod(v, 0, 48);  // 0*8 + 8 = 8 <= 48 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 1, 48);  // 1*8 + 8 = 16 <= 48 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 2, 48);  // 2*8 + 8 = 24 <= 48 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 3, 48);  // 3*8 + 8 = 32 <= 48 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 4, 48);  // 4*8 + 8 = 40 <= 48 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 5, 48);  // 5*8 + 8 = 48 <= 48 ✓\n    assert(bytes[18] as nat == (middle_value / pow2(40)) % 256);\n\n    // Now apply lemma_6_bytes_reconstruct\n    lemma_6_bytes_reconstruct(\n        middle_value,\n        bytes[13],\n        bytes[14],\n        bytes[15],\n        bytes[16],\n        bytes[17],\n        bytes[18],\n    );\n\n    // This gives us:\n    assert(bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8) + bytes[15] as nat * pow2(16)\n        + bytes[16] as nat * pow2(24) + bytes[17] as nat * pow2(32) + bytes[18] as nat * pow2(40)\n        == middle_value);\n\n    // Now multiply both sides by 2^104 to get the bytes at their actual positions\n    lemma_mul_is_distributive_add(\n        pow2(104) as int,\n        (bytes[13] as nat * pow2(0)) as int,\n        (bytes[14] as nat * pow2(8)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(104) as int,\n        (bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8)) as int,\n        (bytes[15] as nat * pow2(16)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(104) as int,\n        (bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8) + bytes[15] as nat * pow2(\n            16,\n        )) as int,\n        (bytes[16] as nat * pow2(24)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(104) as int,\n        (bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8) + bytes[15] as nat * pow2(16)\n            + bytes[16] as nat * pow2(24)) as int,\n        (bytes[17] as nat * pow2(32)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(104) as int,\n        (bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8) + bytes[15] as nat * pow2(16)\n            + bytes[16] as nat * pow2(24) + bytes[17] as nat * pow2(32)) as int,\n        (bytes[18] as nat * pow2(40)) as int,\n    );\n\n    // Distribute the multiplication into each term\n    lemma_mul_is_associative(bytes[13] as int, pow2(0) as int, pow2(104) as int);\n    lemma_mul_is_associative(bytes[14] as int, pow2(8) as int, pow2(104) as int);\n    lemma_mul_is_associative(bytes[15] as int, pow2(16) as int, pow2(104) as int);\n    lemma_mul_is_associative(bytes[16] as int, pow2(24) as int, pow2(104) as int);\n    lemma_mul_is_associative(bytes[17] as int, pow2(32) as int, pow2(104) as int);\n    lemma_mul_is_associative(bytes[18] as int, pow2(40) as int, pow2(104) as int);\n\n    // Simplify using pow2 addition: 2^104 * 2^k = 2^(104+k)\n    lemma_pow2_adds(104, 0);\n\n    lemma_pow2_adds(104, 8);\n\n    lemma_pow2_adds(104, 16);\n\n    lemma_pow2_adds(104, 24);\n\n    lemma_pow2_adds(104, 32);\n\n    lemma_pow2_adds(104, 40);\n\n    // Now we need to show that the distributed sum equals middle_value * pow2(104)\n    // We have: bytes[13] * 2^0 + ... + bytes[18] * 2^40 = middle_value\n    // We distributed 2^104 into each term\n    // Now we need to show the result\n\n    // Build up the sum step by step\n    let sum_0 = bytes[13] as nat * pow2(13 * 8);\n    let sum_1 = sum_0 + bytes[14] as nat * pow2(14 * 8);\n    let sum_2 = sum_1 + bytes[15] as nat * pow2(15 * 8);\n    let sum_3 = sum_2 + bytes[16] as nat * pow2(16 * 8);\n    let sum_4 = sum_3 + bytes[17] as nat * pow2(17 * 8);\n    let sum_5 = sum_4 + bytes[18] as nat * pow2(18 * 8);\n\n    // This should equal middle_value * pow2(104) by the distributivity we applied\n\n    // Final result\n    assert(bytes[13] as nat * pow2(13 * 8) + bytes[14] as nat * pow2(14 * 8) + bytes[15] as nat\n        * pow2(15 * 8) + bytes[16] as nat * pow2(16 * 8) + bytes[17] as nat * pow2(17 * 8)\n        + bytes[18] as nat * pow2(18 * 8) == middle_value * pow2(104));\n\n    // Step 3: Handle boundary bytes\n    // Low 2 bits (byte 12 high part): (limbs[2] % 2^2) * 64 * 2^96 = (limbs[2] % 2^2) * 2^102\n    // High 1 bit (byte 19 low part): (limbs[2] / 2^50) % 2 * 2^152\n\n    assert(64 * pow2(96) == pow2(102)) by {\n        lemma_pow2_adds(96, 6);\n    }\n\n    // From the proof above, we have:\n    let middle_bytes_sum = bytes[13] as nat * pow2(13 * 8) + bytes[14] as nat * pow2(14 * 8)\n        + bytes[15] as nat * pow2(15 * 8) + bytes[16] as nat * pow2(16 * 8) + bytes[17] as nat\n        * pow2(17 * 8) + bytes[18] as nat * pow2(18 * 8);\n\n    let middle_value_at_position = ((limbs[2] as nat / pow2(2)) % pow2(48)) * pow2(104);\n\n    // Substitute into contribution\n    let contribution = limb2_byte_contribution(limbs, bytes);\n    assert(contribution == ((limbs[2] as nat % pow2(2)) * 64) * pow2(96) + middle_bytes_sum + ((\n    limbs[2] as nat / pow2(50)) % 2) * pow2(152));\n\n    // Step 3: Prove the reconstruction identity for limbs[2]\n    // limbs[2] = (limbs[2] % 2^2) + ((limbs[2] / 2^2) % 2^48) * 2^2 + ((limbs[2] / 2^50) % 2^1) * 2^50\n\n    // This follows the same pattern as limb 1, but with different split points:\n    // - Low 2 bits instead of 5\n    // - Middle 48 bits instead of 40\n    // - Split at 2, 50 instead of 5, 45\n\n    // First, reconstruct limbs[2] / 2^2 from its low 48 bits and high part\n    lemma_pow2_pos(48);\n    let shifted_value = limbs[2] as nat / pow2(2);\n    lemma_fundamental_div_mod(shifted_value as int, pow2(48) as int);\n    // lemma_fundamental_div_mod gives: shifted_value == pow2(48) * (shifted_value / pow2(48)) + (shifted_value % pow2(48))\n    // We need: shifted_value == (shifted_value % pow2(48)) + (shifted_value / pow2(48)) * pow2(48)\n    assert(pow2(48) * (shifted_value / pow2(48)) == (shifted_value / pow2(48)) * pow2(48)) by {\n        lemma_mul_is_commutative(pow2(48) as int, (shifted_value / pow2(48)) as int);\n    }\n\n    // Show that (limbs[2] / 2^2) / 2^48 = limbs[2] / 2^50\n    lemma_div_denominator(limbs[2] as int, pow2(2) as int, pow2(48) as int);\n    lemma_pow2_adds(2, 48);\n\n    // So: limbs[2] / 2^2 = ((limbs[2] / 2^2) % 2^48) + (limbs[2] / 2^50) * 2^48\n    assert(shifted_value == (shifted_value % pow2(48)) + (limbs[2] as nat / pow2(50)) * pow2(48));\n\n    // Next, reconstruct limbs[2] from its low 2 bits and (limbs[2] / 2^2)\n    lemma_pow2_pos(2);\n    lemma_fundamental_div_mod(limbs[2] as int, pow2(2) as int);\n    // lemma_fundamental_div_mod gives: limbs[2] == pow2(2) * (limbs[2] / pow2(2)) + (limbs[2] % pow2(2))\n    assert(pow2(2) * shifted_value == shifted_value * pow2(2)) by {\n        lemma_mul_is_commutative(pow2(2) as int, shifted_value as int);\n    }\n\n    // Substitute the reconstruction of shifted_value (limbs[2] / 2^2)\n    assert(limbs[2] as nat == (limbs[2] as nat % pow2(2)) + ((shifted_value % pow2(48)) + (\n    limbs[2] as nat / pow2(50)) * pow2(48)) * pow2(2));\n\n    // Distribute the * 2^2\n    assert(limbs[2] as nat == (limbs[2] as nat % pow2(2)) + (shifted_value % pow2(48)) * pow2(2) + (\n    limbs[2] as nat / pow2(50)) * pow2(48) * pow2(2)) by {\n        lemma_mul_is_distributive_add(\n            pow2(2) as int,\n            (shifted_value % pow2(48)) as int,\n            (limbs[2] as nat / pow2(50) * pow2(48)) as int,\n        );\n    }\n\n    // Use 2^48 * 2^2 = 2^50\n    lemma_pow2_adds(48, 2);\n    assert((limbs[2] as nat / pow2(50)) * pow2(48) * pow2(2) == (limbs[2] as nat / pow2(50)) * pow2(\n        50,\n    )) by {\n        lemma_mul_is_associative(\n            (limbs[2] as nat / pow2(50)) as int,\n            pow2(48) as int,\n            pow2(2) as int,\n        );\n    }\n\n    assert(limbs[2] as nat == (limbs[2] as nat % pow2(2)) + ((limbs[2] as nat / pow2(2)) % pow2(48))\n        * pow2(2) + (limbs[2] as nat / pow2(50)) * pow2(50));\n\n    // Handle the % 2 on the high bit\n    // Since limbs[2] < 2^51, we have limbs[2] / 2^50 < 2^1 = 2\n    lemma_div_bound(limbs[2] as nat, 50, 51);\n    assert(limbs[2] as nat / pow2(50) < pow2(1));\n    lemma_small_mod(limbs[2] as nat / pow2(50), 2);\n\n    // Therefore:\n    assert(limbs[2] as nat == (limbs[2] as nat % pow2(2)) + ((limbs[2] as nat / pow2(2)) % pow2(48))\n        * pow2(2) + ((limbs[2] as nat / pow2(50)) % 2) * pow2(50));\n\n    // Step 4: Now connect the contribution to limbs[2] * 2^102\n    // We have: contribution = ((limbs[2] % 2^2) * 64) * 2^96 + middle_bytes_sum + ((limbs[2] / 2^50) % 2) * 2^152\n    // Where: middle_bytes_sum = ((limbs[2] / 2^2) % 2^48) * 2^104\n\n    // First, simplify the low term: ((limbs[2] % 2^2) * 64) * 2^96 = (limbs[2] % 2^2) * (64 * 2^96) = (limbs[2] % 2^2) * 2^102\n    // We proved earlier that 64 * 2^96 = 2^102\n    let low_part = (limbs[2] as nat % pow2(2));\n    assert(((limbs[2] as nat % pow2(2)) * 64) * pow2(96) == low_part * (64 * pow2(96))) by {\n        lemma_mul_is_associative(low_part as int, 64, pow2(96) as int);\n    }\n\n    // So contribution = (limbs[2] % 2^2) * 2^102 + ((limbs[2] / 2^2) % 2^48) * 2^104 + ((limbs[2] / 2^50) % 2) * 2^152\n    assert(contribution == low_part * pow2(102) + ((limbs[2] as nat / pow2(2)) % pow2(48)) * pow2(\n        104,\n    ) + ((limbs[2] as nat / pow2(50)) % 2) * pow2(152));\n\n    // Rewrite using 2^104 = 2^102 * 2^2 and 2^152 = 2^102 * 2^50\n    lemma_pow2_adds(102, 2);\n    lemma_pow2_adds(102, 50);\n\n    assert(contribution == low_part * pow2(102) + ((limbs[2] as nat / pow2(2)) % pow2(48)) * (pow2(\n        102,\n    ) * pow2(2)) + ((limbs[2] as nat / pow2(50)) % 2) * (pow2(102) * pow2(50)));\n\n    // Apply associativity to move pow2(102) to the left\n    let middle_part = (limbs[2] as nat / pow2(2)) % pow2(48);\n    let high_part = (limbs[2] as nat / pow2(50)) % 2;\n\n    assert(middle_part * (pow2(102) * pow2(2)) == (middle_part * pow2(102)) * pow2(2)) by {\n        lemma_mul_is_associative(middle_part as int, pow2(102) as int, pow2(2) as int);\n    }\n    assert((middle_part * pow2(102)) * pow2(2) == pow2(102) * middle_part * pow2(2)) by {\n        lemma_mul_is_commutative((middle_part * pow2(102)) as int, pow2(2) as int);\n    }\n    assert(pow2(102) * middle_part * pow2(2) == pow2(102) * (middle_part * pow2(2))) by {\n        lemma_mul_is_associative(pow2(102) as int, middle_part as int, pow2(2) as int);\n    }\n\n    assert(high_part * (pow2(102) * pow2(50)) == (high_part * pow2(102)) * pow2(50)) by {\n        lemma_mul_is_associative(high_part as int, pow2(102) as int, pow2(50) as int);\n    }\n    assert((high_part * pow2(102)) * pow2(50) == pow2(102) * high_part * pow2(50)) by {\n        lemma_mul_is_commutative((high_part * pow2(102)) as int, pow2(50) as int);\n    }\n    assert(pow2(102) * high_part * pow2(50) == pow2(102) * (high_part * pow2(50))) by {\n        lemma_mul_is_associative(pow2(102) as int, high_part as int, pow2(50) as int);\n    }\n\n    // Now factor out pow2(102)\n    assert(contribution == low_part * pow2(102) + pow2(102) * (middle_part * pow2(2)) + pow2(102)\n        * (high_part * pow2(50)));\n\n    // Use distributivity to factor out pow2(102)\n    assert(contribution == pow2(102) * (low_part + middle_part * pow2(2) + high_part * pow2(50)))\n        by {\n        lemma_mul_is_distributive_add(\n            pow2(102) as int,\n            low_part as int,\n            (middle_part * pow2(2)) as int,\n        );\n        lemma_mul_is_distributive_add(\n            pow2(102) as int,\n            (low_part + middle_part * pow2(2)) as int,\n            (high_part * pow2(50)) as int,\n        );\n    }\n\n    // The part in parentheses equals limbs[2] by our reconstruction identity!\n    assert(contribution == limbs[2] as nat * pow2(102)) by {\n        lemma_mul_is_commutative(pow2(102) as int, limbs[2] as int);\n    }\n\n}",
      "start_line": 948,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 17
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/bits_be_to_nat().",
      "display_name": "bits_be_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/bits_be_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn bits_be_to_nat(bits: &[bool], len: int) -> nat\n    recommends\n        0 <= len <= bits.len(),\n    decreases len,\n{\n    if len <= 0 {\n        0\n    } else {\n        let bit_value = if bits[len - 1] {\n            1nat\n        } else {\n            0nat\n        };\n        bit_value + 2 * bits_be_to_nat(bits, len - 1)\n    }\n}",
      "start_line": 243,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_sqrt_ratio_times_i().",
      "display_name": "is_sqrt_ratio_times_i",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_sqrt_ratio_times_i().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_sqrt_ratio_times_i(\n    u: &FieldElement51,\n    v: &FieldElement51,\n    r: &FieldElement51,\n) -> bool {\n    (spec_field_element(r) * spec_field_element(r) * spec_field_element(v)) % p() == (\n    spec_field_element(&constants::SQRT_M1) * spec_field_element(u)) % p()\n}",
      "start_line": 444,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "display_name": "decompress",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn decompress(&self) -> (result: Option<\n        EdwardsPoint,\n    >)\n        requires\n            is_valid_compressed_edwards_y(&self.0),\n        ensures\n            math_is_valid_y_coordinate(spec_field_element_from_bytes(&self.0))\n                ==> result.is_some()\n            // The Y coordinate matches the one from the compressed representation\n             && spec_field_element(&result.unwrap().Y) == spec_field_element_from_bytes(\n                &self.0,\n            )\n            // The point is valid\n             && is_valid_edwards_point(\n                result.unwrap(),\n            )\n            // The X coordinate sign bit matches the sign bit from the compressed representation\n             && spec_field_element_sign_bit(&result.unwrap().X) == (self.0[31] >> 7),\n            !math_is_valid_y_coordinate(spec_field_element_from_bytes(&self.0))\n                <==> result.is_none(),\n    {\n        let (is_valid_y_coord, X, Y, Z) = decompress::step_1(self);\n\n        proof {\n            assert(choice_is_true(is_valid_y_coord) ==> math_is_valid_y_coordinate(\n                spec_field_element_from_bytes(&self.0),\n            ));\n            assert(choice_is_true(is_valid_y_coord) ==> math_on_edwards_curve(\n                spec_field_element(&X),\n                spec_field_element(&Y),\n            ));\n        }\n        if choice_into(is_valid_y_coord) {\n            let point = decompress::step_2(self, X, Y, Z);\n            let result = Some(point);\n            proof {\n                // Extract values for lemma\n                let x_orig = spec_field_element(&X);\n                let y = spec_field_element(&Y);\n                \n                // Establish step_2 postconditions needed by lemma\n                // step_2 ensures Y and Z are preserved by reference equality\n                assert(&point.Y == &Y);\n                assert(&point.Z == &Z);\n                assert(spec_field_element(&point.Y) == y);\n                assert(spec_field_element(&point.Z) == 1);\n                \n                // Use the unified lemma to prove all postconditions\n                lemma_decompress_valid_branch(&self.0, x_orig, y, &point);\n            }\n            result\n        } else {\n            let result = None;\n            result\n        }\n    }",
      "start_line": 246,
      "end_line": 22,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 12
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_bounded().",
      "display_name": "lemma_as_nat_prefix_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "file_name": "u8_32_as_nat_injectivity_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_as_nat_prefix_bounded(bytes: &[u8; 32], n: nat)\n    requires\n        n <= 32,\n    ensures\n        as_nat_prefix(bytes, n) < pow2((n * 8) as nat),\n    decreases n,\n{\n    lemma2_to64();\n\n    if n == 0 {\n        // Base case: as_nat_prefix(bytes, 0) == 0 < 1 == pow2(0)\n        assert(pow2(0) == 1) by {\n            lemma2_to64();\n        }\n        assert(as_nat_prefix(bytes, 0) == 0);\n    } else {\n        // Inductive case\n        lemma_as_nat_prefix_bounded(bytes, (n - 1) as nat);\n        lemma_u8_lt_pow2_8(bytes[(n - 1) as int]);\n\n        // Key identity: pow2(n*8) = pow2((n-1)*8 + 8) = pow2((n-1)*8) * pow2(8)\n        assert(n * 8 == (n - 1) * 8 + 8) by {\n            lemma_mul_is_distributive_sub(8, n as int, 1);\n        }\n        lemma_pow2_adds(((n - 1) * 8) as nat, 8);\n        assert(pow2((n * 8) as nat) == pow2(((n - 1) * 8) as nat) * pow2(8));\n\n        // Now use nonlinear arithmetic to combine\n        let prev = as_nat_prefix(bytes, (n - 1) as nat);\n        let byte_val = bytes[(n - 1) as int] as nat;\n        let p1 = pow2(((n - 1) * 8) as nat);\n        let p2 = pow2(8);\n\n        assert(prev + byte_val * p1 < p1 * p2) by (nonlinear_arith)\n            requires\n                prev < p1,\n                byte_val < p2,\n                p2 == 256,\n        {}\n    }\n}",
      "start_line": 34,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 CtOption#is_none().",
      "display_name": "is_none",
      "symbol": "rust-analyzer cargo subtle 2.6.1 CtOption#is_none().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo digest 0.10.7 digest/Digest#update().",
      "display_name": "update",
      "symbol": "rust-analyzer cargo digest 0.10.7 digest/Digest#update().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_projective_niels_point().",
      "display_name": "is_valid_projective_niels_point",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_projective_niels_point().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_valid_projective_niels_point(niels: ProjectiveNielsPoint) -> bool {\n    // A ProjectiveNielsPoint is valid if there exists an EdwardsPoint that:\n    // 1. Is valid itself\n    // 2. The niels point corresponds to it\n    exists|point: EdwardsPoint|\n        is_valid_edwards_point(point) && #[trigger] projective_niels_corresponds_to_edwards(\n            niels,\n            point,\n        )\n}",
      "start_line": 438,
      "end_line": 49,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "display_name": "add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn add(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n        requires\n            limbs_bounded(a),\n            limbs_bounded(b),\n            to_nat(&a.limbs) < group_order(),\n            to_nat(&b.limbs) < group_order(),\n        ensures\n            to_nat(&s.limbs) == (to_nat(&a.limbs) + to_nat(&b.limbs)) % group_order(),\n            // VERIFICATION NOTE: Result is canonical\n            to_nat(&s.limbs) < group_order(),\n            // VERIFICATION NOTE: Result has bounded limbs (from sub)\n            limbs_bounded(&s),\n    {\n        let mut sum = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        proof {\n            assert(1u64 << 52 > 0) by (bit_vector);\n        }\n        let mask = (1u64 << 52) - 1;\n\n        // a + b\n        let mut carry: u64 = 0;\n        proof {\n            // Base case: empty subrange has value 0\n            assert(seq_u64_to_nat(a.limbs@.subrange(0, 0 as int)) == 0);\n            assert(seq_u64_to_nat(b.limbs@.subrange(0, 0 as int)) == 0);\n            assert(seq_u64_to_nat(sum.limbs@.subrange(0, 0 as int)) == 0);\n            assert((carry >> 52) == 0) by (bit_vector)\n                requires\n                    carry == 0,\n            ;\n            lemma2_to64();\n            assert(pow2(0) == 1);\n        }\n        for i in 0..5\n            invariant\n                forall|j: int| 0 <= j < i ==> sum.limbs[j] < 1u64 << 52,\n                limbs_bounded(a),\n                limbs_bounded(b),\n                mask == (1u64 << 52) - 1,\n                i == 0 ==> carry == 0,\n                i >= 1 ==> (carry >> 52) < 2,\n                seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n                    b.limbs@.subrange(0, i as int),\n                ) == seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (carry >> 52) * pow2(\n                    (52 * (i) as nat),\n                ),\n        {\n            proof {\n                lemma_add_loop_bounds(i as int, carry, a.limbs[i as int], b.limbs[i as int]);\n            }\n            let ghost old_carry = carry;\n            carry = a.limbs[i] + b.limbs[i] + (carry >> 52);\n            let ghost sum_loop_start = sum;\n            sum.limbs[i] = carry & mask;\n            assert(sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int));\n            proof {\n                lemma_add_loop_invariant(sum, carry, i, a, b, old_carry, mask, sum_loop_start);\n            }\n            proof {\n                lemma_add_carry_and_sum_bounds(carry, mask);\n            }\n        }\n\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            (52 * (5) as nat),\n        ));\n\n        proof {\n            lemma_add_sum_simplify(a, b, &sum, carry);\n        }\n\n        // subtract l if the sum is >= l\n        proof {\n            lemma_l_value_properties(&constants::L, &sum);\n        }\n        assert(group_order() > to_nat(&sum.limbs) - group_order() >= -group_order());\n        proof {\n            lemma_l_equals_group_order();\n        }\n        proof {\n            lemma_mod_sub_multiples_vanish(to_nat(&sum.limbs) as int, group_order() as int);\n        }\n        Scalar52::sub(&sum, &constants::L)\n    }",
      "start_line": 466,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_negation_preserves_curve().",
      "display_name": "lemma_negation_preserves_curve",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_negation_preserves_curve().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_negation_preserves_curve(x: nat, y: nat)\n    requires\n        math_on_edwards_curve(x, y),\n    ensures\n        math_on_edwards_curve(math_field_neg(x), y),\n{\n    // Goal: on_curve(-x, y)\n    // Strategy: The curve equation uses x², and (-x)² = x², so the equation is identical\n    //\n    //   y² - (-x)² = 1 + d·(-x)²·y²\n    //   y² - x²    = 1 + d·x²·y²      (same equation!)\n    //\n    // The precondition says (x, y) satisfies this, so (-x, y) does too.\n    \n    let neg_x = math_field_neg(x);\n    \n    assert(math_on_edwards_curve(neg_x, y)) by {\n        // Key insight: (-x)² = x²\n        assert(math_field_square(neg_x) == math_field_square(x)) by {\n            lemma_neg_square_eq(x);       // (-x)² = (x % p)²\n            lemma_square_mod_noop(x);     // (x % p)² = x²\n        };\n        // With (-x)² = x², the curve equations are identical\n    };\n}",
      "start_line": 247,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/pow2_sum().",
      "display_name": "pow2_sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/pow2_sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub open spec fn pow2_sum(coefs: &[u8], offset: nat, step: nat, k: nat) -> nat\n    decreases k,\n{\n    if (k == 0) {\n        coefs[offset as int] as nat * pow2(0)\n    } else {\n        // k > 0\n        pow2_sum(coefs, offset, step, (k - 1) as nat) + coefs[(offset + k) as int] as nat * pow2(\n            k * step,\n        )\n    }\n}",
      "start_line": 715,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_square_mod_p().",
      "display_name": "is_square_mod_p",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_square_mod_p().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_square_mod_p(a: nat) -> bool {\n    exists|y: nat| (#[trigger] (y * y) % p()) == (a % p())\n}",
      "start_line": 454,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#enumerate().",
      "display_name": "enumerate",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#enumerate().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_swap().",
      "display_name": "conditional_swap",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_swap().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }",
      "start_line": 683,
      "end_line": 24,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/negate_field_element().",
      "display_name": "negate_field_element",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/negate_field_element().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn negate_field_element(a: &FieldElement51) -> (result: FieldElement51)\n    requires\n        fe51_limbs_bounded(a, 52),  // Relaxed to match conditional_negate (safe up to 54-bit)\n    ensures\n        fe51_limbs_bounded(&result, 52),  // Neg produces 52-bit output\n        spec_field_element(&result) == math_field_neg(spec_field_element(a)),\n{\n    -a\n}",
      "start_line": 289,
      "end_line": 28,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption_factorial().",
      "display_name": "lemma_binomial_absorption_factorial",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption_factorial().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "proof fn lemma_binomial_absorption_factorial(n: nat, k: nat)\n    requires\n        n >= 1,\n        k >= 1,\n        k <= n,\n    ensures\n        k * binomial(n, k) == n * binomial((n - 1) as nat, (k - 1) as nat),\n{\n    lemma_binomial_factorial_relation(n, k);\n    lemma_binomial_factorial_relation((n - 1) as nat, (k - 1) as nat);\n\n    let binom_n_k = binomial(n, k);\n    let binom_nm1_km1 = binomial((n - 1) as nat, (k - 1) as nat);\n    let fact_k = factorial(k);\n    let fact_km1 = factorial((k - 1) as nat);\n    let fact_nmk = factorial((n - k) as nat);\n    let fact_n = factorial(n);\n    let fact_nm1 = factorial((n - 1) as nat);\n\n    assert(fact_k == k * fact_km1);\n    assert(fact_n == n * fact_nm1);\n\n    assert(fact_km1 > 0) by {\n        lemma_factorial_positive((k - 1) as nat);\n    };\n    assert(fact_nmk > 0) by {\n        lemma_factorial_positive((n - k) as nat);\n    };\n\n    assert(binom_n_k * fact_k * fact_nmk == fact_n);\n    assert(binom_nm1_km1 * fact_km1 * fact_nmk == fact_nm1);\n\n    let common = fact_km1 * fact_nmk;\n    assert(common > 0) by {\n        lemma_mul_strictly_positive(fact_km1 as int, fact_nmk as int);\n    };\n\n    assert(k * binom_n_k * common == fact_n) by {\n        assert(binom_n_k * fact_k * fact_nmk == fact_n);\n        assert(fact_k == k * fact_km1);\n        lemma_mul_is_associative(binom_n_k as int, k as int, fact_km1 as int);\n        lemma_mul_is_associative((binom_n_k * k) as int, fact_km1 as int, fact_nmk as int);\n        lemma_mul_is_commutative(binom_n_k as int, k as int);\n    };\n\n    assert(n * binom_nm1_km1 * common == fact_n) by {\n        assert(binom_nm1_km1 * fact_km1 * fact_nmk == fact_nm1);\n        assert(fact_n == n * fact_nm1);\n        lemma_mul_is_associative(n as int, binom_nm1_km1 as int, (fact_km1 * fact_nmk) as int);\n        lemma_mul_is_associative(binom_nm1_km1 as int, fact_km1 as int, fact_nmk as int);\n    };\n\n    // Now we have:\n    // k * binom_n_k * common == fact_n == n * binom_nm1_km1 * common\n    // Since common > 0, we can conclude k * binom_n_k == n * binom_nm1_km1\n    // vstd's lemma_mul_equality_converse requires m * x == m * y (m on left)\n    assert(common * (k * binom_n_k) == common * (n * binom_nm1_km1)) by {\n        lemma_mul_is_commutative((k * binom_n_k) as int, common as int);\n        lemma_mul_is_commutative((n * binom_nm1_km1) as int, common as int);\n    };\n    lemma_mul_equality_converse(common as int, (k * binom_n_k) as int, (n * binom_nm1_km1) as int);\n}",
      "start_line": 357,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_encode().",
      "display_name": "lizard_encode",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_encode().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    pub fn lizard_encode<D: Digest>(data: &[u8; 16]) -> RistrettoPoint\n    where\n        D: Digest<OutputSize = U32>,\n    {\n        let mut fe_bytes: [u8; 32] = Default::default();\n\n        let digest = D::digest(data);\n        fe_bytes[0..32].copy_from_slice(digest.as_slice());\n        fe_bytes[8..24].copy_from_slice(data);\n        fe_bytes[0] &= 254; // make positive since Elligator on r and -r is the same\n        fe_bytes[31] &= 63;\n        let fe = FieldElement::from_bytes(&fe_bytes);\n        RistrettoPoint::elligator_ristretto_flavor(&fe)\n    }",
      "start_line": 30,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/affine_projective_point_montgomery().",
      "display_name": "affine_projective_point_montgomery",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/affine_projective_point_montgomery().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn affine_projective_point_montgomery(\n    point: crate::montgomery::ProjectivePoint,\n) -> nat {\n    let (u, w) = spec_projective_point_montgomery(point);\n    if w == 0 {\n        0  // Identity case\n\n    } else {\n        math_field_mul(u, math_field_inv(w))\n    }\n}",
      "start_line": 211,
      "end_line": 52,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_increases().",
      "display_name": "lemma_mul_increases",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_increases().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/reconstruct_radix_16().",
      "display_name": "reconstruct_radix_16",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/reconstruct_radix_16().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn reconstruct_radix_16(digits: Seq<i8>) -> int {\n    reconstruct_radix_2w(digits, 4)\n}",
      "start_line": 219,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConstantTimeEq#ct_eq().",
      "display_name": "ct_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConstantTimeEq#ct_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn ct_eq(&self, other: &EdwardsPoint) -> (result:\n        Choice)/* VERIFICATION NOTE: we cannot add a \"requires\" clause to ct_eq with ConstantTimeEqSpecImpl,\n            unlike for Add trait implementations through AddSpecImpl.\n        */\n    // requires self.ct_eq_req(other),\n\n        ensures\n    // Two points are equal if they represent the same affine point:\n    // (X/Z, Y/Z) == (X'/Z', Y'/Z')\n    // This is checked by verifying X*Z' == X'*Z and Y*Z' == Y'*Z\n\n            choice_is_true(result) == (edwards_point_as_affine(*self) == edwards_point_as_affine(\n                *other,\n            )),\n    {\n        proof {\n            // Preconditions from ConstantTimeEqSpecImpl::ct_eq_req needed for multiplications below\n            /* VERIFICATION NOTE:\n            - Verus does not support adding a \"requires\" clause to ct_eq with ConstantTimeEqSpecImpl,\n            - For standard types like Add, a \"requires\" clause for \"add\" was supported through the AddSpecImpl\n            */\n            assume(self.ct_eq_req(other));\n        }\n\n        // We would like to check that the point (X/Z, Y/Z) is equal to\n        // the point (X'/Z', Y'/Z') without converting into affine\n        // coordinates (x, y) and (x', y'), which requires two inversions.\n        // We have that X = xZ and X' = x'Z'. Thus, x = x' is equivalent to\n        // (xZ)Z' = (x'Z')Z, and similarly for the y-coordinate.\n        /* ORIGINAL CODE:\n        let result = (&self.X * &other.Z).ct_eq(&(&other.X * &self.Z))\n            & (&self.Y * &other.Z).ct_eq(&(&other.Y * &self.Z));\n        */\n\n        let x_eq = (&self.X * &other.Z).ct_eq(&(&other.X * &self.Z));\n        let y_eq = (&self.Y * &other.Z).ct_eq(&(&other.Y * &self.Z));\n        let result = choice_and(x_eq, y_eq);\n\n        proof {\n            // The equality check via cross-multiplication is equivalent to affine coordinate equality\n            assume(choice_is_true(result) == (edwards_point_as_affine(*self)\n                == edwards_point_as_affine(*other)));\n        }\n\n        result\n    }",
      "start_line": 988,
      "end_line": 13,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_neg().",
      "display_name": "montgomery_neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn montgomery_neg(P: MontgomeryAffine) -> MontgomeryAffine {\n    match P {\n        MontgomeryAffine::Infinity => MontgomeryAffine::Infinity,\n        MontgomeryAffine::Finite { u, v } => { MontgomeryAffine::Finite { u, v: math_field_neg(v) }\n        },\n    }\n}",
      "start_line": 104,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_8_terms().",
      "display_name": "lemma_mul_distributive_8_terms",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_8_terms().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_mul_distributive_8_terms(\n    n: int,\n    x1: int,\n    x2: int,\n    x3: int,\n    x4: int,\n    x5: int,\n    x6: int,\n    x7: int,\n    x8: int,\n)\n    ensures\n        n * (x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8) == (x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8) * n\n            == n * x1 + n * x2 + n * x3 + n * x4 + n * x5 + n * x6 + n * x7 + n * x8,\n{\n    assert(n * (x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8) == (x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8)\n        * n) by {\n        lemma_mul_is_commutative(n, x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8);\n    }\n\n    assert(n * (x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8) == n * (x1 + x2 + x3 + x4 + x5 + x6 + x7) + n\n        * x8) by {\n        lemma_mul_is_distributive_add(n, x1 + x2 + x3 + x4 + x5 + x6 + x7, x8);\n    }\n\n    assert(n * (x1 + x2 + x3 + x4 + x5 + x6 + x7) == n * x1 + n * x2 + n * x3 + n * x4 + n * x5 + n\n        * x6 + n * x7) by {\n        lemma_mul_distributive_7_terms(n, x1, x2, x3, x4, x5, x6, x7);\n    }\n}",
      "start_line": 160,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a4_0_val().",
      "display_name": "a4_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a4_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn a4_0_val(a: [u64; 5]) -> u64 {\n    (c4_val(a) as u64) & mask51\n}",
      "start_line": 96,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_7_terms().",
      "display_name": "lemma_mul_distributive_7_terms",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_7_terms().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_mul_distributive_7_terms(\n    n: int,\n    x1: int,\n    x2: int,\n    x3: int,\n    x4: int,\n    x5: int,\n    x6: int,\n    x7: int,\n)\n    ensures\n        n * (x1 + x2 + x3 + x4 + x5 + x6 + x7) == (x1 + x2 + x3 + x4 + x5 + x6 + x7) * n == n * x1\n            + n * x2 + n * x3 + n * x4 + n * x5 + n * x6 + n * x7,\n{\n    assert(n * (x1 + x2 + x3 + x4 + x5 + x6 + x7) == (x1 + x2 + x3 + x4 + x5 + x6 + x7) * n) by {\n        lemma_mul_is_commutative(n, x1 + x2 + x3 + x4 + x5 + x6 + x7);\n    }\n\n    assert(n * (x1 + x2 + x3 + x4 + x5 + x6 + x7) == n * (x1 + x2 + x3 + x4 + x5 + x6) + n * x7)\n        by {\n        lemma_mul_is_distributive_add(n, x1 + x2 + x3 + x4 + x5 + x6, x7);\n    }\n\n    assert(n * (x1 + x2 + x3 + x4 + x5 + x6) == n * x1 + n * x2 + n * x3 + n * x4 + n * x5 + n * x6)\n        by {\n        lemma_mul_distributive_6_terms(n, x1, x2, x3, x4, x5, x6);\n    }\n}",
      "start_line": 131,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 Choice#Not#not().",
      "display_name": "not",
      "symbol": "rust-analyzer cargo subtle 2.6.1 Choice#Not#not().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "display_name": "lemma_mul_is_distributive_sub_other_way",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sub_limbs().",
      "display_name": "spec_sub_limbs",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sub_limbs().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_sub_limbs(a: &FieldElement51, b: &FieldElement51) -> FieldElement51 {\n    FieldElement51 {\n        limbs: spec_reduce(\n            [\n                ((a.limbs[0] + 36028797018963664u64) - b.limbs[0]) as u64,\n                ((a.limbs[1] + 36028797018963952u64) - b.limbs[1]) as u64,\n                ((a.limbs[2] + 36028797018963952u64) - b.limbs[2]) as u64,\n                ((a.limbs[3] + 36028797018963952u64) - b.limbs[3]) as u64,\n                ((a.limbs[4] + 36028797018963952u64) - b.limbs[4]) as u64,\n            ],\n        ),\n    }\n}",
      "start_line": 55,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_affine_niels_point().",
      "display_name": "is_valid_affine_niels_point",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_affine_niels_point().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_valid_affine_niels_point(niels: AffineNielsPoint) -> bool {\n    exists|point: EdwardsPoint|\n        is_valid_edwards_point(point) && #[trigger] affine_niels_corresponds_to_edwards(\n            niels,\n            point,\n        )\n}",
      "start_line": 503,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#ConstantTimeEq#ct_eq().",
      "display_name": "ct_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#ConstantTimeEq#ct_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn ct_eq(&self, other: &CompressedRistretto) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }",
      "start_line": 221,
      "end_line": 13,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/BasepointTable#create().",
      "display_name": "create",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/BasepointTable#create().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "curve25519-dalek/src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn create(basepoint: &Self::Point) -> Self;\n\n    /// Retrieve the original basepoint from this table.\n    fn basepoint(&self) -> Self::Point;\n\n    /// Multiply a `scalar` by this precomputed basepoint table, in constant time.\n    fn mul_base(&self, scalar: &Scalar) -> Self::Point;\n\n    /// Multiply `clamp_integer(bytes)` by this precomputed basepoint table, in constant time. For\n    /// a description of clamping, see [`clamp_integer`].\n    fn mul_base_clamped(&self, bytes: [u8; 32]) -> Self::Point {\n        // Basepoint multiplication is defined for all values of `bytes` up to and including\n        // 2^255 - 1. The limit comes from the fact that scalar.as_radix_16() doesn't work for\n        // most scalars larger than 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        self.mul_base(&s)\n    }",
      "start_line": 57,
      "end_line": 14,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_decompose().",
      "display_name": "lemma_decompose",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_decompose().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_decompose(a: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        a == (a >> 52) * pow2(52) + (a & mask),\n{\n    lemma2_to64_rest();  // pow2(52)\n    assert(a >> 52 == a / (pow2(52) as u64)) by {\n        lemma_u64_shr_is_div(a, 52);\n    }\n\n    assert(mask == low_bits_mask(52)) by {\n        assert((1u64 << 52) - 1 == 4503599627370495) by (compute);\n    }\n\n    assert(a & mask == a % (pow2(52) as u64)) by {\n        lemma_u64_low_bits_mask_is_mod(a, 52);\n    }\n\n    lemma_fundamental_div_mod(a as int, pow2(52) as int);\n}",
      "start_line": 787,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo proptest 1.9.0 collection/vec().",
      "display_name": "vec",
      "symbol": "rust-analyzer cargo proptest 1.9.0 collection/vec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/zeroize_bool().",
      "display_name": "zeroize_bool",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/zeroize_bool().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub fn zeroize_bool(b: &mut bool)\n    ensures\n        *b == false,\n{\n    use zeroize::Zeroize;\n    b.zeroize();\n}",
      "start_line": 308,
      "end_line": 20,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod_aux().",
      "display_name": "lemma_load8_shift_mod_aux",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod_aux().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_load8_shift_mod_aux(\n    s_jplus1: u64,\n    s_j: u64,\n    a_jplus1: u64,\n    x: u8,\n    j: nat,\n    s: nat,\n    t: nat,\n)\n    requires\n        s_j < pow2(j * 8),\n        s_j + x * pow2(j * 8) <= u64::MAX,\n        a_jplus1 == (x * pow2(j * 8)) as u64,\n        s_jplus1 == s_j + a_jplus1,\n        s_jplus1 / (pow2(s) as u64) == s_j / (pow2(s) as u64) + a_jplus1 / (pow2(s) as u64),\n        0 <= j <= 7,\n        s < 64,\n        t < 64,\n        0 < pow2(s) <= u64::MAX,\n        0 < pow2(t) <= u64::MAX,\n    ensures\n        (s_jplus1 / (pow2(s) as u64)) % (pow2(t) as u64) == (s_j / (pow2(s) as u64)) % (pow2(\n            t,\n        ) as u64) + (a_jplus1 / (pow2(s) as u64)) % (pow2(t) as u64),\n{\n    let ps64 = (pow2(s) as u64);\n    let pt64 = (pow2(t) as u64);\n\n    assert((s_jplus1 / ps64) % pt64 == (s_j / ps64) % pt64 + (a_jplus1 / ps64) % pt64) by {\n        if (s <= j * 8) {\n            assert(pow2(s) <= pow2(j * 8)) by {\n                if (s < j * 8) {\n                    lemma_pow2_strictly_increases(s, j * 8);\n                }\n            }\n            assert(x * pow2(s) <= a_jplus1) by {\n                lemma_mul_inequality(pow2(s) as int, pow2(j * 8) as int, x as int);\n            }\n            assert(s_j + x * pow2(s) <= s_j + a_jplus1 <= u64::MAX);\n\n            let d = (8 * j - s) as nat;\n\n            assert(s_j / ps64 < pow2(d) && a_jplus1 / ps64 == x * pow2(d) && s_j / ps64 + x * pow2(\n                d,\n            ) <= u64::MAX) by {\n                lemma_div_pow2_preserves_decomposition(s_j, x as u64, j * 8, s);\n            }\n\n            assert((s_j / ps64 + x * pow2(d)) as u64 % pt64 == (s_j / ps64) % pt64 + (x * pow2(\n                d,\n            )) as u64 % pt64 == (s_j / ps64) % pt64 + (a_jplus1 / ps64) % pt64) by {\n                lemma_bitops_lifted(s_j / ps64, x as u64, d, t);\n            }\n        } else {\n            // s > j * 8\n            assert(pow2(j * 8) < pow2(s)) by {\n                lemma_pow2_strictly_increases(j * 8, s);\n            }\n            assert(s_j / ps64 == 0) by {\n                lemma_basic_div(s_j as int, ps64 as int);\n            }\n\n            assert(0u64 % pt64 == 0) by {\n                lemma_small_mod(0, pow2(t));\n            }\n        }\n    }\n}",
      "start_line": 367,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption().",
      "display_name": "lemma_binomial_absorption",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_binomial_absorption(n: nat, k: nat)\n    requires\n        n >= 1,\n        k >= 1,\n        k <= n,\n    ensures\n        k * binomial(n, k) == n * binomial((n - 1) as nat, (k - 1) as nat),\n    decreases n,\n{\n    if n == 1 {\n        assert(k == 1);\n        assert(binomial(1, 1) == 1);\n        assert(binomial(0, 0) == 1);\n        assert(1nat * 1nat == 1nat * 1nat);\n    } else if k == n {\n        assert(binomial(n, n) == 1);\n        assert(binomial((n - 1) as nat, (n - 1) as nat) == 1);\n    } else if k == 1 {\n        lemma_binomial_n_1(n);\n        assert(binomial(n, 1) == n);\n        assert(binomial((n - 1) as nat, 0) == 1);\n        lemma_mul_basics(n as int);\n    } else {\n        // Use factorial-based proof\n        assert(binomial(n, k) == binomial((n - 1) as nat, (k - 1) as nat) + binomial(\n            (n - 1) as nat,\n            k,\n        ));\n\n        lemma_mul_is_distributive_add(\n            k as int,\n            binomial((n - 1) as nat, (k - 1) as nat) as int,\n            binomial((n - 1) as nat, k) as int,\n        );\n\n        if k < n - 1 {\n            lemma_binomial_absorption((n - 1) as nat, k);\n        }\n        lemma_binomial_absorption_factorial(n, k);\n    }\n}",
      "start_line": 296,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_as_bytes().",
      "display_name": "spec_as_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_as_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_as_bytes(limbs: [u64; 5]) -> [u8; 32] {\n    let reduced_limbs = spec_reduce(limbs);\n    let q = compute_q_spec(reduced_limbs);\n    bit_arrange(reduce_with_q_spec(reduced_limbs, q))\n}",
      "start_line": 208,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "display_name": "u64_5_as_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn u64_5_as_nat(limbs: [u64; 5]) -> nat {\n                (limbs[0] as nat) +\n    pow2( 51) * (limbs[1] as nat) +\n    pow2(102) * (limbs[2] as nat) +\n    pow2(153) * (limbs[3] as nat) +\n    pow2(204) * (limbs[4] as nat)\n}",
      "start_line": 84,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 47,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_identity_projective_niels().",
      "display_name": "spec_identity_projective_niels",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_identity_projective_niels().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_identity_projective_niels() -> (nat, nat, nat, nat) {\n    (1nat, 1nat, 1nat, 0nat)\n}",
      "start_line": 543,
      "end_line": 48,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MulAssign#mul_assign().",
      "display_name": "mul_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MulAssign#mul_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn mul_assign(&mut self, scalar: &'b Scalar)\n        requires\n            scalar.bytes[31] <= 127,\n            is_well_formed_edwards_point(*old(self)),\n        ensures\n            is_well_formed_edwards_point(*self),\n            edwards_point_as_affine(*self) == edwards_scalar_mul(\n                edwards_point_as_affine(*old(self)),\n                spec_scalar(scalar),\n            ),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &EdwardsPoint) * scalar;\n        CAST TO &EdwardsPoint UNSUPPORTED */\n        let result = &*self * scalar;\n        *self = result;\n    }",
      "start_line": 1645,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn default() -> (result: AffineNielsPoint)\n        ensures\n            result == identity_affine_niels(),\n    {\n        AffineNielsPoint::identity()\n    }",
      "start_line": 283,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "display_name": "multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
      "file_name": "straus.rs",
      "parent_folder": "scalar_mul",
      "body": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<EdwardsPoint>,\n    {\n        use crate::backend::serial::curve_models::ProjectiveNielsPoint;\n        use crate::traits::Identity;\n        use crate::window::LookupTable;\n\n        let lookup_tables: Vec<_> = points\n            .into_iter()\n            .map(|point| LookupTable::<ProjectiveNielsPoint>::from(point.borrow()))\n            .collect();\n\n        // This puts the scalar digits into a heap-allocated Vec.\n        // To ensure that these are erased, pass ownership of the Vec into a\n        // Zeroizing wrapper.\n        #[cfg_attr(not(feature = \"zeroize\"), allow(unused_mut))]\n        let mut scalar_digits: Vec<_> = scalars\n            .into_iter()\n            .map(|s| s.borrow().as_radix_16())\n            .collect();\n\n        let mut Q = EdwardsPoint::identity();\n        for j in (0..64).rev() {\n            Q = Q.mul_by_pow_2(4);\n            let it = scalar_digits.iter().zip(lookup_tables.iter());\n            for (s_i, lookup_table_i) in it {\n                // R_i = s_{i,j} * P_i\n                let R_i = lookup_table_i.select(s_i[j]);\n                // Q = Q + R_i\n                Q = (&Q + &R_i).as_extended();\n            }\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        zeroize::Zeroize::zeroize(&mut scalar_digits);\n\n        Q\n    }",
      "start_line": 101,
      "end_line": 23,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_basics_2().",
      "display_name": "lemma_div_basics_2",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_basics_2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_low_bits_mask_increases().",
      "display_name": "lemma_low_bits_mask_increases",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_low_bits_mask_increases().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mask_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mask_lemmas.rs",
      "file_name": "mask_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_low_bits_mask_increases(a: nat, b: nat)\n    requires\n        a < b,\n    ensures\n        low_bits_mask(a) < low_bits_mask(b),\n    decreases a + b,\n{\n    if (a == 0) {\n        // lbm(0) = 0\n        lemma_low_bits_mask_values();\n        // lbm(b) = 2 * lbm(b - 1) + 1, in particular, > 0\n        lemma_low_bits_mask_unfold(b);\n    } else {\n        // lbm(b) / 2 = lbm(b - 1)\n        lemma_low_bits_mask_div2(b);\n        // lbm(a) / 2 = lbm(a - 1)\n        lemma_low_bits_mask_div2(a);\n        // lbm(a - 1) < lbm(b - 1)\n        lemma_low_bits_mask_increases((a - 1) as nat, (b - 1) as nat);\n    }\n\n}",
      "start_line": 30,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_multiples_vanish().",
      "display_name": "lemma_div_multiples_vanish",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_multiples_vanish().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_lemmas",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_valid_y_coordinate().",
      "display_name": "math_is_valid_y_coordinate",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_valid_y_coordinate().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn math_is_valid_y_coordinate(y: nat) -> bool {\n    let d = spec_field_element(&EDWARDS_D);\n    let y2 = math_field_square(y);\n\n    // Compute u = y² - 1\n    let u = math_field_sub(y2, 1);\n\n    // Compute v = d·y² + 1\n    let v = math_field_add(math_field_mul(d, y2), 1);\n\n    if u % p() == 0 {\n        // If u = 0, then y² = 1, so y = ±1, which gives valid points (x=0, y=±1)\n        true\n    } else if v % p() == 0 {\n        // If v = 0 but u ≠ 0, division by zero case - invalid\n        false\n    } else {\n        // Check if there exists r such that r² * v ≡ ±u (mod p)\n        // This is what sqrt_ratio_i determines\n        exists|r: nat|\n            r < p() && (#[trigger] math_field_mul(math_field_square(r), v) == u % p()\n                || #[trigger] math_field_mul(math_field_square(r), v) == math_field_neg(u))\n    }\n}",
      "start_line": 166,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#negate().",
      "display_name": "negate",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#negate().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    pub fn negate(&mut self)\n        requires\n            forall|i: int| 0 <= i < 5 ==> old(self).limbs[i] < (1u64 << 51),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52),\n            // Assume we start with l = (l0, l1, l2, l3, l4).\n            // Using c0 = 2^51 - 19 and c = 2^51 - 1, we can see that\n            // ( 36028797018963664u64 - l0,\n            //   36028797018963952u64 - l1,\n            //   36028797018963952u64 - l2,\n            //   36028797018963952u64 - l3,\n            //   36028797018963952u64 - l4 )\n            // is just 16 * (c0, c, c, c, c) - l (in vector notation)\n            // Further, u64_5_as_nat((c0, c, c, c, c)) = p, so\n            // u64_5_as_nat(16 * (c0, c, c, c, c) - l) is 16p - u64_5_as_nat(l)\n            // We know u64_5_as_nat(reduce(v)) = u64_5_as_nat(v) - p * (v4 >> 51) for any v.\n            // This gives us the identity\n            // u64_5_as_nat(negate(l)) = u64_5_as_nat(reduce(16 * (c0, c, c, c, c) - l))\n            //                   = 16p - u64_5_as_nat(l) - p * ((16c - l4) >> 51)\n            // Note that (16c - l4) >> 51 is either 14 or 15, in either case < 16.\n            u64_5_as_nat(self.limbs) == 16 * p() - u64_5_as_nat(old(self).limbs) - p() * ((\n            36028797018963952u64 - old(self).limbs[4]) as u64 >> 51),\n            (u64_5_as_nat(self.limbs) + u64_5_as_nat(old(self).limbs)) % p() == 0,\n            self.limbs == spec_negate(old(self).limbs),\n    {\n        proof {\n            lemma_neg_no_underflow(self.limbs);\n            proof_negate(self.limbs);\n        }\n        // See commentary in the Sub impl: (copied below)\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        let neg = FieldElement51::reduce(\n            [\n                36028797018963664u64 - self.limbs[0],\n                36028797018963952u64 - self.limbs[1],\n                36028797018963952u64 - self.limbs[2],\n                36028797018963952u64 - self.limbs[3],\n                36028797018963952u64 - self.limbs[4],\n            ],\n        );\n        self.limbs = neg.limbs;\n    }",
      "start_line": 800,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_left().",
      "display_name": "lemma_mul_mod_noop_left",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_left().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "is_libsignal": false,
      "caller_count": 12,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "display_name": "lemma_6_bytes_reconstruct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_6_bytes_reconstruct(\n    value: nat,\n    byte0: u8,\n    byte1: u8,\n    byte2: u8,\n    byte3: u8,\n    byte4: u8,\n    byte5: u8,\n)\n    requires\n        byte0 as nat == (value / pow2(0)) % 256,\n        byte1 as nat == (value / pow2(8)) % 256,\n        byte2 as nat == (value / pow2(16)) % 256,\n        byte3 as nat == (value / pow2(24)) % 256,\n        byte4 as nat == (value / pow2(32)) % 256,\n        byte5 as nat == (value / pow2(40)) % 256,\n        value < pow2(48),  // 6 bytes = 48 bits\n\n    ensures\n        byte0 as nat * pow2(0) + byte1 as nat * pow2(8) + byte2 as nat * pow2(16) + byte3 as nat\n            * pow2(24) + byte4 as nat * pow2(32) + byte5 as nat * pow2(40) == value,\n{\n    lemma2_to64();\n\n    // Same pattern as lemma_5_bytes_reconstruct, extended to 6 bytes\n    // Use fundamental property: a = (a % d) + (a / d) * d\n\n    // Step 0: value = byte0 + (value / 256) * 256\n    lemma_fundamental_div_mod(value as int, 256);\n\n    let rest1 = value / pow2(8);\n    assert(value == byte0 as nat + rest1 * pow2(8));\n\n    // Step 1: rest1 = byte1 + (rest1 / 256) * 256\n    lemma_pow2_pos(8);\n    lemma_fundamental_div_mod(rest1 as int, 256);\n\n    let rest2 = rest1 / 256;\n    lemma_pow2_adds(8, 8);\n    lemma_div_denominator(value as int, 256, 256);\n\n    // Step 2: rest2 = byte2 + (rest2 / 256) * 256\n    lemma_fundamental_div_mod(rest2 as int, 256);\n    assert(byte2 as nat == (value / pow2(16)) % 256);\n\n    let rest3 = rest2 / 256;\n    lemma_pow2_adds(16, 8);\n    lemma_div_denominator(value as int, pow2(16) as int, 256);\n\n    // Step 3: rest3 = byte3 + (rest3 / 256) * 256\n    lemma_fundamental_div_mod(rest3 as int, 256);\n\n    let rest4 = rest3 / 256;\n    lemma_pow2_adds(24, 8);\n    lemma_div_denominator(value as int, pow2(24) as int, 256);\n    assert(value == byte0 as nat + byte1 as nat * pow2(8) + byte2 as nat * pow2(16) + byte3 as nat\n        * pow2(24) + rest4 * pow2(32));\n\n    // Step 4: rest4 = byte4 + (rest4 / 256) * 256\n    lemma_fundamental_div_mod(rest4 as int, 256);\n\n    let rest5 = rest4 / 256;\n    lemma_pow2_adds(32, 8);\n    lemma_div_denominator(value as int, pow2(32) as int, 256);\n    assert(value == byte0 as nat + byte1 as nat * pow2(8) + byte2 as nat * pow2(16) + byte3 as nat\n        * pow2(24) + byte4 as nat * pow2(32) + rest5 * pow2(40));\n\n    // Step 5: rest5 = byte5 (since value < 2^48, rest5 < 2^8 = 256)\n    lemma_div_bound(value, 40, 48);\n    assert(rest5 < pow2(8));\n\n    lemma_mod_bound(rest5 as int, 256);\n\n    // Final result\n    assert(value == byte0 as nat + byte1 as nat * pow2(8) + byte2 as nat * pow2(16) + byte3 as nat\n        * pow2(24) + byte4 as nat * pow2(32) + byte5 as nat * pow2(40));\n}",
      "start_line": 479,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "display_name": "lemma_limb3_contribution_correctness",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_limb3_contribution_correctness(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[2] < pow2(51),  // Need limb 2 for boundary byte 19\n        limbs[3] < pow2(51),\n        bytes_match_limbs_packing(limbs, bytes),\n    ensures\n        limb3_byte_contribution(limbs, bytes) == limbs[3] as nat * pow2(153),\n{\n    // Limb 3 stored in bytes 19-25, positioned at 2^153\n    // - Byte 19 (high 7 bits): limbs[3]'s bits 0-6\n    // - Bytes 20-24: limbs[3]'s bits 7-46 (40 bits)\n    // - Byte 25 (low 4 bits): limbs[3]'s bits 47-50\n    // Total: 7 + 40 + 4 = 51 bits\n    lemma2_to64();\n    lemma_pow2_adds(152, 1);  // 2^153 = 2^152 * 2\n\n    // Stabilization placeholders\n    assert(pow2(0) == pow2(0 * 8));\n    assert(pow2(8) == pow2(1 * 8));\n    assert(pow2(16) == pow2(2 * 8));\n    assert(pow2(24) == pow2(3 * 8));\n    assert(pow2(32) == pow2(4 * 8));\n\n    // KEY INSIGHT: From bytes_match_limbs_packing:\n    // bytes[20] = (limbs[3] >> 7) as u8\n    // bytes[21] = (limbs[3] >> 15) as u8\n    // ... and so on\n    //\n    // So limb3_byte_contribution is:\n    //   (limbs[3] % 2^7) * 2 * 2^152 +              // Low 7 bits at position 2^153\n    //   (limbs[3] >> 7 ... >> 39) * positions +     // Middle 40 bits at position 2^160\n    //   (limbs[3] / 2^47) % 2^4 * 2^200             // High 4 bits at position 2^200\n    //\n    // This is limbs[3] * 2^153!\n\n    // Step 1: Extract arithmetic values for bytes 20-24\n    // These bytes come from limbs[3] >> 7, 15, 23, 31, 39\n    lemma_byte_from_limb_shift(limbs[3], 7, bytes[20]);\n\n    lemma_byte_from_limb_shift(limbs[3], 15, bytes[21]);\n\n    lemma_byte_from_limb_shift(limbs[3], 23, bytes[22]);\n\n    lemma_byte_from_limb_shift(limbs[3], 31, bytes[23]);\n\n    lemma_byte_from_limb_shift(limbs[3], 39, bytes[24]);\n\n    // Step 2: Prove that bytes[20-24] reconstruct ((limbs[3] / 2^7) % 2^40) at position 2^160\n    //\n    // From lemma_byte_from_limb_shift, we have:\n    // bytes[20] as nat == (limbs[3] / pow2(7)) % 256\n    // bytes[21] as nat == (limbs[3] / pow2(15)) % 256\n    // bytes[22] as nat == (limbs[3] / pow2(23)) % 256\n    // bytes[23] as nat == (limbs[3] / pow2(31)) % 256\n    // bytes[24] as nat == (limbs[3] / pow2(39)) % 256\n    //\n    // The key insight: these bytes extract consecutive 8-bit chunks from (limbs[3] / 2^7)\n\n    // First, rewrite the byte extractions in terms of (limbs[3] / 2^7)\n    // bytes[20] == (limbs[3] / 2^7) / 2^0 % 256\n    lemma_pow2_adds(0, 7);\n    lemma_div_denominator(limbs[3] as int, pow2(7) as int, pow2(0) as int);\n    assert(bytes[20] as nat == (limbs[3] as nat / pow2(7)) / pow2(0) % 256);\n\n    // bytes[21] == (limbs[3] / 2^15) % 256 == (limbs[3] / 2^7) / 2^8 % 256\n    lemma_pow2_adds(7, 8);\n    lemma_div_denominator(limbs[3] as int, pow2(7) as int, pow2(8) as int);\n    assert(limbs[3] as nat / pow2(15) == (limbs[3] as nat / pow2(7)) / pow2(8));\n    assert(bytes[21] as nat == (limbs[3] as nat / pow2(7)) / pow2(8) % 256);\n\n    // bytes[22] == (limbs[3] / 2^23) % 256 == (limbs[3] / 2^7) / 2^16 % 256\n    lemma_pow2_adds(7, 16);\n    assert(pow2(7) * pow2(16) == pow2(23));\n    lemma_div_denominator(limbs[3] as int, pow2(7) as int, pow2(16) as int);\n    assert(limbs[3] as nat / pow2(23) == (limbs[3] as nat / pow2(7)) / pow2(16));\n\n    // bytes[23] == (limbs[3] / 2^31) % 256 == (limbs[3] / 2^7) / 2^24 % 256\n    lemma_pow2_adds(7, 24);\n    lemma_div_denominator(limbs[3] as int, pow2(7) as int, pow2(24) as int);\n\n    // bytes[24] == (limbs[3] / 2^39) % 256 == (limbs[3] / 2^7) / 2^32 % 256\n    lemma_pow2_adds(7, 32);\n    lemma_pow2_pos(32);\n    lemma_div_denominator(limbs[3] as int, pow2(7) as int, pow2(32) as int);\n    assert(limbs[3] as nat / pow2(39) == (limbs[3] as nat / pow2(7)) / pow2(32));\n    assert(bytes[24] as nat == (limbs[3] as nat / pow2(7)) / pow2(32) % 256);\n\n    // Now handle the % 2^40 truncation\n    // Since limbs[3] < 2^51, we have limbs[3] / 2^7 < 2^44\n    lemma_div_bound(limbs[3] as nat, 7, 51);\n\n    // The bytes extract bits at positions [0..8), [8..16), [16..24), [24..32), [32..40)\n    // from (limbs[3] / 2^7). Since all these bit positions are < 40, taking % 2^40\n    // doesn't change the extracted bytes (same argument as limbs 1 & 2).\n\n    let middle_value = (limbs[3] as nat / pow2(7)) % pow2(40);\n\n    // Prove middle_value < 2^40 (trivial by definition of %)\n    lemma_pow2_pos(40);\n    lemma_mod_bound(middle_value as int, pow2(40) as int);\n\n    // Now prove that the bytes extract from middle_value\n    let v = limbs[3] as nat / pow2(7);\n    assert(bytes[23] as nat == v / pow2(24) % 256);\n    assert(bytes[24] as nat == v / pow2(32) % 256);\n\n    // Use lemma_byte_extraction_commutes_with_mod to show extraction commutes with % 2^40\n    // For byte at position k, we need k*8 + 8 <= 40\n    lemma_byte_extraction_commutes_with_mod(v, 0, 40);  // 0*8 + 8 = 8 <= 40 ✓\n    assert(bytes[20] as nat == (middle_value / pow2(0)) % 256);\n\n    lemma_byte_extraction_commutes_with_mod(v, 1, 40);  // 1*8 + 8 = 16 <= 40 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 2, 40);  // 2*8 + 8 = 24 <= 40 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 3, 40);  // 3*8 + 8 = 32 <= 40 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 4, 40);  // 4*8 + 8 = 40 <= 40 ✓\n\n    // Now apply lemma_5_bytes_reconstruct\n    lemma_5_bytes_reconstruct(middle_value, bytes[20], bytes[21], bytes[22], bytes[23], bytes[24]);\n\n    // This gives us:\n    assert(bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8) + bytes[22] as nat * pow2(16)\n        + bytes[23] as nat * pow2(24) + bytes[24] as nat * pow2(32) == middle_value);\n\n    // Now multiply both sides by 2^160 to get the bytes at their actual positions\n    lemma_mul_is_distributive_add(\n        pow2(160) as int,\n        (bytes[20] as nat * pow2(0)) as int,\n        (bytes[21] as nat * pow2(8)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(160) as int,\n        (bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8)) as int,\n        (bytes[22] as nat * pow2(16)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(160) as int,\n        (bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8) + bytes[22] as nat * pow2(\n            16,\n        )) as int,\n        (bytes[23] as nat * pow2(24)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(160) as int,\n        (bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8) + bytes[22] as nat * pow2(16)\n            + bytes[23] as nat * pow2(24)) as int,\n        (bytes[24] as nat * pow2(32)) as int,\n    );\n\n    // Distribute the multiplication into each term\n    lemma_mul_is_associative(bytes[20] as int, pow2(0) as int, pow2(160) as int);\n    lemma_mul_is_associative(bytes[21] as int, pow2(8) as int, pow2(160) as int);\n    lemma_mul_is_associative(bytes[22] as int, pow2(16) as int, pow2(160) as int);\n    lemma_mul_is_associative(bytes[23] as int, pow2(24) as int, pow2(160) as int);\n    lemma_mul_is_associative(bytes[24] as int, pow2(32) as int, pow2(160) as int);\n\n    // Simplify using pow2 addition: 2^160 * 2^k = 2^(160+k)\n    lemma_pow2_adds(160, 0);\n\n    lemma_pow2_adds(160, 8);\n\n    lemma_pow2_adds(160, 16);\n    assert(pow2(160) * pow2(16) == pow2(176));\n\n    lemma_pow2_adds(160, 24);\n\n    lemma_pow2_adds(160, 32);\n\n    // Final result\n    assert(bytes[20] as nat * pow2(20 * 8) + bytes[21] as nat * pow2(21 * 8) + bytes[22] as nat\n        * pow2(22 * 8) + bytes[23] as nat * pow2(23 * 8) + bytes[24] as nat * pow2(24 * 8)\n        == middle_value * pow2(160));\n\n    // Step 3: Handle boundary bytes\n    // Low 7 bits (byte 19 high part): (limbs[3] % 2^7) * 2 * 2^152 = (limbs[3] % 2^7) * 2^153\n    // High 4 bits (byte 25 low part): (limbs[3] / 2^47) % 2^4 * 2^200\n\n    assert(2 * pow2(152) == pow2(153)) by {\n        lemma_pow2_adds(152, 1);\n    }\n\n    // From the proof above, we have:\n    let middle_bytes_sum = bytes[20] as nat * pow2(20 * 8) + bytes[21] as nat * pow2(21 * 8)\n        + bytes[22] as nat * pow2(22 * 8) + bytes[23] as nat * pow2(23 * 8) + bytes[24] as nat\n        * pow2(24 * 8);\n\n    let middle_value_at_position = ((limbs[3] as nat / pow2(7)) % pow2(40)) * pow2(160);\n\n    // Substitute into contribution\n    let contribution = limb3_byte_contribution(limbs, bytes);\n    assert(contribution == ((limbs[3] as nat % pow2(7)) * 2) * pow2(152) + middle_bytes_sum + ((\n    limbs[3] as nat / pow2(47)) % pow2(4)) * pow2(200));\n\n    assert(contribution == ((limbs[3] as nat % pow2(7)) * 2) * pow2(152) + middle_value_at_position\n        + ((limbs[3] as nat / pow2(47)) % pow2(4)) * pow2(200));\n\n    // Step 3: Prove the reconstruction identity for limbs[3]\n    // limbs[3] = (limbs[3] % 2^7) + ((limbs[3] / 2^7) % 2^40) * 2^7 + ((limbs[3] / 2^47) % 2^4) * 2^47\n\n    // First, reconstruct limbs[3] / 2^7 from its low 40 bits and high part\n    lemma_pow2_pos(40);\n    let shifted_value = limbs[3] as nat / pow2(7);\n    lemma_fundamental_div_mod(shifted_value as int, pow2(40) as int);\n    assert(pow2(40) * (shifted_value / pow2(40)) == (shifted_value / pow2(40)) * pow2(40)) by {\n        lemma_mul_is_commutative(pow2(40) as int, (shifted_value / pow2(40)) as int);\n    }\n\n    // Show that (limbs[3] / 2^7) / 2^40 = limbs[3] / 2^47\n    lemma_div_denominator(limbs[3] as int, pow2(7) as int, pow2(40) as int);\n    lemma_pow2_adds(7, 40);\n\n    // So: limbs[3] / 2^7 = ((limbs[3] / 2^7) % 2^40) + (limbs[3] / 2^47) * 2^40\n    assert(shifted_value == (shifted_value % pow2(40)) + (limbs[3] as nat / pow2(47)) * pow2(40));\n\n    // Next, reconstruct limbs[3] from its low 7 bits and (limbs[3] / 2^7)\n    lemma_pow2_pos(7);\n    lemma_fundamental_div_mod(limbs[3] as int, pow2(7) as int);\n    assert(pow2(7) * shifted_value == shifted_value * pow2(7)) by {\n        lemma_mul_is_commutative(pow2(7) as int, shifted_value as int);\n    }\n\n    // Substitute the reconstruction of shifted_value (limbs[3] / 2^7)\n    assert(limbs[3] as nat == (limbs[3] as nat % pow2(7)) + ((shifted_value % pow2(40)) + (\n    limbs[3] as nat / pow2(47)) * pow2(40)) * pow2(7));\n\n    // Distribute the * 2^7\n    assert(limbs[3] as nat == (limbs[3] as nat % pow2(7)) + (shifted_value % pow2(40)) * pow2(7) + (\n    limbs[3] as nat / pow2(47)) * pow2(40) * pow2(7)) by {\n        lemma_mul_is_distributive_add(\n            pow2(7) as int,\n            (shifted_value % pow2(40)) as int,\n            (limbs[3] as nat / pow2(47) * pow2(40)) as int,\n        );\n    }\n\n    // Use 2^40 * 2^7 = 2^47\n    lemma_pow2_adds(40, 7);\n    assert((limbs[3] as nat / pow2(47)) * pow2(40) * pow2(7) == (limbs[3] as nat / pow2(47)) * pow2(\n        47,\n    )) by {\n        lemma_mul_is_associative(\n            (limbs[3] as nat / pow2(47)) as int,\n            pow2(40) as int,\n            pow2(7) as int,\n        );\n    }\n\n    assert(limbs[3] as nat == (limbs[3] as nat % pow2(7)) + ((limbs[3] as nat / pow2(7)) % pow2(40))\n        * pow2(7) + (limbs[3] as nat / pow2(47)) * pow2(47));\n\n    // Handle the % 2^4 on the high bits\n    // Since limbs[3] < 2^51, we have limbs[3] / 2^47 < 2^4\n    lemma_div_bound(limbs[3] as nat, 47, 51);\n    lemma_small_mod(limbs[3] as nat / pow2(47), pow2(4));\n\n    // Therefore:\n    assert(limbs[3] as nat == (limbs[3] as nat % pow2(7)) + ((limbs[3] as nat / pow2(7)) % pow2(40))\n        * pow2(7) + ((limbs[3] as nat / pow2(47)) % pow2(4)) * pow2(47));\n\n    // Step 4: Now connect the contribution to limbs[3] * 2^153\n    // We have: contribution = ((limbs[3] % 2^7) * 2) * 2^152 + middle_value_at_position + ((limbs[3] / 2^47) % 2^4) * 2^200\n    // Where: middle_value_at_position = ((limbs[3] / 2^7) % 2^40) * 2^160\n\n    // First, simplify the low term: ((limbs[3] % 2^7) * 2) * 2^152 = (limbs[3] % 2^7) * (2 * 2^152) = (limbs[3] % 2^7) * 2^153\n    // We proved earlier that 2 * 2^152 = 2^153\n    let low_part = (limbs[3] as nat % pow2(7));\n    assert(((limbs[3] as nat % pow2(7)) * 2) * pow2(152) == low_part * (2 * pow2(152))) by {\n        lemma_mul_is_associative(low_part as int, 2, pow2(152) as int);\n    }\n\n    // So contribution = (limbs[3] % 2^7) * 2^153 + ((limbs[3] / 2^7) % 2^40) * 2^160 + ((limbs[3] / 2^47) % 2^4) * 2^200\n    assert(contribution == low_part * pow2(153) + ((limbs[3] as nat / pow2(7)) % pow2(40)) * pow2(\n        160,\n    ) + ((limbs[3] as nat / pow2(47)) % pow2(4)) * pow2(200));\n\n    // Rewrite using 2^160 = 2^153 * 2^7 and 2^200 = 2^153 * 2^47\n    lemma_pow2_adds(153, 7);\n    lemma_pow2_adds(153, 47);\n\n    assert(contribution == low_part * pow2(153) + ((limbs[3] as nat / pow2(7)) % pow2(40)) * (pow2(\n        153,\n    ) * pow2(7)) + ((limbs[3] as nat / pow2(47)) % pow2(4)) * (pow2(153) * pow2(47)));\n\n    // Apply associativity to move pow2(153) to the left\n    let middle_part = (limbs[3] as nat / pow2(7)) % pow2(40);\n    let high_part = (limbs[3] as nat / pow2(47)) % pow2(4);\n\n    assert(middle_part * (pow2(153) * pow2(7)) == (middle_part * pow2(153)) * pow2(7)) by {\n        lemma_mul_is_associative(middle_part as int, pow2(153) as int, pow2(7) as int);\n    }\n    assert((middle_part * pow2(153)) * pow2(7) == pow2(153) * middle_part * pow2(7)) by {\n        lemma_mul_is_commutative((middle_part * pow2(153)) as int, pow2(7) as int);\n    }\n    assert(pow2(153) * middle_part * pow2(7) == pow2(153) * (middle_part * pow2(7))) by {\n        lemma_mul_is_associative(pow2(153) as int, middle_part as int, pow2(7) as int);\n    }\n\n    assert(high_part * (pow2(153) * pow2(47)) == (high_part * pow2(153)) * pow2(47)) by {\n        lemma_mul_is_associative(high_part as int, pow2(153) as int, pow2(47) as int);\n    }\n    assert((high_part * pow2(153)) * pow2(47) == pow2(153) * high_part * pow2(47)) by {\n        lemma_mul_is_commutative((high_part * pow2(153)) as int, pow2(47) as int);\n    }\n    assert(pow2(153) * high_part * pow2(47) == pow2(153) * (high_part * pow2(47))) by {\n        lemma_mul_is_associative(pow2(153) as int, high_part as int, pow2(47) as int);\n    }\n\n    // Now factor out pow2(153)\n    assert(contribution == low_part * pow2(153) + pow2(153) * (middle_part * pow2(7)) + pow2(153)\n        * (high_part * pow2(47)));\n\n    // Use distributivity to factor out pow2(153)\n    assert(contribution == pow2(153) * (low_part + middle_part * pow2(7) + high_part * pow2(47)))\n        by {\n        lemma_mul_is_distributive_add(\n            pow2(153) as int,\n            low_part as int,\n            (middle_part * pow2(7)) as int,\n        );\n        lemma_mul_is_distributive_add(\n            pow2(153) as int,\n            (low_part + middle_part * pow2(7)) as int,\n            (high_part * pow2(47)) as int,\n        );\n    }\n\n    // The part in parentheses equals limbs[3] by our reconstruction identity!\n    assert(contribution == limbs[3] as nat * pow2(153)) by {\n        lemma_mul_is_commutative(pow2(153) as int, limbs[3] as int);\n    }\n\n}",
      "start_line": 1326,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 17
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_pow2_preserves_decomposition().",
      "display_name": "lemma_div_pow2_preserves_decomposition",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_pow2_preserves_decomposition().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_div_pow2_preserves_decomposition(a: u64, b: u64, s: nat, k: nat)\n    requires\n        a < pow2(s),\n        a + b * pow2(s) <= u64::MAX,\n        k <= s < 64,\n    ensures\n        (a as nat) / pow2(k) < pow2((s - k) as nat),\n        (b * pow2(s)) as nat / pow2(k) == b * pow2((s - k) as nat),\n        (a as nat) / pow2(k) + b * pow2((s - k) as nat) <= u64::MAX,\n{\n    let d = (s - k) as nat;\n\n    assert(pow2(k) > 0) by {\n        lemma_pow2_pos(k);\n    }\n\n    assert(pow2(s) == pow2(d) * pow2(k)) by {\n        lemma_pow2_adds(d, k);\n    }\n\n    assert(a as nat / pow2(k) < pow2(d)) by {\n        assert(a as nat / pow2(k) < pow2(s) / pow2(k)) by {\n            lemma_div_by_multiple_is_strongly_ordered(\n                a as int,\n                pow2(s) as int,\n                pow2(d) as int,\n                pow2(k) as int,\n            );\n        }\n        assert(pow2(s) / pow2(k) == pow2(d)) by {\n            lemma_div_by_multiple(pow2(d) as int, pow2(k) as int);\n        }\n    }\n\n    assert((b * pow2(s)) as nat / pow2(k) == b * pow2(d)) by {\n        pow2_MUL_div(b as nat, s, k);\n    }\n}",
      "start_line": 627,
      "end_line": 52,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#map().",
      "display_name": "map",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#map().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq_lib/Seq#map().",
      "display_name": "map",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq_lib/Seq#map().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#SubAssign#sub_assign().",
      "display_name": "sub_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#SubAssign#sub_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn sub_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) - _rhs;\n    }",
      "start_line": 887,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_decomposition_prefix_rec().",
      "display_name": "lemma_decomposition_prefix_rec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_decomposition_prefix_rec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "file_name": "u8_32_as_nat_injectivity_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_decomposition_prefix_rec(bytes: &[u8; 32], n: nat)\n    requires\n        n <= 32,\n    ensures\n        u8_32_as_nat_rec(bytes, 0) == as_nat_prefix(bytes, n) + u8_32_as_nat_rec(bytes, n),\n    decreases n,\n{\n    if n == 0 {\n        // Base case: u8_32_as_nat_rec(bytes, 0) == 0 + u8_32_as_nat_rec(bytes, 0)\n        assert(as_nat_prefix(bytes, 0) == 0);\n    } else {\n        // Inductive step: assume true for n-1, prove for n\n        lemma_decomposition_prefix_rec(bytes, (n - 1) as nat);\n\n        // Unfold u8_32_as_nat_rec(bytes, n-1):\n        assert(u8_32_as_nat_rec(bytes, (n - 1) as nat) == bytes[(n - 1) as int] as nat * pow2(\n            ((n - 1) * 8) as nat,\n        ) + u8_32_as_nat_rec(bytes, n));\n\n        // Unfold as_nat_prefix(bytes, n):\n        assert(as_nat_prefix(bytes, n) == as_nat_prefix(bytes, (n - 1) as nat) + bytes[(n\n            - 1) as int] as nat * pow2(((n - 1) * 8) as nat));\n    }\n}",
      "start_line": 81,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#unwrap_or().",
      "display_name": "unwrap_or",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#unwrap_or().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_extended_gcd().",
      "display_name": "spec_extended_gcd",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_extended_gcd().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub open spec fn spec_extended_gcd(a: nat, b: nat) -> ExtGcdResult\n    decreases b,\n{\n    if b == 0 {\n        ExtGcdResult { gcd: a, x: 1, y: 0 }\n    } else {\n        let r = spec_extended_gcd(b, a % b);\n        ExtGcdResult { gcd: r.gcd, x: r.y, y: r.x - (a / b) as int * r.y }\n    }\n}",
      "start_line": 889,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_valid_radix_16().",
      "display_name": "is_valid_radix_16",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_valid_radix_16().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_valid_radix_16(digits: &[i8; 64]) -> bool {\n    is_valid_radix_2w(digits, 4, 64)\n}",
      "start_line": 225,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "display_name": "lemma_limb2_contribution_correctness_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub proof fn lemma_limb2_contribution_correctness_52(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[2] < (1u64 << 52),\n        bytes_match_limbs_packing_52(limbs, bytes),\n    ensures\n        limb2_byte_contribution_52(limbs, bytes) == (limbs[2] as nat) * pow2(104),\n{\n    // Proof following docs_22_oct/lemma_limb2_contribution_52_proof.md\n    lemma2_to64();\n    lemma_shift_is_pow2(52);\n\n    // === STEP 1: Define the Split ===\n    let l2_low = limbs[2] as nat % pow2(48);  // Low 48 bits in bytes 13-18\n    let l2_high = limbs[2] as nat / pow2(48);  // High 4 bits in byte 19\n\n    // === STEP 2: Bound the High Part ===\n    lemma_div_bound(limbs[2] as nat, 48, 52);\n    assert(l2_high < pow2(4));\n    lemma_small_mod(l2_high, 16);\n    assert(l2_high % 16 == l2_high);\n\n    // === STEP 3: Reconstruction Identity ===\n    lemma_pow2_pos(48);\n    lemma_fundamental_div_mod(limbs[2] as int, pow2(48) as int);\n    assert(pow2(48) * l2_high == l2_high * pow2(48)) by {\n        lemma_mul_is_commutative(pow2(48) as int, l2_high as int);\n    }\n    assert(limbs[2] as nat == l2_low + l2_high * pow2(48));\n\n    // === STEP 4: Byte Reconstruction for Low 48 Bits ===\n    lemma_shr_zero_is_id(limbs[2]);\n    lemma_byte_from_limb_shift_52(limbs[2], 0, bytes[13]);\n    lemma_byte_from_limb_shift_52(limbs[2], 8, bytes[14]);\n    lemma_byte_from_limb_shift_52(limbs[2], 16, bytes[15]);\n    lemma_byte_from_limb_shift_52(limbs[2], 24, bytes[16]);\n    lemma_byte_from_limb_shift_52(limbs[2], 32, bytes[17]);\n    lemma_byte_from_limb_shift_52(limbs[2], 40, bytes[18]);\n\n    // Byte extractions commute with modulo for positions below 48 bits\n    lemma_mod_bound(l2_low as int, pow2(48) as int);\n    lemma_byte_extraction_commutes_with_mod(limbs[2] as nat, 0, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[2] as nat, 1, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[2] as nat, 2, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[2] as nat, 3, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[2] as nat, 4, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[2] as nat, 5, 48);\n\n    // 6-byte reconstruction lemma gives us the sum\n    lemma_6_bytes_reconstruct(\n        l2_low,\n        bytes[13],\n        bytes[14],\n        bytes[15],\n        bytes[16],\n        bytes[17],\n        bytes[18],\n    );\n\n    let bytes_at_offset_0 = bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8)\n        + bytes[15] as nat * pow2(16) + bytes[16] as nat * pow2(24) + bytes[17] as nat * pow2(32)\n        + bytes[18] as nat * pow2(40);\n\n    assert(bytes_at_offset_0 == l2_low);\n\n    // === STEP 5: Position Adjustment ===\n\n    // Multiply reconstruction identity by pow2(104)\n    assert((l2_low + l2_high * pow2(48)) * pow2(104) == limbs[2] as nat * pow2(104));\n\n    // Distribute\n    assert((l2_low + l2_high * pow2(48)) * pow2(104) == l2_low * pow2(104) + (l2_high * pow2(48))\n        * pow2(104)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(104) as int,\n            l2_low as int,\n            (l2_high * pow2(48)) as int,\n        );\n    }\n\n    // Simplify high term\n    lemma_pow2_adds(48, 104);\n    assert((l2_high * pow2(48)) * pow2(104) == l2_high * pow2(152)) by {\n        lemma_mul_is_associative(l2_high as int, pow2(48) as int, pow2(104) as int);\n    }\n\n    // Now we have: limbs[2] * 2^104 = l2_low * 2^104 + l2_high * 2^152\n\n    // === STEP 6: Expand the Low Part ===\n    // Multiply bytes_at_offset_0 by pow2(104)\n    assert(bytes_at_offset_0 * pow2(104) == l2_low * pow2(104));\n\n    // Distribute pow2(104) into each byte term\n    assert(bytes_at_offset_0 * pow2(104) == bytes[13] as nat * pow2(0) * pow2(104)\n        + bytes[14] as nat * pow2(8) * pow2(104) + bytes[15] as nat * pow2(16) * pow2(104)\n        + bytes[16] as nat * pow2(24) * pow2(104) + bytes[17] as nat * pow2(32) * pow2(104)\n        + bytes[18] as nat * pow2(40) * pow2(104)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(104) as int,\n            (bytes[13] as nat * pow2(0)) as int,\n            (bytes[14] as nat * pow2(8)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(104) as int,\n            (bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8)) as int,\n            (bytes[15] as nat * pow2(16)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(104) as int,\n            (bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8) + bytes[15] as nat * pow2(\n                16,\n            )) as int,\n            (bytes[16] as nat * pow2(24)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(104) as int,\n            (bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8) + bytes[15] as nat * pow2(16)\n                + bytes[16] as nat * pow2(24)) as int,\n            (bytes[17] as nat * pow2(32)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(104) as int,\n            (bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8) + bytes[15] as nat * pow2(16)\n                + bytes[16] as nat * pow2(24) + bytes[17] as nat * pow2(32)) as int,\n            (bytes[18] as nat * pow2(40)) as int,\n        );\n\n        // Apply associativity: (byte * pow2(k)) * pow2(104) = byte * (pow2(k) * pow2(104))\n        lemma_mul_is_associative(bytes[13] as int, pow2(0) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[14] as int, pow2(8) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[15] as int, pow2(16) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[16] as int, pow2(24) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[17] as int, pow2(32) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[18] as int, pow2(40) as int, pow2(104) as int);\n    }\n\n    assert(bytes_at_offset_0 * pow2(104) == bytes[13] as nat * pow2(104) + bytes[14] as nat * pow2(\n        112,\n    ) + bytes[15] as nat * pow2(120) + bytes[16] as nat * pow2(128) + bytes[17] as nat * pow2(136)\n        + bytes[18] as nat * pow2(144)) by {\n        lemma_mul_is_associative(bytes[13] as int, pow2(0) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[14] as int, pow2(8) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[15] as int, pow2(16) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[16] as int, pow2(24) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[17] as int, pow2(32) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[18] as int, pow2(40) as int, pow2(104) as int);\n        lemma_pow2_adds(0, 104);\n        lemma_pow2_adds(8, 104);\n        lemma_pow2_adds(16, 104);\n        lemma_pow2_adds(24, 104);\n        lemma_pow2_adds(32, 104);\n        lemma_pow2_adds(40, 104);\n    }\n}",
      "start_line": 867,
      "end_line": 53,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 18
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "display_name": "edwards_point_as_affine",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn edwards_point_as_affine(point: crate::edwards::EdwardsPoint) -> (nat, nat) {\n    let (x, y, z, _t) = spec_edwards_point(point);\n    let z_inv = math_field_inv(z);\n    (math_field_mul(x, z_inv), math_field_mul(y, z_inv))\n}",
      "start_line": 272,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 23,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_limbs_bounded().",
      "display_name": "lemma_one_limbs_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_limbs_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/constants_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/constants_lemmas.rs",
      "file_name": "constants_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_one_limbs_bounded()\n    ensures\n        fe51_limbs_bounded(&FieldElement51::ONE, 51),\n{\n    assert(fe51_limbs_bounded(&FieldElement51::ONE, 51)) by {\n        assert(0u64 < (1u64 << 51) && 1u64 < (1u64 << 51)) by (bit_vector);\n    };\n}",
      "start_line": 41,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from8().",
      "display_name": "seq_from8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub open spec fn seq_from8(b: &[u8; 8]) -> Seq<u8> {\n    Seq::new(8, |i: int| b[i])\n}",
      "start_line": 74,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_u_coordinate().",
      "display_name": "spec_u_coordinate",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_u_coordinate().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_u_coordinate(point: MontgomeryAffine) -> nat {\n    match point {\n        MontgomeryAffine::Infinity => 0,\n        MontgomeryAffine::Finite { u, v: _ } => u,\n    }\n}",
      "start_line": 175,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_sub_constants_equal_16p().",
      "display_name": "lemma_sub_constants_equal_16p",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_sub_constants_equal_16p().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_sub_constants_equal_16p()\n    ensures\n        (36028797018963664u64 as nat + pow2(51) * (36028797018963952u64 as nat) + pow2(102) * (\n        36028797018963952u64 as nat) + pow2(153) * (36028797018963952u64 as nat) + pow2(204) * (\n        36028797018963952u64 as nat)) == (16 as nat) * p(),\n{\n    lemma2_to64_rest();\n    assert(pow2(51) == 0x8000000000000);\n\n    assert(36028797018963664u64 as nat == 16 * (pow2(51) - 19)) by {\n        assert(16 * (pow2(51) - 19) == 16 * (0x8000000000000 - 19)) by {\n            assert(pow2(51) == 0x8000000000000);\n        }\n        assert(16 * (0x8000000000000 - 19) == 36028797018963664) by (compute);\n    }\n\n    assert(36028797018963952u64 as nat == 16 * (pow2(51) - 1)) by {\n        assert(16 * (pow2(51) - 1) == 16 * (0x8000000000000 - 1)) by {\n            assert(pow2(51) == 0x8000000000000);\n        }\n        assert(16 * (0x8000000000000 - 1) == 36028797018963952) by (compute);\n    }\n\n    calc! {\n        (==)\n        36028797018963664u64 as nat + pow2(51) * (36028797018963952u64 as nat) + pow2(102) * (\n        36028797018963952u64 as nat) + pow2(153) * (36028797018963952u64 as nat) + pow2(204) * (\n        36028797018963952u64 as nat); {\n            // Substitute the constant definitions for clarity\n        }\n        (16 * (pow2(51) - 19) + pow2(51) * (16 * (pow2(51) - 1)) + pow2(102) * (16 * (pow2(51) - 1))\n            + pow2(153) * (16 * (pow2(51) - 1)) + pow2(204) * (16 * (pow2(51) - 1))) as nat; {\n            lemma_mul_is_distributive_add(\n                16,\n                pow2(51) - 19,\n                pow2(51) * (pow2(51) - 1) + pow2(102) * (pow2(51) - 1) + pow2(153) * (pow2(51) - 1)\n                    + pow2(204) * (pow2(51) - 1),\n            );\n        }\n        (16 * ((pow2(51) - 19) + pow2(51) * (pow2(51) - 1) + pow2(102) * (pow2(51) - 1) + pow2(153)\n            * (pow2(51) - 1) + pow2(204) * (pow2(51) - 1))) as nat; {\n            lemma_p_radix_representation();\n        }\n        (16 * p()) as nat;\n    }\n}",
      "start_line": 699,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/term_product_bounds_spec().",
      "display_name": "term_product_bounds_spec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/term_product_bounds_spec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn term_product_bounds_spec(a: [u64; 5], bound: u64) -> bool {\n    // c0\n    &&& (a[0] as u128) * (a[0] as u128) < bound * bound\n    &&& (a[1] as u128) * ((19 * a[4]) as u128) < 19 * (bound * bound)\n    &&& (a[2] as u128) * ((19 * a[3]) as u128) < 19 * (bound\n        * bound)\n    // c1\n    &&& (a[3] as u128) * ((19 * a[3]) as u128) < 19 * (bound * bound)\n    &&& (a[0] as u128) * (a[1] as u128) < (bound * bound)\n    &&& (a[2] as u128) * ((19 * a[4]) as u128) < 19 * (bound\n        * bound)\n    // c2\n    &&& (a[1] as u128) * (a[1] as u128) < (bound * bound)\n    &&& (a[0] as u128) * (a[2] as u128) < (bound * bound)\n    &&& (a[4] as u128) * ((19 * a[3]) as u128) < 19 * (bound\n        * bound)\n    // c3\n    &&& (a[4] as u128) * ((19 * a[4]) as u128) < 19 * (bound * bound)\n    &&& (a[0] as u128) * (a[3] as u128) < (bound * bound)\n    &&& (a[1] as u128) * (a[2] as u128) < (bound * bound)\n    // c4\n    &&& (a[2] as u128) * (a[2] as u128) < (bound * bound)\n    &&& (a[0] as u128) * (a[4] as u128) < (bound * bound)\n    &&& (a[1] as u128) * (a[3] as u128) < (bound * bound)\n}",
      "start_line": 112,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "display_name": "lemma_mul_mod_noop_right",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "is_libsignal": false,
      "caller_count": 14,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_factorial_relation().",
      "display_name": "lemma_binomial_factorial_relation",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_factorial_relation().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "proof fn lemma_binomial_factorial_relation(n: nat, k: nat)\n    requires\n        k <= n,\n    ensures\n        binomial(n, k) * factorial(k) * factorial((n - k) as nat) == factorial(n),\n{\n    admit();\n}",
      "start_line": 421,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from32().",
      "display_name": "seq_from32",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from32().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub open spec fn seq_from32(b: &[u8; 32]) -> Seq<u8> {\n    b@\n}",
      "start_line": 82,
      "end_line": 28,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_base().",
      "display_name": "lemma_load8_at_limb_base",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_base().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_load8_at_limb_base(input: &[u8], i: usize, k: u64)\n    requires\n        i + 7 < input.len(),\n        k < 64,\n    ensures\n        0 < pow2(51) <= u64::MAX,\n        spec_load8_at(input, i) <= u64::MAX,\n        ((spec_load8_at(input, i) as u64) >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64),\n{\n    assert(0 < pow2(51) <= u64::MAX) by {\n        lemma_pow2_pos(51);\n        lemma_pow2_le_max64(51);\n    }\n\n    assert(0 < pow2(k as nat) <= u64::MAX) by {\n        lemma_pow2_pos(k as nat);\n        lemma_pow2_le_max64(k as nat);\n    }\n\n    let p51 = pow2(51) as u64;\n    let pk = pow2(k as nat) as u64;\n\n    assert(mask51 == low_bits_mask(51)) by {\n        l51_bit_mask_lt();\n    }\n\n    assert(spec_load8_at(input, i) <= u64::MAX) by {\n        lemma_spec_load8_at_fits_u64(input, i);\n    }\n\n    assert((spec_load8_at(input, i) as u64 >> k) & (low_bits_mask(51) as u64) == (((input[i + 0]\n        * pow2(0 * 8)) as u64) / pk) % p51 + (((input[i + 1] * pow2(1 * 8)) as u64) / pk) % p51 + ((\n    (input[i + 2] * pow2(2 * 8)) as u64) / pk) % p51 + (((input[i + 3] * pow2(3 * 8)) as u64) / pk)\n        % p51 + (((input[i + 4] * pow2(4 * 8)) as u64) / pk) % p51 + (((input[i + 5] * pow2(\n        5 * 8,\n    )) as u64) / pk) % p51 + (((input[i + 6] * pow2(6 * 8)) as u64) / pk) % p51 + (((input[i + 7]\n        * pow2(7 * 8)) as u64) / pk) % p51) by {\n        lemma_load8_shift_mod(input, i, k, 51);\n    }\n\n}",
      "start_line": 662,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_montgomery_point().",
      "display_name": "spec_montgomery_point",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_montgomery_point().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_montgomery_point(point: crate::montgomery::MontgomeryPoint) -> nat {\n    spec_field_element_from_bytes(&point.0)\n}",
      "start_line": 184,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#mul_base().",
      "display_name": "mul_base",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#mul_base().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn mul_base(&self, scalar: &Scalar) -> (result: EdwardsPoint)\n        requires\n            scalar.bytes[31] <= 127,\n        ensures\n            is_well_formed_edwards_point(result),\n            // Functional correctness: result = [scalar] * B\n            edwards_point_as_affine(result) == edwards_scalar_mul(\n                spec_ed25519_basepoint(),\n                spec_scalar(scalar),\n            ),\n    {\n        let a = scalar.as_radix_2w(4);\n\n        let tables = &self.0;\n        let mut P = EdwardsPoint::identity();\n\n        // ORIGINAL CODE (doesn't work with Verus - .filter() not supported in ghost for loops):\n        // for i in (0..64).filter(|x| x % 2 == 1) {\n        //     P = (&P + &tables[i / 2].select(a[i])).as_extended();\n        // }\n        for i in 0..64 {\n            if i % 2 == 1 {\n                // ORIGINAL CODE: need to add intermediate variables for pre and post conditions\n                //     P = (&P + &tables[i / 2].select(a[i])).as_extended();\n                proof {\n                    // preconditions for select and arithmetic operations\n                    assume(a[i as int] >= -8 && a[i as int] <= 8);\n                }\n                let selected = tables[i / 2].select(a[i]);\n                proof {\n                    // preconditions for addition\n                    assume(is_well_formed_edwards_point(P));\n                    assume(sum_of_limbs_bounded(&P.Z, &P.Z, u64::MAX));  // extra bound for Z2 = &P.Z + &P.Z in add\n                    assume(fe51_limbs_bounded(&selected.y_plus_x, 54));\n                    assume(fe51_limbs_bounded(&selected.y_minus_x, 54));\n                    assume(fe51_limbs_bounded(&selected.xy2d, 54));\n                }\n                let tmp = &P + &selected;\n                proof {\n                    // preconditions for as_extended\n                    assume(fe51_limbs_bounded(&tmp.X, 54));\n                    assume(fe51_limbs_bounded(&tmp.Y, 54));\n                    assume(fe51_limbs_bounded(&tmp.Z, 54));\n                    assume(fe51_limbs_bounded(&tmp.T, 54));\n                }\n                P = tmp.as_extended();\n            }\n        }\n\n        proof {\n            assume(edwards_point_limbs_bounded(P));\n            assume(fe51_limbs_bounded(&P.T, 54));\n        }\n        P = P.mul_by_pow_2(4);\n        // ORIGINAL CODE (doesn't work with Verus - .filter() not supported in ghost for loops):\n        // for i in (0..64).filter(|x| x % 2 == 0) {\n        //     P = (&P + &tables[i / 2].select(a[i])).as_extended();\n        // }\n        for i in 0..64 {\n            if i % 2 == 0 {\n                proof {\n                    // preconditions for select and arithmetic operations\n                    assume(a[i as int] >= -8 && a[i as int] <= 8);\n                }\n                let selected = tables[i / 2].select(a[i]);\n                proof {\n                    // preconditions for addition\n                    assume(is_well_formed_edwards_point(P));\n                    assume(sum_of_limbs_bounded(&P.Z, &P.Z, u64::MAX));  // extra bound for Z2 = &P.Z + &P.Z in add\n                    assume(fe51_limbs_bounded(&selected.y_plus_x, 54));\n                    assume(fe51_limbs_bounded(&selected.y_minus_x, 54));\n                    assume(fe51_limbs_bounded(&selected.xy2d, 54));\n                }\n                let tmp = &P + &selected;\n                proof {\n                    // preconditions for as_extended\n                    assume(fe51_limbs_bounded(&tmp.X, 54));\n                    assume(fe51_limbs_bounded(&tmp.Y, 54));\n                    assume(fe51_limbs_bounded(&tmp.Z, 54));\n                    assume(fe51_limbs_bounded(&tmp.T, 54));\n                }\n                P = tmp.as_extended();\n            }\n        }\n\n        proof {\n            // postconditions\n            assume(is_well_formed_edwards_point(P));\n            assume(edwards_point_as_affine(P) == edwards_scalar_mul(\n                spec_ed25519_basepoint(),\n                spec_scalar(scalar),\n            ));\n        }\n        P\n    }",
      "start_line": 2092,
      "end_line": 16,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn default() -> (result: ProjectiveNielsPoint)\n        ensures\n            result == identity_projective_niels(),\n    {\n        ProjectiveNielsPoint::identity()\n    }",
      "start_line": 261,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop().",
      "display_name": "lemma_mul_mod_noop",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_limbs5().",
      "display_name": "ct_eq_limbs5",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_limbs5().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn ct_eq_limbs5(a: &[u64; 5], b: &[u64; 5]) -> (c: Choice)\n    ensures\n        choice_is_true(c) == (*a == *b),\n{\n    a.ct_eq(b)\n}",
      "start_line": 85,
      "end_line": 20,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "display_name": "lemma_pow2_adds",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 81,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "display_name": "ct_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "curve25519-dalek/src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "    fn ct_eq(&self, other: &FieldElement) -> (result:\n        Choice)/* <VERIFICATION NOTE>\n     - Use wrapper functions for ConstantTimeEq and CtOption\n     - DRAFT SPEC: spec_fe51_to_bytes is a complex spec function that should correspond to as_bytes()\n     - Proof uses lemma_as_bytes_equals_spec_fe51_to_bytes\n    </VERIFICATION NOTE> */\n\n        ensures\n            choice_is_true(result) == (spec_fe51_to_bytes(self) == spec_fe51_to_bytes(other)),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Verus compatibility instead of direct subtle call\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.as_bytes().ct_eq(&other.as_bytes())\n         </ORIGINAL CODE> */\n        // Call as_bytes() in exec mode (outside proof block)\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        let result = ct_eq_bytes32(&self_bytes, &other_bytes);\n\n        proof {\n            // Proof chain:\n            // 1. ct_eq_bytes32 ensures: choice_is_true(result) == (self_bytes == other_bytes)\n            // 2. Array equality <==> sequence equality\n            // 3. as_bytes postcondition: u8_32_as_nat(&bytes) == u64_5_as_nat(fe.limbs) % p()\n            // 4. lemma_as_bytes_equals_spec_fe51_to_bytes: seq_from32(&bytes) == spec_fe51_to_bytes(fe)\n            //    when u8_32_as_nat(&bytes) == u64_5_as_nat(fe.limbs) % p()\n            // 5. Therefore: choice_is_true(result) == (spec_fe51_to_bytes(self) == spec_fe51_to_bytes(other))\n            // From as_bytes() postcondition, we know:\n            // - u8_32_as_nat(&self_bytes) == u64_5_as_nat(self.limbs) % p()\n            // - u8_32_as_nat(&other_bytes) == u64_5_as_nat(other.limbs) % p()\n            // Apply lemmas with the bytes and the postcondition requirement\n            lemma_as_bytes_equals_spec_fe51_to_bytes(self, &self_bytes);\n            lemma_as_bytes_equals_spec_fe51_to_bytes(other, &other_bytes);\n\n            // Now we have:\n            // - seq_from32(&self_bytes) == spec_fe51_to_bytes(self)\n            // - seq_from32(&other_bytes) == spec_fe51_to_bytes(other)\n\n            // Prove the bidirectional implication:\n            // (self_bytes == other_bytes) <==> (spec_fe51_to_bytes(self) == spec_fe51_to_bytes(other))\n\n            // Forward direction: array equality implies spec equality\n            if self_bytes == other_bytes {\n                // Arrays equal => all elements equal => sequences equal\n                assert forall|i: int| 0 <= i < 32 implies self_bytes[i] == other_bytes[i] by {}\n                assert(seq_from32(&self_bytes) == seq_from32(&other_bytes));\n                assert(spec_fe51_to_bytes(self) == spec_fe51_to_bytes(other));\n            }\n            // Backward direction: spec equality implies array equality\n\n            if spec_fe51_to_bytes(self) == spec_fe51_to_bytes(other) {\n                assert(seq_from32(&self_bytes) == seq_from32(&other_bytes));\n                lemma_seq_eq_implies_array_eq(&self_bytes, &other_bytes);\n                assert(self_bytes == other_bytes);\n            }\n            // Therefore: (self_bytes == other_bytes) <==> (spec_fe51_to_bytes(self) == spec_fe51_to_bytes(other))\n            // And since ct_eq_bytes32 ensures: choice_is_true(result) == (self_bytes == other_bytes)\n            // We conclude: choice_is_true(result) == (spec_fe51_to_bytes(self) == spec_fe51_to_bytes(other))\n\n        }\n\n        result\n    }",
      "start_line": 146,
      "end_line": 13,
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_equals_math_field_inv().",
      "display_name": "lemma_invert_equals_math_field_inv",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_equals_math_field_inv().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "file_name": "invert_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_invert_equals_math_field_inv(self_fe: &FieldElement51, t21: &FieldElement51)\n    requires\n// When x != 0, t21 is the multiplicative inverse\n\n        spec_field_element(self_fe) != 0 ==> (spec_field_element(t21) * spec_field_element(self_fe))\n            % p() == 1,\n        // When x == 0, t21 is zero\n        spec_field_element(self_fe) == 0 ==> spec_field_element(t21) == 0,\n    ensures\n        spec_field_element(t21) == math_field_inv(spec_field_element(self_fe)),\n{\n    let x = spec_field_element(self_fe);\n    let t21_val = spec_field_element(t21);\n\n    if x != 0 {\n        // For non-zero x, prove that t21_val is the unique multiplicative inverse\n        // by showing it satisfies the defining properties and using uniqueness\n        // Establish that x is in the valid range and x % p() == x\n        assert(x % p() == x) by {\n            assert(x < p()) by {\n                assert(p() > 0) by {\n                    pow255_gt_19();\n                }\n                lemma_mod_bound(spec_field_element_as_nat(self_fe) as int, p() as int);\n            }\n            lemma_small_mod(x, p());\n        }\n\n        // Since x != 0 and x % p() == x, we have x % p() != 0\n        assert(x % p() != 0);\n\n        // Establish that t21_val is in the valid range\n        assert(t21_val < p()) by {\n            assert(p() > 0) by {\n                pow255_gt_19();\n            }\n            lemma_mod_bound(spec_field_element_as_nat(t21) as int, p() as int);\n        }\n\n        // Show that t21_val satisfies the inverse property: ((x % p()) * t21_val) % p() == 1\n        assert(((x % p()) * t21_val) % p() == 1) by {\n            // From requires: (t21_val * x) % p() == 1\n            // Since x % p() == x, we can substitute\n            assert((x * t21_val) == (t21_val * x)) by (nonlinear_arith);\n            assert(((x % p()) * t21_val) == (x * t21_val));\n        }\n\n        // Both t21_val and math_field_inv(x) satisfy:\n        // 1. They are < p()\n        // 2. ((x % p()) * w) % p() == 1\n        // By uniqueness, they must be equal\n        assert(t21_val == math_field_inv(x)) by {\n            field_inv_property(x);\n            field_inv_unique(x, t21_val);\n        }\n    } else {\n        // For x == 0, show that both t21_val and math_field_inv(0) are 0\n        assert(t21_val == math_field_inv(x)) by {\n            // t21_val == 0 from requires (when x == 0)\n            // math_field_inv(0) == 0 by convention\n            assert(math_field_inv(0) == 0) by {\n                field_inv_zero();\n            }\n        }\n    }\n}",
      "start_line": 397,
      "end_line": 48,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoBasepointTable#create().",
      "display_name": "create",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoBasepointTable#create().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn create(basepoint: &RistrettoPoint) -> RistrettoBasepointTable {\n        RistrettoBasepointTable(EdwardsBasepointTable::create(&basepoint.0))\n    }",
      "start_line": 1104,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_affine().",
      "display_name": "is_valid_lookup_table_affine",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_affine().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "pub open spec fn is_valid_lookup_table_affine<const N: usize>(\n    table: [AffineNielsPoint; N],\n    P: EdwardsPoint,\n    size: nat,\n) -> bool {\n    is_valid_lookup_table_affine_coords(table, edwards_point_as_affine(P), size)\n}",
      "start_line": 88,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "display_name": "mul_internal",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub(crate) fn mul_internal(a: &Scalar52, b: &Scalar52) -> (z: [u128; 9])\n        requires\n            limbs_bounded(a),\n            limbs_bounded(b),\n        ensures\n            slice128_to_nat(&z) == to_nat(&a.limbs) * to_nat(&b.limbs),\n            spec_mul_internal(a, b) == z,\n    {\n        proof { lemma_mul_internal_no_overflow() }\n\n        let mut z = [0u128;9];\n\n        z[0] = m(a.limbs[0], b.limbs[0]);\n        z[1] = m(a.limbs[0], b.limbs[1]) + m(a.limbs[1], b.limbs[0]);\n        z[2] = m(a.limbs[0], b.limbs[2]) + m(a.limbs[1], b.limbs[1]) + m(a.limbs[2], b.limbs[0]);\n        z[3] = m(a.limbs[0], b.limbs[3]) + m(a.limbs[1], b.limbs[2]) + m(a.limbs[2], b.limbs[1])\n            + m(a.limbs[3], b.limbs[0]);\n        z[4] = m(a.limbs[0], b.limbs[4]) + m(a.limbs[1], b.limbs[3]) + m(a.limbs[2], b.limbs[2])\n            + m(a.limbs[3], b.limbs[1]) + m(a.limbs[4], b.limbs[0]);\n        z[5] = m(a.limbs[1], b.limbs[4]) + m(a.limbs[2], b.limbs[3]) + m(a.limbs[3], b.limbs[2])\n            + m(a.limbs[4], b.limbs[1]);\n        z[6] = m(a.limbs[2], b.limbs[4]) + m(a.limbs[3], b.limbs[3]) + m(a.limbs[4], b.limbs[2]);\n        z[7] = m(a.limbs[3], b.limbs[4]) + m(a.limbs[4], b.limbs[3]);\n        z[8] = m(a.limbs[4], b.limbs[4]);\n\n        proof {\n            lemma_mul_internal_correct(&a.limbs, &b.limbs, &z);\n        }\n\n        z\n    }",
      "start_line": 812,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_bound().",
      "display_name": "lemma_div_bound",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_bound().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_div_bound(x: nat, a: nat, b: nat)\n    requires\n        a <= b,\n        x < pow2(b),\n    ensures\n        x / pow2(a) < pow2((b - a) as nat),\n{\n    // Key insight: 2^b / 2^a = 2^(b-a)\n    // Since x < 2^b, we have x / 2^a < 2^b / 2^a = 2^(b-a)\n    lemma_pow2_adds(a, (b - a) as nat);\n\n    // Use division properties\n    lemma_div_strictly_bounded(x as int, pow2(a) as int, pow2((b - a) as nat) as int);\n}",
      "start_line": 52,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 10,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#from_slice().",
      "display_name": "from_slice",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#from_slice().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn from_slice(bytes: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        bytes.try_into().map(CompressedRistretto)\n    }",
      "start_line": 243,
      "end_line": 22,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/to_nat_exec().",
      "display_name": "to_nat_exec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/to_nat_exec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn to_nat_exec(limbs: &[u64; 5]) -> BigUint {\n        let mut result = BigUint::zero();\n        let radix = BigUint::from(1u128 << 52);\n        for i in (0..5).rev() {\n            result = result * &radix + BigUint::from(limbs[i]);\n        }\n        result\n    }",
      "start_line": 1221,
      "end_line": 23,
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Add#add().",
      "display_name": "add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Add#add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn add(self, other: &'b EdwardsPoint) -> (result:\n        EdwardsPoint)/* requires clause in AddSpecImpl<&EdwardsPoint> for &EdwardsPoint above:\n            is_well_formed_edwards_point(*self) && is_well_formed_edwards_point(*rhs)\n        */\n\n        ensures\n            is_valid_edwards_point(result),\n            // Semantic correctness: affine addition law\n            ({\n                let (x1, y1) = edwards_point_as_affine(*self);\n                let (x2, y2) = edwards_point_as_affine(*other);\n                edwards_point_as_affine(result) == edwards_add(x1, y1, x2, y2)\n            }),",
      "start_line": 1352,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "display_name": "ct_eq",
      "symbol": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "display_name": "lemma_small_mod",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 87,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }",
      "start_line": 115,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_from_bytes().",
      "display_name": "spec_fe51_from_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_from_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_fe51_from_bytes(bytes: &[u8; 32]) -> FieldElement51 {\n    // Mimic the implementation in field_verus.rs:from_bytes\n    // Load 8-byte chunks at specified offsets and mask to 51-bit limbs\n    let low_51_bit_mask = mask51;\n\n    FieldElement51 {\n        limbs: [\n        // load bits [  0, 64), mask to 51 bits\n\n            (spec_load8_at(bytes, 0) as u64) & low_51_bit_mask,\n            // load bits [ 48,112), shift right by 3, mask to 51 bits\n            ((spec_load8_at(bytes, 6) as u64) >> 3) & low_51_bit_mask,\n            // load bits [ 96,160), shift right by 6, mask to 51 bits\n            ((spec_load8_at(bytes, 12) as u64) >> 6) & low_51_bit_mask,\n            // load bits [152,216), shift right by 1, mask to 51 bits\n            ((spec_load8_at(bytes, 19) as u64) >> 1) & low_51_bit_mask,\n            // load bits [192,256), shift right by 12, mask to 51 bits (this ignores high bit)\n            ((spec_load8_at(bytes, 24) as u64) >> 12) & low_51_bit_mask,\n        ],\n    }\n}",
      "start_line": 321,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_from_le_bytes().",
      "display_name": "u32_from_le_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_from_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub fn u32_from_le_bytes(bytes: [u8; 4]) -> (x: u32)\n    ensures\n        x as nat == bytes_seq_to_nat(seq_from4(&bytes)),\n{\n    u32::from_le_bytes(bytes)\n}",
      "start_line": 127,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 CtOption#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo subtle 2.6.1 CtOption#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_inverse_field_of_nat().",
      "display_name": "is_inverse_field_of_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_inverse_field_of_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_inverse_field_of_nat(fe: &FieldElement51, n: nat) -> bool {\n    (spec_field_element(fe) * n) % p() == 1\n}",
      "start_line": 415,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "display_name": "lemma_limb1_contribution_correctness",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_limb1_contribution_correctness(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[0] < pow2(51),  // Need limb 0 for boundary byte 6\n        limbs[1] < pow2(51),\n        bytes_match_limbs_packing(limbs, bytes),\n    ensures\n        limb1_byte_contribution(limbs, bytes) == limbs[1] as nat * pow2(51),\n{\n    // Limb 1 is stored in bytes 6-12, but positioned at 2^51\n    // - Byte 6 (high 5 bits): limbs[1]'s bits 0-4\n    // - Bytes 7-11: limbs[1]'s bits 5-44 (40 bits)\n    // - Byte 12 (low 6 bits): limbs[1]'s bits 45-50\n    // Total: 5 + 40 + 6 = 51 bits\n    lemma2_to64();\n    lemma_pow2_adds(48, 3);\n\n    // Stabilization placeholders\n    assert(pow2(0) == pow2(0 * 8));\n    assert(pow2(8) == pow2(1 * 8));\n    assert(pow2(16) == pow2(2 * 8));\n    assert(pow2(24) == pow2(3 * 8));\n    assert(pow2(32) == pow2(4 * 8));\n\n    // KEY INSIGHT: From bytes_match_limbs_packing, we know:\n    // bytes[7] = (limbs[1] >> 5) as u8\n    // bytes[8] = (limbs[1] >> 13) as u8\n    // ... and so on\n    //\n    // So limb1_byte_contribution is actually:\n    //   (limbs[1] % 2^5) * 8 * 2^48 +              // Low 5 bits at position 2^51\n    //   (limbs[1] >> 5 ... >> 37) * positions +    // Middle 40 bits starting at position 2^56\n    //   (limbs[1] / 2^45) % 2^6 * 2^96             // High 6 bits at position 2^96\n    //\n    // This is just limbs[1] * 2^51 with bits partitioned across the byte array!\n\n    // Strategy: Show that the contribution reconstructs limbs[1] * 2^51\n    // We'll use the same approach as limb 0:\n    // 1. Convert bytes 7-11 to arithmetic form\n    // 2. Show they reconstruct (limbs[1] >> 5) at position 2^56\n    // 3. Handle boundary bits\n    // 4. Combine using div-mod theorem\n\n    // Step 1: Extract arithmetic values for bytes 7-11\n    // These bytes come from limbs[1] >> 5, 13, 21, 29, 37\n    lemma_byte_from_limb_shift(limbs[1], 5, bytes[7]);\n\n    lemma_byte_from_limb_shift(limbs[1], 13, bytes[8]);\n\n    lemma_byte_from_limb_shift(limbs[1], 21, bytes[9]);\n\n    lemma_byte_from_limb_shift(limbs[1], 29, bytes[10]);\n\n    lemma_byte_from_limb_shift(limbs[1], 37, bytes[11]);\n\n    // Step 2: Recognize that bytes 7-11 weighted by their positions reconstruct\n    // (limbs[1] >> 5) at position 2^56 = 2^(7*8)\n    //\n    // bytes[7]*2^56 + bytes[8]*2^64 + ... = (limbs[1] >> 5) * 2^56\n    //\n    // Note: The byte positions in limb1_byte_contribution are:\n    // bytes[7] * pow2(7*8) = bytes[7] * 2^56\n    // bytes[8] * pow2(8*8) = bytes[8] * 2^64 = bytes[8] * 2^(56+8)\n    // etc.\n\n    // Prove that bytes[7-11] reconstruct ((limbs[1] / 2^5) % 2^40) at position 2^56\n    //\n    // From lemma_byte_from_limb_shift, we have:\n    // bytes[7] as nat == (limbs[1] / pow2(5)) % 256\n    // bytes[8] as nat == (limbs[1] / pow2(13)) % 256\n    // bytes[9] as nat == (limbs[1] / pow2(21)) % 256\n    // bytes[10] as nat == (limbs[1] / pow2(29)) % 256\n    // bytes[11] as nat == (limbs[1] / pow2(37)) % 256\n    //\n    // The key insight: these bytes extract consecutive 8-bit chunks from (limbs[1] / 2^5)\n\n    // First, rewrite the byte extractions in terms of (limbs[1] / 2^5)\n    // bytes[7] == (limbs[1] / 2^5) / 2^0 % 256\n    lemma_pow2_adds(0, 5);\n    lemma_div_denominator(limbs[1] as int, pow2(5) as int, pow2(0) as int);\n\n    // bytes[8] == (limbs[1] / 2^13) % 256 == (limbs[1] / 2^5) / 2^8 % 256\n    lemma_pow2_adds(5, 8);\n    lemma_div_denominator(limbs[1] as int, pow2(5) as int, pow2(8) as int);\n\n    // bytes[9] == (limbs[1] / 2^21) % 256 == (limbs[1] / 2^5) / 2^16 % 256\n    lemma_pow2_adds(5, 16);\n    lemma_div_denominator(limbs[1] as int, pow2(5) as int, pow2(16) as int);\n\n    // bytes[10] == (limbs[1] / 2^29) % 256 == (limbs[1] / 2^5) / 2^24 % 256\n    lemma_pow2_adds(5, 24);\n    lemma_div_denominator(limbs[1] as int, pow2(5) as int, pow2(24) as int);\n\n    // bytes[11] == (limbs[1] / 2^37) % 256 == (limbs[1] / 2^5) / 2^32 % 256\n    lemma_pow2_adds(5, 32);\n    lemma_div_denominator(limbs[1] as int, pow2(5) as int, pow2(32) as int);\n\n    // Now handle the % 2^40 truncation\n    // Since limbs[1] < 2^51, we have limbs[1] / 2^5 < 2^46\n    lemma_div_bound(limbs[1] as nat, 5, 51);\n\n    // The bytes extract bits at positions [0..8), [8..16), [16..24), [24..32), [32..40)\n    // from (limbs[1] / 2^5). Since all these bit positions are < 40, taking % 2^40\n    // doesn't change the extracted bytes.\n    //\n    // For k < 40, if we extract byte k from value v, we get: (v / 2^(k*8)) % 256\n    // If v < 2^46, then taking (v % 2^40) only affects bits 40+\n    // So for k*8 < 40 (i.e., k < 5), we have:\n    //   (v / 2^(k*8)) % 256 == ((v % 2^40) / 2^(k*8)) % 256\n    //\n    // Since our bytes extract at offsets 0, 8, 16, 24, 32 (all < 40), they extract\n    // from (limbs[1] / 2^5) % 2^40 the same way.\n\n    let middle_value = (limbs[1] as nat / pow2(5)) % pow2(40);\n\n    // Prove middle_value < 2^40 (trivial by definition of %)\n    lemma_pow2_pos(40);\n    assert(pow2(40) > 0);\n    lemma_mod_bound(middle_value as int, pow2(40) as int);\n\n    // Now prove that the bytes extract from middle_value\n    // Since we're extracting at bit positions [0, 8, 16, 24, 32], all < 40,\n    // extracting from (limbs[1] / 2^5) or from ((limbs[1] / 2^5) % 2^40) gives the same result\n    //\n    // For byte extraction at position k where k*8 < 40:\n    //   (v / 2^(k*8)) % 256 == ((v % 2^40) / 2^(k*8)) % 256\n    //\n    // This is because v % 2^40 only affects bits >= 40, and byte extraction at k*8\n    // only looks at bits [k*8, k*8+8), which are all < 40.\n\n    let v = limbs[1] as nat / pow2(5);\n\n    // Use lemma_byte_extraction_commutes_with_mod to show extraction commutes with % 2^40\n    // For byte at position k, we need k*8 + 8 <= 40\n    lemma_byte_extraction_commutes_with_mod(v, 0, 40);  // 0*8 + 8 = 8 <= 40 ✓\n    assert(bytes[7] as nat == (middle_value / pow2(0)) % 256);\n\n    lemma_byte_extraction_commutes_with_mod(v, 1, 40);  // 1*8 + 8 = 16 <= 40 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 2, 40);  // 2*8 + 8 = 24 <= 40 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 3, 40);  // 3*8 + 8 = 32 <= 40 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 4, 40);  // 4*8 + 8 = 40 <= 40 ✓\n\n    // Now apply lemma_5_bytes_reconstruct\n    lemma_5_bytes_reconstruct(middle_value, bytes[7], bytes[8], bytes[9], bytes[10], bytes[11]);\n\n    // This gives us:\n    assert(bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8) + bytes[9] as nat * pow2(16)\n        + bytes[10] as nat * pow2(24) + bytes[11] as nat * pow2(32) == middle_value);\n\n    // Now multiply both sides by 2^56 to get the bytes at their actual positions\n    lemma_mul_is_distributive_add(\n        pow2(56) as int,\n        (bytes[7] as nat * pow2(0)) as int,\n        (bytes[8] as nat * pow2(8)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(56) as int,\n        (bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8)) as int,\n        (bytes[9] as nat * pow2(16)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(56) as int,\n        (bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8) + bytes[9] as nat * pow2(16)) as int,\n        (bytes[10] as nat * pow2(24)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(56) as int,\n        (bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8) + bytes[9] as nat * pow2(16)\n            + bytes[10] as nat * pow2(24)) as int,\n        (bytes[11] as nat * pow2(32)) as int,\n    );\n\n    // Distribute the multiplication into each term\n    lemma_mul_is_associative(bytes[7] as int, pow2(0) as int, pow2(56) as int);\n    lemma_mul_is_associative(bytes[8] as int, pow2(8) as int, pow2(56) as int);\n    lemma_mul_is_associative(bytes[9] as int, pow2(16) as int, pow2(56) as int);\n    lemma_mul_is_associative(bytes[10] as int, pow2(24) as int, pow2(56) as int);\n    lemma_mul_is_associative(bytes[11] as int, pow2(32) as int, pow2(56) as int);\n\n    // Simplify using pow2 addition: 2^56 * 2^k = 2^(56+k)\n    lemma_pow2_adds(56, 0);\n\n    lemma_pow2_adds(56, 8);\n\n    lemma_pow2_adds(56, 16);\n\n    lemma_pow2_adds(56, 24);\n\n    lemma_pow2_adds(56, 32);\n    assert(pow2(88) == pow2(11 * 8));\n\n    // Final result§\n    assert(bytes[7] as nat * pow2(7 * 8) + bytes[8] as nat * pow2(8 * 8) + bytes[9] as nat * pow2(\n        9 * 8,\n    ) + bytes[10] as nat * pow2(10 * 8) + bytes[11] as nat * pow2(11 * 8) == middle_value * pow2(\n        56,\n    ));\n\n    // Step 3: Handle boundary bytes\n    // Low 5 bits (byte 6 high part): (limbs[1] % 2^5) * 8 * 2^48 = (limbs[1] % 2^5) * 2^51\n    // High 6 bits (byte 12 low part): (limbs[1] / 2^45) % 2^6 * 2^96\n\n    assert(8 * pow2(48) == pow2(51)) by {\n        lemma_pow2_adds(48, 3);\n    }\n\n    // Step 4: Prove the final equality using division-modulo reconstruction\n    // Goal: Show limb1_byte_contribution == limbs[1] * 2^51\n\n    // First, expand limb1_byte_contribution using its definition\n    let contribution = limb1_byte_contribution(limbs, bytes);\n    assert(contribution == ((limbs[1] as nat % pow2(5)) * 8) * pow2(6 * 8) + bytes[7] as nat * pow2(\n        7 * 8,\n    ) + bytes[8] as nat * pow2(8 * 8) + bytes[9] as nat * pow2(9 * 8) + bytes[10] as nat * pow2(\n        10 * 8,\n    ) + bytes[11] as nat * pow2(11 * 8) + ((limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(12 * 8));\n\n    // Create a variable for the middle bytes sum\n    let middle_bytes_sum = bytes[7] as nat * pow2(7 * 8) + bytes[8] as nat * pow2(8 * 8)\n        + bytes[9] as nat * pow2(9 * 8) + bytes[10] as nat * pow2(10 * 8) + bytes[11] as nat * pow2(\n        11 * 8,\n    );\n\n    // From the proof above, we have:\n    // middle_bytes_sum == ((limbs[1] / pow2(5)) % pow2(40)) * pow2(56)\n    let middle_value_at_position = ((limbs[1] as nat / pow2(5)) % pow2(40)) * pow2(56);\n\n    // Substitute into contribution\n    assert(contribution == ((limbs[1] as nat % pow2(5)) * 8) * pow2(48) + middle_bytes_sum + ((\n    limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(96));\n\n    assert(contribution == ((limbs[1] as nat % pow2(5)) * 8) * pow2(48) + middle_value_at_position\n        + ((limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(96));\n\n    // Now complete the algebraic proof using division-modulo reconstruction\n    // Goal: Show contribution = limbs[1] * 2^51\n\n    // Step 1: Simplify the low contribution term\n    // We have: ((limbs[1] % 2^5) * 8) * 2^48\n    // We proved earlier that 8 * 2^48 = 2^51\n    // So: ((limbs[1] % 2^5) * 8) * 2^48 = (limbs[1] % 2^5) * (8 * 2^48) = (limbs[1] % 2^5) * 2^51\n    // For now, accept this simplification (requires multiplication associativity)\n    let low_term = (limbs[1] as nat % pow2(5)) * pow2(51);\n    let middle_term = ((limbs[1] as nat / pow2(5)) % pow2(40)) * pow2(56);\n    let high_term = ((limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(96);\n\n    // Step 2: Establish power relationships needed for factoring\n    lemma_pow2_adds(51, 5);  // 2^56 = 2^51 * 2^5\n\n    lemma_pow2_adds(51, 45);  // 2^96 = 2^51 * 2^45\n\n    // Step 3: Prove limbs[1] can be reconstructed from the three parts\n    // We'll show: limbs[1] = (limbs[1] % 2^5) + ((limbs[1] / 2^5) % 2^40) * 2^5 + ((limbs[1] / 2^45) % 2^6) * 2^45\n\n    // First, reconstruct limbs[1] / 2^5 from its low 40 bits and high part\n    lemma_pow2_pos(40);\n    let shifted_value = limbs[1] as nat / pow2(5);\n    lemma_fundamental_div_mod(shifted_value as int, pow2(40) as int);\n    // lemma_fundamental_div_mod gives: shifted_value == pow2(40) * (shifted_value / pow2(40)) + (shifted_value % pow2(40))\n    // We need: shifted_value == (shifted_value % pow2(40)) + (shifted_value / pow2(40)) * pow2(40)\n    assert(pow2(40) * (shifted_value / pow2(40)) == (shifted_value / pow2(40)) * pow2(40)) by {\n        lemma_mul_is_commutative(pow2(40) as int, (shifted_value / pow2(40)) as int);\n    }\n\n    // Show that (limbs[1] / 2^5) / 2^40 = limbs[1] / 2^45\n    lemma_div_denominator(limbs[1] as int, pow2(5) as int, pow2(40) as int);\n    lemma_pow2_adds(5, 40);\n\n    // So: limbs[1] / 2^5 = ((limbs[1] / 2^5) % 2^40) + (limbs[1] / 2^45) * 2^40\n    assert(shifted_value == (shifted_value % pow2(40)) + (limbs[1] as nat / pow2(45)) * pow2(40));\n\n    // Next, reconstruct limbs[1] from its low 5 bits and (limbs[1] / 2^5)\n    lemma_pow2_pos(5);\n    lemma_fundamental_div_mod(limbs[1] as int, pow2(5) as int);\n    // lemma_fundamental_div_mod gives: limbs[1] == pow2(5) * (limbs[1] / pow2(5)) + (limbs[1] % pow2(5))\n    assert(pow2(5) * shifted_value == shifted_value * pow2(5)) by {\n        lemma_mul_is_commutative(pow2(5) as int, shifted_value as int);\n    }\n\n    // Substitute the reconstruction of shifted_value (limbs[1] / 2^5)\n    assert(limbs[1] as nat == (limbs[1] as nat % pow2(5)) + ((shifted_value % pow2(40)) + (\n    limbs[1] as nat / pow2(45)) * pow2(40)) * pow2(5));\n\n    // Distribute the * 2^5\n    assert(limbs[1] as nat == (limbs[1] as nat % pow2(5)) + (shifted_value % pow2(40)) * pow2(5) + (\n    limbs[1] as nat / pow2(45)) * pow2(40) * pow2(5)) by {\n        lemma_mul_is_distributive_add(\n            pow2(5) as int,\n            (shifted_value % pow2(40)) as int,\n            (limbs[1] as nat / pow2(45) * pow2(40)) as int,\n        );\n    }\n\n    // Use 2^40 * 2^5 = 2^45\n    lemma_pow2_adds(40, 5);\n    assert((limbs[1] as nat / pow2(45)) * pow2(40) * pow2(5) == (limbs[1] as nat / pow2(45)) * pow2(\n        45,\n    )) by {\n        lemma_mul_is_associative(\n            (limbs[1] as nat / pow2(45)) as int,\n            pow2(40) as int,\n            pow2(5) as int,\n        );\n    }\n\n    assert(limbs[1] as nat == (limbs[1] as nat % pow2(5)) + ((limbs[1] as nat / pow2(5)) % pow2(40))\n        * pow2(5) + (limbs[1] as nat / pow2(45)) * pow2(45));\n\n    // Handle the % 2^6 on the high bits\n    // Since limbs[1] < 2^51, we have limbs[1] / 2^45 < 2^6\n    lemma_div_bound(limbs[1] as nat, 45, 51);\n    lemma_small_mod(limbs[1] as nat / pow2(45), pow2(6));\n\n    // Therefore:\n    assert(limbs[1] as nat == (limbs[1] as nat % pow2(5)) + ((limbs[1] as nat / pow2(5)) % pow2(40))\n        * pow2(5) + ((limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(45));\n\n    // Step 4: Now connect the contribution to limbs[1] * 2^51\n    // We have: contribution = ((limbs[1] % 2^5) * 8) * 2^48 + middle_value_at_position + ((limbs[1] / 2^45) % 2^6) * 2^96\n    // Where: middle_value_at_position = ((limbs[1] / 2^5) % 2^40) * 2^56\n\n    // First, simplify the low term: ((limbs[1] % 2^5) * 8) * 2^48 = (limbs[1] % 2^5) * (8 * 2^48) = (limbs[1] % 2^5) * 2^51\n    // We proved earlier that 8 * 2^48 = 2^51\n    let low_part = (limbs[1] as nat % pow2(5));\n    assert(((limbs[1] as nat % pow2(5)) * 8) * pow2(48) == low_part * (8 * pow2(48))) by {\n        lemma_mul_is_associative(low_part as int, 8, pow2(48) as int);\n    }\n\n    // So contribution = (limbs[1] % 2^5) * 2^51 + ((limbs[1] / 2^5) % 2^40) * 2^56 + ((limbs[1] / 2^45) % 2^6) * 2^96\n    assert(contribution == low_part * pow2(51) + ((limbs[1] as nat / pow2(5)) % pow2(40)) * pow2(56)\n        + ((limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(96));\n\n    // Rewrite using 2^56 = 2^51 * 2^5 and 2^96 = 2^51 * 2^45\n    assert(contribution == low_part * pow2(51) + ((limbs[1] as nat / pow2(5)) % pow2(40)) * (pow2(\n        51,\n    ) * pow2(5)) + ((limbs[1] as nat / pow2(45)) % pow2(6)) * (pow2(51) * pow2(45)));\n\n    // Apply associativity to move pow2(51) to the left\n    let middle_part = (limbs[1] as nat / pow2(5)) % pow2(40);\n    let high_part = (limbs[1] as nat / pow2(45)) % pow2(6);\n\n    assert(middle_part * (pow2(51) * pow2(5)) == (middle_part * pow2(51)) * pow2(5)) by {\n        lemma_mul_is_associative(middle_part as int, pow2(51) as int, pow2(5) as int);\n    }\n    assert((middle_part * pow2(51)) * pow2(5) == pow2(51) * middle_part * pow2(5)) by {\n        lemma_mul_is_commutative((middle_part * pow2(51)) as int, pow2(5) as int);\n    }\n    assert(pow2(51) * middle_part * pow2(5) == pow2(51) * (middle_part * pow2(5))) by {\n        lemma_mul_is_associative(pow2(51) as int, middle_part as int, pow2(5) as int);\n    }\n\n    assert(high_part * (pow2(51) * pow2(45)) == (high_part * pow2(51)) * pow2(45)) by {\n        lemma_mul_is_associative(high_part as int, pow2(51) as int, pow2(45) as int);\n    }\n    assert((high_part * pow2(51)) * pow2(45) == pow2(51) * high_part * pow2(45)) by {\n        lemma_mul_is_commutative((high_part * pow2(51)) as int, pow2(45) as int);\n    }\n    assert(pow2(51) * high_part * pow2(45) == pow2(51) * (high_part * pow2(45))) by {\n        lemma_mul_is_associative(pow2(51) as int, high_part as int, pow2(45) as int);\n    }\n\n    // Now factor out pow2(51)\n    assert(contribution == low_part * pow2(51) + pow2(51) * (middle_part * pow2(5)) + pow2(51) * (\n    high_part * pow2(45)));\n\n    // Use distributivity to factor out pow2(51)\n    assert(contribution == pow2(51) * (low_part + middle_part * pow2(5) + high_part * pow2(45)))\n        by {\n        lemma_mul_is_distributive_add(\n            pow2(51) as int,\n            low_part as int,\n            (middle_part * pow2(5)) as int,\n        );\n        lemma_mul_is_distributive_add(\n            pow2(51) as int,\n            (low_part + middle_part * pow2(5)) as int,\n            (high_part * pow2(45)) as int,\n        );\n    }\n\n    // The part in parentheses equals limbs[1] by our reconstruction identity!\n    assert(contribution == limbs[1] as nat * pow2(51)) by {\n        lemma_mul_is_commutative(pow2(51) as int, limbs[1] as int);\n    }\n\n}",
      "start_line": 558,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 17
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/sum_of_scalars().",
      "display_name": "sum_of_scalars",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/sum_of_scalars().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn sum_of_scalars(scalars: Seq<Scalar>) -> nat\n    decreases scalars.len(),\n{\n    if scalars.len() == 0 {\n        0\n    } else {\n        (sum_of_scalars(scalars.skip(1)) + bytes_to_nat(&scalars[0].bytes)) % group_order()\n    }\n}",
      "start_line": 74,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#expect().",
      "display_name": "expect",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#expect().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "curve25519-dalek/build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#SubAssign#sub_assign().",
      "display_name": "sub_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#SubAssign#sub_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn sub_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        *self = &*self - _rhs;\n    }",
      "start_line": 790,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_montgomery_point().",
      "display_name": "is_valid_montgomery_point",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_montgomery_point().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_valid_montgomery_point(point: crate::montgomery::MontgomeryPoint) -> bool {\n    let u = spec_montgomery_point(point);\n    is_valid_u_coordinate(u)\n}",
      "start_line": 95,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_add_mod_noop().",
      "display_name": "lemma_add_mod_noop",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_add_mod_noop().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "is_libsignal": false,
      "caller_count": 13,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_limbs_bounded().",
      "display_name": "lemma_rr_limbs_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_limbs_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_rr_limbs_bounded()\n    ensures\n        0x000d63c715bea69fu64 < (1u64 << 52),\n{\n    // Verus can figure that out the other 4 limbs are bounded\n    assert(0x000d63c715bea69fu64 < (1u64 << 52)) by (bit_vector);\n}",
      "start_line": 384,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/spec_scalar().",
      "display_name": "spec_scalar",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/spec_scalar().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_scalar(s: &Scalar) -> nat {\n    bytes_to_nat(&s.bytes) % group_order()\n}",
      "start_line": 39,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Mul#mul().",
      "display_name": "mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Mul#mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn mul(self, basepoint_table: &'a EdwardsBasepointTable) -> (result:\n        EdwardsPoint)/* requires clause in MulSpecImpl<&EdwardsBasepointTable> for &Scalar in mul_specs.rs:\n        requires self.bytes[31] <= 127\n    */\n\n        ensures\n            is_well_formed_edwards_point(result),\n            // Functional correctness: result = [scalar] * B\n            edwards_point_as_affine(result) == edwards_scalar_mul(\n                spec_ed25519_basepoint(),\n                spec_scalar(self),\n            ),\n    {\n        basepoint_table * self\n    }",
      "start_line": 2216,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_scalar().",
      "display_name": "to_scalar",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_scalar().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn to_scalar(limbs: &[u64; 5]) -> nat {\n    to_nat(limbs) % group_order()\n}",
      "start_line": 56,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash_verus().",
      "display_name": "from_hash_verus",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash_verus().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn from_hash_verus(hash_bytes: [u8; 64]) -> (result: Scalar)\n        ensures\n            is_random_bytes(&hash_bytes) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        let result = Scalar::from_bytes_mod_order_wide(&hash_bytes);\n        assume(false);\n        result\n    }",
      "start_line": 1451,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/VartimeEdwardsPrecomputation#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "display_name": "optional_mixed_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/VartimeEdwardsPrecomputation#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        self.0\n            .optional_mixed_multiscalar_mul(static_scalars, dynamic_scalars, dynamic_points)\n    }",
      "start_line": 1884,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_none().",
      "display_name": "ct_option_is_none",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_none().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn ct_option_is_none<T>(opt: &CtOption<T>) -> (c: Choice)\n    ensures\n        choice_is_true(c) == !ct_option_has_value(*opt),\n{\n    opt.is_none()\n}",
      "start_line": 178,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_basics_3().",
      "display_name": "lemma_div_basics_3",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_basics_3().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_is_binary().",
      "display_name": "lemma_q_is_binary",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_is_binary().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_q_is_binary(limbs: [u64; 5], q: u64)\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 52),\n        u64_5_as_nat(limbs) < 2 * p(),  // From reduce()'s postcondition\n        q == compute_q_spec(limbs),\n        q < 3,\n    ensures\n        q == 0 || q == 1,\n        q as nat == (u64_5_as_nat(limbs) + 19) / pow2(255),  // Export for reuse\n{\n    lemma_carry_propagation_is_division(limbs, q);\n\n    // Establish basic facts\n    lemma2_to64();\n    pow255_gt_19();\n    lemma_pow2_adds(255, 1);  // Establish pow2(256) == pow2(255) * 2\n\n    // Simplified reasoning:\n    // Since p() = 2^255 - 19 < 2^255, we have:\n    // u64_5_as_nat(limbs) < 2*p() < 2*2^255\n    // Therefore: u64_5_as_nat(limbs) + 19 < 2*2^255\n    assert(p() < pow2(255)) by {\n        pow255_gt_19();\n    }\n\n    // By integer division: if x < 2 * d, then x / d < 2\n    lemma_pow2_pos(255);\n    lemma_div_strictly_bounded((u64_5_as_nat(limbs) + 19) as int, pow2(255) as int, 2);\n\n    // Since q = (u64_5_as_nat(limbs) + 19) / 2^255, we have q < 2\n}",
      "start_line": 472,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#to_radix_2w_size_hint().",
      "display_name": "to_radix_2w_size_hint",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#to_radix_2w_size_hint().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn to_radix_2w_size_hint(w: usize) -> usize\n        requires\n            4 <= w <= 8,\n        returns\n            if w < 8 {\n                (256 + w - 1) / (w as int)\n            } else {\n                (256 + w - 1) / (w as int) + 1\n            } as usize,",
      "start_line": 2267,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb3_byte_contribution_52().",
      "display_name": "limb3_byte_contribution_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb3_byte_contribution_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub open spec fn limb3_byte_contribution_52(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    // Byte 19 high 4 bits (limbs[3]'s bits 0-3)\n    ((limbs[3] as nat % pow2(4)) * 16) * pow2(19 * 8) +\n    bytes[20] as nat * pow2(20 * 8) +\n    bytes[21] as nat * pow2(21 * 8) +\n    bytes[22] as nat * pow2(22 * 8) +\n    bytes[23] as nat * pow2(23 * 8) +\n    bytes[24] as nat * pow2(24 * 8) +\n    bytes[25] as nat * pow2(25 * 8)\n}",
      "start_line": 113,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_rec_version_is_exec().",
      "display_name": "lemma_load8_at_rec_version_is_exec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_rec_version_is_exec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_load8_at_rec_version_is_exec(input: &[u8], i: usize)\n    ensures\n        load8_at_or_version_rec(input, i, 7) == (input[i as int] as u64) | ((input[i + 1] as u64)\n            << 8) | ((input[i + 2] as u64) << 16) | ((input[i + 3] as u64) << 24) | ((input[i\n            + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((input[i + 6] as u64) << 48) | ((\n        input[i + 7] as u64) << 56),\n{\n    assert(load8_at_or_version_rec(input, i, 0) == (input[i as int] as u64));\n\n    assert forall|j: nat| 1 <= j <= 7 implies #[trigger] load8_at_or_version_rec(input, i, j)\n        == load8_at_or_version_rec(input, i, (j - 1) as nat) | ((input[i + j] as u64) << 8 * j) by {\n        reveal_with_fuel(load8_at_or_version_rec, 1);\n    }\n}",
      "start_line": 32,
      "end_line": 48,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "display_name": "step_2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub(super) fn step_2(s: FieldElement) -> (Choice, Choice, Choice, RistrettoPoint) {\n        // Step 2.  Compute (X:Y:Z:T).\n        let one = FieldElement::ONE;\n        let ss = s.square();\n        let u1 = &one - &ss; //  1 + as²\n        let u2 = &one + &ss; //  1 - as²    where a=-1\n        let u2_sqr = u2.square(); // (1 - as²)²\n\n        // v == ad(1+as²)² - (1-as²)²            where d=-121665/121666\n        let v = &(&(-&constants::EDWARDS_D) * &u1.square()) - &u2_sqr;\n\n        let (ok, I) = (&v * &u2_sqr).invsqrt(); // 1/sqrt(v*u_2²)\n\n        let Dx = &I * &u2; // 1/sqrt(v)\n        let Dy = &I * &(&Dx * &v); // 1/u2\n\n        // x == | 2s/sqrt(v) | == + sqrt(4s²/(ad(1+as²)² - (1-as²)²))\n        let mut x = &(&s + &s) * &Dx;\n        let x_neg = x.is_negative();\n        x.conditional_negate(x_neg);\n\n        // y == (1-as²)/(1+as²)\n        let y = &u1 * &Dy;\n\n        // t == ((1+as²) sqrt(4s²/(ad(1+as²)² - (1-as²)²)))/(1-as²)\n        let t = &x * &y;\n\n        (\n            ok,\n            t.is_negative(),\n            y.is_zero(),\n            RistrettoPoint(EdwardsPoint {\n                X: x,\n                Y: y,\n                Z: one,\n                T: t,\n            }),\n        )\n    }",
      "start_line": 294,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_constants_lemmas/field_lemmas/lemmas/lemma_zero_field_element_value().",
      "display_name": "lemma_zero_field_element_value",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_constants_lemmas/field_lemmas/lemmas/lemma_zero_field_element_value().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/unused_constants_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/unused_constants_lemmas.rs",
      "file_name": "unused_constants_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_zero_field_element_value()\n    ensures\n        spec_field_element(&FieldElement51::ZERO) == 0,\n{\n    assert(spec_field_element(&FieldElement51::ZERO) == 0) by {\n        // Step 1: Establish limbs values\n        assert(FieldElement51::ZERO.limbs[0] == 0);\n        assert(FieldElement51::ZERO.limbs[1] == 0);\n        assert(FieldElement51::ZERO.limbs[2] == 0);\n        assert(FieldElement51::ZERO.limbs[3] == 0);\n        assert(FieldElement51::ZERO.limbs[4] == 0);\n\n        // Step 2: u64_5_as_nat([0, 0, 0, 0, 0]) = 0\n        // Expands to: 0 + pow2(51)*0 + pow2(102)*0 + pow2(153)*0 + pow2(204)*0 = 0\n        // This is a computational fact about the representation\n        assume(u64_5_as_nat(FieldElement51::ZERO.limbs) == 0);\n\n        // Step 3: 0 % p = 0\n        // 0 mod anything = 0\n        assume(0nat % p() == 0);\n    };\n}",
      "start_line": 66,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "display_name": "lemma_sub_mod_noop",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "is_libsignal": false,
      "caller_count": 15,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_byte_from_limb_shift_52().",
      "display_name": "lemma_byte_from_limb_shift_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_byte_from_limb_shift_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "proof fn lemma_byte_from_limb_shift_52(limb: u64, shift: u64, byte: u8)\n    requires\n        limb < pow2(52),\n        shift < 64,\n        byte == (limb >> shift) as u8,\n    ensures\n        byte as nat == (limb as nat / pow2(shift as nat)) % 256,\n{\n    // Bitwise shift to arithmetic conversion\n    // When we shift right by `shift` bits and cast to u8, we extract 8 bits starting at position `shift`\n    // In arithmetic terms: (limb / 2^shift) % 256\n    lemma2_to64();\n    assert((limb >> shift) as nat == limb as nat / pow2(shift as nat)) by {\n        lemma_u64_shr_is_div(limb, shift);\n    }\n\n    // The u8 cast takes the low 8 bits, which is % 256\n    // Proof: use vstd lemma that & 0xFF = % 256, then bit_vector to show casting = masking\n    let shifted = limb >> shift;\n    assert(shifted & 0xFF == shifted % 256) by {\n        lemma_u64_low_bits_mask_is_mod(shifted, 8);\n    }\n    assert(shifted as u8 == (shifted & 0xFF) as u8) by (bit_vector);\n    // Therefore: (shifted as u8) as nat == shifted % 256\n    assert((limb >> shift) as u8 as nat == ((limb >> shift) as nat) % 256);\n}",
      "start_line": 245,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_bounded_shr_51().",
      "display_name": "lemma_bounded_shr_51",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_bounded_shr_51().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_bounded_shr_51(x: u64)\n    requires\n        x < 3 * pow2(51),\n    ensures\n        (x >> 51) < 3,\n{\n    lemma_pow2_pos(51);\n    lemma_mul_is_commutative(3, pow2(51) as int);\n\n    let shifted = x >> 51;\n    lemma_u64_shr_is_div(x, 51);\n    lemma_div_strictly_bounded(x as int, pow2(51) as int, 3);\n}",
      "start_line": 23,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo proptest 1.9.0 array/uniform32().",
      "display_name": "uniform32",
      "symbol": "rust-analyzer cargo proptest 1.9.0 array/uniform32().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/get_selected_backend().",
      "display_name": "get_selected_backend",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/get_selected_backend().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "backend",
      "body": "fn get_selected_backend() -> (result: BackendKind)\n    ensures\n        matches!(result, BackendKind::Serial),\n{\n    // #[cfg(all(curve25519_dalek_backend = \"simd\", nightly))]\n    // {\n    //     cpufeatures::new!(cpuid_avx512, \"avx512ifma\", \"avx512vl\");\n    //     let token_avx512: cpuid_avx512::InitToken = cpuid_avx512::init();\n    //     if token_avx512.get() {\n    //         return BackendKind::Avx512;\n    //     }\n    // }\n    // #[cfg(curve25519_dalek_backend = \"simd\")]\n    // {\n    //     cpufeatures::new!(cpuid_avx2, \"avx2\");\n    //     let token_avx2: cpuid_avx2::InitToken = cpuid_avx2::init();\n    //     if token_avx2.get() {\n    //         return BackendKind::Avx2;\n    //     }\n    // }\n    BackendKind::Serial\n}",
      "start_line": 64,
      "end_line": 24,
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_sub_multiples_vanish().",
      "display_name": "lemma_mod_sub_multiples_vanish",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_sub_multiples_vanish().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/radix_16_all_bounded().",
      "display_name": "radix_16_all_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/radix_16_all_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn radix_16_all_bounded(digits: &[i8; 64]) -> bool {\n    forall|i: int| 0 <= i < 64 ==> radix_16_digit_bounded(#[trigger] digits[i])\n}",
      "start_line": 236,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_plus_one().",
      "display_name": "lemma_pow2_plus_one",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_plus_one().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_plus_one(n: nat)\n    ensures\n        pow2(n + 1) == pow2(n) + pow2(n),\n{\n    assert(pow2(n + 1) == pow2(n) * pow2(1)) by {\n        lemma_pow2_adds(n, 1);\n    }\n    assert(pow2(1) == 1 + 1) by {\n        lemma2_to64();\n    }\n    assert(pow2(n) * (1 + 1) == pow2(n) + pow2(n)) by {\n        lemma_mul_is_distributive_add(pow2(n) as int, 1, 1);\n        lemma_mul_basics_3(pow2(n) as int);\n    }\n}",
      "start_line": 35,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_partial_binomial_sum_mod_p().",
      "display_name": "lemma_partial_binomial_sum_mod_p",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_partial_binomial_sum_mod_p().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "proof fn lemma_partial_binomial_sum_mod_p(a: nat, p: nat, j: nat)\n    requires\n        is_prime(p),\n        j <= p,\n    ensures\n        j < p ==> binomial_sum(a, p, j) % p == 1,\n        j == p ==> binomial_sum(a, p, j) % p == (1 + (pow(a as int, p) as nat)) % p,\n    decreases j,\n{\n    if j == 0 {\n        // S_0 = C(p,0) * a^0 = 1 * 1 = 1\n        assert(binomial(p, 0) == 1);\n        reveal(pow);\n        assert(pow(a as int, 0) == 1);\n        assert(pow(a as int, 0) as nat == 1nat);\n        assert(binomial(p, 0) * (pow(a as int, 0) as nat) == 1nat);\n        assert(binomial_sum(a, p, 0) == 1);\n        lemma_small_mod(1nat, p);\n    } else if j < p {\n        // 0 < j < p\n        // S_j = S_{j-1} + C(p,j) * a^j\n        // By IH: S_{j-1} % p == 1\n        // C(p,j) % p == 0 for 0 < j < p\n        lemma_partial_binomial_sum_mod_p(a, p, (j - 1) as nat);\n        assert(binomial_sum(a, p, (j - 1) as nat) % p == 1);\n\n        lemma_binomial_divisible_by_prime(p, j);\n        assert(binomial(p, j) % p == 0);\n\n        // C(p,j) * a^j % p == 0\n        // Since C(p,j) % p == 0, we have C(p,j) = q*p for some q\n        // So C(p,j) * a^j = q*p * a^j, which is divisible by p\n\n        // Use the fact that (x % p == 0) implies (x * y) % p == 0\n        lemma_pow_nonnegative(a as int, j);\n        assert(pow(a as int, j) >= 0);\n\n        // Work with int types for the modular arithmetic\n        let binom_int = binomial(p, j) as int;\n        let pow_int = pow(a as int, j);\n        let term_int = binom_int * pow_int;\n\n        // term_int % p == 0\n        assert(term_int % (p as int) == 0) by {\n            // First, establish that binom_int % p == 0\n            assert(binom_int % (p as int) == 0);\n\n            // Apply lemma_mul_mod_noop_left\n            lemma_mul_mod_noop_left(binom_int, pow_int, p as int);\n            // This gives: (binom_int * pow_int) % p == (binom_int % p * pow_int) % p\n\n            // binom_int % p == 0, so (binom_int % p) * pow_int == 0 * pow_int == 0\n            lemma_mul_basics(pow_int);\n            assert((binom_int % (p as int)) * pow_int == 0);\n\n            // 0 % p == 0 for any p > 0\n            assert(p > 1) by {  /* is_prime(p) implies p > 1 */\n            };\n            lemma_small_mod(0nat, p);\n        };\n\n        // term_int >= 0 since both factors >= 0\n        assert(term_int >= 0) by {\n            lemma_mul_nonnegative(binom_int, pow_int);\n        };\n\n        // The nat version matches the int version\n        let term_j = binomial(p, j) * (pow(a as int, j) as nat);\n        assert(term_j == term_int as nat);\n        assert(term_j % p == 0) by {\n            // term_j as int == term_int, term_int % p == 0, so term_j % p == 0\n        };\n\n        // S_j = S_{j-1} + term_j\n        // S_j % p == (S_{j-1} + term_j) % p == (S_{j-1} % p + term_j % p) % p\n        //         == (1 + 0) % p == 1\n        assert(binomial_sum(a, p, j) == binomial_sum(a, p, (j - 1) as nat) + term_j);\n\n        assert(binomial_sum(a, p, j) % p == 1) by {\n            lemma_mod_adds(binomial_sum(a, p, (j - 1) as nat) as int, term_j as int, p as int);\n            lemma_small_mod(1nat, p);\n        };\n    } else {\n        // j == p\n        // S_p = S_{p-1} + C(p,p) * a^p\n        // By IH: S_{p-1} % p == 1\n        // C(p,p) = 1\n        if p == 1 {\n            // Special case: p = 1\n            // S_1 = C(1,0)*a^0 + C(1,1)*a^1 = 1 + a\n            // (1 + a^1) = 1 + a\n            // So S_1 % 1 == (1 + a) % 1 == 0\n            assert(binomial_sum(a, 1, 1) == binomial_sum(a, 1, 0) + binomial(1, 1) * pow(\n                a as int,\n                1,\n            ) as nat);\n            assert(binomial_sum(a, 1, 0) == 1);\n            assert(binomial(1, 1) == 1);\n            assert(pow(a as int, 1) == a as int) by {\n                reveal(pow);\n                lemma_mul_basics(1int);\n            };\n        }\n        lemma_partial_binomial_sum_mod_p(a, p, (p - 1) as nat);\n        assert(binomial_sum(a, p, (p - 1) as nat) % p == 1);\n\n        assert(binomial(p, p) == 1);\n\n        // term_p = binomial(p,p) * a^p = 1 * a^p = a^p\n        let pow_a_p = pow(a as int, p) as nat;\n        lemma_pow_nonnegative(a as int, p);\n        assert(pow(a as int, p) >= 0);\n\n        let term_p = binomial(p, p) * pow_a_p;\n        assert(term_p == pow_a_p) by {\n            assert(binomial(p, p) == 1);\n        };\n\n        // S_p = S_{p-1} + a^p\n        assert(binomial_sum(a, p, p) == binomial_sum(a, p, (p - 1) as nat) + term_p);\n\n        // S_p % p == (S_{p-1} + a^p) % p\n        //         == (S_{p-1} % p + a^p % p) % p\n        //         == (1 + (a^p % p)) % p\n        //         == (1 + a^p) % p  [since (x % p + y % p) % p == (x + y) % p]\n\n        // First show: (S_{p-1} + term_p) % p == (1 + term_p % p) % p\n        lemma_mod_adds(binomial_sum(a, p, (p - 1) as nat) as int, term_p as int, p as int);\n        // This gives: (S_{p-1} + term_p) % p == (S_{p-1} % p + term_p % p) % p == (1 + term_p % p) % p\n\n        // Since term_p == pow_a_p, term_p % p == pow_a_p % p\n        assert(term_p % p == pow_a_p % p);\n\n        // Now show: (1 + term_p % p) % p == (1 + pow_a_p) % p\n        // This is because (1 + (x % p)) % p == (1 + x) % p\n        lemma_mod_adds(1, pow_a_p as int, p as int);\n        // This gives: (1 + pow_a_p) % p == (1 % p + pow_a_p % p) % p\n        lemma_small_mod(1nat, p);\n        // So (1 + pow_a_p) % p == (1 + pow_a_p % p) % p\n\n        assert(binomial_sum(a, p, p) % p == (1 + pow_a_p) % p);\n    }\n}",
      "start_line": 525,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 12
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_le_u64().",
      "display_name": "lemma_shr_le_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_le_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_shr_le_u64(a: u64, b: u64, k: nat)\n    requires\n        a <= b,\n        k < 64,\n    ensures\n        (a >> k) <= (b >> k),\n{\n    lemma_pow2_pos(k);\n    lemma_u64_shr_is_div(a, k as u64);\n    lemma_u64_shr_is_div(b, k as u64);\n    lemma_div_is_ordered(a as int, b as int, pow2(k) as int);\n}",
      "start_line": 170,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
      "start_line": 1259,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Mul#mul().",
      "display_name": "mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Mul#mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            spec_field_element(&output) == math_field_mul(\n                spec_field_element(self),\n                spec_field_element(_rhs),\n            ),\n            // Actual bound: 2^51 + 2^13 < 2^52 (from carry propagation)\n            fe51_limbs_bounded(&output, 52),\n            // 52-bit implies 54-bit (for compatibility with callers)\n            fe51_limbs_bounded(&output, 54),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }",
      "start_line": 480,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective_niels().",
      "display_name": "as_projective_niels",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective_niels().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn as_projective_niels(&self) -> (result: ProjectiveNielsPoint)\n        requires\n            edwards_point_limbs_bounded(*self),\n            edwards_point_sum_bounded(*self),\n        ensures\n            projective_niels_corresponds_to_edwards(result, *self),\n            fe51_limbs_bounded(&result.Y_plus_X, 54),\n            fe51_limbs_bounded(&result.Y_minus_X, 54),\n            fe51_limbs_bounded(&result.Z, 54),\n            fe51_limbs_bounded(&result.T2d, 54),\n    {\n        proof {\n            assume(fe51_limbs_bounded(&constants::EDWARDS_D2, 54));  // for T2d\n        }\n\n        let result = ProjectiveNielsPoint {\n            Y_plus_X: &self.Y + &self.X,\n            Y_minus_X: &self.Y - &self.X,\n            Z: self.Z,\n            T2d: &self.T * &constants::EDWARDS_D2,\n        };\n\n        proof {\n            // postconditions:\n            assume(projective_niels_corresponds_to_edwards(result, *self));\n            assume(fe51_limbs_bounded(&result.Y_plus_X, 54));\n            assume(fe51_limbs_bounded(&result.Y_minus_X, 54));\n            assume(fe51_limbs_bounded(&result.Z, 54));\n            assume(fe51_limbs_bounded(&result.T2d, 54));\n        }\n\n        result\n    }",
      "start_line": 1087,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul_u8().",
      "display_name": "lemma_pow2_mul_div_mod_small_mul_u8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul_u8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_mul_div_mod_small_mul_u8(x: u8, k: nat, s: nat, t: nat)\n    requires\n        k <= s,\n        8 <= t + s - k,\n    ensures\n        ((x as nat * pow2(k)) / pow2(s)) % pow2(t) == x as nat / pow2((s - k) as nat),\n{\n    assert(x < pow2(8)) by {\n        lemma2_to64();  // pow2(8)\n    }\n    lemma_pow2_mul_div_mod_small_mul(x as nat, 8, k, s, t);\n}",
      "start_line": 533,
      "end_line": 49,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#PartialEq#eq().",
      "display_name": "eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#PartialEq#eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn eq(&self, other: &RistrettoPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
      "start_line": 822,
      "end_line": 10,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_lt_pow2_8().",
      "display_name": "lemma_u8_lt_pow2_8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_lt_pow2_8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_u8_lt_pow2_8(a: u8)\n    ensures\n        a < pow2(8),\n{\n    assert(u8::MAX < pow2(8)) by {\n        lemma2_to64();\n    }\n}",
      "start_line": 15,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_subtracts().",
      "display_name": "lemma_pow2_subtracts",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_subtracts().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_all_carries_bounded_by_3().",
      "display_name": "lemma_all_carries_bounded_by_3",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_all_carries_bounded_by_3().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_all_carries_bounded_by_3(limbs: [u64; 5])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 52),\n    ensures\n        ({\n            let q0 = ((limbs[0] + 19) as u64 >> 51) as u64;\n            let q1 = ((limbs[1] + q0) as u64 >> 51) as u64;\n            let q2 = ((limbs[2] + q1) as u64 >> 51) as u64;\n            let q3 = ((limbs[3] + q2) as u64 >> 51) as u64;\n            let q4 = ((limbs[4] + q3) as u64 >> 51) as u64;\n            q0 < 3 && q1 < 3 && q2 < 3 && q3 < 3 && q4 < 3\n        }),",
      "start_line": 428,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_niels_point_as_affine_edwards().",
      "display_name": "projective_niels_point_as_affine_edwards",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_niels_point_as_affine_edwards().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn projective_niels_point_as_affine_edwards(niels: ProjectiveNielsPoint) -> (\n    nat,\n    nat,\n) {\n    let y_plus_x = spec_field_element(&niels.Y_plus_X);\n    let y_minus_x = spec_field_element(&niels.Y_minus_X);\n    let z = spec_field_element(&niels.Z);\n\n    // Recover projective X and Y from Y+X and Y-X\n    let x_proj = math_field_mul(math_field_sub(y_plus_x, y_minus_x), math_field_inv(2));\n    let y_proj = math_field_mul(math_field_add(y_plus_x, y_minus_x), math_field_inv(2));\n\n    // Convert to affine by dividing by Z\n    let z_inv = math_field_inv(z);\n    let x = math_field_mul(x_proj, z_inv);\n    let y = math_field_mul(y_proj, z_inv);\n\n    (x, y)\n}",
      "start_line": 452,
      "end_line": 58,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#cmp().",
      "display_name": "cmp",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#cmp().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
      "file_name": "pippenger.rs",
      "parent_folder": "scalar_mul",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_lemmas/lemmas/add().",
      "display_name": "add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_lemmas/lemmas/add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/sum_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/sum_lemmas.rs",
      "file_name": "sum_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub open spec fn add(a: nat, b: nat) -> nat {\n    a + b\n}",
      "start_line": 14,
      "end_line": 21,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "display_name": "lemma_limb3_contribution_correctness_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub proof fn lemma_limb3_contribution_correctness_52(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[2] < (1u64 << 52),  // Need limb 2 for boundary byte 19\n        limbs[3] < (1u64 << 52),\n        bytes_match_limbs_packing_52(limbs, bytes),\n    ensures\n        limb3_byte_contribution_52(limbs, bytes) == (limbs[3] as nat) * pow2(156),\n{\n    // Proof following docs_22_oct/lemma_limb3_contribution_52_proof.md\n    lemma2_to64();\n    lemma_shift_is_pow2(52);\n\n    // === STEP 1: Define the Split ===\n    let l3_low = limbs[3] as nat % pow2(4);  // Low 4 bits in byte 19\n    let l3_high = limbs[3] as nat / pow2(4);  // High 48 bits in bytes 20-25\n\n    // === STEP 2: Bound the High Part ===\n    lemma_div_bound(limbs[3] as nat, 4, 52);\n    assert(l3_high < pow2(48));\n\n    // === STEP 3: Reconstruction Identity ===\n    lemma_pow2_pos(4);\n    lemma_fundamental_div_mod(limbs[3] as int, pow2(4) as int);\n    assert(pow2(4) * l3_high == l3_high * pow2(4)) by {\n        lemma_mul_is_commutative(pow2(4) as int, l3_high as int);\n    }\n    assert(limbs[3] as nat == l3_low + l3_high * pow2(4));\n\n    // === STEP 4: Byte Reconstruction for High 48 Bits ===\n    lemma_byte_from_limb_shift_52(limbs[3], 4, bytes[20]);\n    lemma_byte_from_limb_shift_52(limbs[3], 12, bytes[21]);\n    lemma_byte_from_limb_shift_52(limbs[3], 20, bytes[22]);\n    lemma_byte_from_limb_shift_52(limbs[3], 28, bytes[23]);\n    lemma_byte_from_limb_shift_52(limbs[3], 36, bytes[24]);\n    lemma_byte_from_limb_shift_52(limbs[3], 44, bytes[25]);\n\n    // Rewrite byte extractions in terms of l3_high = limbs[3] / 2^4\n    lemma_pow2_adds(4, 0);\n    lemma_pow2_pos(0);\n    lemma_div_denominator(limbs[3] as int, pow2(4) as int, pow2(0) as int);\n    assert(bytes[20] as nat == l3_high / pow2(0) % 256);\n\n    lemma_pow2_adds(4, 8);\n    lemma_pow2_pos(8);\n    lemma_div_denominator(limbs[3] as int, pow2(4) as int, pow2(8) as int);\n    assert(bytes[21] as nat == l3_high / pow2(8) % 256);\n\n    lemma_pow2_adds(4, 16);\n    lemma_pow2_pos(16);\n    lemma_div_denominator(limbs[3] as int, pow2(4) as int, pow2(16) as int);\n    assert(bytes[22] as nat == l3_high / pow2(16) % 256);\n\n    lemma_pow2_adds(4, 24);\n    lemma_pow2_pos(24);\n    lemma_div_denominator(limbs[3] as int, pow2(4) as int, pow2(24) as int);\n    assert(bytes[23] as nat == l3_high / pow2(24) % 256);\n\n    lemma_pow2_adds(4, 32);\n    lemma_pow2_pos(32);\n    lemma_div_denominator(limbs[3] as int, pow2(4) as int, pow2(32) as int);\n    assert(bytes[24] as nat == l3_high / pow2(32) % 256);\n\n    lemma_pow2_adds(4, 40);\n    lemma_pow2_pos(40);\n    lemma_div_denominator(limbs[3] as int, pow2(4) as int, pow2(40) as int);\n    assert(bytes[25] as nat == l3_high / pow2(40) % 256);\n\n    // 6-byte reconstruction lemma\n    lemma_6_bytes_reconstruct(\n        l3_high,\n        bytes[20],\n        bytes[21],\n        bytes[22],\n        bytes[23],\n        bytes[24],\n        bytes[25],\n    );\n\n    let bytes_at_offset_0 = bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8)\n        + bytes[22] as nat * pow2(16) + bytes[23] as nat * pow2(24) + bytes[24] as nat * pow2(32)\n        + bytes[25] as nat * pow2(40);\n\n    assert(bytes_at_offset_0 == l3_high);\n\n    // === STEP 5: Position Adjustment ===\n    //assert(19 * 8 == 152);\n\n    // Multiply reconstruction identity by pow2(156)\n    assert((l3_low + l3_high * pow2(4)) * pow2(156) == limbs[3] as nat * pow2(156));\n\n    // Distribute\n    assert((l3_low + l3_high * pow2(4)) * pow2(156) == l3_low * pow2(156) + (l3_high * pow2(4))\n        * pow2(156)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(156) as int,\n            l3_low as int,\n            (l3_high * pow2(4)) as int,\n        );\n    }\n\n    // Simplify high term\n    lemma_pow2_adds(4, 156);\n    assert((l3_high * pow2(4)) * pow2(156) == l3_high * pow2(160)) by {\n        lemma_mul_is_associative(l3_high as int, pow2(4) as int, pow2(156) as int);\n    }\n\n    // Now we have: limbs[3] * 2^156 = l3_low * 2^156 + l3_high * 2^160\n\n    // === STEP 6: Express Low Part in Contribution Form ===\n    // l3_low * 2^156 = l3_low * 2^152 * 2^4 = (l3_low * 16) * 2^152\n    lemma_pow2_adds(152, 4);\n    assert(pow2(156) == pow2(152) * pow2(4));\n    assert(pow2(4) == 16) by {\n        assert(pow2(2) == 4);\n        assert(pow2(4) == pow2(2) * pow2(2)) by {\n            lemma_pow2_adds(2, 2);\n        }\n    }\n\n    assert(l3_low * pow2(156) == l3_low * (pow2(152) * pow2(4))) by {\n        // pow2(156) = pow2(152) * pow2(4) proven above\n    }\n    assert(l3_low * (pow2(152) * pow2(4)) == (l3_low * pow2(152)) * pow2(4)) by {\n        lemma_mul_is_associative(l3_low as int, pow2(152) as int, pow2(4) as int);\n    }\n    assert((l3_low * pow2(152)) * pow2(4) == pow2(152) * l3_low * pow2(4)) by {\n        lemma_mul_is_commutative((l3_low * pow2(152)) as int, pow2(4) as int);\n    }\n    assert(pow2(152) * l3_low * pow2(4) == pow2(152) * (l3_low * pow2(4))) by {\n        lemma_mul_is_associative(pow2(152) as int, l3_low as int, pow2(4) as int);\n    }\n    assert(l3_low * pow2(156) == (l3_low * 16) * pow2(152));\n\n    // === STEP 7: Expand the High Part ===\n    // Multiply bytes_at_offset_0 by pow2(160)\n    assert(bytes_at_offset_0 * pow2(160) == l3_high * pow2(160));\n\n    // Distribute pow2(160) into each byte term\n    assert(bytes_at_offset_0 * pow2(160) == bytes[20] as nat * pow2(0) * pow2(160)\n        + bytes[21] as nat * pow2(8) * pow2(160) + bytes[22] as nat * pow2(16) * pow2(160)\n        + bytes[23] as nat * pow2(24) * pow2(160) + bytes[24] as nat * pow2(32) * pow2(160)\n        + bytes[25] as nat * pow2(40) * pow2(160)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(160) as int,\n            (bytes[20] as nat * pow2(0)) as int,\n            (bytes[21] as nat * pow2(8)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(160) as int,\n            (bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8)) as int,\n            (bytes[22] as nat * pow2(16)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(160) as int,\n            (bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8) + bytes[22] as nat * pow2(\n                16,\n            )) as int,\n            (bytes[23] as nat * pow2(24)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(160) as int,\n            (bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8) + bytes[22] as nat * pow2(16)\n                + bytes[23] as nat * pow2(24)) as int,\n            (bytes[24] as nat * pow2(32)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(160) as int,\n            (bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8) + bytes[22] as nat * pow2(16)\n                + bytes[23] as nat * pow2(24) + bytes[24] as nat * pow2(32)) as int,\n            (bytes[25] as nat * pow2(40)) as int,\n        );\n\n        // Apply associativity: (byte * pow2(k)) * pow2(160) = byte * (pow2(k) * pow2(160))\n        lemma_mul_is_associative(bytes[20] as int, pow2(0) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[21] as int, pow2(8) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[22] as int, pow2(16) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[23] as int, pow2(24) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[24] as int, pow2(32) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[25] as int, pow2(40) as int, pow2(160) as int);\n    }\n\n    // Apply power addition and connect to final positions\n    assert(bytes_at_offset_0 * pow2(160) == bytes[20] as nat * pow2(160) + bytes[21] as nat * pow2(\n        168,\n    ) + bytes[22] as nat * pow2(176) + bytes[23] as nat * pow2(184) + bytes[24] as nat * pow2(192)\n        + bytes[25] as nat * pow2(200)) by {\n        lemma_mul_is_associative(bytes[20] as int, pow2(0) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[21] as int, pow2(8) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[22] as int, pow2(16) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[23] as int, pow2(24) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[24] as int, pow2(32) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[25] as int, pow2(40) as int, pow2(160) as int);\n        lemma_pow2_adds(0, 160);\n        lemma_pow2_adds(8, 160);\n        lemma_pow2_adds(16, 160);\n        lemma_pow2_adds(24, 160);\n        lemma_pow2_adds(32, 160);\n        lemma_pow2_adds(40, 160);\n    }\n}",
      "start_line": 1021,
      "end_line": 53,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_constants/lizard/test_lizard_constants().",
      "display_name": "test_lizard_constants",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_constants/lizard/test_lizard_constants().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_constants.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_constants.rs",
      "file_name": "lizard_constants.rs",
      "parent_folder": "lizard",
      "body": "    fn test_lizard_constants() {\n        let (_, sqrt_id) = FieldElement::sqrt_ratio_i(\n            &(&constants::SQRT_M1 * &constants::EDWARDS_D),\n            &FieldElement::ONE,\n        );\n        assert_eq!(sqrt_id, SQRT_ID);\n\n        assert_eq!(\n            &(&constants::EDWARDS_D + &FieldElement::ONE)\n                * &(&constants::EDWARDS_D - &FieldElement::ONE).invert(),\n            DP1_OVER_DM1\n        );\n\n        assert_eq!(\n            MDOUBLE_INVSQRT_A_MINUS_D,\n            -&(&constants::INVSQRT_A_MINUS_D + &constants::INVSQRT_A_MINUS_D)\n        );\n\n        assert_eq!(\n            MIDOUBLE_INVSQRT_A_MINUS_D,\n            &MDOUBLE_INVSQRT_A_MINUS_D * &constants::SQRT_M1\n        );\n\n        let (_, invsqrt_one_plus_d) = (&constants::EDWARDS_D + &FieldElement::ONE).invsqrt();\n        assert_eq!(-&invsqrt_one_plus_d, MINVSQRT_ONE_PLUS_D);\n    }",
      "start_line": 22,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#ConstantTimeEq#ct_eq().",
      "display_name": "ct_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#ConstantTimeEq#ct_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn ct_eq(&self, other: &MontgomeryPoint) -> (result: Choice)\n        ensures\n    // Two MontgomeryPoints are equal if their u-coordinates are equal mod p\n\n            choice_is_true(result) == (spec_field_element_from_bytes(&self.0)\n                == spec_field_element_from_bytes(&other.0)),\n    {\n        let self_fe = FieldElement::from_bytes(&self.0);\n        let other_fe = FieldElement::from_bytes(&other.0);\n\n        let result = self_fe.ct_eq(&other_fe);\n\n        proof {\n            // The postcondition follows from FieldElement::ct_eq's specification\n            assume(choice_is_true(result) == (spec_field_element_from_bytes(&self.0)\n                == spec_field_element_from_bytes(&other.0)));\n        }\n\n        result\n    }",
      "start_line": 108,
      "end_line": 13,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/Sub#sub().",
      "display_name": "sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/Sub#sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn sub(self, other: &'b RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 - other.0)\n    }",
      "start_line": 875,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_from_le_bytes().",
      "display_name": "u16_from_le_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_from_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub fn u16_from_le_bytes(bytes: [u8; 2]) -> (x: u16)\n    ensures\n        x as nat == bytes_seq_to_nat(seq_from2(&bytes)),\n{\n    u16::from_le_bytes(bytes)\n}",
      "start_line": 119,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_sum_bounds().",
      "display_name": "lemma_pow2_sum_bounds",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_sum_bounds().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_sum_bounds(coefs: &[u8], offset: nat, step: nat, k: nat)\n    requires\n        offset + k <= coefs.len(),\n        forall|i: nat| 0 <= i <= k ==> #[trigger] coefs[(offset + i) as int] < pow2(step),\n    ensures\n        pow2_sum(coefs, offset, step, k) < pow2((k + 1) * step),\n    decreases k,\n{\n    if (k == 0) {\n        assert(pow2(0) == 1) by {\n            lemma2_to64();\n        }\n        assert(coefs[offset as int] * pow2(0) == coefs[offset as int]) by {\n            lemma_mul_basics_3(coefs[offset as int] as int);\n        }\n    } else {\n        assert(pow2_sum(coefs, offset, step, k) == pow2_sum(coefs, offset, step, (k - 1) as nat)\n            + coefs[(offset + k) as int] * pow2(k * step)) by {\n            reveal_with_fuel(pow2_sum, 1);\n        }\n\n        assert(pow2_sum(coefs, offset, step, (k - 1) as nat) < pow2(k * step)) by {\n            lemma_pow2_sum_bounds(coefs, offset, step, (k - 1) as nat);\n        }\n\n        assert(coefs[(offset + k) as int] * pow2(k * step) <= pow2((k + 1) * step) - pow2(k * step))\n            by {\n            assert((k + 1) * step == k * step + step) by {\n                lemma_mul_is_distributive_add_other_way(step as int, k as int, 1);\n            }\n            assert(coefs[(offset + k) as int] * pow2(k * step) <= pow2(k * step + step) - pow2(\n                k * step,\n            )) by {\n                lemma_pow2_mul_bound_general(coefs[(offset + k) as int] as nat, step, k * step);\n            }\n        }\n    }\n}",
      "start_line": 728,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_add().",
      "display_name": "edwards_add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn edwards_add(x1: nat, y1: nat, x2: nat, y2: nat) -> (nat, nat) {\n    let d = spec_field_element(&EDWARDS_D);\n    let x1x2 = math_field_mul(x1, x2);\n    let y1y2 = math_field_mul(y1, y2);\n    let x1y2 = math_field_mul(x1, y2);\n    let y1x2 = math_field_mul(y1, x2);\n    let t = math_field_mul(d, math_field_mul(x1x2, y1y2));\n    let denom_x = math_field_add(1, t);\n    let denom_y = math_field_sub(1, t);\n    let x3 = math_field_mul(math_field_add(x1y2, y1x2), math_field_inv(denom_x));\n    let y3 = math_field_mul(math_field_add(y1y2, x1x2), math_field_inv(denom_y));\n    (x3, y3)\n}",
      "start_line": 602,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_m().",
      "display_name": "lemma_m",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_m().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_m(x: u64, y: u64, bx: u64, by: u64)\n    requires\n        x < bx,\n        y < by,\n    ensures\n        (x as u128) * (y as u128) < (bx as u128) * (by as u128),\n{\n    lemma_mul_lt(x as nat, bx as nat, y as nat, by as nat);\n}",
      "start_line": 43,
      "end_line": 21,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#AddAssign#add_assign().",
      "display_name": "add_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#AddAssign#add_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn add_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) + _rhs;\n    }",
      "start_line": 865,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mult_maps_to_nonzero().",
      "display_name": "lemma_mult_maps_to_nonzero",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mult_maps_to_nonzero().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_mult_maps_to_nonzero(a: nat, i: nat, p: nat)\n    requires\n        is_prime(p),\n        a % p != 0,\n        1 <= i < p,\n    ensures\n        1 <= (a * i) % p < p,\n{\n    // (a * i) % p is in [0, p) by definition\n    lemma_mod_bound((a * i) as int, p as int);\n\n    // (a * i) % p != 0 because a % p != 0 and i % p != 0\n    assert(i % p != 0) by {\n        lemma_small_mod(i, p);\n    };\n    lemma_product_nonzero_mod_prime(a, i, p);\n}",
      "start_line": 1332,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/m().",
      "display_name": "m",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/m().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "fn m(x: u64, y: u64) -> (z: u128)\n    requires\n        x < (1u64 << 52),\n        y < (1u64 << 52),\n    ensures\n        z < (1u128 << 104),\n        z == x * y,\n{\n    proof {\n        lemma_52_52(x, y);\n    }\n    (x as u128) * (y as u128)\n}",
      "start_line": 112,
      "end_line": 5,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_6_terms().",
      "display_name": "lemma_mul_distributive_6_terms",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_6_terms().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_mul_distributive_6_terms(\n    n: int,\n    x1: int,\n    x2: int,\n    x3: int,\n    x4: int,\n    x5: int,\n    x6: int,\n)\n    ensures\n        n * (x1 + x2 + x3 + x4 + x5 + x6) == (x1 + x2 + x3 + x4 + x5 + x6) * n == n * x1 + n * x2\n            + n * x3 + n * x4 + n * x5 + n * x6,\n{\n    assert(n * (x1 + x2 + x3 + x4 + x5 + x6) == (x1 + x2 + x3 + x4 + x5 + x6) * n) by {\n        lemma_mul_is_commutative(n, x1 + x2 + x3 + x4 + x5 + x6);\n    }\n\n    assert(n * (x1 + x2 + x3 + x4 + x5 + x6) == n * (x1 + x2 + x3 + x4 + x5) + n * x6) by {\n        lemma_mul_is_distributive_add(n, x1 + x2 + x3 + x4 + x5, x6);\n    }\n\n    assert(n * (x1 + x2 + x3 + x4 + x5) == n * x1 + n * x2 + n * x3 + n * x4 + n * x5) by {\n        lemma_mul_distributive_5_terms(n, x1, x2, x3, x4, x5);\n    }\n}",
      "start_line": 105,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_by_zero_is_zero().",
      "display_name": "lemma_mul_by_zero_is_zero",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_by_zero_is_zero().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_uniform_bytes().",
      "display_name": "from_uniform_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_uniform_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn from_uniform_bytes(bytes: &[u8; 64]) -> RistrettoPoint {\n        // This follows the one-way map construction from the Ristretto RFC:\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#section-4.3.4\n        let mut r_1_bytes = [0u8; 32];\n        r_1_bytes.copy_from_slice(&bytes[0..32]);\n        let r_1 = FieldElement::from_bytes(&r_1_bytes);\n        let R_1 = RistrettoPoint::elligator_ristretto_flavor(&r_1);\n\n        let mut r_2_bytes = [0u8; 32];\n        r_2_bytes.copy_from_slice(&bytes[32..64]);\n        let r_2 = FieldElement::from_bytes(&r_2_bytes);\n        let R_2 = RistrettoPoint::elligator_ristretto_flavor(&r_2);\n\n        // Applying Elligator twice and adding the results ensures a\n        // uniform distribution.\n        R_1 + R_2\n    }",
      "start_line": 786,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "display_name": "as_extended",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    pub fn as_extended(&self) -> (result: EdwardsPoint)\n        requires\n            is_valid_completed_point(*self),\n            // preconditions for mul\n            fe51_limbs_bounded(&self.X, 54),\n            fe51_limbs_bounded(&self.Y, 54),\n            fe51_limbs_bounded(&self.Z, 54),\n            fe51_limbs_bounded(&self.T, 54),\n        ensures\n            is_valid_edwards_point(result),\n            is_well_formed_edwards_point(result),\n            spec_edwards_point(result) == spec_completed_to_extended(*self),\n            edwards_point_as_affine(result) == completed_point_as_affine_edwards(*self),\n    {\n        let result = EdwardsPoint {\n            X: &self.X * &self.T,\n            Y: &self.Y * &self.Z,\n            Z: &self.Z * &self.T,\n            T: &self.X * &self.Y,\n        };\n        proof {\n            // postconditions\n            assume(is_valid_edwards_point(result));\n            // mul ensures limbs bounded by 54, and sum bounded follows from field properties\n            assume(is_well_formed_edwards_point(result));\n            assume(spec_edwards_point(result) == spec_completed_to_extended(*self));\n            assume(edwards_point_as_affine(result) == completed_point_as_affine_edwards(*self));\n        }\n        result\n    }",
      "start_line": 487,
      "end_line": 23,
      "is_libsignal": false,
      "caller_count": 9,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/edwards_lemmas/lemmas/lemma_edwards_d_limbs_bounded().",
      "display_name": "lemma_edwards_d_limbs_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/edwards_lemmas/lemmas/lemma_edwards_d_limbs_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/constants_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/constants_lemmas.rs",
      "file_name": "constants_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub(crate) proof fn lemma_edwards_d_limbs_bounded()\n    ensures fe51_limbs_bounded(&EDWARDS_D, 51),\n{\n    // Goal: All EDWARDS_D limbs < 2^51\n    assert(fe51_limbs_bounded(&EDWARDS_D, 51)) by {\n        assert(929955233495203u64 < (1u64 << 51)) by (bit_vector);\n        assert(466365720129213u64 < (1u64 << 51)) by (bit_vector);\n        assert(1662059464998953u64 < (1u64 << 51)) by (bit_vector);\n        assert(2033849074728123u64 < (1u64 << 51)) by (bit_vector);\n        assert(1442794654840575u64 < (1u64 << 51)) by (bit_vector);\n    };\n}",
      "start_line": 45,
      "end_line": 50,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        writeln!(f, \"NafLookupTable8([\")?;\n        for i in 0..64 {\n            writeln!(f, \"\\t{:?},\", &self.0[i])?;\n        }\n        write!(f, \"])\")\n    }",
      "start_line": 593,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat().",
      "display_name": "lemma_from_bytes_as_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_from_bytes_as_nat(bytes: &[u8; 32])\n    ensures\n        u64_5_as_nat(\n            [\n                spec_load8_at(bytes, 0) as u64 & mask51,\n                (spec_load8_at(bytes, 6) as u64 >> 3) & mask51,\n                (spec_load8_at(bytes, 12) as u64 >> 6) & mask51,\n                (spec_load8_at(bytes, 19) as u64 >> 1) & mask51,\n                (spec_load8_at(bytes, 24) as u64 >> 12) & mask51,\n            ],\n        ) == (bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (bytes[2] * pow2(2 * 8)) + (\n        bytes[3] * pow2(3 * 8)) + (bytes[4] * pow2(4 * 8)) + (bytes[5] * pow2(5 * 8)) + (bytes[6]\n            * pow2(6 * 8)) + (bytes[7] * pow2(7 * 8)) + (bytes[8] * pow2(8 * 8)) + (bytes[9] * pow2(\n            9 * 8,\n        )) + (bytes[10] * pow2(10 * 8)) + (bytes[11] * pow2(11 * 8)) + (bytes[12] * pow2(12 * 8))\n            + (bytes[13] * pow2(13 * 8)) + (bytes[14] * pow2(14 * 8)) + (bytes[15] * pow2(15 * 8))\n            + (bytes[16] * pow2(16 * 8)) + (bytes[17] * pow2(17 * 8)) + (bytes[18] * pow2(18 * 8))\n            + (bytes[19] * pow2(19 * 8)) + (bytes[20] * pow2(20 * 8)) + (bytes[21] * pow2(21 * 8))\n            + (bytes[22] * pow2(22 * 8)) + (bytes[23] * pow2(23 * 8)) + (bytes[24] * pow2(24 * 8))\n            + (bytes[25] * pow2(25 * 8)) + (bytes[26] * pow2(26 * 8)) + (bytes[27] * pow2(27 * 8))\n            + (bytes[28] * pow2(28 * 8)) + (bytes[29] * pow2(29 * 8)) + (bytes[30] * pow2(30 * 8))\n            + ((bytes[31] as nat % pow2(7)) * pow2((31 * 8) as nat)),\n{\n    lemma_from_bytes_as_nat_01234(bytes);\n}",
      "start_line": 397,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb4_byte_contribution_52().",
      "display_name": "limb4_byte_contribution_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb4_byte_contribution_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub open spec fn limb4_byte_contribution_52(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    bytes[26] as nat * pow2(26 * 8) +\n    bytes[27] as nat * pow2(27 * 8) +\n    bytes[28] as nat * pow2(28 * 8) +\n    bytes[29] as nat * pow2(29 * 8) +\n    bytes[30] as nat * pow2(30 * 8) +\n    bytes[31] as nat * pow2(31 * 8)\n}",
      "start_line": 127,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Neg#neg().",
      "display_name": "neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Neg#neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn neg(self) -> RistrettoPoint {\n        -&self\n    }",
      "start_line": 917,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_point().",
      "display_name": "spec_edwards_point",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_point().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_edwards_point(point: crate::edwards::EdwardsPoint) -> (nat, nat, nat, nat) {\n    let x = spec_field_element(&point.X);\n    let y = spec_field_element(&point.Y);\n    let z = spec_field_element(&point.Z);\n    let t = spec_field_element(&point.T);\n    (x, y, z, t)\n}",
      "start_line": 262,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/axiom_p_is_prime().",
      "display_name": "axiom_p_is_prime",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/axiom_p_is_prime().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/primality_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/primality_specs.rs",
      "file_name": "primality_specs.rs",
      "parent_folder": "specs",
      "body": "pub proof fn axiom_p_is_prime()\n    ensures\n        is_prime(p()),\n{\n    admit();  // Mathematical fact: 2^255 - 19 is prime\n}",
      "start_line": 24,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar{{\\n\\tbytes: {:?},\\n}}\", &self.bytes)\n    }",
      "start_line": 465,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "display_name": "group_order",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn group_order() -> nat {\n    pow2(252) + 27742317777372353535851937790883648493nat\n}",
      "start_line": 192,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 58,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_inequality().",
      "display_name": "lemma_mul_inequality",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_inequality().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 12,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_affine_coords().",
      "display_name": "is_valid_lookup_table_affine_coords",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_affine_coords().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "pub open spec fn is_valid_lookup_table_affine_coords<const N: usize>(\n    table: [AffineNielsPoint; N],\n    basepoint: (nat, nat),\n    size: nat,\n) -> bool {\n    &&& table.len() == size\n    &&& forall|j: int|\n        #![trigger table[j]]\n        0 <= j < size ==> affine_niels_point_as_affine_edwards(table[j]) == edwards_scalar_mul(\n            basepoint,\n            (j + 1) as nat,\n        )\n}",
      "start_line": 72,
      "end_line": 53,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_two_factoring().",
      "display_name": "lemma_two_factoring",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_two_factoring().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_two_factoring(a: nat, b: nat, v: u64)\n    ensures\n        pow2(a + b) * v == pow2(a) * (pow2(b) * v),\n{\n    lemma_pow2_adds(a, b);\n    lemma_mul_is_associative(pow2(a) as int, pow2(b) as int, v as int);\n}",
      "start_line": 69,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_to_extended().",
      "display_name": "spec_projective_to_extended",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_to_extended().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_projective_to_extended(point: ProjectivePoint) -> (nat, nat, nat, nat) {\n    let (x, y, z) = spec_projective_point_edwards(point);\n    (math_field_mul(x, z), math_field_mul(y, z), math_field_square(z), math_field_mul(x, y))\n}",
      "start_line": 713,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec_aux().",
      "display_name": "lemma_load8_at_plus_version_is_spec_aux",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec_aux().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_load8_at_plus_version_is_spec_aux(input: &[u8], i: usize, j: nat)\n    requires\n        1 <= j <= 7,\n    ensures\n        (input[i + j] as u64) << 8 * j == pow2(j * 8) * input[i + j],\n        input[i + j] * pow2(j * 8) <= u64::MAX,\n        pow2(8 * (j + 1)) - 1 <= pow2(64) - 1,\n        pow2(8) * pow2(8 * j) == pow2(8 * (j + 1)),\n{\n    assert(pow2(64) - 1 == u64::MAX) by {\n        lemma2_to64_rest();\n    }\n\n    assert(u8::MAX + 1 == pow2(8)) by {\n        lemma2_to64();\n    }\n\n    assert(pow2(8 * (j + 1)) - 1 <= pow2(64) - 1) by {\n        if (j < 7) {\n            lemma_pow2_strictly_increases(8 * (j + 1), 64);\n        }\n    }\n\n    lemma_pow2_adds(8, j * 8);\n\n    lemma_mul_inequality(input[i + j] as int, u8::MAX as int, pow2(j * 8) as int);\n\n    assert((input[i + j] as u64) * pow2(j * 8) <= u64::MAX) by {\n        assert(u8::MAX * pow2(j * 8) <= pow2(64) - 1) by {\n            assert(u8::MAX * pow2(j * 8) == (pow2(8) - 1) * pow2(j * 8) == pow2(8 * (j + 1)) - pow2(\n                j * 8,\n            )) by {\n                assert(pow2(8) >= 1) by {\n                    lemma2_to64();\n                }\n                lemma_mul_is_distributive_sub(pow2(8) as int, 1, pow2(j * 8) as int);\n            }\n            assert(pow2(j * 8) > 1) by {\n                lemma2_to64();  // pow2(0)\n                lemma_pow2_strictly_increases(0, j * 8)\n            }\n        }\n    }\n    lemma_u64_shl_is_mul((input[i + j] as u64), (j * 8) as u64);\n}",
      "start_line": 130,
      "end_line": 49,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_extract_byte_at_index().",
      "display_name": "lemma_extract_byte_at_index",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_extract_byte_at_index().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "file_name": "u8_32_as_nat_injectivity_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_extract_byte_at_index(bytes: &[u8; 32], i: nat)\n    requires\n        i < 32,\n    ensures\n        bytes[i as int] as nat == (u8_32_as_nat(bytes) / pow2(i * 8)) % pow2(8),\n{\n    lemma2_to64();\n\n    // Step 1: Apply lemma_pow2_div_mod to transform the expression\n    assert((u8_32_as_nat(bytes) / pow2(i * 8)) % pow2(8) == (u8_32_as_nat(bytes) % pow2(8 + i * 8))\n        / pow2(i * 8)) by {\n        lemma_pow2_div_mod(u8_32_as_nat(bytes), i * 8, 8);\n    }\n\n    // Step 2: Simplify 8 + i*8 = (i+1)*8\n    assert(8 + i * 8 == (i + 1) * 8) by {\n        lemma_mul_is_distributive_add(8, 1, i as int);\n    }\n\n    // Step 3: Apply modulo truncation lemma\n    assert(u8_32_as_nat(bytes) % pow2((i + 1) * 8) == as_nat_prefix(bytes, i + 1)) by {\n        lemma_u8_32_as_nat_mod_truncates(bytes, i + 1);\n    }\n\n    // Step 4: Apply division extraction lemma\n    assert((as_nat_prefix(bytes, i + 1) / pow2(i * 8)) % pow2(8) == bytes[i as int] as nat) by {\n        lemma_as_nat_prefix_div_extracts_byte(bytes, i);\n    }\n\n    // Step 5: Combine all steps\n    assert(bytes[i as int] as nat == (u8_32_as_nat(bytes) / pow2(i * 8)) % pow2(8));\n}",
      "start_line": 302,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_self_0().",
      "display_name": "lemma_mod_self_0",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_self_0().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "file_name": "field_algebra_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 10,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_cancels_negatives().",
      "display_name": "lemma_mul_cancels_negatives",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_cancels_negatives().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_multiply_step().",
      "display_name": "lemma_square_multiply_step",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_multiply_step().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_square_multiply_step(new_y: nat, y_before: nat, y0: nat, R: nat, L: nat, k: nat)\n    requires\n        L > 0,\n        R > 0,\n        (new_y * R) % L == (y_before * y_before) % L,\n        (y_before * pow(R as int, (pow2(k) - 1) as nat) as nat) % L == (pow(\n            y0 as int,\n            pow2(k),\n        ) as nat) % L,\n    ensures\n        (new_y * pow(R as int, (pow2(k + 1) - 1) as nat) as nat) % L == (pow(\n            y0 as int,\n            pow2(k + 1),\n        ) as nat) % L,\n{\n    use vstd::arithmetic::power2::{lemma_pow2_unfold, lemma_pow2_pos};\n    use vstd::arithmetic::mul::lemma_mul_is_associative;\n    use crate::lemmas::common_lemmas::pow_lemmas::{lemma_pow_nonnegative, lemma_pow2_square};\n\n    lemma_pow2_unfold(k + 1);\n    lemma_pow2_pos(k);\n\n    let exp_k = (pow2(k) - 1) as nat;\n    let exp_k1 = (pow2(k + 1) - 1) as nat;\n    let R_exp_k: int = pow(R as int, exp_k);\n    let R_exp_k_sq: nat = (R_exp_k * R_exp_k) as nat;\n    let y_R: nat = y_before * (R_exp_k as nat);\n    let y0_k: nat = pow(y0 as int, pow2(k)) as nat;\n\n    assert(exp_k1 == 2 * exp_k + 1) by (nonlinear_arith)\n        requires\n            pow2(k) >= 1,\n            pow2(k + 1) == 2 * pow2(k),\n            exp_k == (pow2(k) - 1) as nat,\n            exp_k1 == (pow2(k + 1) - 1) as nat,\n    ;\n    lemma_pow_positive(R as int, exp_k);\n    lemma_pow_positive(R_exp_k, 2);\n\n    assert(R_exp_k_sq == pow(R_exp_k, 2) as nat) by {\n        lemma_pow1(R_exp_k);\n        lemma_pow_adds(R_exp_k, 1, 1);\n    }\n    assert(y_R * y_R == (y_before * y_before) * R_exp_k_sq) by (nonlinear_arith)\n        requires\n            y_R == y_before * (R_exp_k as nat),\n            R_exp_k_sq == (R_exp_k * R_exp_k) as nat,\n            R_exp_k > 0,\n    ;\n    assert((new_y * R) * R_exp_k_sq == new_y * pow(R as int, exp_k1) as nat) by {\n        lemma_pow_adds(R as int, 1nat, 2 * exp_k);\n        lemma_pow1(R as int);\n        lemma_pow_multiplies(R as int, exp_k, 2nat);\n        lemma_mul_is_associative(new_y as int, R as int, R_exp_k_sq as int);\n    }\n    lemma_pow_multiplies(y0 as int, pow2(k), 2);\n    lemma_pow2_square(y0 as int, k);\n    lemma_pow_nonnegative(y0 as int, pow2(k));\n\n    calc! {\n        (==)\n        (new_y * pow(R as int, exp_k1) as nat) % L; {}\n        ((new_y * R) * R_exp_k_sq) % L; {\n            lemma_mul_mod_noop((new_y * R) as int, R_exp_k_sq as int, L as int);\n            lemma_mul_mod_noop((y_before * y_before) as int, R_exp_k_sq as int, L as int);\n        }\n        ((y_before * y_before) * R_exp_k_sq) % L; {}\n        (y_R * y_R) % L; {\n            lemma_mul_mod_noop(y_R as int, y_R as int, L as int);\n            lemma_mul_mod_noop(y0_k as int, y0_k as int, L as int);\n        }\n        (y0_k * y0_k) % L; {}\n        (pow(y0 as int, pow2(k + 1)) as nat) % L;\n    }\n}",
      "start_line": 1939,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_bound().",
      "display_name": "lemma_group_order_bound",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_bound().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_group_order_bound()\n    ensures\n        group_order() < pow2(255),\n{\n    // group_order = 2^252 + 27742317777372353535851937790883648493\n    lemma_l_equals_group_order();\n    lemma_pow252();\n\n    // First compare the constant to the concrete numeral for 2^126\n    assert(27742317777372353535851937790883648493nat < 0x40000000000000000000000000000000)\n        by (compute_only);\n\n    // Establish pow2(126) == 0x4000...0000 so we can rewrite the bound\n    assert(pow2(63) == 0x8000000000000000) by {\n        lemma2_to64_rest();\n    };\n    lemma_pow2_adds(63, 63);\n    assert(pow2(126) == 0x40000000000000000000000000000000);\n\n    // Hence the constant < 2^126 < 2^252\n    assert(27742317777372353535851937790883648493nat < pow2(126));\n    lemma_pow2_strictly_increases(126, 252);\n    assert(27742317777372353535851937790883648493nat < pow2(252));\n\n    // Therefore group_order < 2^252 + 2^252 = 2^253\n    assert(group_order() == pow2(252) + 27742317777372353535851937790883648493nat);\n    assert(group_order() < pow2(252) + pow2(252));\n\n    // 2^252 + 2^252 = 2^253\n    assert(pow2(252) + pow2(252) == pow2(253)) by {\n        lemma_pow2_adds(1, 252);\n        lemma2_to64();\n    }\n\n    // 2^253 < 2^255\n    lemma_pow2_strictly_increases(253, 255);\n    assert(group_order() < pow2(255));\n}",
      "start_line": 1619,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#fold().",
      "display_name": "fold",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#fold().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#ConstantTimeEq#ct_eq().",
      "display_name": "ct_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#ConstantTimeEq#ct_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn ct_eq(&self, other: &CompressedEdwardsY) -> (result: Choice)\n        ensures\n            choice_is_true(result) == (self.0 == other.0),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function ct_eq_bytes32 instead of direct subtle call to ct_eq for Verus compatibility.\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.as_bytes().ct_eq(other.as_bytes())\n         </ORIGINAL CODE> */\n        ct_eq_bytes32(self.as_bytes(), other.as_bytes())\n    }",
      "start_line": 195,
      "end_line": 13,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_loop_invariant().",
      "display_name": "lemma_add_loop_invariant",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_loop_invariant().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_add_loop_invariant(\n    sum: Scalar52,\n    carry: u64,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    old_carry: u64,\n    mask: u64,\n    sum_loop_start: Scalar52,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> sum.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) == seq_u64_to_nat(sum_loop_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) * pow2(\n            (52 * (i) as nat),\n        ),\n        sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int),\n        sum.limbs[i as int] == carry & mask,\n        carry == a.limbs[i as int] + b.limbs[i as int] + (old_carry >> 52),\n    ensures\n        seq_u64_to_nat(sum.limbs@.subrange(0, i + 1)) + (carry >> 52) * pow2((52 * (i + 1) as nat))\n            == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i + 1),\n        ),\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] as nat * pow2(\n            52 * i as nat,\n        ) + seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] as nat * pow2(\n            52 * i as nat,\n        ); {\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                a.limbs[i as int] as int,\n                b.limbs[i as int] as int,\n            );\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) + (a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(\n            52 * i as nat,\n        ) + (a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                (old_carry >> 52) as int,\n                (a.limbs[i as int] as nat + b.limbs[i as int] as nat) as int,\n            );\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + ((old_carry >> 52) as nat\n            + a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(carry == a.limbs[i as int] + b.limbs[i as int] + (old_carry >> 52));\n            assert(sum.limbs[i as int] == carry & mask);\n            // Decompose carry using the mask\n            lemma_decompose(carry, mask);\n            assert(carry == (carry >> 52) * pow2(52) + sum.limbs[i as int]);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + ((carry >> 52) as nat * pow2(52)\n            + sum.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                lemma_pow2_adds(52, 52 * i as nat);\n            };\n            assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                (carry >> 52) as nat * pow2(52) as int,\n                sum.limbs[i as int] as int,\n            );\n            assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat\n                * pow2(52 * (i + 1) as nat)) by {\n                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                lemma_mul_is_associative(\n                    (carry >> 52) as int,\n                    pow2(52) as int,\n                    pow2(52 * i as nat) as int,\n                );\n            };\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n            52 * (i + 1) as nat,\n        ) + sum.limbs[i as int] as nat * pow2(52 * i as nat); {\n            lemma_seq_u64_to_nat_subrange_extend(sum.limbs@, i as int);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i + 1)) + (carry >> 52) as nat * pow2(\n            (52 * (i + 1) as nat),\n        );\n    }\n}",
      "start_line": 1412,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_compute_q().",
      "display_name": "lemma_compute_q",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_compute_q().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_compute_q(limbs: [u64; 5], q: u64)\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 52),\n        u64_5_as_nat(limbs) < 2 * p(),  // From reduce()'s postcondition\n        q == compute_q_spec(limbs),\n    ensures\n        q == 0 || q == 1,\n        u64_5_as_nat(limbs) >= p() <==> q == 1,\n        u64_5_as_nat(limbs) < p() <==> q == 0,\n{\n    // Step 1: Prove q < 3 (all carries bounded)\n    lemma_all_carries_bounded_by_3(limbs);\n\n    // Step 2: Prove q can only be 0 or 1 (not 2)\n    // Note: This also establishes q as nat == (u64_5_as_nat(limbs) + 19) / pow2(255)\n    // internally by calling lemma_carry_propagation_is_division\n    lemma_q_is_binary(limbs, q);\n\n    // Step 3: Prove the biconditionals\n    // With the tight bound u64_5_as_nat < 2*p(), this is now straightforward\n    lemma_q_biconditional(limbs, q);\n}",
      "start_line": 558,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#PartialEq#eq().",
      "display_name": "eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#PartialEq#eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn eq(&self, other: &EdwardsPoint) -> (result:\n        bool)  /* VERIFICATION NOTE: we cannot add a \"requires\" clause to eq with PartialEqSpecImpl, */  // requires self.ct_eq_req(other),FORMATTER_NOT_INLINE_MARKER\n        ensures\n            result == (edwards_point_as_affine(*self) == edwards_point_as_affine(*other)),\n    {\n        /* ORIGINAL CODE:\n        self.ct_eq(other).into()\n        */\n        let choice = self.ct_eq(other);\n        let result = choice_into(choice);\n\n        proof {\n            assert(choice_is_true(choice) == (edwards_point_as_affine(*self)\n                == edwards_point_as_affine(*other)));\n            assert(result == choice_is_true(choice));\n        }\n\n        result\n    }",
      "start_line": 1057,
      "end_line": 10,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_bytes32().",
      "display_name": "ct_eq_bytes32",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_bytes32().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn ct_eq_bytes32(a: &[u8; 32], b: &[u8; 32]) -> (c: Choice)\n    ensures\n        choice_is_true(c) == (*a == *b),\n{\n    a.ct_eq(b)\n}",
      "start_line": 76,
      "end_line": 21,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_constants_lemmas/field_lemmas/lemmas/lemma_zero_limbs_bounded().",
      "display_name": "lemma_zero_limbs_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_constants_lemmas/field_lemmas/lemmas/lemma_zero_limbs_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/unused_constants_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/unused_constants_lemmas.rs",
      "file_name": "unused_constants_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_zero_limbs_bounded()\n    ensures\n        fe51_limbs_bounded(&FieldElement51::ZERO, 51),\n{\n    assert(fe51_limbs_bounded(&FieldElement51::ZERO, 51)) by {\n        assert(0u64 < (1u64 << 51)) by (bit_vector);\n    };\n}",
      "start_line": 29,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Neg#neg().",
      "display_name": "neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Neg#neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        let result = (&self).neg();\n        result\n    }/* <ORIGINAL CODE>",
      "start_line": 892,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_clamped_integer().",
      "display_name": "is_clamped_integer",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_clamped_integer().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_clamped_integer(bytes: &[u8; 32]) -> bool {\n    // The 3 least significant bits are cleared (divisible by 8)\n    bytes[0] & 0b0000_0111\n        == 0\n    // Bit 255 (MSB) is cleared, making it < 2^255\n     && bytes[31] & 0b1000_0000 == 0\n    // Bit 254 is set, so result >= 2^254\n     && bytes[31] & 0b0100_0000\n        == 0b0100_0000\n    // MSB cleared implies bytes[31] <= 127 (needed for mul_req precondition)\n     && bytes[31] <= 127\n}",
      "start_line": 100,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/Add#add().",
      "display_name": "add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/Add#add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn add(self, other: &'b RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 + other.0)\n    }",
      "start_line": 853,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#part2().",
      "display_name": "part2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#part2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn part2(sum: u128) -> (res: (u128, u64))\n        ensures\n            ({\n                let carry = res.0;\n                let w = res.1;\n                &&& w < (1u64\n                    << 52)  // VER NOTE: w is bounded by 52 bits (lower limb)\n                // VER NOTE: The sum equals w plus carry shifted left by 52 bits\n                &&& sum == (w as u128) + (carry << 52)\n            }),",
      "start_line": 999,
      "end_line": 13,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#IndexMut#index_mut().",
      "display_name": "index_mut",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#IndexMut#index_mut().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn index_mut(&mut self, _index: usize) -> &mut u64 {\n        &mut (self.limbs[_index])\n    }",
      "start_line": 103,
      "end_line": 17,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    fn default() -> (result: LookupTable<ProjectiveNielsPoint>)\n        ensures\n    // All table entries are set to the identity point\n\n            forall|i: int|\n                0 <= i < 8 ==> result.0[i]\n                    == crate::specs::edwards_specs::identity_projective_niels(),\n    {\n        LookupTable([ProjectiveNielsPoint::default();8])\n    }",
      "start_line": 300,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/main().",
      "display_name": "main",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/main().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "file_name": "u64_5_as_nat_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "fn main() {\n}",
      "start_line": 564,
      "end_line": 8,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries1().",
      "display_name": "lemma_as_bytes_boundaries1",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries1().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/as_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/as_bytes_lemmas.rs",
      "file_name": "as_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_as_bytes_boundaries1(raw_limbs: [u64; 5])\n    ensures\n        spec_reduce(raw_limbs)[0] + 19 < u64::MAX,\n        spec_reduce(raw_limbs)[1] + 2 < u64::MAX,\n        spec_reduce(raw_limbs)[2] + 2 < u64::MAX,\n        spec_reduce(raw_limbs)[3] + 2 < u64::MAX,\n        spec_reduce(raw_limbs)[4] + 2 < u64::MAX,\n        forall|i: int| 0 <= i <= 4 ==> compute_q_arr(spec_reduce(raw_limbs))[i] as u64 <= 2,\n        (1u64 << 52) + 19 <= u64::MAX,\n        ((1u64 << 52) + 19) as u64 >> 51 == 2,\n        ((1u64 << 52) + 2) as u64 >> 51 == 2,\n{\n    proof_reduce(raw_limbs);\n\n    let limbs = spec_reduce(raw_limbs);\n\n    assert((1u64 << 52) + 19 <= u64::MAX) by (compute);\n    assert(((1u64 << 52) + 19) as u64 >> 51 == 2) by (compute);\n    assert(((1u64 << 52) + 2) as u64 >> 51 == 2) by (compute);\n\n    let q_arr = compute_q_arr(limbs);\n    let q0 = q_arr[0];\n    let q1 = q_arr[1];\n    let q2 = q_arr[2];\n    let q3 = q_arr[3];\n    let q4 = q_arr[4];\n\n    assert(q0 <= 2) by {\n        lemma_shr_le_u64((limbs[0] + 19) as u64, ((1u64 << 52) + 19) as u64, 51);\n    }\n\n    assert(q1 <= 2) by {\n        lemma_shr_le_u64((limbs[1] + q0) as u64, ((1u64 << 52) + 2) as u64, 51);\n    }\n\n    assert(q2 <= 2) by {\n        lemma_shr_le_u64((limbs[2] + q1) as u64, ((1u64 << 52) + 2) as u64, 51);\n    }\n\n    assert(q3 <= 2) by {\n        lemma_shr_le_u64((limbs[3] + q2) as u64, ((1u64 << 52) + 2) as u64, 51);\n    }\n\n    assert(q4 <= 2) by {\n        lemma_shr_le_u64((limbs[4] + q3) as u64, ((1u64 << 52) + 2) as u64, 51);\n    }\n}",
      "start_line": 31,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "display_name": "pow2",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "    (limbs[8] as nat) * pow2(416)\n}\n\n#[verusfmt::skip]\npub open spec fn five_limbs_to_nat_aux(limbs: [u64; 5]) -> nat {\n                (limbs[0] as nat) +\n    pow2( 52) * (limbs[1] as nat) +\n    pow2(104) * (limbs[2] as nat) +\n    pow2(156) * (limbs[3] as nat) +\n    pow2(208) * (limbs[4] as nat)\n}",
      "start_line": 43,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 221,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_projective_u_coordinate().",
      "display_name": "spec_projective_u_coordinate",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_projective_u_coordinate().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_projective_u_coordinate(P: ProjectivePoint) -> nat {\n    let U = spec_field_element(&P.U);\n    let W = spec_field_element(&P.W);\n    if W == 0 {\n        0\n    } else {\n        math_field_mul(U, math_field_inv(W))\n    }\n}",
      "start_line": 265,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_as_nat().",
      "display_name": "spec_field_element_as_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_as_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_field_element_as_nat(fe: &FieldElement51) -> nat {\n    u64_5_as_nat(fe.limbs)\n}",
      "start_line": 69,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 10,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_inv_witness().",
      "display_name": "is_inv_witness",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_inv_witness().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_inv_witness(v: nat, w: nat) -> bool {\n    ((v % p()) * (w % p())) % p() == 1\n}",
      "start_line": 464,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter_mut().",
      "display_name": "iter_mut",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter_mut().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_lo_limbs_bounded().",
      "display_name": "lemma_lo_limbs_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_lo_limbs_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "file_name": "scalar_lemmas_extra.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_lo_limbs_bounded(lo: &Scalar52, words: &[u64; 8], mask: u64)\n    requires\n        mask == (1u64 << 52) - 1u64,\n        lo.limbs[0] == words[0] & mask,\n        lo.limbs[1] == ((words[0] >> 52) | (words[1] << 12)) & mask,\n        lo.limbs[2] == ((words[1] >> 40) | (words[2] << 24)) & mask,\n        lo.limbs[3] == ((words[2] >> 28) | (words[3] << 36)) & mask,\n        lo.limbs[4] == ((words[3] >> 16) | (words[4] << 48)) & mask,\n    ensures\n        forall|i: int| #![auto] 0 <= i < 5 ==> lo.limbs[i] < (1u64 << 52),\n{\n    lemma_borrow_and_mask_bounded(words[0], mask);\n    lemma_borrow_and_mask_bounded((words[0] >> 52) | (words[1] << 12), mask);\n    lemma_borrow_and_mask_bounded((words[1] >> 40) | (words[2] << 24), mask);\n    lemma_borrow_and_mask_bounded((words[2] >> 28) | (words[3] << 36), mask);\n    lemma_borrow_and_mask_bounded((words[3] >> 16) | (words[4] << 48), mask);\n}",
      "start_line": 500,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core array/Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core array/Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo num-bigint 0.4.6 convert/biguint/BigUint#From#from().",
      "display_name": "from",
      "symbol": "rust-analyzer cargo num-bigint 0.4.6 convert/biguint/BigUint#From#from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_loop_bounds().",
      "display_name": "lemma_add_loop_bounds",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_loop_bounds().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_add_loop_bounds(i: int, carry: u64, a_limb: u64, b_limb: u64)\n    requires\n        0 <= i < 5,\n        a_limb < (1u64 << 52),\n        b_limb < (1u64 << 52),\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n    ensures\n        (carry >> 52) + a_limb + b_limb < (1u64 << 53),\n{\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert((1u64 << 52) + (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}",
      "start_line": 299,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_constants_lemmas/field_lemmas/lemmas/lemma_zero_limbs_bounded_54().",
      "display_name": "lemma_zero_limbs_bounded_54",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_constants_lemmas/field_lemmas/lemmas/lemma_zero_limbs_bounded_54().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/unused_constants_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/unused_constants_lemmas.rs",
      "file_name": "unused_constants_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_zero_limbs_bounded_54()\n    ensures\n        fe51_limbs_bounded(&FieldElement51::ZERO, 54),\n{\n    assert(fe51_limbs_bounded(&FieldElement51::ZERO, 54)) by {\n        lemma_zero_limbs_bounded();\n        assert((1u64 << 51) < (1u64 << 54)) by (bit_vector);\n    };\n}",
      "start_line": 42,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/reconstruct().",
      "display_name": "reconstruct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/reconstruct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn reconstruct(naf: Seq<i8>) -> int\n    decreases naf.len(),\n{\n    if naf.len() == 0 {\n        0\n    } else {\n        (naf[0] as int) + 2 * reconstruct(naf.skip(1))\n    }\n}",
      "start_line": 162,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/vartime_double_base_mul().",
      "display_name": "vartime_double_base_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/vartime_double_base_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "backend",
      "body": "pub fn vartime_double_base_mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> EdwardsPoint {\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 => vector::scalar_mul::vartime_double_base::spec_avx2::mul(a, A, b),\n        // #[cfg(all(curve25519_dalek_backend = \"simd\", nightly))]\n        // BackendKind::Avx512 => {\n        //     vector::scalar_mul::vartime_double_base::spec_avx512ifma_avx512vl::mul(a, A, b)\n        // }\n        BackendKind::Serial => serial::scalar_mul::vartime_double_base::mul(a, A, b),\n    }\n}",
      "start_line": 278,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec().",
      "display_name": "lemma_load8_at_plus_version_is_spec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_load8_at_plus_version_is_spec(input: &[u8], i: usize)\n    ensures\n        load8_at_plus_version_rec(input, i, 7) == spec_load8_at(input, i),\n{\n    assert(load8_at_plus_version_rec(input, i, 0) == input[i as int] as u64);\n\n    assert(pow2(64) - 1 == u64::MAX) by {\n        lemma2_to64_rest();\n    }\n\n    assert(u8::MAX + 1 == pow2(8)) by {\n        lemma2_to64();\n    }\n\n    assert((input[i as int] as u64) == pow2(0 * 8) * input[i + 0]) by {\n        lemma2_to64();\n    }\n    lemma_load8_at_plus_version_is_spec_aux(input, i, 1);\n    lemma_load8_at_plus_version_is_spec_aux(input, i, 2);\n    lemma_load8_at_plus_version_is_spec_aux(input, i, 3);\n    lemma_load8_at_plus_version_is_spec_aux(input, i, 4);\n    lemma_load8_at_plus_version_is_spec_aux(input, i, 5);\n    lemma_load8_at_plus_version_is_spec_aux(input, i, 6);\n    lemma_load8_at_plus_version_is_spec_aux(input, i, 7);\n\n    // suffices to prove this, the _lemma results then give the spec formulation for free\n    assert(load8_at_plus_version_rec(input, i, 7) == (input[i as int] as u64) + ((input[i\n        + 1] as u64) << 8) + ((input[i + 2] as u64) << 16) + ((input[i + 3] as u64) << 24) + ((\n    input[i + 4] as u64) << 32) + ((input[i + 5] as u64) << 40) + ((input[i + 6] as u64) << 48) + ((\n    input[i + 7] as u64) << 56)) by {\n        assert forall|j: nat| 1 <= j <= 7 implies #[trigger] load8_at_plus_version_rec(input, i, j)\n            == load8_at_plus_version_rec(input, i, (j - 1) as nat) + ((input[i + j] as u64) << j\n            * 8) by {\n            reveal_with_fuel(load8_at_plus_version_rec, 1);\n\n            assert(load8_at_plus_version_rec(input, i, (j - 1) as nat) + ((input[i + j] as u64) << j\n                * 8) <= u64::MAX) by {\n                assert(load8_at_plus_version_rec(input, i, (j - 1) as nat) <= pow2(8 * j) - 1) by {\n                    lemma_load8_at_plus_version_rec_is_bounded(input, i, (j - 1) as nat);\n                }\n\n                assert((input[i + j] as u64) << j * 8 <= u8::MAX * pow2(j * 8)) by {\n                    // input[k] < MAX8 => input[k] * 2^(8j) < MAX8 * 2^(8j)\n                    lemma_mul_inequality(input[i + j] as int, u8::MAX as int, pow2(j * 8) as int);\n                }\n\n                assert(load8_at_plus_version_rec(input, i, (j - 1) as nat) + ((input[i + j] as u64)\n                    << j * 8) <= pow2(8 * (j + 1)) - 1) by {\n                    lemma_mul_is_distributive_add(1, u8::MAX as int, pow2(j * 8) as int);\n                }\n            }\n\n        }\n    }\n}",
      "start_line": 176,
      "end_line": 49,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_is_sqrt_ratio_to_math_field().",
      "display_name": "lemma_is_sqrt_ratio_to_math_field",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_is_sqrt_ratio_to_math_field().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_is_sqrt_ratio_to_math_field(\n    x: nat,    // spec_field_element(&X)\n    u: nat,    // spec_field_element(&u_field_elem)  \n    v: nat,    // spec_field_element(&v_field_elem)\n)\n    requires\n        // is_sqrt_ratio condition: (x * x * v) % p == u\n        (x * x * v) % p() == u,\n    ensures\n        math_field_mul(math_field_square(x), v) == u % p(),\n{\n    let p = p();\n    p_gt_2();\n    \n    // math_field_square(x) = (x * x) % p\n    let x2 = math_field_square(x);\n    assert(x2 == (x * x) % p);\n    \n    // math_field_mul(x2, v) = (x2 * v) % p = ((x*x) % p * v) % p\n    // By lemma_mul_mod_noop_left: ((x*x) % p * v) % p == ((x*x) * v) % p\n    assert(math_field_mul(x2, v) == (x * x * v) % p) by {\n        lemma_mul_mod_noop_left((x * x) as int, v as int, p as int);\n        assert(((x * x) % p as nat * v) % p == ((x * x) * v) % p);\n    };\n    \n    // From requires: (x * x * v) % p == u\n    // Since math_field_mul always returns a value < p, and u might not be < p\n    // we need u % p\n    assert((x * x * v) % p == u);\n    \n    // u % p == u when is_sqrt_ratio holds (since is_sqrt_ratio uses spec_field_element which is < p)\n    // But we express the ensures as u % p to be safe\n    lemma_mod_bound((x * x * v) as int, p as int);\n    assert(math_field_mul(x2, v) < p);\n    lemma_small_mod(math_field_mul(x2, v), p);\n    assert(math_field_mul(x2, v) == math_field_mul(x2, v) % p);\n    assert(math_field_mul(x2, v) == u % p);\n}",
      "start_line": 892,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_ratio_exponent_value().",
      "display_name": "lemma_sqrt_ratio_exponent_value",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_ratio_exponent_value().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/unused_sqrt_ratio_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/unused_sqrt_ratio_lemmas.rs",
      "file_name": "unused_sqrt_ratio_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_sqrt_ratio_exponent_value()\n    ensures sqrt_ratio_exponent() == (pow2(252) - 3) as nat,\n{\n    admit();\n}",
      "start_line": 27,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_factorial_coprime_to_prime().",
      "display_name": "lemma_factorial_coprime_to_prime",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_factorial_coprime_to_prime().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "proof fn lemma_factorial_coprime_to_prime(n: nat, prime: nat)\n    requires\n        is_prime(prime),\n        n < prime,\n    ensures\n        factorial(n) % prime != 0,\n    decreases n,\n{\n    // n! = 1 * 2 * ... * n\n    // Each factor is in {1, ..., n} which is a subset of {1, ..., prime-1}\n    // prime doesn't divide any number in {1, ..., prime-1}\n    // Therefore prime doesn't divide n!\n    if n == 0 {\n        // 0! = 1, and 1 % prime != 0 since prime > 1\n        assert(factorial(0) == 1);\n        assert(1nat % prime != 0) by {\n            lemma_small_mod(1nat, prime);\n        };\n    } else {\n        // n! = n * (n-1)!\n        // n % prime != 0 since 1 <= n < prime\n        // (n-1)! % prime != 0 by induction\n        assert(factorial(n) == n * factorial((n - 1) as nat));\n\n        // n < prime and n >= 1, so n % prime = n != 0\n        assert(1 <= n < prime);\n        assert(n % prime == n) by {\n            lemma_small_mod(n, prime);\n        };\n        assert(n % prime != 0);\n\n        // By induction: (n-1) < n < prime\n        lemma_factorial_coprime_to_prime((n - 1) as nat, prime);\n        assert(factorial((n - 1) as nat) % prime != 0);\n\n        // n! = n * (n-1)!\n        // prime doesn't divide n and prime doesn't divide (n-1)!\n        // by Euclid's lemma, prime doesn't divide n!\n        if factorial(n) % prime == 0 {\n            lemma_euclid_prime(n, factorial((n - 1) as nat), prime);\n            assert(false);\n        }\n    }\n}",
      "start_line": 1571,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#non_adjacent_form().",
      "display_name": "non_adjacent_form",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#non_adjacent_form().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn non_adjacent_form(&self, w: usize) -> (result:\n        [i8; 256])\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            2 <= w <= 8,\n        ensures\n    // result encodes the same integer\n\n            reconstruct(result@) == scalar_to_nat(self) as int,\n            // result digits follow NAF rules\n            is_valid_naf(result@, w as nat),\n    {\n        // VERIFICATION NOTE: we tell verus not to verify debug assertions\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert!(w >= 2);\n        // required so that the NAF digits fit in i8\n        // VERIFICATION NOTE: we tell verus not to verify debug assertions\n        #[cfg(not(verus_keep_ghost))]\n            debug_assert!(w <= 8);\n\n        let mut naf = [0i8;256];\n\n        // VERIFICATION NOTE: Inline the read_le_u64_into logic to avoid Verus unsupported features - IN PROGRESS\n        /* <ORIGINAL CODE>\n            let mut x_u64 = [0u64; 5];\n            read_le_u64_into(&self.bytes, &mut x_u64[0..4]);\n             <ORIGINAL CODE> */\n        // Read 4 u64s from the 32-byte array (self.bytes)\n        assume(false);\n        let mut x_u64 = [0u64;5];\n        x_u64[0] = u64_from_le_bytes(\n            [\n                self.bytes[0],\n                self.bytes[1],\n                self.bytes[2],\n                self.bytes[3],\n                self.bytes[4],\n                self.bytes[5],\n                self.bytes[6],\n                self.bytes[7],\n            ],\n        );\n        x_u64[1] = u64_from_le_bytes(\n            [\n                self.bytes[8],\n                self.bytes[9],\n                self.bytes[10],\n                self.bytes[11],\n                self.bytes[12],\n                self.bytes[13],\n                self.bytes[14],\n                self.bytes[15],\n            ],\n        );\n        x_u64[2] = u64_from_le_bytes(\n            [\n                self.bytes[16],\n                self.bytes[17],\n                self.bytes[18],\n                self.bytes[19],\n                self.bytes[20],\n                self.bytes[21],\n                self.bytes[22],\n                self.bytes[23],\n            ],\n        );\n        x_u64[3] = u64_from_le_bytes(\n            [\n                self.bytes[24],\n                self.bytes[25],\n                self.bytes[26],\n                self.bytes[27],\n                self.bytes[28],\n                self.bytes[29],\n                self.bytes[30],\n                self.bytes[31],\n            ],\n        );\n        // x_u64[4] remains 0\n\n        let width = 1 << w;\n        let window_mask = width - 1;\n\n        let mut pos = 0;\n        let mut carry = 0;\n        while pos < 256\n            decreases 256 - pos,\n        {\n            assume(false);\n\n            // Construct a buffer of bits of the scalar, starting at bit `pos`\n            let u64_idx = pos / 64;\n            let bit_idx = pos % 64;\n            let bit_buf: u64 = if bit_idx < 64 - w {\n                // This window's bits are contained in a single u64\n                x_u64[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (x_u64[u64_idx] >> bit_idx) | (x_u64[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Add the carry into the current window\n            assume(false);\n            let window = carry + (bit_buf & window_mask);\n\n            if window & 1 == 0 {\n                // If the window value is even, preserve the carry and continue.\n                // Why is the carry preserved?\n                // If carry == 0 and window & 1 == 0, then the next carry should be 0\n                // If carry == 1 and window & 1 == 0, then bit_buf & 1 == 1 so the next carry should be 1\n                pos += 1;\n                continue ;\n            }\n            if window < width / 2 {\n                carry = 0;\n                naf[pos] = window as i8;\n            } else {\n                carry = 1;\n                naf[pos] = (window as i8).wrapping_sub(width as i8);\n            }\n            assume(false);\n            pos += w;\n        }\n\n        naf\n    }",
      "start_line": 2054,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Product#product().",
      "display_name": "product",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Product#product().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn product<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified product_of_slice function\n        Scalar::product_of_slice(&scalars)\n    }  /* </MODIFIED CODE> */",
      "start_line": 943,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#to_u64_digits().",
      "display_name": "to_u64_digits",
      "symbol": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#to_u64_digits().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strictly_positive().",
      "display_name": "lemma_mul_strictly_positive",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strictly_positive().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "curve25519-dalek/src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn identity() -> Self where Self: Sized;\n}\n\n/// Trait for testing if a curve point is equivalent to the identity point.\npub trait IsIdentity {\n    /// Return true if this element is the identity element of the curve.\n    fn is_identity(&self) -> bool;\n}",
      "start_line": 32,
      "end_line": 16,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"AffineNielsPoint{{\\n\\ty_plus_x: {:?},\\n\\ty_minus_x: {:?},\\n\\txy2d: {:?}\\n}}\",\n            &self.y_plus_x, &self.y_minus_x, &self.xy2d\n        )\n    }",
      "start_line": 889,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_inverse().",
      "display_name": "is_inverse",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_inverse().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_inverse(a: &Scalar, b: &Scalar) -> bool {\n    (bytes_to_nat(&a.bytes) * bytes_to_nat(&b.bytes)) % group_order() == 1\n}",
      "start_line": 56,
      "end_line": 28,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_to_nat().",
      "display_name": "words_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn words_to_nat(words: &[u64; 4]) -> nat {\n    words_to_nat_gen_u64(words, 4, 64)\n}",
      "start_line": 187,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 DalekBits#Display#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 DalekBits#Display#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "curve25519-dalek/build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {\n        let w_bits = match self {\n            DalekBits::Dalek32 => \"32\",\n            DalekBits::Dalek64 => \"64\",\n        };\n        write!(f, \"{w_bits}\")\n    }",
      "start_line": 14,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_cast_then_mod_51().",
      "display_name": "lemma_cast_then_mod_51",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_cast_then_mod_51().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_cast_then_mod_51(x: u128)\n    ensures\n        (x as u64) % (pow2(51) as u64) == x % (pow2(51) as u128),\n{\n    lemma2_to64_rest();  // pow2(51 | 64)\n    assert((x as u64) % 0x8000000000000 == x % 0x8000000000000) by (bit_vector);\n}",
      "start_line": 80,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_square_of_complement().",
      "display_name": "lemma_square_of_complement",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_square_of_complement().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_square_of_complement(a: nat, p: nat)\n    requires\n        p > 0,\n        0 < a && a < p,\n    ensures\n        (((p - a) * (p - a)) as nat) % p == ((a * a) as nat) % p,\n{\n    let p_int = p as int;\n    let a_int = a as int;\n    let p_minus_a = (p - a) as int;\n    \n    // Step 1: Algebraic expansion\n    // (p - a)² = p² - 2pa + a²\n    \n    // lemma_mul_is_distributive_sub(x, y, z) proves: x * (y - z) = x*y - x*z\n    \n    // First: (p - a) * (p - a) = (p-a)*p - (p-a)*a\n    assert(p_minus_a * p_minus_a == p_minus_a * p_int - p_minus_a * a_int) by {\n        lemma_mul_is_distributive_sub(p_minus_a, p_int, a_int);\n    }\n    \n    // Expand (p-a)*p = p*p - a*p\n    assert(p_minus_a * p_int == p_int * p_int - a_int * p_int) by {\n        lemma_mul_is_commutative(p_minus_a, p_int);\n        // p * (p - a) = p*p - p*a\n        lemma_mul_is_distributive_sub(p_int, p_int, a_int);\n    }\n    \n    // Expand (p-a)*a = p*a - a*a\n    assert(p_minus_a * a_int == p_int * a_int - a_int * a_int) by {\n        lemma_mul_is_commutative(p_minus_a, a_int);\n        // a * (p - a) = a*p - a*a\n        lemma_mul_is_distributive_sub(a_int, p_int, a_int);\n    }\n    \n    // Combine: (p-a)² = (p² - ap) - (pa - a²) = p² - ap - pa + a²\n    // Note: ap = pa by commutativity\n    assert(a_int * p_int == p_int * a_int) by {\n        lemma_mul_is_commutative(a_int, p_int);\n    }\n    \n    // So: (p-a)² = p² - 2pa + a²\n    // We have: (p-a)² = (p² - ap) - (pa - a²) = p² - ap - pa + a²\n    // And ap = pa, so: p² - ap - pa + a² = p² - 2pa + a²\n    \n    // Step: Show ap + pa = 2pa\n    // Since a*p = p*a (commutativity), we have:\n    // a*p + p*a = p*a + p*a = 2*(p*a)\n    let pa = p_int * a_int;\n    assert(a_int * p_int == pa);\n    assert(pa + pa == 2 * pa);\n    assert(2 * pa == 2 * p_int * a_int) by {\n        lemma_mul_is_associative(2int, p_int, a_int);\n    }\n    assert(a_int * p_int + p_int * a_int == 2 * p_int * a_int);\n    \n    // Now show the full expansion\n    // We have: (p-a)² = (p² - ap) - (pa - a²)\n    assert(p_minus_a * p_minus_a == (p_int * p_int - a_int * p_int) - (p_int * a_int - a_int * a_int));\n    \n    // Simplify: (A - B) - (C - D) = A - B - C + D\n    let A = p_int * p_int;\n    let B = a_int * p_int;\n    let C = p_int * a_int;\n    let D = a_int * a_int;\n    assert((A - B) - (C - D) == A - B - C + D);\n    \n    // Now A - B - C + D = p² - ap - pa + a² = p² - (ap + pa) + a² = p² - 2pa + a²\n    // Since B = ap = pa = C, we have B + C = 2pa\n    assert(B == C);  // ap = pa\n    assert(A - B - C + D == A - (B + C) + D);\n    assert(B + C == 2 * pa);\n    assert(A - (B + C) + D == A - 2 * pa + D);\n    assert(A - 2 * pa + D == p_int * p_int - 2 * p_int * a_int + a_int * a_int);\n    \n    assert(p_minus_a * p_minus_a == p_int * p_int - 2 * p_int * a_int + a_int * a_int);\n    \n    // Step 2: p² % p = 0\n    assert((p_int * p_int) % p_int == 0) by {\n        lemma_mod_multiples_basic(p_int, p_int);\n    }\n    \n    // Step 3: 2pa % p = 0\n    // 2*p*a = (2*a) * p, so it's a multiple of p\n    assert((2 * p_int * a_int) % p_int == 0) by {\n        // Need to show: 2 * p * a = (2 * a) * p\n        assert(2 * p_int * a_int == (2 * a_int) * p_int) by {\n            lemma_mul_is_associative(2int, p_int, a_int);\n            lemma_mul_is_commutative(2int, p_int);\n            lemma_mul_is_associative(p_int, 2int, a_int);\n            lemma_mul_is_commutative(p_int, 2 * a_int);\n        }\n        // (2*a) * p is divisible by p\n        lemma_mod_multiples_basic(2 * a_int, p_int);\n    }\n    \n    // Step 4: Combine\n    // (p² - 2pa + a²) % p = a² % p\n    // Because p² % p = 0 and 2pa % p = 0\n    \n    // First: (p² - 2pa) % p = 0\n    assert((p_int * p_int - 2 * p_int * a_int) % p_int == 0) by {\n        lemma_sub_mod_noop(p_int * p_int, 2 * p_int * a_int, p_int);\n        // Both p² % p = 0 and 2pa % p = 0, so (p² - 2pa) % p = (0 - 0) % p = 0\n        lemma_small_mod(0nat, p);\n    }\n    \n    // Then: (p² - 2pa + a²) % p = (0 + a²) % p = a² % p\n    // lemma_add_mod_noop: (x + y) % m = ((x % m) + (y % m)) % m\n    let x = p_int * p_int - 2 * p_int * a_int;\n    let y = a_int * a_int;\n    \n    // We have x % p = 0 (from above)\n    assert(x % p_int == 0);\n    \n    // Apply lemma_add_mod_noop\n    lemma_add_mod_noop(x, y, p_int);\n    // This gives: (x + y) % p = ((x % p) + (y % p)) % p = (0 + (y % p)) % p\n    assert((x + y) % p_int == ((x % p_int) + (y % p_int)) % p_int);\n    assert(((x % p_int) + (y % p_int)) % p_int == (0 + (y % p_int)) % p_int);\n    \n    // Now: (0 + (y % p)) % p = (y % p) % p = y % p\n    // Because 0 + z = z and (z % p) % p = z % p\n    let y_mod_p = y % p_int;\n    assert(0 + y_mod_p == y_mod_p);\n    lemma_mod_twice(y, p_int);  // (y % p) % p = y % p\n    assert((y_mod_p) % p_int == y % p_int);\n    assert((0 + y_mod_p) % p_int == y_mod_p % p_int);\n    \n    // Final chain: (x + y) % p = y % p\n    assert((x + y) % p_int == (y) % p_int);\n    assert((p_int * p_int - 2 * p_int * a_int + a_int * a_int) % p_int == (a_int * a_int) % p_int);\n    \n    // Step 5: Connect to the ensures clause\n    // We showed: (p-a)² = p² - 2pa + a² and (p² - 2pa + a²) % p = a² % p\n    // So (p-a)² % p = a² % p\n    \n    // Cast to nat for the ensures clause\n    assert(p_minus_a * p_minus_a >= 0) by {\n        lemma_mul_nonnegative(p_minus_a, p_minus_a);\n    }\n    assert(a_int * a_int >= 0) by {\n        lemma_mul_nonnegative(a_int, a_int);\n    }\n}",
      "start_line": 1700,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_3_terms().",
      "display_name": "lemma_mul_distributive_3_terms",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_3_terms().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_mul_distributive_3_terms(n: int, x1: int, x2: int, x3: int)\n    ensures\n        n * (x1 + x2 + x3) == (x1 + x2 + x3) * n == n * x1 + n * x2 + n * x3,\n{\n    assert(n * (x1 + x2 + x3) == (x1 + x2 + x3) * n) by {\n        lemma_mul_is_commutative(n, x1 + x2 + x3);\n    }\n\n    assert(n * (x1 + x2 + x3) == n * (x1 + x2) + n * x3) by {\n        lemma_mul_is_distributive_add(n, x1 + x2, x3);\n    }\n\n    assert(n * (x1 + x2) == n * x1 + n * x2) by {\n        lemma_mul_is_distributive_add(n, x1, x2);\n    }\n}",
      "start_line": 53,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/montgomery_reduce_non_canonical_product_fails_postcondition().",
      "display_name": "montgomery_reduce_non_canonical_product_fails_postcondition",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/montgomery_reduce_non_canonical_product_fails_postcondition().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn montgomery_reduce_non_canonical_product_fails_postcondition() {\n        // This is the minimal failing case found by proptest\n        let limbs: [u128; 9] = [\n            0,\n            0,\n            0,\n            0,\n            43234767039827164816921,\n            0,\n            0,\n            0,\n            130605075492091607448940168551,\n        ];\n\n        // Verify the input limbs are relatively small (much smaller than 2^104 which is the\n        // theoretical max for products of 52-bit limbs)\n        assert!(limbs[0] < (1u128 << 1), \"limbs[0] should be < 2^1\");\n        assert!(limbs[1] < (1u128 << 1), \"limbs[1] should be < 2^1\");\n        assert!(limbs[2] < (1u128 << 1), \"limbs[2] should be < 2^1\");\n        assert!(limbs[3] < (1u128 << 1), \"limbs[3] should be < 2^1\");\n        assert!(limbs[4] < (1u128 << 76), \"limbs[4] should be < 2^76\");\n        assert!(limbs[5] < (1u128 << 1), \"limbs[5] should be < 2^1\");\n        assert!(limbs[6] < (1u128 << 1), \"limbs[6] should be < 2^1\");\n        assert!(limbs[7] < (1u128 << 1), \"limbs[7] should be < 2^1\");\n        assert!(limbs[8] < (1u128 << 97), \"limbs[8] should be < 2^97\");\n\n        let result = Scalar52::montgomery_reduce(&limbs);\n\n        let result_nat = to_nat_exec(&result.limbs);\n        let limbs_nat = slice128_to_nat_exec(&limbs);\n        let l = group_order_exec();\n        let r = montgomery_radix_exec();\n\n        // The Montgomery property should still hold\n        assert_eq!(\n            (&result_nat * &r) % &l,\n            &limbs_nat % &l,\n            \"Montgomery property violated\"\n        );\n\n        // The result should be limbs_bounded\n        assert!(\n            limbs_bounded_exec(&result),\n            \"Result limbs not bounded by 2^52\"\n        );\n\n        // But the canonicality postcondition FAILS\n        assert!(\n            &result_nat < &l,\n            \"Result not in canonical form (>= L): {} >= {}\",\n            result_nat,\n            l\n        );\n    }",
      "start_line": 1299,
      "end_line": 67,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_hash().",
      "display_name": "from_hash",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_hash().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn from_hash<D>(hash: D) -> RistrettoPoint\n    where\n        D: Digest<OutputSize = U64> + Default,\n    {\n        // dealing with generic arrays is clumsy, until const generics land\n        let output = hash.finalize();\n        let mut output_bytes = [0u8; 64];\n        output_bytes.copy_from_slice(output.as_slice());\n\n        RistrettoPoint::from_uniform_bytes(&output_bytes)\n    }",
      "start_line": 763,
      "end_line": 21,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"CompletedPoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?},\\n\\tT: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z, &self.T\n        )\n    }",
      "start_line": 879,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "display_name": "lemma_sqrt_ratio_implies_on_curve",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_sqrt_ratio_implies_on_curve(x: nat, y: nat)\n    requires\n        ({\n            let d = spec_field_element(&EDWARDS_D);\n            let y2 = math_field_square(y);\n            let u = math_field_sub(y2, 1);\n            let v = math_field_add(math_field_mul(d, y2), 1);\n            v != 0 && math_field_mul(math_field_square(x), v) == u\n        }),",
      "start_line": 61,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 16
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_masked_lt_51().",
      "display_name": "lemma_masked_lt_51",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_masked_lt_51().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_masked_lt_51(v: u64)\n    ensures\n        v & mask51 < (1u64 << 51),\n{\n    l51_bit_mask_lt();  // mask51 == low_bits_mask(51)\n    lemma_masked_lt(v, 51);\n}",
      "start_line": 104,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#From#from().",
      "display_name": "from",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#From#from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_affine_niels(); 8];\n        let A2 = A.double();\n        for i in 0..7 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n        NafLookupTable5(Ai)\n    }",
      "start_line": 564,
      "end_line": 12,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/lemma_fermat_for_p().",
      "display_name": "lemma_fermat_for_p",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/lemma_fermat_for_p().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub proof fn lemma_fermat_for_p(x: nat)\n    requires\n        x % p() != 0,\n    ensures\n        (pow(x as int, (p() - 1) as nat) as nat) % p() == 1,\n{\n    axiom_p_is_prime();\n    lemma_fermat_little_theorem(x, p());\n}",
      "start_line": 292,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "display_name": "batch_invert",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "curve25519-dalek/src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn batch_invert(\n        inputs: &mut [FieldElement],\n    )/* <VERIFICATION NOTE>\n     - Refactored for Verus: Index loops instead of iterators, manual Vec construction\n     - Choice type operations handled by wrappers in subtle_assumes.rs\n     - PROOF BYPASSES because of trait issues and proof obligations.\n    </VERIFICATION NOTE> */\n\n        requires\n            forall|i: int|\n                #![trigger old(inputs)[i]]\n                0 <= i < old(inputs).len() ==> (forall|j: int|\n                    0 <= j < 5 ==> old(inputs)[i].limbs[j] < 1u64 << 54),\n        ensures\n    // Each element is replaced appropriately:\n\n            forall|i: int|\n                #![auto]\n                0 <= i < inputs.len() ==> {\n                    // If input was non-zero, it's replaced with its inverse\n                    (spec_field_element(&old(inputs)[i]) != 0) ==> is_inverse_field(\n                        &old(inputs)[i],\n                        &inputs[i],\n                    ) &&\n                    // If input was zero, it remains zero\n                    (spec_field_element(&old(inputs)[i]) == 0) ==> spec_field_element(&inputs[i])\n                        == 0\n                },",
      "start_line": 526,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#create().",
      "display_name": "create",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#create().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn create(basepoint: &EdwardsPoint) -> (result: EdwardsBasepointTable)\n        requires\n            is_well_formed_edwards_point(*basepoint),\n        ensures\n            is_valid_edwards_basepoint_table(result, edwards_point_as_affine(*basepoint)),\n    {\n        // XXX use init_with\n        let mut table = EdwardsBasepointTable([LookupTableRadix16::default();32]);\n        let mut P = *basepoint;\n        for i in 0..32 {\n            // P = (16²)^i * basepoint\n            table.0[i] = LookupTableRadix16::from(&P);\n            proof {\n                assume(fe51_limbs_bounded(&P.X, 54));\n                assume(fe51_limbs_bounded(&P.Y, 54));\n                assume(fe51_limbs_bounded(&P.Z, 54));\n                assume(fe51_limbs_bounded(&P.T, 54));\n            }\n            P = P.mul_by_pow_2(4 + 4);  // P = P * 2^8 = P * 256 = P * 16²\n        }\n        proof {\n            assume(is_valid_edwards_basepoint_table(table, edwards_point_as_affine(*basepoint)));\n        }\n        table\n    }",
      "start_line": 1985,
      "end_line": 14,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/spec_state_after_hash_montgomery().",
      "display_name": "spec_state_after_hash_montgomery",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/spec_state_after_hash_montgomery().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub open spec fn spec_state_after_hash_montgomery<H>(\n    initial_state: H,\n    point: &MontgomeryPoint,\n) -> H {\n    // The hash state of a MontgomeryPoint is determined by its canonical bytes\n    // Canonical bytes are: spec_fe51_to_bytes(spec_fe51_from_bytes(point.0))\n    let canonical_seq = spec_fe51_to_bytes(&spec_fe51_from_bytes(&point.0));\n    let canonical_bytes = seq_to_array_32(canonical_seq);\n    spec_state_after_hash(initial_state, &canonical_bytes)\n}",
      "start_line": 199,
      "end_line": 50,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_from_bytes_to_nat_wide().",
      "display_name": "lemma_words_from_bytes_to_nat_wide",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_from_bytes_to_nat_wide().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "file_name": "scalar_lemmas_extra.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_words_from_bytes_to_nat_wide(bytes: &[u8; 64])\n    ensures\n        words_from_bytes_to_nat(bytes, 8) == word_from_bytes(bytes, 0) + pow2(64) * word_from_bytes(\n            bytes,\n            1,\n        ) + pow2(128) * word_from_bytes(bytes, 2) + pow2(192) * word_from_bytes(bytes, 3) + pow2(\n            256,\n        ) * word_from_bytes(bytes, 4) + pow2(320) * word_from_bytes(bytes, 5) + pow2(384)\n            * word_from_bytes(bytes, 6) + pow2(448) * word_from_bytes(bytes, 7),\n{\n    reveal_with_fuel(words_from_bytes_to_nat, 9);\n    lemma2_to64();\n    assert(words_from_bytes_to_nat(bytes, 1) == words_from_bytes_to_nat(bytes, 0) + word_from_bytes(\n        bytes,\n        0,\n    ) * pow2((0 * 64) as nat));\n    // Reorder multiplications using commutativity\n    assert(words_from_bytes_to_nat(bytes, 8) == word_from_bytes(bytes, 0) + pow2(64)\n        * word_from_bytes(bytes, 1) + pow2(128) * word_from_bytes(bytes, 2) + pow2(192)\n        * word_from_bytes(bytes, 3) + pow2(256) * word_from_bytes(bytes, 4) + pow2(320)\n        * word_from_bytes(bytes, 5) + pow2(384) * word_from_bytes(bytes, 6) + pow2(448)\n        * word_from_bytes(bytes, 7)) by {\n        broadcast use lemma_mul_is_commutative;\n\n    };\n}",
      "start_line": 276,
      "end_line": 48,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb3().",
      "display_name": "lemma_load8_at_limb3",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb3().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_load8_at_limb3(input: &[u8])\n    requires\n        19 + 7 < input.len(),\n    ensures\n        ((spec_load8_at(input, 19) as u64) >> 1) & mask51 == (input[19] as nat / pow2(1)) + (\n        input[20] * pow2((1 * 8 - 1) as nat)) + (input[21] * pow2((2 * 8 - 1) as nat)) + (input[22]\n            * pow2((3 * 8 - 1) as nat)) + (input[23] * pow2((4 * 8 - 1) as nat)) + (input[24]\n            * pow2((5 * 8 - 1) as nat)) + ((input[25] as nat % pow2(4)) * pow2((6 * 8 - 1) as nat)),\n{\n    let i = 19;\n    let k = 1;\n\n    let j_div = 1;\n    let j_id = 6;\n    let j_shift = 7;\n\n    lemma_load8_at_limb_X(input, i, k, j_div, j_id, j_shift);\n\n    // Sanity check\n    assert((spec_load8_at(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n        / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n    pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64));\n}",
      "start_line": 946,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_prime_divisibility_helper().",
      "display_name": "lemma_binomial_prime_divisibility_helper",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_prime_divisibility_helper().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "proof fn lemma_binomial_prime_divisibility_helper(p: nat, k: nat)\n    requires\n        is_prime(p),\n        0 < k < p,\n    ensures\n        binomial(p, k) % p == 0,\n{\n    lemma_binomial_absorption(p, k);\n\n    let prod = k * binomial(p, k);\n    assert(prod == p * binomial((p - 1) as nat, (k - 1) as nat));\n\n    assert(prod % p == 0) by {\n        lemma_mod_multiples_basic(binomial((p - 1) as nat, (k - 1) as nat) as int, p as int);\n    };\n\n    assert(k % p != 0) by {\n        lemma_small_mod(k, p);\n    };\n\n    if binomial(p, k) % p != 0 {\n        lemma_euclid_prime(k, binomial(p, k), p);\n        assert(false);\n    }\n}",
      "start_line": 269,
      "end_line": 50,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime_helper().",
      "display_name": "lemma_euclid_prime_helper",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime_helper().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "proof fn lemma_euclid_prime_helper(a: nat, b: nat, p: nat)\n    requires\n        is_prime(p),\n        0 < a < p,\n        (a * b) % p == 0,\n    ensures\n        b % p == 0,\n    decreases a,\n{\n    // We prove by induction on a\n    // Key idea: if a doesn't divide p evenly (which it can't since a < p and p is prime),\n    // we can find a smaller representative\n    if a == 1 {\n        // 1 * b % p == 0 means b % p == 0\n        assert(a * b == b) by {\n            lemma_mul_basics(b as int);\n        };\n    } else {\n        // a > 1 and a < p\n        // Since p is prime and 1 < a < p, p % a != 0\n        // We use the division algorithm: p = q * a + r where 0 <= r < a\n        // Since p doesn't divide a and a doesn't divide p, r > 0\n        // Then: r * b ≡ p * b - q * a * b ≡ 0 - q * 0 ≡ 0 (mod p)\n        // And r < a, so by induction...\n        let q = p / a;\n        let r = p % a;\n\n        // r > 0 because p is prime and 1 < a < p means a doesn't divide p\n        assert(r > 0) by {\n            if r == 0 {\n                // Then p = q * a, meaning a divides p\n                // But a < p and a > 1, contradicting that p is prime\n                assert(p % a == 0);\n                assert(1 < a < p);\n                // is_prime says: forall d. 1 < d < p ==> p % d != 0\n                assert(false);\n            }\n        };\n\n        // p = q * a + r, so r = p - q * a\n        assert(p == q * a + r) by {\n            lemma_fundamental_div_mod(p as int, a as int);\n        };\n\n        // (r * b) % p == ?\n        // r * b = (p - q * a) * b = p * b - q * a * b\n        // (r * b) % p = (p * b - q * a * b) % p = (0 - q * (a * b)) % p = (-q * 0) % p = 0\n\n        assert((r * b) % p == 0) by {\n            // r = p - q * a\n            // r * b = p * b - q * a * b\n            assert(r * b == p * b - q * a * b) by {\n                assert(r == p - q * a);\n                lemma_mul_is_distributive_sub_other_way(b as int, p as int, (q * a) as int);\n                assert((p - q * a) * b == p * b - (q * a) * b);\n                lemma_mul_is_associative(q as int, a as int, b as int);\n            };\n\n            // (p * b) % p == 0\n            assert((p * b) % p == 0) by {\n                lemma_mod_multiples_basic(b as int, p as int);\n            };\n\n            // (q * a * b) % p == q * ((a * b) % p) % p == q * 0 % p == 0\n            assert((q * (a * b)) % p == 0) by {\n                lemma_mul_mod_noop_right(q as int, (a * b) as int, p as int);\n                assert((a * b) % p == 0);\n                lemma_mul_basics(q as int);\n                lemma_small_mod(0nat, p);\n            };\n\n            // r * b = p * b - q * a * b\n            // (r * b) % p = (p * b - q * a * b) % p\n            // Both (p * b) and (q * a * b) are divisible by p\n            // So their difference is also divisible by p\n            lemma_mul_is_associative(q as int, a as int, b as int);\n            assert(q * a * b == q * (a * b));\n\n            // (p * b) % p == 0 and (q * (a * b)) % p == 0\n            // So (p * b - q * (a * b)) % p == 0\n            // Which means (r * b) % p == 0\n            assert((p * b) % p == 0) by {\n                lemma_mod_multiples_basic(b as int, p as int);\n            };\n            assert((q * (a * b)) % p == 0) by {\n                lemma_mul_mod_noop_right(q as int, (a * b) as int, p as int);\n                lemma_mul_basics(q as int);\n                lemma_small_mod(0nat, p);\n            };\n            // Both are 0 mod p, so their difference is 0 mod p\n            lemma_mod_difference_zero((p * b) as int, (q * (a * b)) as int, p as int);\n        };\n\n        // By induction on r < a\n        assert(0 < r < a);\n        assert(r < p) by {\n            lemma_mod_bound(p as int, a as int);\n        };\n        lemma_euclid_prime_helper(r, b, p);\n    }\n}",
      "start_line": 1101,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_0_val_boundaries().",
      "display_name": "ci_0_val_boundaries",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_0_val_boundaries().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn ci_0_val_boundaries(a: [u64; 5], bound: u64) -> bool {\n    &&& c0_0_val(a) < 77 * (bound * bound)\n    &&& c1_0_val(a) < 59 * (bound * bound)\n    &&& c2_0_val(a) < 41 * (bound * bound)\n    &&& c3_0_val(a) < 23 * (bound * bound)\n    &&& c4_0_val(a) < 5 * (bound * bound)\n}",
      "start_line": 158,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_chunk_extraction_commutes_with_mod().",
      "display_name": "lemma_chunk_extraction_commutes_with_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_chunk_extraction_commutes_with_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_chunk_extraction_commutes_with_mod(x: nat, k: nat, b: nat, m: nat)\n    requires\n        b > 0,\n        k * b + b\n            <= m,  // The chunk we're extracting is entirely below the modulo boundary\n\n    ensures\n        (x / pow2(k * b)) % pow2(b) == ((x % pow2(m)) / pow2(k * b)) % pow2(b),\n{\n    assert((x / pow2(k * b)) % pow2(b) == (x % pow2(k * b + b)) / pow2(k * b)) by {\n        lemma_pow2_div_mod(x, k * b, b);\n    }\n\n    let y = x % pow2(m);\n\n    assert((y / pow2(k * b)) % pow2(b) == (y % pow2(k * b + b)) / pow2(k * b)) by {\n        lemma_pow2_div_mod(y, k * b, b);\n    }\n\n    let s = k * b + b;\n    let ps = pow2(s);\n\n    assert(x % ps == y % ps) by {\n        let d = (m - s) as nat;\n        let pd = pow2(d);\n        assert(pow2(m) == ps * pd) by {\n            lemma_pow2_adds(s, d);\n        }\n\n        assert((x % (ps * pd)) % ps == x % ps) by {\n            lemma_pow2_pos(d);\n            lemma_pow2_pos(s);\n            lemma_mod_mod(x as int, ps as int, pd as int);\n        }\n    }\n}",
      "start_line": 678,
      "end_line": 54,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow0().",
      "display_name": "lemma_pow0",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow0().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/pow2_mul_div_mod_close_mod_u8_t51_cond().",
      "display_name": "pow2_mul_div_mod_close_mod_u8_t51_cond",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/pow2_mul_div_mod_close_mod_u8_t51_cond().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn pow2_mul_div_mod_close_mod_u8_t51_cond(k: nat, j: nat) -> bool {\n    (k <= j * 8) && (j * 8 - k <= 51)\n}",
      "start_line": 720,
      "end_line": 56,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#coset4().",
      "display_name": "coset4",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#coset4().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn coset4(&self) -> [EdwardsPoint; 4] {\n        [\n            self.0,\n            self.0 + constants::EIGHT_TORSION[2],\n            self.0 + constants::EIGHT_TORSION[4],\n            self.0 + constants::EIGHT_TORSION[6],\n        ]\n    }",
      "start_line": 638,
      "end_line": 14,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_field_element_value().",
      "display_name": "lemma_one_field_element_value",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_field_element_value().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/constants_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/constants_lemmas.rs",
      "file_name": "constants_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_one_field_element_value()\n    ensures\n        spec_field_element(&FieldElement51::ONE) == 1,\n{\n    // Goal: spec_field_element(ONE) = u64_5_as_nat(ONE.limbs) % p = 1\n    //\n    // Mathematical reasoning:\n    //   ONE.limbs = [1, 0, 0, 0, 0]\n    //   u64_5_as_nat([1, 0, 0, 0, 0])\n    //     = 1 + 2^51·0 + 2^102·0 + 2^153·0 + 2^204·0\n    //     = 1    (since n·0 = 0 for all n)\n    //   1 % p = 1    (since p > 2 > 1, by lemma_small_mod)\n\n    assert(spec_field_element(&FieldElement51::ONE) == 1) by {\n        // Subgoal 1: ONE.limbs = [1, 0, 0, 0, 0]\n        assert(FieldElement51::ONE.limbs[0] == 1);\n        assert(FieldElement51::ONE.limbs[1] == 0);\n        assert(FieldElement51::ONE.limbs[2] == 0);\n        assert(FieldElement51::ONE.limbs[3] == 0);\n        assert(FieldElement51::ONE.limbs[4] == 0);\n\n        // Subgoal 2: u64_5_as_nat([1, 0, 0, 0, 0]) = 1\n        // SMT recognizes: 1 + pow2(51)*0 + pow2(102)*0 + pow2(153)*0 + pow2(204)*0 = 1\n        assert(u64_5_as_nat(FieldElement51::ONE.limbs) == 1);\n\n        // Subgoal 3: 1 % p = 1\n        p_gt_2();  // proves p > 2, hence p > 1\n        lemma_small_mod(1, p());  // x < m ==> x % m = x\n    };\n}",
      "start_line": 75,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/differential_add_and_double().",
      "display_name": "differential_add_and_double",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/differential_add_and_double().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "fn differential_add_and_double(\n    P: &mut ProjectivePoint,\n    Q: &mut ProjectivePoint,\n    affine_PmQ: &FieldElement,\n)\n    requires\n// The differential relationship: P and Q have valid u-coordinates,\n// and affine_PmQ is u(P - Q) using canonical lifts\n\n        ({\n            let u_P = spec_projective_u_coordinate(*old(P));\n            let u_Q = spec_projective_u_coordinate(*old(Q));\n            let P_aff = canonical_montgomery_lift(u_P);\n            let Q_aff = canonical_montgomery_lift(u_Q);\n\n            // Both u-coordinates must be valid (allowing canonical Montgomery lift)\n            is_valid_u_coordinate(u_P) && is_valid_u_coordinate(u_Q)\n                &&\n            // P and Q are distinct points\n            P_aff != Q_aff\n                &&\n            // affine_PmQ is exactly u(canonical_lift(P) - canonical_lift(Q))\n            match montgomery_sub(P_aff, Q_aff) {\n                MontgomeryAffine::Finite { u: u_diff, .. } => spec_field_element(affine_PmQ)\n                    == u_diff,\n                MontgomeryAffine::Infinity => false,\n            }\n        }),",
      "start_line": 710,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_val_boundaries().",
      "display_name": "ci_val_boundaries",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_val_boundaries().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn ci_val_boundaries(a: [u64; 5]) -> bool {\n    &&& (c0_val(a) >> 51) <= (u64::MAX as u128)\n    &&& (c1_val(a) >> 51) <= (u64::MAX as u128)\n    &&& (c2_val(a) >> 51) <= (u64::MAX as u128)\n    &&& (c3_val(a) >> 51) <= (u64::MAX as u128)\n    &&& (c4_val(a) >> 51) <= (u64::MAX as u128)\n}",
      "start_line": 176,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "display_name": "spec_load8_at",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/core_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/core_specs.rs",
      "file_name": "core_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_load8_at(input: &[u8], i: usize) -> nat {\n    (pow2(0 * 8) * input[i + 0] +\n     pow2(1 * 8) * input[i + 1] +\n     pow2(2 * 8) * input[i + 2] +\n     pow2(3 * 8) * input[i + 3] +\n     pow2(4 * 8) * input[i + 4] +\n     pow2(5 * 8) * input[i + 5] +\n     pow2(6 * 8) * input[i + 6] +\n     pow2(7 * 8) * input[i + 7]) as nat\n}",
      "start_line": 93,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 18,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#double_and_compress_batch().",
      "display_name": "double_and_compress_batch",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#double_and_compress_batch().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn double_and_compress_batch<'a, I>(points: I) -> Vec<CompressedRistretto>\n    where\n        I: IntoIterator<Item = &'a RistrettoPoint>,\n    {\n        #[derive(Copy, Clone, Debug)]\n        struct BatchCompressState {\n            e: FieldElement,\n            f: FieldElement,\n            g: FieldElement,\n            h: FieldElement,\n            eg: FieldElement,\n            fh: FieldElement,\n        }\n\n        impl BatchCompressState {\n            fn efgh(&self) -> FieldElement {\n                &self.eg * &self.fh\n            }\n        }\n\n        impl<'a> From<&'a RistrettoPoint> for BatchCompressState {\n            #[rustfmt::skip] // keep alignment of explanatory comments\n            fn from(P: &'a RistrettoPoint) -> BatchCompressState {\n                let XX = P.0.X.square();\n                let YY = P.0.Y.square();\n                let ZZ = P.0.Z.square();\n                let dTT = &P.0.T.square() * &constants::EDWARDS_D;\n\n                let e = &P.0.X * &(&P.0.Y + &P.0.Y); // = 2*X*Y\n                let f = &ZZ + &dTT;                  // = Z^2 + d*T^2\n                let g = &YY + &XX;                   // = Y^2 - a*X^2\n                let h = &ZZ - &dTT;                  // = Z^2 - d*T^2\n\n                let eg = &e * &g;\n                let fh = &f * &h;\n\n                BatchCompressState{ e, f, g, h, eg, fh }\n            }\n        }\n\n        let states: Vec<BatchCompressState> =\n            points.into_iter().map(BatchCompressState::from).collect();\n\n        let mut invs: Vec<FieldElement> = states.iter().map(|state| state.efgh()).collect();\n\n        FieldElement::batch_invert(&mut invs[..]);\n\n        states\n            .iter()\n            .zip(invs.iter())\n            .map(|(state, inv): (&BatchCompressState, &FieldElement)| {\n                let Zinv = &state.eg * inv;\n                let Tinv = &state.fh * inv;\n\n                let mut magic = constants::INVSQRT_A_MINUS_D;\n\n                let negcheck1 = (&state.eg * &Zinv).is_negative();\n\n                let mut e = state.e;\n                let mut g = state.g;\n                let mut h = state.h;\n\n                let minus_e = -&e;\n                let f_times_sqrta = &state.f * &constants::SQRT_M1;\n\n                e.conditional_assign(&state.g, negcheck1);\n                g.conditional_assign(&minus_e, negcheck1);\n                h.conditional_assign(&f_times_sqrta, negcheck1);\n\n                magic.conditional_assign(&constants::SQRT_M1, negcheck1);\n\n                let negcheck2 = (&(&h * &e) * &Zinv).is_negative();\n\n                g.conditional_negate(negcheck2);\n\n                let mut s = &(&h - &g) * &(&magic * &(&g * &Tinv));\n\n                let s_is_negative = s.is_negative();\n                s.conditional_negate(s_is_negative);\n\n                CompressedRistretto(s.as_bytes())\n            })\n            .collect()\n    }",
      "start_line": 552,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "display_name": "as_radix_16",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn as_radix_16(&self) -> (result:\n        [i8; 64])\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n    // Top bit must be clear (scalar < 2^255)\n\n            self.bytes[31] <= 127,\n        ensures\n    // Result digits are in valid range\n\n            is_valid_radix_16(&result),\n            // Simple bounds: all digits in [-8, 8] for easy access\n            radix_16_all_bounded(&result),\n            // Reconstruction property: digits reconstruct the scalar value\n            reconstruct_radix_16(result@) == scalar_to_nat(self) as int,\n    {\n        // VERIFICATION NOTE: we tell verus not to verify debug assertions\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert!(self[31] <= 127);\n        let mut output = [0i8;64];\n\n        // Step 1: change radix.\n        // Convert from radix 256 (bytes) to radix 16 (nibbles)\n        // VERIFICATION NOTE: Moved helper functions outside for Verus compatibility\n        /* <ORIGINAL CODE>\n            #[allow(clippy::identity_op)]\n            #[inline(always)]\n            fn bot_half(x: u8) -> u8 {\n                (x >> 0) & 15\n            }\n            #[inline(always)]\n            fn top_half(x: u8) -> u8 {\n                (x >> 4) & 15\n            }\n\n            for i in 0..32 {\n                output[2 * i] = bot_half(self[i]) as i8;\n                output[2 * i + 1] = top_half(self[i]) as i8;\n            }\n            </ORIGINAL CODE> */\n        for i in 0..32 {\n            output[2 * i] = bot_half(self.bytes[i]) as i8;\n            output[2 * i + 1] = top_half(self.bytes[i]) as i8;\n        }\n        // Precondition note: since self[31] <= 127, output[63] <= 7\n\n        // Step 2: recenter coefficients from [0,16) to [-8,8)\n        for i in 0..63 {\n            assume(false);\n            let carry = (output[i] + 8) >> 4;\n            output[i] -= carry << 4;\n            /* <ORIGINAL CODE> :\n                output[i + 1] += carry;\n                </ORIGINAL CODE> */\n            // VERIFICATION NOTE: Changed += to explicit assignment for Verus compatibility\n            // Verus doesn't support += on indexed arrays with computed indices\n            let next_idx = i + 1;\n            output[next_idx] += carry;\n        }\n        // Precondition note: output[63] is not recentered.  It\n        // increases by carry <= 1.  Thus output[63] <= 8.\n\n        proof {\n            // postconditions\n            assume(is_valid_radix_16(&output));\n            assume(radix_16_all_bounded(&output));\n            assume(reconstruct_radix_16(output@) == scalar_to_nat(self) as int);\n        }\n\n        output\n    }",
      "start_line": 2192,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_rec_suffix_divisible().",
      "display_name": "lemma_rec_suffix_divisible",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_rec_suffix_divisible().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "file_name": "u8_32_as_nat_injectivity_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_rec_suffix_divisible(bytes: &[u8; 32], n: nat)\n    requires\n        n <= 32,\n    ensures\n        u8_32_as_nat_rec(bytes, n) % pow2((n * 8) as nat) == 0,\n    decreases (32 - n),\n{\n    lemma2_to64();\n\n    if n >= 32 {\n        // Base case: u8_32_as_nat_rec(bytes, 32) == 0\n        assert(u8_32_as_nat_rec(bytes, 32) == 0);\n        lemma_pow2_pos((32 * 8) as nat);\n        assert(0nat % pow2((32 * 8) as nat) == 0);\n    } else {\n        // Inductive step: show u8_32_as_nat_rec(bytes, n) is divisible by pow2(n*8)\n        let term1 = bytes[n as int] as nat * pow2((n * 8) as nat);\n        let d = pow2((n * 8) as nat);\n        lemma_pow2_pos((n * 8) as nat);\n\n        // Part 1: term1 = bytes[n] * d, so term1 % d = 0\n        assert((bytes[n as int] as nat * d) % d == 0) by {\n            lemma_mod_multiples_basic(bytes[n as int] as int, d as int);\n        }\n        assert(term1 % d == 0);\n\n        // Part 2: u8_32_as_nat_rec(bytes, n+1) is divisible by pow2((n+1)*8) by IH\n        assert(u8_32_as_nat_rec(bytes, (n + 1) as nat) % pow2(((n + 1) * 8) as nat) == 0) by {\n            lemma_rec_suffix_divisible(bytes, (n + 1) as nat);\n        }\n\n        // Since pow2((n+1)*8) == pow2(n*8) * pow2(8), it's also divisible by pow2(n*8)\n        assert(pow2(((n + 1) * 8) as nat) == pow2((n * 8) as nat) * pow2(8)) by {\n            lemma_pow2_adds((n * 8) as nat, 8);\n        }\n\n        // If x % (d * k) == 0, then x % d == 0 (follows from lemma_mod_breakdown)\n        let term2 = u8_32_as_nat_rec(bytes, (n + 1) as nat);\n        assert(term2 % d == 0) by {\n            lemma_mod_breakdown(term2 as int, d as int, pow2(8) as int);\n        }\n\n        // Part 3: Sum of two numbers divisible by d is divisible by d\n        assert((term1 + term2) % d == 0) by {\n            lemma_mod_sum_both_divisible(term1, term2, d);\n        }\n\n        // Conclusion: u8_32_as_nat_rec(bytes, n) == term1 + term2, so it's divisible by d\n        assert(u8_32_as_nat_rec(bytes, n) == term1 + term2);\n    }\n}",
      "start_line": 110,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_unique().",
      "display_name": "field_inv_unique",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_unique().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub proof fn field_inv_unique(a: nat, w: nat)\n    requires\n        a % p() != 0,\n        w < p(),\n        ((a % p()) * w) % p() == 1,\n    ensures\n        w == math_field_inv(a),\n{\n    let a_red = a % p();\n    let z = math_field_inv(a);\n\n    // Establish that z satisfies the inverse property\n    field_inv_property(a);\n\n    // Show a_red < p()\n    assert(a_red < p()) by {\n        lemma_mod_bound(a as int, p() as int);\n    };\n    // Show a_red % p() == a_red, which means a_red is in canonical form\n    assert(a_red % p() == a_red) by {\n        lemma_small_mod(a_red, p());\n    };\n    // Apply the core uniqueness lemma\n    // Both w and z are inverses of a_red in the canonical range [0, p)\n    lemma_inverse_unique_core(a_red, w, z, p());\n}",
      "start_line": 233,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/negate_affine_niels().",
      "display_name": "negate_affine_niels",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/negate_affine_niels().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn negate_affine_niels(p: AffineNielsPoint) -> AffineNielsPoint {\n    AffineNielsPoint {\n        y_plus_x: p.y_minus_x,\n        y_minus_x: p.y_plus_x,\n        xy2d: crate::field::FieldElement {\n            limbs: crate::specs::field_specs_u64::spec_negate(p.xy2d.limbs),\n        },\n    }\n}",
      "start_line": 565,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/bytes_match_limbs_packing().",
      "display_name": "bytes_match_limbs_packing",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/bytes_match_limbs_packing().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn bytes_match_limbs_packing(limbs: [u64; 5], bytes: [u8; 32]) -> bool {\n    bytes[0] == limbs[0] as u8 && bytes[1] == (limbs[0] >> 8) as u8 && bytes[2] == (limbs[0]\n        >> 16) as u8 && bytes[3] == (limbs[0] >> 24) as u8 && bytes[4] == (limbs[0] >> 32) as u8\n        && bytes[5] == (limbs[0] >> 40) as u8 && bytes[6] == ((limbs[0] >> 48) | (limbs[1]\n        << 3)) as u8 && bytes[7] == (limbs[1] >> 5) as u8 && bytes[8] == (limbs[1] >> 13) as u8\n        && bytes[9] == (limbs[1] >> 21) as u8 && bytes[10] == (limbs[1] >> 29) as u8 && bytes[11]\n        == (limbs[1] >> 37) as u8 && bytes[12] == ((limbs[1] >> 45) | (limbs[2] << 6)) as u8\n        && bytes[13] == (limbs[2] >> 2) as u8 && bytes[14] == (limbs[2] >> 10) as u8 && bytes[15]\n        == (limbs[2] >> 18) as u8 && bytes[16] == (limbs[2] >> 26) as u8 && bytes[17] == (limbs[2]\n        >> 34) as u8 && bytes[18] == (limbs[2] >> 42) as u8 && bytes[19] == ((limbs[2] >> 50) | (\n    limbs[3] << 1)) as u8 && bytes[20] == (limbs[3] >> 7) as u8 && bytes[21] == (limbs[3]\n        >> 15) as u8 && bytes[22] == (limbs[3] >> 23) as u8 && bytes[23] == (limbs[3] >> 31) as u8\n        && bytes[24] == (limbs[3] >> 39) as u8 && bytes[25] == ((limbs[3] >> 47) | (limbs[4]\n        << 4)) as u8 && bytes[26] == (limbs[4] >> 4) as u8 && bytes[27] == (limbs[4] >> 12) as u8\n        && bytes[28] == (limbs[4] >> 20) as u8 && bytes[29] == (limbs[4] >> 28) as u8 && bytes[30]\n        == (limbs[4] >> 36) as u8 && bytes[31] == (limbs[4] >> 44) as u8\n}",
      "start_line": 27,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 9,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "display_name": "math_field_add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn math_field_add(a: nat, b: nat) -> nat {\n    (a + b) % p()\n}",
      "start_line": 94,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 28,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_niels_corresponds_to_edwards().",
      "display_name": "projective_niels_corresponds_to_edwards",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_niels_corresponds_to_edwards().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn projective_niels_corresponds_to_edwards(\n    niels: ProjectiveNielsPoint,\n    point: EdwardsPoint,\n) -> bool {\n    let x = spec_field_element(&point.X);\n    let y = spec_field_element(&point.Y);\n    let z = spec_field_element(&point.Z);\n    let t = spec_field_element(&point.T);\n    let d = spec_field_element(&EDWARDS_D);\n\n    let y_plus_x = spec_field_element(&niels.Y_plus_X);\n    let y_minus_x = spec_field_element(&niels.Y_minus_X);\n    let niels_z = spec_field_element(&niels.Z);\n    let t2d = spec_field_element(&niels.T2d);\n\n    // Check the relationships\n    // 2d is computed as math_field_mul(2, d) in field arithmetic\n    &&& y_plus_x == math_field_add(y, x)\n    &&& y_minus_x == math_field_sub(y, x)\n    &&& niels_z == z\n    &&& t2d == math_field_mul(math_field_mul(2, d), t)\n}",
      "start_line": 413,
      "end_line": 57,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_corresponds_to_edwards().",
      "display_name": "montgomery_corresponds_to_edwards",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_corresponds_to_edwards().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn montgomery_corresponds_to_edwards(\n    montgomery: crate::montgomery::MontgomeryPoint,\n    edwards: crate::edwards::EdwardsPoint,\n) -> bool {\n    let u = spec_montgomery_point(montgomery);\n    let (x, y) = crate::specs::edwards_specs::edwards_point_as_affine(edwards);\n    let denominator = math_field_sub(1, y);\n\n    if denominator == 0 {\n        // Special case: Edwards identity (x=0, y=1) maps to Montgomery u=0\n        u == 0\n    } else {\n        // General case: u = (1+y)/(1-y)\n        let numerator = math_field_add(1, y);\n        u == math_field_mul(numerator, math_field_inv(denominator))\n    }\n}",
      "start_line": 191,
      "end_line": 51,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ValidityCheck#is_valid().",
      "display_name": "is_valid",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ValidityCheck#is_valid().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn is_valid(&self) -> (result: bool)\n        requires\n            edwards_point_limbs_bounded(*self),\n        ensures\n            result == is_valid_edwards_point(*self),\n    {\n        let proj = self.as_projective();\n        proof {\n            // The limb bounds are preserved by as_projective() (proj.X == self.X, etc.)\n            // and self has limbs_bounded from the preconditions\n            assert(fe51_limbs_bounded(&proj.X, 54));\n            assert(fe51_limbs_bounded(&proj.Y, 54));\n            assert(fe51_limbs_bounded(&proj.Z, 54));\n        }\n        let point_on_curve = proj.is_valid();\n\n        let on_segre_image = (&self.X * &self.Y) == (&self.Z * &self.T);\n\n        let result = point_on_curve && on_segre_image;\n        proof {\n            // postcondition: capturing both point_on_curve and on_segre_image\n            assume(result == is_valid_edwards_point(*self));\n        }\n        result\n    }",
      "start_line": 909,
      "end_line": 16,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_little_theorem().",
      "display_name": "lemma_fermat_little_theorem",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_little_theorem().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_fermat_little_theorem(x: nat, prime: nat)\n    requires\n        is_prime(prime),\n        x % prime != 0,\n    ensures\n        (pow(x as int, (prime - 1) as nat) as nat) % prime == 1,\n{\n    let n = (prime - 1) as nat;\n    let a = x % prime;\n\n    // a % prime == a since a < prime\n    assert(a < prime) by {\n        lemma_mod_bound(x as int, prime as int);\n    };\n    assert(a % prime == a) by {\n        lemma_small_mod(a, prime);\n    };\n    assert(a % prime != 0) by {\n        // x % prime != 0 and a = x % prime\n    };\n\n    // Step 1: product_of_multiples(a, n) = a^n * n! (by lemma_product_of_multiples_eq)\n    lemma_product_of_multiples_eq(a, n);\n    assert(product_of_multiples(a, n) == pow(a as int, n) as nat * factorial(n));\n\n    // Step 2: product_of_multiples(a, n) % prime == factorial(n) % prime (by permutation argument)\n    lemma_product_of_multiples_mod_eq_factorial(a, prime);\n    assert((product_of_multiples(a, n)) % prime == factorial(n) % prime);\n\n    // Step 3: (a^n * n!) % prime == n! % prime\n    // This means a^n * n! ≡ n! (mod prime)\n    // So (a^n - 1) * n! ≡ 0 (mod prime)\n\n    // Step 4: Since gcd(n!, prime) = 1 (because prime > n, so prime doesn't divide n!),\n    // we can conclude a^n ≡ 1 (mod prime)\n\n    // First show n! % prime != 0 (n = prime - 1 < prime)\n    lemma_factorial_coprime_to_prime(n, prime);\n    assert(factorial(n) % prime != 0);\n\n    // Now use cancellation: if a^n * n! ≡ n! (mod p) and gcd(n!, p) = 1, then a^n ≡ 1\n    // Need to verify the precondition: (pow(a, n) * factorial(n)) % prime == factorial(n) % prime\n    assert((pow(a as int, n) as nat * factorial(n)) % prime == factorial(n) % prime) by {\n        // product_of_multiples(a, n) % prime == factorial(n) % prime\n        // product_of_multiples(a, n) == pow(a, n) * factorial(n)\n        // So (pow(a, n) * factorial(n)) % prime == factorial(n) % prime\n    };\n    lemma_cancellation_mod_prime(pow(a as int, n) as nat, factorial(n), prime);\n    // Now we have: pow(a, n) % prime == 1\n    assert((pow(a as int, n) as nat) % prime == 1);\n\n    // Finally, pow(a, n) % prime == pow(x, n) % prime since a = x % prime\n    // lemma_pow_mod_noop gives: pow(x % prime, n) % prime == pow(x, n) % prime\n    lemma_pow_mod_noop(x as int, n, prime as int);\n\n    // We have: a = x % prime\n    // So pow(a, n) = pow(x % prime, n)\n    // By lemma_pow_mod_noop: pow(x % prime, n) % prime == pow(x, n) % prime\n    // We proved: pow(a, n) % prime == 1\n    // Therefore: pow(x, n) % prime == 1\n\n    // pow(a, n) is non-negative since both a and n are non-negative\n    assert(pow(a as int, n) >= 0) by {\n        if a > 0 {\n            lemma_pow_positive(a as int, n);\n        } else {\n            // a == 0, but a % prime != 0, contradiction\n            assert(a == 0);\n            assert(a % prime == 0) by {\n                lemma_small_mod(0nat, prime);\n            };\n        }\n    };\n\n    // Since a = x % prime, pow(a, n) = pow(x % prime, n)\n    // pow_mod_noop: pow((x % prime) as int, n) % prime == pow(x as int, n) % prime\n    assert(pow(a as int, n) % (prime as int) == pow(x as int, n) % (prime as int)) by {\n        assert(a == (x % prime) as nat);\n        assert(a as int == (x as int) % (prime as int)) by {\n            lemma_mod_bound(x as int, prime as int);\n        };\n    };\n\n    // Converting the int result to nat for the postcondition\n    assert((pow(x as int, n) as nat) % prime == 1) by {\n        // pow(a, n) % prime == 1 (as nat)\n        // pow(a, n) % prime == pow(x, n) % prime (as int)\n        // So pow(x, n) % prime == 1 (as int)\n        // Since pow(x, n) >= 0 and prime > 0, pow(x, n) % prime >= 0\n        assert(pow(x as int, n) >= 0) by {\n            if x > 0 {\n                lemma_pow_positive(x as int, n);\n            } else {\n                // x == 0, but x % prime != 0, contradiction\n                assert(x == 0);\n                lemma_small_mod(0nat, prime);\n                assert(false);\n            }\n        };\n    };\n}",
      "start_line": 1468,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 12
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_to_array_32().",
      "display_name": "seq_to_array_32",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_to_array_32().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub open spec fn seq_to_array_32(s: Seq<u8>) -> [u8; 32] {\n    [\n        s[0],\n        s[1],\n        s[2],\n        s[3],\n        s[4],\n        s[5],\n        s[6],\n        s[7],\n        s[8],\n        s[9],\n        s[10],\n        s[11],\n        s[12],\n        s[13],\n        s[14],\n        s[15],\n        s[16],\n        s[17],\n        s[18],\n        s[19],\n        s[20],\n        s[21],\n        s[22],\n        s[23],\n        s[24],\n        s[25],\n        s[26],\n        s[27],\n        s[28],\n        s[29],\n        s[30],\n        s[31],\n    ]\n}",
      "start_line": 241,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#efgh().",
      "display_name": "efgh",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#efgh().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "            fn efgh(&self) -> FieldElement {\n                &self.eg * &self.fh\n            }",
      "start_line": 567,
      "end_line": 20,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Neg#neg().",
      "display_name": "neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Neg#neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn neg(\n        self,\n    ) -> EdwardsPoint/* requires clause in NegSpecImpl for EdwardsPoint above:\n            requires fe51_limbs_bounded(&self.X, 51) && fe51_limbs_bounded(&self.T, 51)\n        */\n     {\n        /* ORIGINAL CODE\n        -&self\n        */\n        // REFACTORED: Use explicit Neg::neg() call to avoid Verus type inference issues\n        use core::ops::Neg;\n        Neg::neg(&self)\n    }",
      "start_line": 1626,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_one().",
      "display_name": "lemma_pow_mod_one",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_one().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow_mod_one(x: int, n: nat, m: int)\n    requires\n        m > 1,\n        x % m == 1,\n    ensures\n        pow(x, n) % m == 1,\n    decreases n,\n{\n    if n == 0 {\n        assert(pow(x, 0) == 1) by { lemma_pow0(x) };\n        assert(1int % m == 1) by { lemma_small_mod(1nat, m as nat) };\n        assert(pow(x, n) % m == 1);\n    } else {\n        lemma_pow_mod_one(x, (n - 1) as nat, m);\n        // pow(x,n) == pow(x,n-1) * x\n        assert(pow(x, n) == pow(x, (n - 1) as nat) * x) by {\n            lemma_pow_adds(x, 1, (n - 1) as nat);\n            lemma_pow1(x);\n        };\n\n        // x^n = x^(n - 1) * x (mod m)\n        assert(pow(x, n) % m == (pow(x, (n - 1) as nat) * x) % m);\n        assert(pow(x, n) % m == ((pow(x, (n - 1) as nat) % m) * (x % m)) % m) by {\n            lemma_mul_mod_noop(pow(x, (n - 1) as nat), x, m);\n        };\n\n        assert(pow(x, n) % m == (1int * 1int) % m);\n        assert(pow(x, n) % m == 1int % m);\n        assert(1int % m == 1) by { lemma_small_mod(1nat, m as nat) };\n        assert(pow(x, n) % m == 1);\n    }\n}",
      "start_line": 833,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_and().",
      "display_name": "choice_and",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_and().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn choice_and(a: Choice, b: Choice) -> (c: Choice)\n    ensures\n        choice_is_true(c) == (choice_is_true(a) && choice_is_true(b)),\n{\n    use core::ops::BitAnd;\n    a.bitand(b)\n}",
      "start_line": 121,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo std https://github.com/rust-lang/rust/library/std env/var().",
      "display_name": "var",
      "symbol": "rust-analyzer cargo std https://github.com/rust-lang/rust/library/std env/var().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "curve25519-dalek/build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_inverse_correct().",
      "display_name": "lemma_mod_inverse_correct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_inverse_correct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_mod_inverse_correct(a: nat, m: nat)\n    requires\n        m > 1,\n        spec_gcd(a % m, m) == 1,\n    ensures\n        spec_mod_inverse(a, m) < m,\n        (a * spec_mod_inverse(a, m)) % m == 1,\n{\n    let a_red = a % m;\n    let r = spec_extended_gcd(a_red, m);\n\n    lemma_bezout_identity(a_red, m);\n    lemma_extended_gcd_is_gcd(a_red, m);\n\n    // (m * r.y) % m = 0\n    assert((m as int * r.y) % (m as int) == 0) by {\n        lemma_mul_is_commutative(m as int, r.y);\n        lemma_mod_multiples_basic(r.y, m as int);\n    };\n\n    // (a_red * r.x) % m = 1\n    assert((a_red as int * r.x) % (m as int) == 1) by {\n        lemma_add_mod_noop(a_red as int * r.x, m as int * r.y, m as int);\n        lemma_mod_twice(a_red as int * r.x, m as int);\n        lemma_small_mod(1nat, m);\n    };\n\n    let inv = spec_mod_inverse(a, m);\n    let normalized_x = (((r.x % (m as int)) + (m as int)) % (m as int)) as nat;\n\n    assert(inv < m) by {\n        lemma_mod_bound((r.x % (m as int)) + (m as int), m as int);\n    };\n\n    // normalized_x ≡ r.x (mod m)\n    assert((normalized_x as int) % (m as int) == r.x % (m as int)) by {\n        lemma_add_mod_noop(r.x % (m as int), m as int, m as int);\n        lemma_mod_self_0(m as int);\n        lemma_mod_twice(r.x, m as int);\n    };\n\n    // (a_red * normalized_x) % m = 1\n    assert((a_red as int * normalized_x as int) % (m as int) == 1) by {\n        lemma_mul_mod_noop_right(a_red as int, normalized_x as int, m as int);\n        lemma_mul_mod_noop_right(a_red as int, r.x, m as int);\n    };\n\n    // (a * inv) % m = 1\n    assert((a * inv) % m == 1) by {\n        lemma_mul_mod_noop_left(a as int, inv as int, m as int);\n    };\n}",
      "start_line": 977,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "display_name": "is_zero",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "curve25519-dalek/src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn is_zero(&self) -> (result:\n        Choice)/* VERIFICATION NOTE:\n    - PROOF BYPASS AND SPEC BYPASS\n    - we cannot write this directly; need to find a spec function for FieldElement51::as_bytes\n    ensures choice_is_true(result) == (self.as_bytes() == [0u8; 32])\n    - (note: maybe an all_zeroes(as_bytes(...)) is sufficient as a spec)\n    </VERIFICATION NOTE> */\n\n        ensures\n    // SPEC BYPASS through placeholder spec_fe51_to_bytes\n\n            choice_is_true(result) == (spec_fe51_to_bytes(self) == seq![0u8; 32]),\n    {\n        let zero = [0u8;32];\n        let bytes = self.as_bytes();\n\n        let result = ct_eq_bytes32(&bytes, &zero);\n\n        proof {\n            // Proof: choice_is_true(result) == (spec_fe51_to_bytes(self) == seq![0u8; 32])\n            //\n            // From ct_eq_bytes32 postcondition: choice_is_true(result) == (bytes == zero)\n            // From as_bytes() postcondition: u8_32_as_nat(&bytes) == u64_5_as_nat(self.limbs) % p()\n            //\n            // Apply lemma to establish: seq_from32(&bytes) == spec_fe51_to_bytes(self)\n            lemma_as_bytes_equals_spec_fe51_to_bytes(self, &bytes);\n\n            // Prove bidirectional implication: (bytes == zero) <==> (spec_fe51_to_bytes(self) == seq![0u8; 32])\n\n            if bytes == zero {\n                // Forward: byte array equality implies spec equality\n                assert(spec_fe51_to_bytes(self) == seq![0u8; 32]);\n            }\n            if spec_fe51_to_bytes(self) == seq![0u8; 32] {\n                // Backward: spec equality implies byte array equality\n                assert(seq_from32(&bytes) == seq_from32(&zero));\n                assert(bytes == zero);\n            }\n        }\n\n        result\n    }",
      "start_line": 247,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "display_name": "as_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn as_bytes(self) -> (s: [u8; 32])\n        requires\n            limbs_bounded(&self),\n        ensures\n            bytes_to_nat(&s) == to_nat(&self.limbs) % pow2(256),\n    {\n        let mut s = [0u8;32];\n\n        s[0] = (self.limbs[0] >> 0) as u8;\n        s[1] = (self.limbs[0] >> 8) as u8;\n        s[2] = (self.limbs[0] >> 16) as u8;\n        s[3] = (self.limbs[0] >> 24) as u8;\n        s[4] = (self.limbs[0] >> 32) as u8;\n        s[5] = (self.limbs[0] >> 40) as u8;\n        s[6] = ((self.limbs[0] >> 48) | (self.limbs[1] << 4)) as u8;\n        s[7] = (self.limbs[1] >> 4) as u8;\n        s[8] = (self.limbs[1] >> 12) as u8;\n        s[9] = (self.limbs[1] >> 20) as u8;\n        s[10] = (self.limbs[1] >> 28) as u8;\n        s[11] = (self.limbs[1] >> 36) as u8;\n        s[12] = (self.limbs[1] >> 44) as u8;\n        s[13] = (self.limbs[2] >> 0) as u8;\n        s[14] = (self.limbs[2] >> 8) as u8;\n        s[15] = (self.limbs[2] >> 16) as u8;\n        s[16] = (self.limbs[2] >> 24) as u8;\n        s[17] = (self.limbs[2] >> 32) as u8;\n        s[18] = (self.limbs[2] >> 40) as u8;\n        s[19] = ((self.limbs[2] >> 48) | (self.limbs[3] << 4)) as u8;\n        s[20] = (self.limbs[3] >> 4) as u8;\n        s[21] = (self.limbs[3] >> 12) as u8;\n        s[22] = (self.limbs[3] >> 20) as u8;\n        s[23] = (self.limbs[3] >> 28) as u8;\n        s[24] = (self.limbs[3] >> 36) as u8;\n        s[25] = (self.limbs[3] >> 44) as u8;\n        s[26] = (self.limbs[4] >> 0) as u8;\n        s[27] = (self.limbs[4] >> 8) as u8;\n        s[28] = (self.limbs[4] >> 16) as u8;\n        s[29] = (self.limbs[4] >> 24) as u8;\n        s[30] = (self.limbs[4] >> 32) as u8;\n        s[31] = (self.limbs[4] >> 40) as u8;\n\n        proof {\n            // The main lemma proves the property using the non-recursive (_aux) versions\n            lemma_as_bytes_52(self.limbs, s);\n            lemma_five_limbs_equals_to_nat(&self.limbs);\n        }\n\n        s\n    }",
      "start_line": 415,
      "end_line": 20,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_scalar_mul_u().",
      "display_name": "montgomery_scalar_mul_u",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_scalar_mul_u().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn montgomery_scalar_mul_u(u: nat, n: nat) -> nat {\n    // Compute full scalar mul and extract u-coordinate\n    montgomery_affine_u(\n        montgomery_scalar_mul(\n            MontgomeryAffine::Finite { u, v: canonical_sqrt(montgomery_rhs(u)) },\n            n,\n        ),\n    )\n}",
      "start_line": 346,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#Clone#clone().",
      "display_name": "clone",
      "symbol": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#Clone#clone().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_canonical_bytes_equal().",
      "display_name": "lemma_canonical_bytes_equal",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_canonical_bytes_equal().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "file_name": "u8_32_as_nat_injectivity_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_canonical_bytes_equal(bytes1: &[u8; 32], bytes2: &[u8; 32])\n    requires\n        u8_32_as_nat(bytes1) == u8_32_as_nat(bytes2),\n    ensures\n        forall|i: int| 0 <= i < 32 ==> bytes1[i] == bytes2[i],\n{\n    assert forall|i: int| 0 <= i < 32 implies #[trigger] bytes1[i] == bytes2[i] by {\n        // Extract byte i from both arrays\n        lemma_extract_byte_at_index(bytes1, i as nat);\n        lemma_extract_byte_at_index(bytes2, i as nat);\n\n        // Since u8_32_as_nat(bytes1) == u8_32_as_nat(bytes2), the extracted bytes must be equal\n        assert(bytes1[i] as nat == (u8_32_as_nat(bytes1) / pow2((i as nat) * 8)) % pow2(8));\n        assert(bytes2[i] as nat == (u8_32_as_nat(bytes2) / pow2((i as nat) * 8)) % pow2(8));\n        assert(bytes1[i] == bytes2[i]);\n    }\n}",
      "start_line": 343,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_scalar52_lt_pow2_256_if_canonical().",
      "display_name": "lemma_scalar52_lt_pow2_256_if_canonical",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_scalar52_lt_pow2_256_if_canonical().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_scalar52_lt_pow2_256_if_canonical(a: &Scalar52)\n    requires\n        limbs_bounded(a),\n        to_nat(&a.limbs) < group_order(),\n    ensures\n        to_nat(&a.limbs) < pow2(256),\n{\n    // group_order() < 2^255\n    lemma_group_order_bound();\n\n    // Chain: to_nat(a) < group_order() < 2^255 < 2^256\n    calc! {\n        (<)\n        to_nat(&a.limbs); {  /* from precondition */\n        }\n        group_order(); {  /* from lemma_group_order_bound */\n        }\n        pow2(255); {\n            vstd::arithmetic::power2::lemma_pow2_strictly_increases(255, 256);\n        }\n        pow2(256);\n    }\n}",
      "start_line": 1659,
      "end_line": 53,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_as_nat_bound_from_51bit_limbs().",
      "display_name": "lemma_as_nat_bound_from_51bit_limbs",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_as_nat_bound_from_51bit_limbs().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_as_nat_bound_from_51bit_limbs(limbs: [u64; 5])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51),\n    ensures\n        u64_5_as_nat(limbs) < pow2(255),\n{\n    // Strategy: Prove that the maximum value (when all limbs = 2^51 - 1) equals 2^255 - 1\n    // We'll prove this by showing the algebraic identity directly using bit manipulation\n    lemma2_to64_rest();\n    assert((1u64 << 51) as nat == pow2(51)) by (compute);\n\n    // Establish power-of-2 relationships\n    lemma_pow2_adds(51, 51);  // 2^102 = 2^51 * 2^51\n    lemma_pow2_adds(51, 102);  // 2^153 = 2^51 * 2^102\n    lemma_pow2_adds(51, 153);  // 2^204 = 2^51 * 2^153\n    lemma_pow2_adds(51, 204);  // 2^255 = 2^51 * 2^204\n\n    // Expand u64_5_as_nat definition\n    assert(u64_5_as_nat(limbs) == limbs[0] as nat + pow2(51) * limbs[1] as nat + pow2(102)\n        * limbs[2] as nat + pow2(153) * limbs[3] as nat + pow2(204) * limbs[4] as nat);\n\n    // Each limb < 2^51, so limbs[i] <= 2^51 - 1\n    lemma_pow2_pos(51);\n    let max_limb = (pow2(51) - 1) as nat;\n\n    // Prove upper bound for each term\n    lemma_mul_upper_bound(pow2(51), limbs[1] as nat, max_limb);\n\n    lemma_mul_upper_bound(pow2(102), limbs[2] as nat, max_limb);\n\n    lemma_mul_upper_bound(pow2(153), limbs[3] as nat, max_limb);\n\n    lemma_mul_upper_bound(pow2(204), limbs[4] as nat, max_limb);\n\n    // Therefore, u64_5_as_nat(limbs) <= sum of maximum values\n    // u64_5_as_nat(limbs) <= max_limb + pow2(51)*max_limb + pow2(102)*max_limb + pow2(153)*max_limb + pow2(204)*max_limb\n    //                = max_limb * (1 + pow2(51) + pow2(102) + pow2(153) + pow2(204))\n\n    // Since each term is maximized at max_limb = 2^51 - 1, we have:\n    let max_val = max_limb + pow2(51) * max_limb + pow2(102) * max_limb + pow2(153) * max_limb\n        + pow2(204) * max_limb;\n\n    // Factor out max_limb using distributivity\n    lemma_mul_is_distributive_add(max_limb as int, 1, pow2(51) as int);\n    lemma_mul_is_distributive_add(max_limb as int, (1 + pow2(51)) as int, pow2(102) as int);\n    lemma_mul_is_distributive_add(\n        max_limb as int,\n        (1 + pow2(51) + pow2(102)) as int,\n        pow2(153) as int,\n    );\n    lemma_mul_is_distributive_add(\n        max_limb as int,\n        (1 + pow2(51) + pow2(102) + pow2(153)) as int,\n        pow2(204) as int,\n    );\n\n    // Now use the geometric series identity: (2^51 - 1) * (1 + 2^51 + 2^102 + 2^153 + 2^204) = 2^255 - 1\n    lemma_geometric_sum_5_terms();\n\n    // Since u64_5_as_nat(limbs) <= max_val = 2^255 - 1 < 2^255, we're done\n    assert(pow2(255) - 1 < pow2(255)) by {\n        lemma_pow2_pos(255);\n    }\n}",
      "start_line": 282,
      "end_line": 49,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "display_name": "is_canonical_scalar",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_canonical_scalar(s: &Scalar) -> bool {\n    // Invariant #2: Scalar is reduced (< group order)\n    bytes_to_nat(&s.bytes)\n        < group_order()\n    // Invariant #1: High bit is clear (< 2^255)\n     && s.bytes[31] <= 127\n}",
      "start_line": 46,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 14,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "display_name": "montgomery_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn montgomery_mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n        requires\n            limbs_bounded(a),\n            limbs_bounded(b),\n        ensures\n            limbs_bounded(&result),\n            (to_nat(&result.limbs) * montgomery_radix()) % group_order() == (to_nat(&a.limbs)\n                * to_nat(&b.limbs)) % group_order(),\n    {\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b))\n    }",
      "start_line": 1121,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_assign().",
      "display_name": "conditional_assign",
      "symbol": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from16().",
      "display_name": "seq_from16",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from16().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub open spec fn seq_from16(b: &[u8; 16]) -> Seq<u8> {\n    Seq::new(16, |i: int| b[i])\n}",
      "start_line": 78,
      "end_line": 28,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb1_byte_contribution_52().",
      "display_name": "limb1_byte_contribution_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb1_byte_contribution_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub open spec fn limb1_byte_contribution_52(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    // Byte 6 high 4 bits (limbs[1]'s bits 0-3)\n    ((limbs[1] as nat % pow2(4)) * 16) * pow2(6 * 8) +\n    bytes[ 7] as nat * pow2( 7 * 8) +\n    bytes[ 8] as nat * pow2( 8 * 8) +\n    bytes[ 9] as nat * pow2( 9 * 8) +\n    bytes[10] as nat * pow2(10 * 8) +\n    bytes[11] as nat * pow2(11 * 8) +\n    bytes[12] as nat * pow2(12 * 8)\n}",
      "start_line": 85,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_congruent().",
      "display_name": "lemma_pow_mod_congruent",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_congruent().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow_mod_congruent(a: int, b: int, n: nat, m: int)\n    requires\n        m > 0,\n        a % m == b % m,\n    ensures\n        pow(a, n) % m == pow(b, n) % m,\n{\n    lemma_pow_mod_noop(a, n, m);\n    lemma_pow_mod_noop(b, n, m);\n}",
      "start_line": 897,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_edwards_identity().",
      "display_name": "math_edwards_identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_edwards_identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn math_edwards_identity() -> (nat, nat) {\n    (0, 1)\n}",
      "start_line": 192,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mod_u8().",
      "display_name": "lemma_pow2_mul_div_mod_small_mod_u8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mod_u8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_mul_div_mod_small_mod_u8(x: u8, k: nat, s: nat, t: nat)\n    requires\n        s <= k,\n        t <= k - s,\n    ensures\n        ((x as nat * pow2(k)) / pow2(s)) % pow2(t) == 0,\n{\n    assert(x < pow2(8)) by {\n        lemma2_to64();  // pow2(8)\n    }\n    lemma_pow2_mul_div_mod_small_mod(x as nat, 8, k, s, t);\n}",
      "start_line": 614,
      "end_line": 49,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_lemmas/lemmas/u8_32_as_nat_le_pow2_256().",
      "display_name": "u8_32_as_nat_le_pow2_256",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_lemmas/lemmas/u8_32_as_nat_le_pow2_256().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/core_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/core_lemmas.rs",
      "file_name": "core_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn u8_32_as_nat_le_pow2_256(bytes: &[u8; 32])\n    ensures\n        u8_32_as_nat(&bytes) < pow2(256),\n        u8_32_as_nat(&bytes) == u8_32_as_nat(&bytes) % pow2(256),\n{\n    assert forall|i: nat| 0 <= i <= 31 implies #[trigger] bytes[i as int] * pow2(i * 8) <= pow2(\n        (i + 1) * 8,\n    ) - pow2(i * 8) by {\n        let b = bytes[i as int];\n        assert(b < pow2(8)) by {\n            lemma_u8_lt_pow2_8(b);\n        }\n        lemma_pow2_mul_bound_general(b as nat, 8, i * 8);\n        assert(i * 8 + 8 == (i + 1) * 8) by {\n            lemma_mul_is_distributive_add_other_way(i as int, 1, 8);\n        }\n    }\n    assert(pow2(0 * 8) == 1) by {\n        lemma2_to64();\n    }\n    assert(u8_32_as_nat(&bytes) % pow2(256) == u8_32_as_nat(&bytes)) by {\n        lemma_small_mod(u8_32_as_nat(&bytes), pow2(256));\n    }\n}",
      "start_line": 13,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_clamped().",
      "display_name": "mul_clamped",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_clamped().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_clamped(self, bytes: [u8; 32]) -> (result: Self)\n        requires\n            is_well_formed_edwards_point(self),\n        ensures\n            is_well_formed_edwards_point(result),\n            // Result is scalar multiplication of self by the clamped scalar\n            edwards_point_as_affine(result) == edwards_scalar_mul(\n                edwards_point_as_affine(self),\n                spec_scalar(&Scalar { bytes: spec_clamp_integer(bytes) }),\n            ),",
      "start_line": 1743,
      "end_line": 23,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bit_or_is_plus().",
      "display_name": "lemma_bit_or_is_plus",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bit_or_is_plus().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/bit_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/bit_lemmas.rs",
      "file_name": "bit_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_bit_or_is_plus(a: u64, b: u64, k: u64)\n    by (bit_vector)\n    requires\n        b <= (u64::MAX >> k),\n        a < 1u64 << k,\n    ensures\n        a | (b << k) == a + (b << k),\n{\n}",
      "start_line": 28,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_carry_and_sum_bounds().",
      "display_name": "lemma_add_carry_and_sum_bounds",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_carry_and_sum_bounds().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_add_carry_and_sum_bounds(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) < 2,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n\n    lemma_pow2_pos(52);\n    lemma_shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}",
      "start_line": 315,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "display_name": "sqrt_ratio_i",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "curve25519-dalek/src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn sqrt_ratio_i(u: &FieldElement, v: &FieldElement) -> (result: (\n        Choice,\n        FieldElement,\n    ))\n        requires\n            // Input bounds for sqrt_ratio_i\n            // u and v can be up to 54-bit bounded (from sub/add operations in decompress)\n            fe51_limbs_bounded(u, 54),\n            fe51_limbs_bounded(v, 54),\n        ensures\n    // When u = 0: always return (true, 0)\n\n            (spec_field_element(u) == 0) ==> (choice_is_true(result.0) && spec_field_element(\n                &result.1,\n            ) == 0),\n            // When v = 0 but u ≠ 0: return (false, 0) [division by zero case]\n            (spec_field_element(v) == 0 && spec_field_element(u) != 0) ==> (!choice_is_true(\n                result.0,\n            ) && spec_field_element(&result.1) == 0),\n            // When successful and v ≠ 0: r² * v ≡ u (mod p)\n            (choice_is_true(result.0) && spec_field_element(v) != 0) ==> is_sqrt_ratio(\n                u,\n                v,\n                &result.1,\n            ),\n            // When unsuccessful and v ≠ 0: r² * v ≡ i*u (mod p) [nonsquare case]\n            (!choice_is_true(result.0) && spec_field_element(v) != 0 && spec_field_element(u) != 0)\n                ==> is_sqrt_ratio_times_i(\n                u,\n                v,\n                &result.1,\n            ),\n            // NEW: The result is always the \"non-negative\" square root (LSB = 0)\n            // This is a fundamental property of sqrt_ratio_i that the original code\n            // relies on for decompression sign bit handling\n            (spec_field_element(&result.1) % p()) % 2 == 0,\n            // NEW: The result is bounded (reduced mod p)\n            spec_field_element(&result.1) < p(),\n            // Limb bounds: result is 52-bit bounded (from conditional_negate)\n            fe51_limbs_bounded(&result.1, 52),\n    // VERIFICATION NOTE: PROOF BYPASS\n\n    {\n        // Using the same trick as in ed25519 decoding, we merge the\n        // inversion, the square root, and the square test as follows.\n        //\n        // To compute sqrt(α), we can compute β = α^((p+3)/8).\n        // Then β^2 = ±α, so multiplying β by sqrt(-1) if necessary\n        // gives sqrt(α).\n        //\n        // To compute 1/sqrt(α), we observe that\n        //    1/β = α^(p-1 - (p+3)/8) = α^((7p-11)/8)\n        //                            = α^3 * (α^7)^((p-5)/8).\n        //\n        // We can therefore compute sqrt(u/v) = sqrt(u)/sqrt(v)\n        // by first computing\n        //    r = u^((p+3)/8) v^(p-1-(p+3)/8)\n        //      = u u^((p-5)/8) v^3 (v^7)^((p-5)/8)\n        //      = (uv^3) (uv^7)^((p-5)/8).\n        //\n        // If v is nonzero and u/v is square, then r^2 = ±u/v,\n        //                                     so vr^2 = ±u.\n        // If vr^2 =  u, then sqrt(u/v) = r.\n        // If vr^2 = -u, then sqrt(u/v) = r*sqrt(-1).\n        //\n        // If v is zero, r is also zero.\n        proof {\n            // ALGEBRAIC CORRECTNESS PROOF STRUCTURE:\n            // 1. p ≡ 5 (mod 8), so the algorithm works\n            lemma_p_mod_8_eq_5();\n            \n            // 2. The key algebraic property: v*r² = u * (4th root of unity)\n            //    where r = (uv³)(uv⁷)^((p-5)/8)\n            //    This means check ∈ {u, -u, u*i, -u*i}\n            \n            // 3. If check = u: return (true, r)\n            // 4. If check = -u: return (true, r*i) since (r*i)²*v = -r²*v = u\n            // 5. If check = u*i: return (false, r) - u/v is not a square, but i*u/v is\n            // 6. If check = -u*i: return (false, r*i) since (r*i)²*v = -r²*v = u*i\n            \n            // The detailed proofs for each case use the lemmas in sqrt_ratio_lemmas.rs:\n            //\n            // Case 4 (check = -u): after r ← r*i, we have v·r² = u\n            //   → lemma_flipped_sign_becomes_correct(u_math, v_math, r_math)\n            //\n            // Case 6 (check = -u*i): after r ← r*i, we have v·r² = u*i\n            //   → lemma_flipped_sign_becomes_correct(u_math * spec_sqrt_m1(), v_math, r_math)\n            //\n            // For now, we assume the algebraic correctness\n            assume(false);  // TODO: Replace with full algebraic proof using lemmas above\n        }\n        // BOUNDS TRACKING:\n        // v is 54-bit bounded (from requires)\n        // v.square() requires 54-bit, produces 52-bit\n        let v3 = &v.square() * v;\n        proof {\n            // v² is 52-bit, v is 54-bit, mul produces 52-bit\n            // Since 52 < 54, v² qualifies as 54-bit input\n            assert((1u64 << 52) < (1u64 << 54)) by (bit_vector);\n            assert(fe51_limbs_bounded(&v3, 52));  // from mul postcondition\n        }\n        let v7 = &v3.square() * v;\n        proof {\n            // v3² is 52-bit, v is 54-bit, mul produces 52-bit\n            assert(fe51_limbs_bounded(&v7, 52));  // from mul postcondition\n        }\n        let uv3 = u * &v3;\n        let uv7 = u * &v7;\n        proof {\n            // u is 54-bit, v3/v7 are 52-bit < 54-bit, mul produces 52-bit\n            assert(fe51_limbs_bounded(&uv3, 52));\n            assert(fe51_limbs_bounded(&uv7, 52));\n        }\n        let uv7_pow = uv7.pow_p58();\n        proof {\n            // pow_p58 requires 54-bit (52 < 54 ✓), produces 54-bit\n            assert(fe51_limbs_bounded(&uv7_pow, 54));\n        }\n        let mut r = &uv3 * &uv7_pow;\n        proof {\n            // uv3 is 52-bit < 54-bit, uv7_pow is 54-bit, mul produces 52-bit\n            assert(fe51_limbs_bounded(&r, 52));  // from mul postcondition\n        }\n        let check = v * &r.square();\n\n        let i = &constants::SQRT_M1;\n\n        let correct_sign_sqrt = check.ct_eq(u);\n\n        // ORIGINAL CODE:\n        // let flipped_sign_sqrt = check.ct_eq(&(-u));\n        // let flipped_sign_sqrt_i = check.ct_eq(&(&(-u) * i));\n        // REFACTORED: Use wrapper to avoid Verus internal error with negation\n        let u_neg = negate_field(u);\n        let flipped_sign_sqrt = check.ct_eq(&u_neg);\n        let flipped_sign_sqrt_i = check.ct_eq(&(&u_neg * i));\n\n        let r_prime = &constants::SQRT_M1 * &r;\n        proof {\n            // SQRT_M1 is 51-bit < 54-bit, r is 52-bit < 54-bit, mul produces 52-bit\n            assert(fe51_limbs_bounded(&r_prime, 52));\n        }\n        // ORIGINAL CODE:\n        // r.conditional_assign(&r_prime, flipped_sign_sqrt | flipped_sign_sqrt_i);\n        // REFACTORED: Use wrapper for Choice bitwise OR\n        let ghost r_before_assign = r;\n        let the_choice = choice_or(flipped_sign_sqrt, flipped_sign_sqrt_i);\n        r.conditional_assign(&r_prime, the_choice);\n        proof {\n            // conditional_assign ensures:\n            // - If choice is false: r.limbs[i] == r_before_assign.limbs[i] (52-bit)\n            // - If choice is true: r.limbs[i] == r_prime.limbs[i] (52-bit)\n            // Either way, result is 52-bit bounded\n            assert(fe51_limbs_bounded(&r_before_assign, 52));\n            assert(fe51_limbs_bounded(&r_prime, 52));\n            // Prove bounds preservation for each limb\n            assert forall|i: int| 0 <= i < 5 implies r.limbs[i] < (1u64 << 52) by {\n                if choice_is_true(the_choice) {\n                    // r.limbs[i] == r_prime.limbs[i] < 2^52\n                    assert(r.limbs[i] == r_prime.limbs[i]);\n                    assert(r_prime.limbs[i] < (1u64 << 52));\n                } else {\n                    // r.limbs[i] == r_before_assign.limbs[i] < 2^52\n                    assert(r.limbs[i] == r_before_assign.limbs[i]);\n                    assert(r_before_assign.limbs[i] < (1u64 << 52));\n                }\n            }\n            assert(fe51_limbs_bounded(&r, 52));\n        }\n\n        // Choose the nonnegative square root.\n        let r_is_negative = r.is_negative();\n        // ORIGINAL CODE:\n        // r.conditional_negate(r_is_negative);\n        // REFACTORED: Use specialized wrapper with specs\n        conditional_negate_field_element(&mut r, r_is_negative);\n\n        // ORIGINAL CODE:\n        // let was_nonzero_square = correct_sign_sqrt | flipped_sign_sqrt;\n        // REFACTORED: Use wrapper for Choice bitwise OR\n        let was_nonzero_square = choice_or(correct_sign_sqrt, flipped_sign_sqrt);\n\n        (was_nonzero_square, r)\n    }",
      "start_line": 795,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_one_canonical().",
      "display_name": "prop_montgomery_reduce_one_canonical",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_one_canonical().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "        fn prop_montgomery_reduce_one_canonical(limbs in arb_nine_limbs_one_canonical()) {\n            // Call montgomery_reduce\n            let result = Scalar52::montgomery_reduce(&limbs);\n\n            // Convert to BigUint using executable spec functions\n            let result_nat = to_nat_exec(&result.limbs);\n            let limbs_nat = slice128_to_nat_exec(&limbs);\n            let l = group_order_exec();\n            let r = montgomery_radix_exec();\n\n            // Postcondition 1: Montgomery property (holds by first part of spec)\n            let lhs = (&result_nat * &r) % &l;\n            let rhs = &limbs_nat % &l;\n            prop_assert_eq!(lhs, rhs,\n                \"Montgomery reduce spec violated: (result * R) mod L != limbs mod L\");\n\n            // Postcondition 2: limbs_bounded (holds by first part of spec)\n            prop_assert!(limbs_bounded_exec(&result),\n                \"Result limbs not bounded by 2^52\");\n\n            // Postcondition 3: Canonicality - SHOULD hold by second part of spec\n            // (exists bounded, canonical such that limbs = mul(bounded, canonical)) ==> result < L\n            prop_assert!(&result_nat < &l,\n                \"Result not in canonical form (>= L), but input was product of bounded × canonical\");\n        }",
      "start_line": 1528,
      "end_line": 48,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_divisibility_factor().",
      "display_name": "lemma_divisibility_factor",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_divisibility_factor().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_divisibility_factor(n: nat, a: nat, b: nat)\n    requires\n        n % (a * b) == 0,\n        a > 0,\n        b > 0,\n    ensures\n        (n / a) % b == 0,\n{\n    // Use lemma_mod_breakdown: n % (a * b) = a * ((n / a) % b) + n % a\n    // Since n % (a * b) == 0: 0 = a * ((n / a) % b) + n % a\n    // Both terms are non-negative and sum to 0, so both must be 0\n    assert((n / a) % b == 0) by {\n        lemma_mod_breakdown(n as int, a as int, b as int);\n        assert(0 == a * ((n / a) % b) + n % a);\n        // Since a > 0 and a * ((n / a) % b) = 0, we have (n / a) % b = 0\n        assert((n / a) % b == 0) by (nonlinear_arith)\n            requires\n                a > 0,\n                a * ((n / a) % b) == 0,\n        ;\n    }\n}",
      "start_line": 158,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/pow2_mul_div_mod_small_mod_u8_t51_cond().",
      "display_name": "pow2_mul_div_mod_small_mod_u8_t51_cond",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/pow2_mul_div_mod_small_mod_u8_t51_cond().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn pow2_mul_div_mod_small_mod_u8_t51_cond(k: nat, j: nat) -> bool {\n    (k <= j * 8) && (51 <= j * 8 - k)\n}",
      "start_line": 724,
      "end_line": 56,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/sha512_hash_bytes().",
      "display_name": "sha512_hash_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/sha512_hash_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub fn sha512_hash_bytes(input: &[u8]) -> (result: [u8; 64])\n    ensures\n        is_random_bytes(input) ==> is_random_bytes(&result),\n{\n    use digest::Digest;\n    let mut hasher = sha2::Sha512::new();\n    hasher.update(input);\n    hasher.finalize().into()\n}",
      "start_line": 176,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb0_contribution_correctness().",
      "display_name": "lemma_limb0_contribution_correctness",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb0_contribution_correctness().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_limb0_contribution_correctness(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[0] < pow2(51),\n        bytes_match_limbs_packing(limbs, bytes),\n    ensures\n        limb0_byte_contribution(limbs, bytes) == limbs[0] as nat,\n{\n    // Limb 0 is stored in bytes 0-6\n    // - Bytes 0-5: full bytes containing limbs[0]'s bits 0-47 (48 bits total)\n    // - Byte 6 (low 3 bits): limbs[0]'s bits 48-50 (3 bits)\n    // Total: 51 bits, which matches limbs[0] < 2^51\n    //\n    // Strategy: Apply div-mod theorem at the 48-bit boundary\n    // limbs[0] = (limbs[0] % 2^48) + (limbs[0] / 2^48) * 2^48\n    lemma2_to64();\n    assert(pow2(8) == 256);\n\n    // Stabilization placeholders\n    assert(pow2(0) == pow2(0 * 8));\n    assert(pow2(8) == pow2(1 * 8));\n    assert(pow2(16) == pow2(2 * 8));\n    assert(pow2(24) == pow2(3 * 8));\n    assert(pow2(32) == pow2(4 * 8));\n\n    // Step 1: Show bytes 0-5 contribute (limbs[0] % 2^48)\n    // From bytes_match_limbs_packing, we know:\n    // bytes[0] = limbs[0] as u8\n    // bytes[1] = (limbs[0] >> 8) as u8\n    // ... and so on\n\n    // These bytes, when summed with their position weights, reconstruct limbs[0] % 2^48\n    let low_48_bits = bytes[0] as nat * pow2(0 * 8) + bytes[1] as nat * pow2(1 * 8)\n        + bytes[2] as nat * pow2(2 * 8) + bytes[3] as nat * pow2(3 * 8) + bytes[4] as nat * pow2(\n        4 * 8,\n    ) + bytes[5] as nat * pow2(5 * 8);\n\n    // Prove this equals limbs[0] % 2^48\n    // From bytes_match_limbs_packing, we know each byte is exactly (limbs[0] >> (i*8)) as u8\n\n    // Use lemma_byte_from_limb_shift to establish arithmetic value of each byte\n    lemma_shr_zero_is_id(limbs[0]);  // Explicit call instead of broadcast for better Z3 performance\n    assert(bytes[0] == (limbs[0] >> 0) as u8);\n    lemma_byte_from_limb_shift(limbs[0], 0, bytes[0]);\n    assert(bytes[0] as nat == (limbs[0] as nat / pow2(0)) % 256);\n\n    lemma_byte_from_limb_shift(limbs[0], 8, bytes[1]);\n    assert(bytes[1] as nat == (limbs[0] as nat / pow2(8)) % 256);\n\n    lemma_byte_from_limb_shift(limbs[0], 16, bytes[2]);\n    assert(bytes[2] as nat == (limbs[0] as nat / pow2(16)) % 256);\n\n    lemma_byte_from_limb_shift(limbs[0], 24, bytes[3]);\n\n    lemma_byte_from_limb_shift(limbs[0], 32, bytes[4]);\n    assert(bytes[4] as nat == (limbs[0] as nat / pow2(32)) % 256);\n\n    lemma_byte_from_limb_shift(limbs[0], 40, bytes[5]);\n    assert(bytes[5] as nat == (limbs[0] as nat / pow2(40)) % 256);\n\n    // Now we know the arithmetic value of each byte!\n    // We need to show that summing them reconstructs limbs[0] % 2^48\n\n    // Key insight: We have bytes extracted from limbs[0], but our reconstruction lemma\n    // expects bytes extracted from (limbs[0] % 2^48). We need to show these are the same.\n\n    // For each byte i (i=0..5), show that extraction from limbs[0] equals extraction from limbs[0] % 2^48\n    // This holds because byte i is at position i*8, and i*8+7 < 48, so it's below the modulo boundary\n\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 0, 48);\n    assert(bytes[0] as nat == ((limbs[0] as nat % pow2(48)) / pow2(0)) % 256);\n\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 1, 48);\n\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 2, 48);\n    assert(bytes[2] as nat == ((limbs[0] as nat % pow2(48)) / pow2(16)) % 256);\n\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 3, 48);\n    assert(bytes[3] as nat == ((limbs[0] as nat % pow2(48)) / pow2(24)) % 256);\n\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 4, 48);\n    assert(bytes[4] as nat == ((limbs[0] as nat % pow2(48)) / pow2(32)) % 256);\n\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 5, 48);\n\n    // Now the bytes satisfy the preconditions of our reconstruction lemma!\n    // We also need to show that (limbs[0] % 2^48) < 2^48\n    lemma_pow2_pos(48);\n    assert(pow2(48) > 0);\n    assert(limbs[0] as nat % pow2(48) < pow2(48)) by {\n        lemma_mod_bound(limbs[0] as int, pow2(48) as int);\n    }\n\n    // The modulo value fits in u64 since 2^48 < 2^64\n    let modulo_value = limbs[0] as nat % pow2(48);\n    assert(pow2(48) < pow2(64)) by {\n        lemma_pow2_strictly_increases(48, 64);\n    }\n    assert(modulo_value < pow2(64));\n\n    let limb0_low48 = modulo_value as u64;\n\n    // Show that limb0_low48 satisfies the preconditions\n    // The cast to u64 and back to nat preserves the value since modulo_value < 2^64\n    // For x < 2^64, (x as u64) as nat == x - this is a fundamental property of u64 casting\n    // Verus should be able to verify this directly\n    assert(limb0_low48 as nat == modulo_value);\n    assert(limb0_low48 as nat == limbs[0] as nat % pow2(48));\n\n    // The bytes we extracted from limbs[0] % pow2(48) satisfy the preconditions\n    // We already proved: bytes[i] == ((limbs[0] % pow2(48)) / pow2(i*8)) % 256\n    assert(bytes[0] as nat == (limb0_low48 as nat / pow2(0)) % 256);\n    assert(bytes[1] as nat == (limb0_low48 as nat / pow2(8)) % 256);\n    assert(bytes[2] as nat == (limb0_low48 as nat / pow2(16)) % 256);\n    assert(bytes[3] as nat == (limb0_low48 as nat / pow2(24)) % 256);\n    assert(bytes[4] as nat == (limb0_low48 as nat / pow2(32)) % 256);\n    assert(bytes[5] as nat == (limb0_low48 as nat / pow2(40)) % 256);\n\n    // Now apply our reconstruction lemma\n    lemma_6_bytes_reconstruct(\n        limb0_low48 as nat,\n        bytes[0],\n        bytes[1],\n        bytes[2],\n        bytes[3],\n        bytes[4],\n        bytes[5],\n    );\n\n    // The reconstruction lemma tells us: low_48_bits == limbs[0] % 2^48\n    assert(low_48_bits == (limbs[0] as nat % pow2(48)));\n\n    // Step 2: Show the contribution from byte 6\n    // From bytes_match_limbs_packing: bytes[6] == ((limbs[0] >> 48) | (limbs[1] << 3)) as u8\n    // The low 3 bits of bytes[6] come from limbs[0] >> 48\n    // which is limbs[0] / 2^48\n\n    // Since limbs[0] < 2^51, we have limbs[0] / 2^48 < 2^3 = 8\n    assert(limbs[0] < pow2(51));\n    lemma_div_bound(limbs[0] as nat, 48, 51);\n    assert(limbs[0] as nat / pow2(48) < pow2((51 - 48) as nat));\n    assert(limbs[0] as nat / pow2(48) < pow2(3));\n    lemma2_to64();\n    assert(pow2(3) == 8);\n    assert(limbs[0] as nat / pow2(48) < 8);\n\n    // The high 5 bits of byte 6 come from limbs[1], so the low 3 bits are:\n    let high_3_bits_contribution = ((limbs[0] as nat / pow2(48)) % 8) * pow2(6 * 8);\n\n    // Since limbs[0]/2^48 < 8, taking % 8 is identity\n    assert((limbs[0] as nat / pow2(48)) % 8 == limbs[0] as nat / pow2(48));\n    assert(high_3_bits_contribution == (limbs[0] as nat / pow2(48)) * pow2(48));\n\n    // Step 3: Apply div-mod theorem\n    // limbs[0] = (limbs[0] % 2^48) + (limbs[0] / 2^48) * 2^48\n    lemma_pow2_pos(48);  // Establishes pow2(48) > 0\n    assert(pow2(48) > 0);\n    lemma_fundamental_div_mod(limbs[0] as int, pow2(48) as int);\n    assert(limbs[0] as nat == (limbs[0] as nat % pow2(48)) + (limbs[0] as nat / pow2(48)) * pow2(\n        48,\n    ));\n\n    // Step 4: Show this equals limb0_byte_contribution\n    assert(limb0_byte_contribution(limbs, bytes) == low_48_bits + high_3_bits_contribution);\n    assert(limb0_byte_contribution(limbs, bytes) == (limbs[0] as nat % pow2(48)) + (limbs[0] as nat\n        / pow2(48)) * pow2(48));\n    assert(limb0_byte_contribution(limbs, bytes) == limbs[0] as nat);\n}",
      "start_line": 243,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 13
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "display_name": "montgomery_reduce",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub(crate) fn montgomery_reduce(limbs: &[u128; 9]) -> (result:\n        Scalar52)\n    // If the input is the product of 2 bounded scalars, we get 2 postconditions.\n    // If the 2nd scalar is also canonical, we unlock a 3rd postcondition.\n    // Not all calling code needs the 3rd postcondition.\n    // Note: This spec is not yet confirmed because the function is unproved.\n    // The spec is checked by prop_montgomery_reduce_two_bounded and prop_montgomery_reduce_one_canonical.\n    // If you edit this spec, please update the proptests.\n    // Once this function and all deps are proved, you can remove those proptests,\n    // and montgomery_reduce_non_canonical_product_fails_postcondition,\n    // and test_canonical_scalar_generator (if it's then unused)\n\n        ensures\n            (exists|bounded1: &Scalar52, bounded2: &Scalar52|\n                limbs_bounded(bounded1) && limbs_bounded(bounded2) && spec_mul_internal(\n                    bounded1,\n                    bounded2,\n                ) == limbs) ==> ((to_nat(&result.limbs) * montgomery_radix()) % group_order()\n                == slice128_to_nat(limbs) % group_order() && limbs_bounded(&result)),\n            (exists|bounded: &Scalar52, canonical: &Scalar52|\n                limbs_bounded(bounded) && limbs_bounded(canonical) && to_nat(&canonical.limbs)\n                    < group_order() && spec_mul_internal(bounded, canonical) == limbs) ==> to_nat(\n                &result.limbs,\n            ) < group_order(),\n    {\n        assume(false);  // TODO: Add proofs\n\n        // note: l[3] is zero, so its multiples can be skipped\n        let l = &constants::L;\n\n        // the first half computes the Montgomery adjustment factor n, and begins adding n*l to make limbs divisible by R\n        let (carry, n0) = Self::part1(limbs[0]);\n        let (carry, n1) = Self::part1(carry + limbs[1] + m(n0, l.limbs[1]));\n        let (carry, n2) = Self::part1(carry + limbs[2] + m(n0, l.limbs[2]) + m(n1, l.limbs[1]));\n        let (carry, n3) = Self::part1(carry + limbs[3] + m(n1, l.limbs[2]) + m(n2, l.limbs[1]));\n        let (carry, n4) = Self::part1(\n            carry + limbs[4] + m(n0, l.limbs[4]) + m(n2, l.limbs[2]) + m(n3, l.limbs[1]),\n        );\n\n        // limbs is divisible by R now, so we can divide by R by simply storing the upper half as the result\n        let (carry, r0) = Self::part2(\n            carry + limbs[5] + m(n1, l.limbs[4]) + m(n3, l.limbs[2]) + m(n4, l.limbs[1]),\n        );\n        let (carry, r1) = Self::part2(carry + limbs[6] + m(n2, l.limbs[4]) + m(n4, l.limbs[2]));\n        let (carry, r2) = Self::part2(carry + limbs[7] + m(n3, l.limbs[4]));\n        let (carry, r3) = Self::part2(carry + limbs[8] + m(n4, l.limbs[4]));\n        let r4 = carry as u64;\n\n        // result may be >= l, so attempt to subtract l\n        Scalar52::sub(&Scalar52 { limbs: [r0, r1, r2, r3, r4] }, l)\n    }",
      "start_line": 906,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 11,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_bytes().",
      "display_name": "is_random_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub uninterp spec fn is_random_bytes(bytes: &[u8]) -> bool;\n\npub uninterp spec fn is_random_scalar(scalar: &Scalar) -> bool;\n\n#[cfg(feature = \"rand_core\")]\n#[verifier::external_body]\npub fn fill_bytes<R: RngCore>(rng: &mut R, bytes: &mut [u8; 64])\n    ensures\n        is_random_bytes(bytes),\n{\n    rng.fill_bytes(bytes)\n}",
      "start_line": 159,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_fourth_power_is_fourth_root().",
      "display_name": "lemma_fourth_power_is_fourth_root",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_fourth_power_is_fourth_root().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/unused_sqrt_ratio_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/unused_sqrt_ratio_lemmas.rs",
      "file_name": "unused_sqrt_ratio_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_fourth_power_is_fourth_root(x: nat)\n    requires x % p() != 0,\n    ensures is_fourth_root_of_unity(pow(x as int, ((p() - 1) / 4) as nat) as nat),\n{\n    // (x^((p-1)/4))^4 = x^(p-1) = 1 by Fermat\n    assume(is_fourth_root_of_unity(pow(x as int, ((p() - 1) / 4) as nat) as nat));\n}",
      "start_line": 78,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_point().",
      "display_name": "spec_completed_point",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_point().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_completed_point(\n    point: crate::backend::serial::curve_models::CompletedPoint,\n) -> (nat, nat, nat, nat) {\n    let x_abs = spec_field_element(&point.X);\n    let y_abs = spec_field_element(&point.Y);\n    let z_abs = spec_field_element(&point.Z);\n    let t_abs = spec_field_element(&point.T);\n    (x_abs, y_abs, z_abs, t_abs)\n}",
      "start_line": 280,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#from_slice().",
      "display_name": "from_slice",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#from_slice().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn from_slice(bytes: &[u8]) -> (result: Result<\n        CompressedEdwardsY,\n        TryFromSliceError,\n    >)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            bytes@.len() == 32 ==> matches!(result, Ok(_)),\n            bytes@.len() != 32 ==> matches!(result, Err(_)),\n            match result {\n                Ok(point) => point.0@ == bytes@,\n                Err(_) => true,\n            },",
      "start_line": 793,
      "end_line": 22,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"ProjectiveNielsPoint{{\\n\\tY_plus_X: {:?},\\n\\tY_minus_X: {:?},\\n\\tZ: {:?},\\n\\tT2d: {:?}\\n}}\",\n               &self.Y_plus_X, &self.Y_minus_X, &self.Z, &self.T2d)\n    }",
      "start_line": 899,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/from_le_bytes().",
      "display_name": "from_le_bytes",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/from_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "display_name": "optional_mixed_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        self.0\n            .optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points.into_iter().map(|P_opt| P_opt.map(|P| P.0)),\n            )\n            .map(RistrettoPoint)\n    }",
      "start_line": 1029,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_swap_montgomery_projective().",
      "display_name": "conditional_swap_montgomery_projective",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_swap_montgomery_projective().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn conditional_swap_montgomery_projective(\n    a: &mut crate::montgomery::ProjectivePoint,\n    b: &mut crate::montgomery::ProjectivePoint,\n    choice: Choice,\n)\n    ensures\n// If choice is false, points remain unchanged\n\n        !choice_is_true(choice) ==> {\n            &&& a.U == old(a).U\n            &&& a.W == old(a).W\n            &&& b.U == old(b).U\n            &&& b.W == old(b).W\n        },",
      "start_line": 312,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "display_name": "lemma_decompress_correct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_decompress_correct(\n    repr_bytes: &[u8; 32],\n    y: nat,\n    x_sqrt: nat,\n    sign_bit: u8,\n)\n    requires\n        y == spec_field_element_from_bytes(repr_bytes),\n        sign_bit == (repr_bytes[31] >> 7),\n        math_is_valid_y_coordinate(y),\n        ({\n            let d = spec_field_element(&EDWARDS_D);\n            let y2 = math_field_square(y);\n            let u = math_field_sub(y2, 1);\n            let v = math_field_add(math_field_mul(d, y2), 1);\n            v != 0 && math_field_mul(math_field_square(x_sqrt), v) == u % p()\n        }),",
      "start_line": 404,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 16
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "display_name": "lemma_byte_sum_equals_limb_sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_byte_sum_equals_limb_sum(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < pow2(51),\n        bytes_match_limbs_packing(limbs, bytes),\n    ensures\n        u8_32_as_nat(&bytes) == u64_5_as_nat(limbs),\n{\n    // This lemma performs the complete algebraic expansion:\n    //\n    // LHS: u8_32_as_nat(bytes)\n    //    = bytes[0] + bytes[1]*256 + bytes[2]*256^2 + ... + bytes[31]*256^31\n    //\n    // Substitute each byte[i] from bytes_match_limbs_packing:\n    //    = (limbs[0])\n    //      + (limbs[0]>>8)*256\n    //      + (limbs[0]>>16)*256^2\n    //      + ... [and so on for all 32 bytes]\n    //\n    // Group terms by limb:\n    //    = [terms involving limbs[0]]\n    //      + [terms involving limbs[1]]\n    //      + [terms involving limbs[2]]\n    //      + [terms involving limbs[3]]\n    //      + [terms involving limbs[4]]\n    //\n    // Show each group equals limbs[i] * pow2(i*51):\n    //    = limbs[0]*pow2(0) + limbs[1]*pow2(51) + limbs[2]*pow2(102) + limbs[3]*pow2(153) + limbs[4]*pow2(204)\n    //    = u64_5_as_nat(limbs)\n    //\n    // The proof strategy is:\n    // 1. Define each limb's byte contribution as a spec function\n    // 2. Prove each contribution equals limbs[i] * pow2(i*51) using helper lemmas\n    // 3. Prove the sum of contributions equals u8_32_as_nat(bytes)\n    // 4. Therefore u8_32_as_nat(bytes) == u64_5_as_nat(limbs)\n    //\n    // Key insight: pow2(48) * 8 = pow2(51) (the radix change point)\n    lemma2_to64();\n    lemma_pow2_adds(48, 3);  // Establishes pow2(51) = pow2(48) * 8\n\n    // Prove each limb's contribution to the byte sum\n    // Each lemma shows that the bytes from that limb contribute exactly limbs[i] * pow2(i*51)\n    let limb0_contribution = limb0_byte_contribution(limbs, bytes);\n    let limb1_contribution = limb1_byte_contribution(limbs, bytes);\n    let limb2_contribution = limb2_byte_contribution(limbs, bytes);\n    let limb3_contribution = limb3_byte_contribution(limbs, bytes);\n    let limb4_contribution = limb4_byte_contribution(limbs, bytes);\n\n    // Prove each contribution equals limbs[i] * pow2(i*51)\n    lemma_limb0_contribution_correctness(limbs, bytes);\n\n    lemma_limb1_contribution_correctness(limbs, bytes);\n\n    lemma_limb2_contribution_correctness(limbs, bytes);\n\n    lemma_limb3_contribution_correctness(limbs, bytes);\n\n    lemma_limb4_contribution_correctness(limbs, bytes);\n\n    // Prove the sum of contributions equals u8_32_as_nat(&bytes)\n    lemma_sum_equals_byte_nat(limbs, bytes);\n    assert(u8_32_as_nat(&bytes) == limb0_contribution + limb1_contribution + limb2_contribution\n        + limb3_contribution + limb4_contribution);\n\n    // Therefore, the sum equals u64_5_as_nat(limbs)\n}",
      "start_line": 66,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 17
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core map/adapters/iter/Map#Iterator#next().",
      "display_name": "next",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core map/adapters/iter/Map#Iterator#next().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
      "file_name": "pippenger.rs",
      "parent_folder": "scalar_mul",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_sqrt().",
      "display_name": "math_sqrt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_sqrt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn math_sqrt(a: nat) -> nat\n    recommends\n        math_is_square(a),\n{\n    choose|y: nat| y < p() && #[trigger] ((y * y) % p()) == (a % p())\n}",
      "start_line": 311,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#to_jacobi_quartic_ristretto().",
      "display_name": "to_jacobi_quartic_ristretto",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#to_jacobi_quartic_ristretto().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    fn to_jacobi_quartic_ristretto(self) -> [JacobiPoint; 4] {\n        let x2 = self.0.X.square(); // X^2\n        let y2 = self.0.Y.square(); // Y^2\n        let y4 = y2.square(); // Y^4\n        let z2 = self.0.Z.square(); // Z^2\n        let z_min_y = &self.0.Z - &self.0.Y; // Z - Y\n        let z_pl_y = &self.0.Z + &self.0.Y; // Z + Y\n        let z2_min_y2 = &z2 - &y2; // Z^2 - Y^2\n\n        // gamma := 1/sqrt( Y^4 X^2 (Z^2 - Y^2) )\n        let (_, gamma) = (&(&y4 * &x2) * &z2_min_y2).invsqrt();\n\n        let den = &gamma * &y2;\n\n        let s_over_x = &den * &z_min_y;\n        let sp_over_xp = &den * &z_pl_y;\n\n        let s0 = &s_over_x * &self.0.X;\n        let s1 = &(-(&sp_over_xp)) * &self.0.X;\n\n        // t_0 := -2/sqrt(-d-1) * Z * sOverX\n        // t_1 := -2/sqrt(-d-1) * Z * spOverXp\n        let tmp = &lizard_constants::MDOUBLE_INVSQRT_A_MINUS_D * &self.0.Z;\n        let mut t0 = &tmp * &s_over_x;\n        let mut t1 = &tmp * &sp_over_xp;\n\n        // den := -1/sqrt(1+d) (Y^2 - Z^2) gamma\n        let den = &(&(-(&z2_min_y2)) * &lizard_constants::MINVSQRT_ONE_PLUS_D) * &gamma;\n\n        // Same as before but with the substitution (X, Y, Z) = (Y, X, i*Z)\n        let iz = &constants::SQRT_M1 * &self.0.Z; // iZ\n        let iz_min_x = &iz - &self.0.X; // iZ - X\n        let iz_pl_x = &iz + &self.0.X; // iZ + X\n\n        let s_over_y = &den * &iz_min_x;\n        let sp_over_yp = &den * &iz_pl_x;\n\n        let mut s2 = &s_over_y * &self.0.Y;\n        let mut s3 = &(-(&sp_over_yp)) * &self.0.Y;\n\n        // t_2 := -2/sqrt(-d-1) * i*Z * sOverY\n        // t_3 := -2/sqrt(-d-1) * i*Z * spOverYp\n        let tmp = &lizard_constants::MDOUBLE_INVSQRT_A_MINUS_D * &iz;\n        let mut t2 = &tmp * &s_over_y;\n        let mut t3 = &tmp * &sp_over_yp;\n\n        // Special case: X=0 or Y=0.  Then return\n        //\n        //  (0,1)   (1,-2i/sqrt(-d-1)   (-1,-2i/sqrt(-d-1))\n        //\n        // Note that if X=0 or Y=0, then s_i = t_i = 0.\n        let x_or_y_is_zero = self.0.X.is_zero() | self.0.Y.is_zero();\n        t0.conditional_assign(&FieldElement::ONE, x_or_y_is_zero);\n        t1.conditional_assign(&FieldElement::ONE, x_or_y_is_zero);\n        t2.conditional_assign(\n            &lizard_constants::MIDOUBLE_INVSQRT_A_MINUS_D,\n            x_or_y_is_zero,\n        );\n        t3.conditional_assign(\n            &lizard_constants::MIDOUBLE_INVSQRT_A_MINUS_D,\n            x_or_y_is_zero,\n        );\n        s2.conditional_assign(&FieldElement::ONE, x_or_y_is_zero);\n        s3.conditional_assign(&(-(&FieldElement::ONE)), x_or_y_is_zero);\n\n        [\n            JacobiPoint { S: s0, T: t0 },\n            JacobiPoint { S: s1, T: t1 },\n            JacobiPoint { S: s2, T: t2 },\n            JacobiPoint { S: s3, T: t3 },\n        ]\n    }",
      "start_line": 158,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc string/ToString#to_string().",
      "display_name": "to_string",
      "symbol": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc string/ToString#to_string().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "curve25519-dalek/build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_add_sub_rearrange().",
      "display_name": "lemma_field_add_sub_rearrange",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_add_sub_rearrange().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
      "file_name": "field_algebra_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_field_add_sub_rearrange(a: nat, b: nat, c: nat)\n    requires\n        a < p(), b < p(), c < p(),\n        math_field_add(a, b) == math_field_sub(c, 1),\n    ensures\n        math_field_add(a, 1) == math_field_sub(c, b),\n{\n    let p = p();\n    let (a_int, b_int, c_int, p_int) = (a as int, b as int, c as int, p as int);\n    p_gt_2();\n    \n    // Goal: (a + 1) % p = (c - b) % p\n    assert(math_field_add(a, 1) == math_field_sub(c, b)) by {\n        // Small mod simplifications\n        lemma_small_mod(c, p);\n        lemma_small_mod(1nat, p);\n        lemma_small_mod(b, p);\n        \n        // Step 1: (a + b + 1) % p = c\n        lemma_add_mod_noop(a_int + b_int, 1, p_int);\n        lemma_add_mod_noop(c_int + p_int - 1, 1, p_int);\n        lemma_mod_add_multiples_vanish(c_int, p_int);\n        assert((a_int + b_int + 1) % p_int == c_int);\n        \n        // Step 2: (a + 1) % p = (c - b) % p\n        lemma_sub_mod_noop(a_int + b_int + 1, b_int, p_int);\n        \n        // Step 3: (c - b) % p = (c + p - b) % p\n        lemma_mod_add_multiples_vanish(c_int - b_int, p_int);\n    };\n}",
      "start_line": 146,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mod().",
      "display_name": "lemma_pow2_mul_div_mod_small_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_mul_div_mod_small_mod(x: nat, px: nat, k: nat, s: nat, t: nat)\n    requires\n        x < pow2(px),\n        s <= k,\n        t <= k - s,\n    ensures\n        ((x * pow2(k)) / pow2(s)) % pow2(t) == 0,\n{\n    let d = (k - s) as nat;\n\n    assert((x * pow2(k)) / pow2(s) == x * pow2(d)) by {\n        pow2_MUL_div(x, k, s);\n    }\n\n    let dd = (d - t) as nat;\n\n    assert(x * pow2(d) == (x * pow2(dd)) * pow2(t)) by {\n        lemma_pow2_adds(dd, t);\n        lemma_mul_is_associative(x as int, pow2(dd) as int, pow2(t) as int);\n    }\n\n    assert(pow2(t) > 0) by {\n        lemma_pow2_pos(t);\n    }\n\n    assert(((x * pow2(dd)) * pow2(t)) % pow2(t) == 0) by {\n        lemma_mod_multiples_basic((x * pow2(dd)) as int, pow2(t) as int);\n    }\n}",
      "start_line": 584,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_vanish().",
      "display_name": "lemma_mod_multiples_vanish",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_vanish().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#SubAssign#sub_assign().",
      "display_name": "sub_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#SubAssign#sub_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            fe51_limbs_bounded(old(self), 54) && fe51_limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            spec_field_element(self) == math_field_sub(\n                spec_field_element(old(self)),\n                spec_field_element(_rhs),\n            ),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(spec_field_element(self) == math_field_sub(\n            spec_field_element(old(self)),\n            spec_field_element(_rhs),\n        ));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }",
      "start_line": 281,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops().",
      "display_name": "lemma_bitops",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/bit_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/bit_lemmas.rs",
      "file_name": "bit_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_bitops(a: u64, b: u64, c: u64)\n    requires\n        c < 64,\n    ensures\n        (a | b) >> c == (a >> c) | (b >> c),\n        (a | b) & (low_bits_mask(c as nat) as u64) == (a & (low_bits_mask(c as nat) as u64)) | (b\n            & (low_bits_mask(c as nat) as u64)),\n{\n    assert(low_bits_mask(c as nat) <= u64::MAX) by {\n        lemma_low_bits_masks_fit_u64(c as nat);\n    }\n    assert((a | b) >> c == (a >> c) | (b >> c)) by (bit_vector);\n    let lbm = (low_bits_mask(c as nat) as u64);\n    assert((a | b) & lbm == (a & lbm) | (b & lbm)) by (bit_vector);\n}",
      "start_line": 38,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_affine_u().",
      "display_name": "montgomery_affine_u",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_affine_u().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn montgomery_affine_u(P: MontgomeryAffine) -> nat {\n    match P {\n        MontgomeryAffine::Infinity => 0,  // Convention: infinity maps to 0\n        MontgomeryAffine::Finite { u, v: _ } => u,\n    }\n}",
      "start_line": 337,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#Clone#clone().",
      "display_name": "clone",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#Clone#clone().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    fn clone(&self) -> Self {\n        *self\n    }",
      "start_line": 280,
      "end_line": 13,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_geometric_mul_step().",
      "display_name": "lemma_prove_geometric_mul_step",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_geometric_mul_step().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow_chain_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow_chain_lemmas.rs",
      "file_name": "pow_chain_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_prove_geometric_mul_step(\n    base: int,\n    val_a: nat,\n    val_b: nat,\n    val_result: nat,\n    exp_a: nat,\n    exp_b: nat,\n)\n    requires\n        base >= 0,\n        p() > 0,\n        val_a % p() == pow(base, exp_a) as nat % p(),\n        val_b % p() == pow(base, exp_b) as nat % p(),\n        val_result % p() == (val_a * val_b) % p(),\n    ensures\n        val_result % p() == pow(base, (exp_a + exp_b) as nat) as nat % p(),\n{\n    // Prove pow(base, exp_a) >= 0 and pow(base, exp_b) >= 0\n    assert(pow(base, exp_a) >= 0) by {\n        lemma_pow_nonnegative(base, exp_a);\n    }\n    assert(pow(base, exp_b) >= 0) by {\n        lemma_pow_nonnegative(base, exp_b);\n    }\n\n    // Use modular multiplication property\n    assert(val_result % p() == ((val_a % p()) * (val_b % p())) % p()) by {\n        lemma_mul_mod_noop_general(val_a as int, val_b as int, p() as int);\n    }\n\n    // Substitute known values\n    assert(val_result % p() == ((pow(base, exp_a) as nat % p()) * (pow(base, exp_b) as nat % p()))\n        % p());\n\n    // Remove inner mods\n    assert(val_result % p() == (pow(base, exp_a) as nat * pow(base, exp_b) as nat) % p()) by {\n        lemma_mul_mod_noop_general(\n            pow(base, exp_a) as nat as int,\n            pow(base, exp_b) as nat as int,\n            p() as int,\n        );\n    }\n\n    // Apply power addition rule: x^a * x^b = x^(a+b)\n    assert(pow(base, exp_a) * pow(base, exp_b) == pow(base, exp_a + exp_b)) by {\n        lemma_pow_adds(base, exp_a, exp_b);\n    }\n\n    // Prove pow(base, exp_a + exp_b) >= 0\n    assert(pow(base, exp_a + exp_b) >= 0) by {\n        lemma_pow_nonnegative(base, exp_a + exp_b);\n    }\n\n    // Chain the equalities to prove the postcondition\n    // val_result % p() == (val_a * val_b) % p() (from precondition)\n    // We proved: val_result % p() == (pow(base, exp_a) as nat * pow(base, exp_b) as nat) % p()\n    // We proved: pow(base, exp_a) * pow(base, exp_b) == pow(base, exp_a + exp_b)\n    // Therefore: val_result % p() == pow(base, (exp_a + exp_b) as nat) as nat % p()\n\n    assert((pow(base, exp_a + exp_b) % (p() as int)) as nat == pow(\n        base,\n        (exp_a + exp_b) as nat,\n    ) as nat % p());\n    assert(val_result % p() == (pow(base, exp_a) as nat * pow(base, exp_b) as nat) % p());\n    assert((pow(base, exp_a) as nat * pow(base, exp_b) as nat) == (pow(base, exp_a) * pow(\n        base,\n        exp_b,\n    )) as nat);\n    assert(val_result % p() == pow(base, (exp_a + exp_b) as nat) as nat % p());\n}",
      "start_line": 87,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_projective_point_montgomery().",
      "display_name": "spec_projective_point_montgomery",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_projective_point_montgomery().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_projective_point_montgomery(point: crate::montgomery::ProjectivePoint) -> (\n    nat,\n    nat,\n) {\n    let u = spec_field_element(&point.U);\n    let w = spec_field_element(&point.W);\n    (u, w)\n}",
      "start_line": 225,
      "end_line": 50,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_adds().",
      "display_name": "lemma_pow_adds",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_adds().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "display_name": "mul_bits_be",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_bits_be(&self, bits: &[bool]) -> (result: MontgomeryPoint)\n        requires\n            bits.len() <= 255,\n            is_valid_montgomery_point(*self),\n        ensures\n            ({\n                // Let P be the canonical affine lift of input u-coordinate\n                let P = canonical_montgomery_lift(spec_montgomery_point(*self));\n                let n = bits_be_to_nat(bits, bits@.len() as int);\n                let R = montgomery_scalar_mul(P, n);\n\n                // result encodes u([n]P)\n                spec_montgomery_point(result) == spec_u_coordinate(R)\n            }),",
      "start_line": 382,
      "end_line": 23,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 16
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#MulAssign#mul_assign().",
      "display_name": "mul_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#MulAssign#mul_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn mul_assign(&mut self, scalar: &Scalar)\n        requires\n            is_valid_montgomery_point(*old(self)),\n        ensures\n    // Result represents [n]old(self) where n is the UNREDUCED scalar value\n    // Uses canonical Montgomery lift\n\n            ({\n                let P = canonical_montgomery_lift(spec_montgomery_point(*old(self)));\n                let n_unreduced = scalar_to_nat(scalar);\n                let R = montgomery_scalar_mul(P, n_unreduced);\n                spec_montgomery_point(*self) == spec_u_coordinate(R)\n            }),",
      "start_line": 856,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "display_name": "from_bytes_mod_order_wide",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == bytes_wide_to_nat(input) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        /* <ORIGINAL CODE>\n        UnpackedScalar::from_bytes_wide(input).pack()\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        // The proof chain:\n        // 1. from_bytes_wide ensures: to_nat(&s.limbs) < group_order() AND limbs_bounded(&s)\n        // 2. pack() requires limbs_bounded, ensures: to_nat(&self.limbs) < group_order() ==> is_canonical_scalar(&result)\n        // 3. is_canonical_scalar includes bytes[31] <= 127\n        let unpacked = UnpackedScalar::from_bytes_wide(input);\n        let result = unpacked.pack();\n\n        proof {\n            // from_bytes_wide postconditions:\n            // - limbs_bounded(&unpacked)\n            // - to_nat(&unpacked.limbs) % group_order() == bytes_wide_to_nat(input) % group_order()\n            // - to_nat(&unpacked.limbs) < group_order()\n            // pack() postconditions:\n            // - bytes_to_nat(&result.bytes) == to_nat(&unpacked.limbs) % pow2(256)\n            // - to_nat(&unpacked.limbs) < group_order() ==> is_canonical_scalar(&result)\n            // Since to_nat(&unpacked.limbs) < group_order() < pow2(256),\n            // we have to_nat(&unpacked.limbs) % pow2(256) == to_nat(&unpacked.limbs)\n            lemma_group_order_smaller_than_pow256();\n            lemma_small_mod(to_nat(&unpacked.limbs), pow2(256));\n\n            // Therefore bytes_to_nat(&result.bytes) == to_nat(&unpacked.limbs)\n            // And bytes_to_nat(&result.bytes) % group_order() == to_nat(&unpacked.limbs) % group_order()\n            //                                                 == bytes_wide_to_nat(input) % group_order()\n        }\n\n        result  /* </MODIFIED CODE> */\n\n    }",
      "start_line": 275,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_compressed_edwards_y().",
      "display_name": "is_valid_compressed_edwards_y",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_compressed_edwards_y().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_valid_compressed_edwards_y(bytes: &[u8; 32]) -> bool {\n    let y = spec_field_element_from_bytes(bytes);\n    let sign_bit = bytes[31] >> 7;\n    // If y² ≡ 1 (mod p), then x = 0, so sign_bit must be 0\n    // Equivalently: sign_bit == 1 implies y² ≢ 1\n    math_field_square(y) == 1 ==> sign_bit == 0\n}",
      "start_line": 399,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/pippenger_optional_multiscalar_mul().",
      "display_name": "pippenger_optional_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/pippenger_optional_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "backend",
      "body": "pub fn pippenger_optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator<Item = Option<EdwardsPoint>>,\n{\n    use crate::traits::VartimeMultiscalarMul;\n\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 =>\n        //     vector::scalar_mul::pippenger::spec_avx2::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n        // #[cfg(all(curve25519_dalek_backend = \"simd\", nightly))]\n        // BackendKind::Avx512 =>\n        //     vector::scalar_mul::pippenger::spec_avx512ifma_avx512vl::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n        BackendKind::Serial => {\n            serial::scalar_mul::pippenger::Pippenger::optional_multiscalar_mul::<I, J>(\n                scalars, points,\n            )\n        }\n    }\n}",
      "start_line": 90,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#as_bytes().",
      "display_name": "as_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#as_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    pub const fn as_bytes(&self) -> (result: &[u8; 32])\n        ensures\n            result == &self.0,\n    {\n        &self.0\n    }",
      "start_line": 449,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_select().",
      "display_name": "conditional_select",
      "symbol": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode().",
      "display_name": "test_lizard_encode",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    fn test_lizard_encode() {\n        test_lizard_encode_helper(\n            &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            &[\n                0xf0, 0xb7, 0xe3, 0x44, 0x84, 0xf7, 0x4c, 0xf0, 0xf, 0x15, 0x2, 0x4b, 0x73, 0x85,\n                0x39, 0x73, 0x86, 0x46, 0xbb, 0xbe, 0x1e, 0x9b, 0xc7, 0x50, 0x9a, 0x67, 0x68, 0x15,\n                0x22, 0x7e, 0x77, 0x4f,\n            ],\n        );\n\n        test_lizard_encode_helper(\n            &[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            &[\n                0xcc, 0x92, 0xe8, 0x1f, 0x58, 0x5a, 0xfc, 0x5c, 0xaa, 0xc8, 0x86, 0x60, 0xd8, 0xd1,\n                0x7e, 0x90, 0x25, 0xa4, 0x44, 0x89, 0xa3, 0x63, 0x4, 0x21, 0x23, 0xf6, 0xaf, 0x7,\n                0x2, 0x15, 0x6e, 0x65,\n            ],\n        );\n\n        test_lizard_encode_helper(\n            &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n            &[\n                0xc8, 0x30, 0x57, 0x3f, 0x8a, 0x8e, 0x77, 0x78, 0x67, 0x1f, 0x76, 0xcd, 0xc7, 0x96,\n                0xdc, 0xa, 0x23, 0x5c, 0xf1, 0x77, 0xf1, 0x97, 0xd9, 0xfc, 0xba, 0x6, 0xe8, 0x4e,\n                0x96, 0x24, 0x74, 0x44,\n            ],\n        );\n    }",
      "start_line": 261,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#AddAssign#add_assign().",
      "display_name": "add_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#AddAssign#add_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn add_assign(&mut self, _rhs: &'b EdwardsPoint)\n        requires\n            is_well_formed_edwards_point(*old(self)),\n            is_well_formed_edwards_point(*_rhs),\n        ensures\n            is_valid_edwards_point(*self),\n            // Semantic correctness: result is the addition of old(self) + rhs\n            ({\n                let (x1, y1) = edwards_point_as_affine(*old(self));\n                let (x2, y2) = edwards_point_as_affine(*_rhs);\n                edwards_point_as_affine(*self) == edwards_add(x1, y1, x2, y2)\n            }),",
      "start_line": 1417,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_nonzero().",
      "display_name": "lemma_mul_nonzero",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_nonzero().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from4().",
      "display_name": "seq_from4",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from4().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub open spec fn seq_from4(b: &[u8; 4]) -> Seq<u8> {\n    Seq::new(4, |i: int| b[i])\n}",
      "start_line": 70,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_int_nat_mod_equiv().",
      "display_name": "lemma_int_nat_mod_equiv",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_int_nat_mod_equiv().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_int_nat_mod_equiv(v: int, m: nat)\n    requires\n        v >= 0,\n        m > 0,\n    ensures\n        v % (m as int) == ((v as nat) % m) as int,\n{\n    let v_nat = v as nat;\n    let r_nat = v_nat % m;\n    let q_nat = v_nat / m;\n\n    assert(v_nat == q_nat * m + r_nat) by {\n        lemma_fundamental_div_mod(v, m as int);\n    }\n\n    lemma_fundamental_div_mod_converse_mod(v, m as int, q_nat as int, r_nat as int);\n}",
      "start_line": 187,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/top_half().",
      "display_name": "top_half",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/top_half().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "fn top_half(x: u8) -> (result:\n    u8)/* <VERIFICATION NOTE>\n- Adjust the spec as needed for the proof of as_radix_16\n</VERIFICATION NOTE> */\n\n    ensures\n// Result is the upper 4 bits (upper nibble) of x\n\n        result == x / 16,\n        // Result is in range [0, 15]\n        result <= 15,\n{\n    let result = (x >> 4) & 15;\n    proof {\n        assert((x >> 4) & 15 == x / 16) by (bit_vector);\n    }\n    result\n}",
      "start_line": 1893,
      "end_line": 12,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/bot_half().",
      "display_name": "bot_half",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/bot_half().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "fn bot_half(x: u8) -> (result:\n    u8)/* <VERIFICATION NOTE>\n- Adjust the spec as needed for the proof of as_radix_16\n</VERIFICATION NOTE> */\n\n    ensures\n// Result is the lower 4 bits (lower nibble) of x\n\n        result == x % 16,\n        // Result is in range [0, 15]\n        result <= 15,\n{\n    let result = (x >> 0) & 15;\n    proof {\n        assert((x >> 0) & 15 == x % 16) by (bit_vector);\n    }\n    result\n}",
      "start_line": 1873,
      "end_line": 12,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "display_name": "montgomery_square",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn montgomery_square(&self) -> (result: Scalar52)\n        requires\n            limbs_bounded(self),\n        ensures\n            limbs_bounded(&result),\n            (to_nat(&result.limbs) * montgomery_radix()) % group_order() == (to_nat(&self.limbs)\n                * to_nat(&self.limbs)) % group_order(),\n    {\n        Scalar52::montgomery_reduce(&Scalar52::square_internal(self))\n    }",
      "start_line": 1135,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#PartialEq#eq().",
      "display_name": "eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#PartialEq#eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "curve25519-dalek/src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "    fn eq(&self, other: &FieldElement) -> (result:\n        bool)/* VERIFICATION NOTE:\n     - DRAFT SPEC: spec_fe51_to_bytes is a complex spec function that should correspond to as_bytes()\n     - PartialEqSpecImpl trait provides the external specification\n     - Proof follows from ct_eq and choice_into postconditions\n     */\n\n        ensures\n            result == (spec_fe51_to_bytes(self) == spec_fe51_to_bytes(other)),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Choice::into\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.ct_eq(other).into()\n         </ORIGINAL CODE> */\n        let choice = self.ct_eq(other);\n        let result = choice_into(choice);\n\n        proof {\n            // Proof chain:\n            // 1. ct_eq ensures: choice_is_true(choice) == (spec_fe51_to_bytes(self) == spec_fe51_to_bytes(other))\n            // 2. choice_into ensures: result == choice_is_true(choice)\n            // 3. Therefore: result == (spec_fe51_to_bytes(self) == spec_fe51_to_bytes(other))\n            // This is a direct consequence of the two postconditions\n            assert(result == choice_is_true(choice));  // from choice_into\n            assert(choice_is_true(choice) == (spec_fe51_to_bytes(self) == spec_fe51_to_bytes(\n                other,\n            )));  // from ct_eq\n            assert(result == (spec_fe51_to_bytes(self) == spec_fe51_to_bytes(other)));\n        }\n\n        result\n    }",
      "start_line": 106,
      "end_line": 10,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_factorial_positive().",
      "display_name": "lemma_factorial_positive",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_factorial_positive().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "proof fn lemma_factorial_positive(n: nat)\n    ensures\n        factorial(n) > 0,\n    decreases n,\n{\n    if n == 0 {\n        assert(factorial(0) == 1);\n    } else {\n        lemma_factorial_positive((n - 1) as nat);\n        assert(factorial(n) == n * factorial((n - 1) as nat));\n        lemma_mul_strictly_positive(n as int, factorial((n - 1) as nat) as int);\n    }\n}",
      "start_line": 431,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_clamped().",
      "display_name": "mul_clamped",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_clamped().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_clamped(self, bytes: [u8; 32]) -> (result: Self)\n        requires\n            is_valid_montgomery_point(self),\n        ensures/* VERIFICATION NOTE: Result represents [n]self where n is the clamped integer value\n      The corresponding scalar is not reduced modulo the group order. */\n\n            ({\n                let P = canonical_montgomery_lift(spec_montgomery_point(self));\n                let clamped_bytes = spec_clamp_integer(bytes);\n                let n = bytes_to_nat(&clamped_bytes);\n                let R = montgomery_scalar_mul(P, n);\n                spec_montgomery_point(result) == spec_u_coordinate(R)\n            }),",
      "start_line": 276,
      "end_line": 23,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_swap().",
      "display_name": "conditional_swap",
      "symbol": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_swap().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "display_name": "map",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 13,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple_is_strongly_ordered().",
      "display_name": "lemma_div_by_multiple_is_strongly_ordered",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple_is_strongly_ordered().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "display_name": "lemma_cancel_mul_pow2_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_cancel_mul_pow2_mod(a: nat, b: nat, r_pow: nat)\n    requires\n// r_pow is a power of two, and r_pow and group_order are coprime\n// (montgomery_radix() is 2^260; group_order() is odd)\n\n        r_pow == pow2(260),\n        (a * r_pow) % group_order() == (b * r_pow) % group_order(),\n    ensures\n        a % group_order() == b % group_order(),\n{\n    // Constructive proof using inverse-of-2 modulo L.\n    let L = group_order();\n\n    lemma_group_order_is_odd();\n\n    // Define inv2 = (L + 1) / 2\n    let inv2 = (L + 1) / 2;\n\n    // From division: (L + 1) == 2 * ((L + 1) / 2) + (L + 1) % 2\n    lemma_fundamental_div_mod((L + 1) as int, 2);\n    // Since L is odd, (L + 1) % 2 == 0, so 2 * inv2 == L + 1\n    assert(2 * inv2 == L + 1);\n\n    // inv_pow = inv2^260\n    let inv_pow = pow(inv2 as int, 260);\n\n    // Multiply given congruence (a * r_pow) ≡ (b * r_pow) (mod L) by inv_pow\n    lemma_mul_factors_congruent_implies_products_congruent(\n        inv_pow as int,\n        (a * r_pow) as int,\n        (b * r_pow) as int,\n        L as int,\n    );\n\n    // So (inv_pow * a * r_pow) % L == (inv_pow * b * r_pow) % L.\n    // Show that (inv_pow * r_pow) % L == 1.\n\n    // First, (inv2 * 2) % L == 1\n    assert((inv2 * 2) % L == 1) by {\n        // we already have 2 * inv2 == L + 1\n        assert(2 * inv2 == L + 1);\n\n        // rewrite to (L + 1) % L\n        assert((2 * inv2) % L == (L + 1) % L);\n\n        // show group_order() > 1\n        // pow2(252) == 2 * pow2(251)\n        lemma_pow2_adds(1, 251);\n        assert(pow2(1) == 2) by { lemma2_to64() };\n        assert(pow2(252) == 2 * pow2(251));\n\n        // pow2(251) > 0  ==> pow2(252) >= 2\n        lemma_pow2_pos(251);\n        assert(pow2(251) > 0);\n        // since pow2(252) == 2 * pow2(251) and pow2(251) >= 1, pow2(252) >= 2\n        assert(pow2(252) >= 2);\n\n        // group_order() = pow2(252) + C, so group_order() >= pow2(252) >= 2\n        // (use compute / definition unfolding if needed)\n        assert(group_order() >= pow2(252));\n        assert(group_order() >= 2);\n        assert(group_order() > 1);\n\n        // Now L + 1 == L * 1 + 1 and 0 <= 1 < L, so remainder of (L+1) mod L is 1.\n        assert(L + 1 == L * 1 + 1);\n        assert(0 <= 1 && 1 < L);\n\n        // Use the converse lemma: if x == q * d + r and 0 <= r < d then r == x % d\n        lemma_fundamental_div_mod_converse((L + 1) as int, L as int, 1, 1);\n\n        assert((L + 1) % L == 1);\n    }\n\n    // pow((inv2 * 2), 260) % L == 1\n    lemma_pow_mod_one((inv2 * 2) as int, 260, L as int);\n\n    // pow(inv2 * 2, 260) == pow(inv2,260) * pow(2,260)\n    lemma_pow_distributes(inv2 as int, 2int, 260);\n\n    // Using the above, (pow(inv2,260) * pow(2,260)) % L == 1\n    // Note r_pow == pow2(260) == pow(2,260)\n\n    // Let c = inv_pow * r_pow\n    let c = (inv_pow * r_pow) as int;\n\n    // c % L == 1\n    assert(c % (L as int) == 1) by {\n        // pow(inv2,260) * pow(2,260) is congruent to 1\n        assert(pow(inv2 as int, 260) * pow(2 as int, 260) == pow((inv2 * 2) as int, 260));\n        assert((pow(inv2 as int, 260) * pow(2 as int, 260)) % (L as int) == 1);\n        assert(pow(2int, 260) == (pow2(260) as int)) by { lemma_pow2(260) };\n    }\n\n    assert(1int < L);\n    assert(1int % (L as int) == 1) by { lemma_small_mod(1nat, L) };\n\n    // (a * r_pow) % L = (b * r_pow) % L\n    lemma_mul_factors_congruent_implies_products_congruent(\n        inv_pow,\n        (a * r_pow) as int,\n        (b * r_pow) as int,\n        L as int,\n    );\n\n    assert(((a * r_pow) * inv_pow) % (L as int) == ((b * r_pow) * inv_pow) % (L as int));\n    assert(((a * r_pow) * inv_pow) % (L as int) == (a * (r_pow * inv_pow)) % (L as int)) by {\n        lemma_mul_is_associative(a as int, r_pow as int, inv_pow as int)\n    };\n\n    assert(((b * r_pow) * inv_pow) % (L as int) == (b * (r_pow * inv_pow)) % (L as int)) by {\n        lemma_mul_is_associative(b as int, r_pow as int, inv_pow as int)\n    };\n    // assert((a * (r_pow * inv_pow)) % (L as int) == (b * (r_pow * inv_pow)) % (L as int));\n\n    lemma_mul_factors_congruent_implies_products_congruent(a as int, c, 1, L as int);\n    lemma_mul_factors_congruent_implies_products_congruent(b as int, c, 1, L as int);\n\n}",
      "start_line": 1705,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_assign_u64().",
      "display_name": "conditional_assign_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_assign_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn conditional_assign_u64(a: &mut u64, b: &u64, choice: Choice)\n    ensures\n        !choice_is_true(choice) ==> *a == *old(a),\n        choice_is_true(choice) ==> *a == *b,\n{\n    a.conditional_assign(b, choice)\n}",
      "start_line": 242,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_one().",
      "display_name": "lemma_sqrt_m1_neq_one",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_one().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "file_name": "sqrt_ratio_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_sqrt_m1_neq_one()\n    ensures\n        spec_sqrt_m1() != 1,\n{\n    // Proof by contradiction: suppose spec_sqrt_m1() = 1\n    // Then i² = 1, but axiom_sqrt_m1_squared says i² = p - 1\n    // So we need 1 = p - 1, meaning p = 2\n    // But p > 2, contradiction\n    \n    pow255_gt_19();  // Establishes p() > 0 and pow2(255) > 19\n    \n    // Step 1: i² = p - 1 (which is -1 mod p)\n    assert((spec_sqrt_m1() * spec_sqrt_m1()) % p() == (p() - 1)) by {\n        axiom_sqrt_m1_squared();\n    };\n    \n    // Step 2: p > 2 (since p = 2^255 - 19 and 2^255 > 21)\n    // We know pow2(255) > 19, so p = pow2(255) - 19 > 0\n    // Also, pow2(255) ≥ pow2(5) = 32 > 21, so p > 2\n    assert(p() > 2) by {\n        p_gt_2();\n    };\n    \n    // Step 3: 1 * 1 % p = 1 (since 1 < p)\n    assert(1 < p());\n    assert((1nat * 1nat) % p() == 1) by {\n        lemma_small_mod(1, p());\n    };\n    \n    // Step 4: Since (1*1) % p = 1 ≠ p - 1 (because p > 2), we have i ≠ 1\n    assert((p() - 1) != 1);  // Because p > 2\n    \n    // Therefore if spec_sqrt_m1() = 1, we'd have 1 = p - 1, contradiction\n}",
      "start_line": 129,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConditionallySelectable#conditional_select().",
      "display_name": "conditional_select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConditionallySelectable#conditional_select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> (Self) {\n        let mut bytes = [0u8;32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            /* <VERIFICATION NOTE>\n            Use wrapper function for Verus compatibility instead of direct subtle call\n            </VERIFICATION NOTE> */\n            /* <ORIGINAL CODE>\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n            </ORIGINAL CODE> */\n            /* <MODIFIED CODE> */\n            bytes[i] = select_u8(&a.bytes[i], &b.bytes[i], choice);\n            /* </MODIFIED CODE> */\n        }\n        Scalar { bytes }\n    }",
      "start_line": 907,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_single_stage_division().",
      "display_name": "lemma_single_stage_division",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_single_stage_division().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_single_stage_division(limb: u64, carry_in: u64, stage_input: u64, carry_out: u64)\n    requires\n        limb < (1u64 << 52),\n        limb + carry_in <= u64::MAX,  // No overflow\n        stage_input == (limb + carry_in) as u64,\n        stage_input < 3 * pow2(51),\n        carry_out == (stage_input >> 51) as u64,\n    ensures\n        carry_out < 3,\n        carry_out as int == (limb as int + carry_in as int) / pow2(51) as int,\n{\n    lemma_carry_propagation_setup();\n\n    // Prove the division relationship\n    lemma_u64_shr_is_div(stage_input, 51);\n    // Since limb + carry_in <= u64::MAX, the cast doesn't change the value\n\n    // Prove the bound\n    lemma_bounded_shr_51(stage_input);\n}",
      "start_line": 321,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_n_1().",
      "display_name": "lemma_binomial_n_1",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_n_1().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "proof fn lemma_binomial_n_1(n: nat)\n    requires\n        n >= 1,\n    ensures\n        binomial(n, 1) == n,\n    decreases n,\n{\n    if n == 1 {\n        assert(binomial(1, 1) == 1);\n    } else {\n        assert(binomial(n, 1) == binomial((n - 1) as nat, 0) + binomial((n - 1) as nat, 1));\n        assert(binomial((n - 1) as nat, 0) == 1);\n        lemma_binomial_n_1((n - 1) as nat);\n        assert(binomial((n - 1) as nat, 1) == (n - 1) as nat);\n    }\n}",
      "start_line": 339,
      "end_line": 28,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo rand 0.8.5 thread/rngs/ThreadRng#RngCore#fill_bytes().",
      "display_name": "fill_bytes",
      "symbol": "rust-analyzer cargo rand 0.8.5 thread/rngs/ThreadRng#RngCore#fill_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_to_projective().",
      "display_name": "spec_completed_to_projective",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_to_projective().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_completed_to_projective(\n    point: crate::backend::serial::curve_models::CompletedPoint,\n) -> (nat, nat, nat) {\n    let (x, y, z, t) = spec_completed_point(point);\n    (math_field_mul(x, t), math_field_mul(y, z), math_field_mul(z, t))\n}",
      "start_line": 691,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "display_name": "u8_32_as_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/core_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/core_specs.rs",
      "file_name": "core_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn u8_32_as_nat(bytes: &[u8; 32]) -> nat {\n    // Verus error: `core::iter::range::impl&%15::fold` is not supported\n    // we write them out manually\n    (bytes[ 0] as nat) * pow2( 0 * 8) +\n    (bytes[ 1] as nat) * pow2( 1 * 8) +\n    (bytes[ 2] as nat) * pow2( 2 * 8) +\n    (bytes[ 3] as nat) * pow2( 3 * 8) +\n    (bytes[ 4] as nat) * pow2( 4 * 8) +\n    (bytes[ 5] as nat) * pow2( 5 * 8) +\n    (bytes[ 6] as nat) * pow2( 6 * 8) +\n    (bytes[ 7] as nat) * pow2( 7 * 8) +\n    (bytes[ 8] as nat) * pow2( 8 * 8) +\n    (bytes[ 9] as nat) * pow2( 9 * 8) +\n    (bytes[10] as nat) * pow2(10 * 8) +\n    (bytes[11] as nat) * pow2(11 * 8) +\n    (bytes[12] as nat) * pow2(12 * 8) +\n    (bytes[13] as nat) * pow2(13 * 8) +\n    (bytes[14] as nat) * pow2(14 * 8) +\n    (bytes[15] as nat) * pow2(15 * 8) +\n    (bytes[16] as nat) * pow2(16 * 8) +\n    (bytes[17] as nat) * pow2(17 * 8) +\n    (bytes[18] as nat) * pow2(18 * 8) +\n    (bytes[19] as nat) * pow2(19 * 8) +\n    (bytes[20] as nat) * pow2(20 * 8) +\n    (bytes[21] as nat) * pow2(21 * 8) +\n    (bytes[22] as nat) * pow2(22 * 8) +\n    (bytes[23] as nat) * pow2(23 * 8) +\n    (bytes[24] as nat) * pow2(24 * 8) +\n    (bytes[25] as nat) * pow2(25 * 8) +\n    (bytes[26] as nat) * pow2(26 * 8) +\n    (bytes[27] as nat) * pow2(27 * 8) +\n    (bytes[28] as nat) * pow2(28 * 8) +\n    (bytes[29] as nat) * pow2(29 * 8) +\n    (bytes[30] as nat) * pow2(30 * 8) +\n    (bytes[31] as nat) * pow2(31 * 8)\n}",
      "start_line": 22,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 19,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_le_u64().",
      "display_name": "lemma_shl_le_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_le_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_shl_le_u64(a: u64, b: u64, k: nat)\n    requires\n        a <= b,\n        k < 64,\n        (b * pow2(k)) <= u64::MAX,\n    ensures\n        (a << k) <= (b << k),\n{\n    lemma_mul_le(a as nat, b as nat, pow2(k), pow2(k));\n    lemma_u64_shl_is_mul(a, k as u64);\n    lemma_u64_shl_is_mul(b, k as u64);\n}",
      "start_line": 63,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nat_is_nat().",
      "display_name": "lemma_pow_nat_is_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nat_is_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow_nat_is_nat(v: nat, i: nat)\n    ensures\n        pow(v as int, pow2(i)) >= 0,\n{\n    lemma_pow2_pos(i);  // pow2(i) > 0\n    if (v == 0) {\n        lemma0_pow(pow2(i));\n    } else {\n        lemma_pow_positive(v as int, pow2(i));\n    }\n}",
      "start_line": 89,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_montgomery_mod().",
      "display_name": "lemma_cancel_mul_montgomery_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_montgomery_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_cancel_mul_montgomery_mod(x: nat, a: nat, rr: nat)\n    requires\n        ((x * montgomery_radix()) % group_order()) == ((a * rr) % group_order()),\n        (rr % group_order()) == ((montgomery_radix() * montgomery_radix()) % group_order()),\n        group_order() > 0,\n    ensures\n        (x % group_order()) == ((a * montgomery_radix()) % group_order()),\n{\n    // 1. Substitute rr with r*r\n    lemma_mul_mod_noop_right(a as int, rr as int, group_order() as int);\n    lemma_mul_mod_noop_right(\n        a as int,\n        (montgomery_radix() * montgomery_radix()) as int,\n        group_order() as int,\n    );\n\n    // let lhs = (x * montgomery_radix()) % group_order();\n    // let step1 = (a * rr) % group_order();\n    // let step2 = (a * (rr % group_order())) % group_order();\n    // let step3 = (a * ((montgomery_radix() * montgomery_radix()) % group_order())) % group_order();\n    // let step4 = (a * (montgomery_radix() * montgomery_radix())) % group_order();\n    // let rhs = (a * montgomery_radix() * montgomery_radix()) % group_order();\n    lemma_mul_is_associative(a as int, montgomery_radix() as int, montgomery_radix() as int);\n\n    assert((x * montgomery_radix()) % group_order() == (a * montgomery_radix() * montgomery_radix())\n        % group_order());\n\n    // 2. use the inverse to remove r from both sides\n\n    // Step 1: Multiply both sides by inv_montgomery_radix() using modular properties\n    lemma_mul_mod_noop_right(\n        inv_montgomery_radix() as int,\n        (x * montgomery_radix()) as int,\n        group_order() as int,\n    );\n    lemma_mul_mod_noop_right(\n        inv_montgomery_radix() as int,\n        (a * montgomery_radix() * montgomery_radix()) as int,\n        group_order() as int,\n    );\n\n    assert((x * montgomery_radix() * inv_montgomery_radix()) % group_order() == (a\n        * montgomery_radix() * montgomery_radix() * inv_montgomery_radix()) % group_order());\n\n    // Step 2: Group (R * R^-1) together using associativity\n    // x * (R * R^-1) and (a * R) * (R * R^-1)\n    lemma_mul_is_associative(x as int, montgomery_radix() as int, inv_montgomery_radix() as int);\n    lemma_mul_is_associative(\n        (a * montgomery_radix()) as int,\n        montgomery_radix() as int,\n        inv_montgomery_radix() as int,\n    );\n\n    assert((x * (montgomery_radix() * inv_montgomery_radix())) % group_order() == ((a\n        * montgomery_radix()) * (montgomery_radix() * inv_montgomery_radix())) % group_order());\n\n    // Step 3: Use lemma_montgomery_inverse to substitute (R * R^-1) % n = 1\n    lemma_montgomery_inverse();\n\n    // Step 4: Substitute and simplify using (R * R^-1) ≡ 1\n    lemma_mul_mod_noop_right(\n        x as int,\n        (montgomery_radix() * inv_montgomery_radix()) as int,\n        group_order() as int,\n    );\n    lemma_mul_mod_noop_right(\n        (a * montgomery_radix()) as int,\n        (montgomery_radix() * inv_montgomery_radix()) as int,\n        group_order() as int,\n    );\n\n}",
      "start_line": 392,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_geometric_sum_5_terms().",
      "display_name": "lemma_geometric_sum_5_terms",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_geometric_sum_5_terms().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_geometric_sum_5_terms()\n    ensures\n        (pow2(51) - 1) * (1 + pow2(51) + pow2(102) + pow2(153) + pow2(204)) == pow2(255) - 1,\n{\n    // Establish power-of-2 relationships\n    lemma_pow2_adds(51, 51);  // 2^102 = 2^51 * 2^51\n    lemma_pow2_adds(51, 102);  // 2^153 = 2^51 * 2^102\n    lemma_pow2_adds(51, 153);  // 2^204 = 2^51 * 2^153\n    lemma_pow2_adds(51, 204);  // 2^255 = 2^51 * 2^204\n\n    // Geometric series formula: For r^n with n terms starting at r^0:\n    // (r - 1) * (1 + r + r^2 + ... + r^(n-1)) = r^n - 1\n    // Here: r = 2^51, n = 5, so (2^51 - 1) * (sum of 5 terms) = 2^255 - 1\n\n    // We'll prove this by expanding the left-hand side and showing it equals the right\n    // LHS = (2^51 - 1) * (1 + 2^51 + 2^102 + 2^153 + 2^204)\n    //     = 2^51*(1 + 2^51 + 2^102 + 2^153 + 2^204) - 1*(1 + 2^51 + 2^102 + 2^153 + 2^204)\n    //     = (2^51 + 2^102 + 2^153 + 2^204 + 2^255) - (1 + 2^51 + 2^102 + 2^153 + 2^204)\n    //     = 2^255 - 1  [all middle terms cancel]\n\n    let sum = 1 + pow2(51) + pow2(102) + pow2(153) + pow2(204);\n    let lhs = (pow2(51) - 1) * sum;\n\n    // Expand (a - 1) * b = a * b - b\n    assert(lhs == pow2(51) * sum - 1 * sum) by {\n        lemma_mul_is_distributive_sub(sum as int, pow2(51) as int, 1);\n    }\n\n    // Expand pow2(51) * sum using distributivity\n    assert(pow2(51) * sum == pow2(51) * 1 + pow2(51) * pow2(51) + pow2(51) * pow2(102) + pow2(51)\n        * pow2(153) + pow2(51) * pow2(204)) by {\n        lemma_mul_is_distributive_add(pow2(51) as int, 1, pow2(51) as int);\n        lemma_mul_is_distributive_add(pow2(51) as int, 1 + pow2(51) as int, pow2(102) as int);\n        lemma_mul_is_distributive_add(\n            pow2(51) as int,\n            1 + pow2(51) + pow2(102) as int,\n            pow2(153) as int,\n        );\n        lemma_mul_is_distributive_add(\n            pow2(51) as int,\n            1 + pow2(51) + pow2(102) + pow2(153) as int,\n            pow2(204) as int,\n        );\n    }\n\n    // Simplify using power-of-2 addition properties\n    assert(pow2(51) * pow2(153) == pow2(204));\n    assert(pow2(51) * pow2(204) == pow2(255));\n\n    // Now compute lhs = (pow2(51) + pow2(102) + pow2(153) + pow2(204) + pow2(255)) - sum\n    //                 = (pow2(51) + pow2(102) + pow2(153) + pow2(204) + pow2(255))\n    //                   - (1 + pow2(51) + pow2(102) + pow2(153) + pow2(204))\n\n    // The middle terms cancel, leaving: pow2(255) - 1\n}",
      "start_line": 224,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limbs_to_bytes().",
      "display_name": "lemma_limbs_to_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limbs_to_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_limbs_to_bytes(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51),\n        bytes_match_limbs_packing(limbs, bytes),\n    ensures\n        u8_32_as_nat(&bytes) == u64_5_as_nat(limbs),\n{\n    // Connect the bit shift in the requires clause to pow2\n    lemma_shift_is_pow2(51);\n    lemma_byte_sum_equals_limb_sum(limbs, bytes);\n}",
      "start_line": 49,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#TryFrom#try_from().",
      "display_name": "try_from",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#TryFrom#try_from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn try_from(slice: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        Self::from_slice(slice)\n    }",
      "start_line": 350,
      "end_line": 16,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_unwrap().",
      "display_name": "ct_option_unwrap",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_unwrap().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn ct_option_unwrap<T>(opt: CtOption<T>) -> (val: T)\n    requires\n        ct_option_has_value(opt),\n    ensures\n        val == ct_option_value(opt),\n{\n    opt.unwrap()\n}",
      "start_line": 187,
      "end_line": 24,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a1_0_val().",
      "display_name": "a1_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a1_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn a1_0_val(a: [u64; 5]) -> u64 {\n    (c1_val(a) as u64) & mask51\n}",
      "start_line": 84,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/load8_at_or_version_rec().",
      "display_name": "load8_at_or_version_rec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/load8_at_or_version_rec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn load8_at_or_version_rec(input: &[u8], i: usize, k: nat) -> u64\n    decreases k,\n{\n    if (k == 0) {\n        (input[i as int] as u64)\n    } else {\n        // k > 0\n        load8_at_or_version_rec(input, i, (k - 1) as nat) | ((input[i + k] as u64) << k * 8)\n    }\n}",
      "start_line": 21,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#ConditionallySelectable#conditional_assign().",
      "display_name": "conditional_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#ConditionallySelectable#conditional_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.y_plus_x.conditional_assign(&other.y_plus_x, choice);\n        self.y_minus_x.conditional_assign(&other.y_minus_x, choice);\n        self.xy2d.conditional_assign(&other.xy2d, choice);\n    }",
      "start_line": 390,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/negate_field().",
      "display_name": "negate_field",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/negate_field().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub fn negate_field<T>(a: &T) -> (result: T) where for <'a>&'a T: core::ops::Neg<Output = T> {\n    -a\n}",
      "start_line": 152,
      "end_line": 20,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_edwards().",
      "display_name": "to_edwards",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_edwards().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    pub fn to_edwards(&self, sign: u8) -> (result: Option<EdwardsPoint>)\n        ensures\n            match result {\n                Some(edwards) => montgomery_corresponds_to_edwards(*self, edwards),\n                None => is_equal_to_minus_one(spec_montgomery_point(*self)),\n            },",
      "start_line": 480,
      "end_line": 22,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_is_mod_recursive().",
      "display_name": "lemma_mod_is_mod_recursive",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_is_mod_recursive().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "file_name": "invert_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#by_ref().",
      "display_name": "by_ref",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#by_ref().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_zero().",
      "display_name": "field_inv_zero",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_zero().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub proof fn field_inv_zero()\n    ensures\n        math_field_inv(0nat) == 0,\n{\n    // Proof: By definition of math_field_inv, when a % p() == 0, it returns 0\n    assert(p() > 0) by {\n        pow255_gt_19();\n    };\n\n    // Since p() > 0, we have 0 % p() == 0\n    assert(0nat % p() == 0);\n\n    // By the if-branch in math_field_inv's definition: math_field_inv(0) == 0\n}",
      "start_line": 265,
      "end_line": 28,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core map/adapters/iter/Map#Iterator#fold().",
      "display_name": "fold",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core map/adapters/iter/Map#Iterator#fold().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
      "file_name": "pippenger.rs",
      "parent_folder": "scalar_mul",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#hash_from_bytes().",
      "display_name": "hash_from_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#hash_from_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn hash_from_bytes<D>(input: &[u8]) -> RistrettoPoint\n    where\n        D: Digest<OutputSize = U64> + Default,\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        RistrettoPoint::from_hash(hash)\n    }",
      "start_line": 748,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn identity() -> (result: CompressedEdwardsY)\n        ensures\n    // Identity point has y = 1 and sign bit = 0\n\n            spec_field_element_from_bytes(&result.0) == 1,\n            (result.0[31] >> 7) == 0,\n    {\n        let result = CompressedEdwardsY(\n            [\n                1,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n            ],\n        );\n\n        proof {\n            // byte 31 is 0, so sign bit (bit 7) is 0\n            assert(result.0[31] == 0);\n            assert((0u8 >> 7) == 0) by (bit_vector);\n\n            // spec_field_element_from_bytes([1, 0, ...]) = 1\n            // The bytes represent 1 in little-endian: byte[0] = 1, rest = 0\n            assume(spec_field_element_from_bytes(&result.0) == 1);\n        }\n\n        result\n    }",
      "start_line": 716,
      "end_line": 16,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 CtOption#unwrap().",
      "display_name": "unwrap",
      "symbol": "rust-analyzer cargo subtle 2.6.1 CtOption#unwrap().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "display_name": "is_well_formed_edwards_point",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_well_formed_edwards_point(point: crate::edwards::EdwardsPoint) -> bool {\n    is_valid_edwards_point(point) && edwards_point_limbs_bounded(point)\n        && edwards_point_sum_bounded(point)\n}",
      "start_line": 255,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 17,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn zeroize(&mut self) {\n        self.y_plus_x.zeroize();\n        self.y_minus_x.zeroize();\n        self.xy2d.zeroize();\n    }",
      "start_line": 198,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 From#from().",
      "display_name": "from",
      "symbol": "rust-analyzer cargo subtle 2.6.1 From#from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "curve25519-dalek/src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn zeroize(&mut self) {\n        self.Y_plus_X.zeroize();\n        self.Y_minus_X.zeroize();\n        self.Z.zeroize();\n        self.T2d.zeroize();\n    }",
      "start_line": 221,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_masked_lt().",
      "display_name": "lemma_masked_lt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_masked_lt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mask_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mask_lemmas.rs",
      "file_name": "mask_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_masked_lt(v: u64, k: nat)\n    requires\n        0 <= k < 64,\n    ensures\n        v & (low_bits_mask(k) as u64) < (1u64 << k),\n{\n    // v & (low_bits_mask(k) as u64) = v % pow2(k)\n    lemma_u64_low_bits_mask_is_mod(v, k);\n    // pow2(k) > 0\n    lemma_pow2_pos(k);\n    // v % pow2(k) < pow2(k)\n    lemma_mod_bound(v as int, pow2(k) as int);\n    // 1 << k = pow2(k)\n    lemma_shift_is_pow2(k);\n}",
      "start_line": 13,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn default() -> RistrettoPoint {\n        RistrettoPoint::identity()\n    }",
      "start_line": 812,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#is_small_order().",
      "display_name": "is_small_order",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#is_small_order().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn is_small_order(&self) -> bool {\n        self.mul_by_cofactor().is_identity()\n    }",
      "start_line": 2331,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/identity_projective_niels().",
      "display_name": "identity_projective_niels",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/identity_projective_niels().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn identity_projective_niels() -> ProjectiveNielsPoint {\n    ProjectiveNielsPoint {\n        Y_plus_X: crate::field::FieldElement { limbs: [1, 0, 0, 0, 0] },  // 1\n        Y_minus_X: crate::field::FieldElement { limbs: [1, 0, 0, 0, 0] },  // 1\n        Z: crate::field::FieldElement { limbs: [1, 0, 0, 0, 0] },  // 1\n        T2d: crate::field::FieldElement { limbs: [0, 0, 0, 0, 0] },  // 0\n    }\n}",
      "start_line": 548,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#parse_bytes().",
      "display_name": "parse_bytes",
      "symbol": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#parse_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_square().",
      "display_name": "lemma_pow2_square",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_square().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_square(v: int, i: nat)\n    ensures\n        pow(v, pow2(i)) * pow(v, pow2(i)) == pow(v, pow2(i + 1)),\n{\n    // pow(v, pow2(i)) * pow(v, pow2(i)) = pow(v, pow2(i) + pow2(i));\n    lemma_pow_adds(v as int, pow2(i), pow2(i));\n    // 2 * pow2(i) = pow2(i + 1)\n    lemma_pow2_unfold(i + 1);\n}",
      "start_line": 78,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_is_division().",
      "display_name": "lemma_carry_propagation_is_division",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_is_division().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_carry_propagation_is_division(limbs: [u64; 5], q: u64)\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 52),\n        q == compute_q_spec(limbs),\n    ensures\n        q as nat == (u64_5_as_nat(limbs) + 19) / pow2(255),\n{\n    // Setup: establish basic power-of-2 facts (needed for overflow checks)\n    lemma_carry_propagation_setup();\n\n    // Extract the carry values computed by the algorithm\n    let q0 = ((limbs[0] + 19) as u64 >> 51) as u64;\n    let q1 = ((limbs[1] + q0) as u64 >> 51) as u64;\n    let q2 = ((limbs[2] + q1) as u64 >> 51) as u64;\n    let q3 = ((limbs[3] + q2) as u64 >> 51) as u64;\n    let q4 = ((limbs[4] + q3) as u64 >> 51) as u64;\n\n    // Prove all carries are bounded by 3 (needed for no overflow)\n    lemma_all_carries_bounded_by_3(limbs);\n\n    // Prove no overflow for all stages (each limb < 2^52, each carry < 3)\n\n    // Stage 0: Process limbs[0] + 19\n    lemma_single_stage_division(limbs[0], 19, (limbs[0] + 19) as u64, q0);\n    let r0 = lemma_stage_division_theorem(limbs[0], 19, q0 as int);\n\n    // Stage 1: Process limbs[1] + q0\n    lemma_single_stage_division(limbs[1], q0, (limbs[1] + q0) as u64, q1);\n    let r1 = lemma_stage_division_theorem(limbs[1], q0 as int, q1 as int);\n\n    // Stage 2: Process limbs[2] + q1\n    lemma_single_stage_division(limbs[2], q1, (limbs[2] + q1) as u64, q2);\n    let r2 = lemma_stage_division_theorem(limbs[2], q1 as int, q2 as int);\n\n    // Stage 3: Process limbs[3] + q2\n    lemma_single_stage_division(limbs[3], q2, (limbs[3] + q2) as u64, q3);\n    let r3 = lemma_stage_division_theorem(limbs[3], q2 as int, q3 as int);\n\n    // Stage 4: Process limbs[4] + q3\n    lemma_single_stage_division(limbs[4], q3, (limbs[4] + q3) as u64, q4);\n    let r4 = lemma_stage_division_theorem(limbs[4], q3 as int, q4 as int);\n\n    // Telescoping property: show that q4 = (u64_5_as_nat(limbs) + 19) / 2^255\n    // Use the remainders we just computed to directly prove the telescoping division\n    lemma_radix51_telescoping_direct(\n        limbs,\n        q0 as int,\n        q1 as int,\n        q2 as int,\n        q3 as int,\n        q4 as int,\n        r0,\n        r1,\n        r2,\n        r3,\n        r4,\n    );\n}",
      "start_line": 367,
      "end_line": 49,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#decompress().",
      "display_name": "decompress",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#decompress().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn decompress(&self) -> Option<RistrettoPoint> {\n        let (s_encoding_is_canonical, s_is_negative, s) = decompress::step_1(self);\n\n        if (!s_encoding_is_canonical | s_is_negative).into() {\n            return None;\n        }\n\n        let (ok, t_is_negative, y_is_zero, res) = decompress::step_2(s);\n\n        if (!ok | t_is_negative | y_is_zero).into() {\n            None\n        } else {\n            Some(res)\n        }\n    }",
      "start_line": 254,
      "end_line": 22,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#PartialEq#eq().",
      "display_name": "eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#PartialEq#eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn eq(&self, other: &MontgomeryPoint) -> (result: bool)\n        ensures\n            result == (spec_field_element_from_bytes(&self.0) == spec_field_element_from_bytes(\n                &other.0,\n            )),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Choice::into\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.ct_eq(other).into()\n         </ORIGINAL CODE> */\n        let choice = self.ct_eq(other);\n        let result = choice_into(choice);\n\n        proof {\n            assert(choice_is_true(choice) == (spec_field_element_from_bytes(&self.0)\n                == spec_field_element_from_bytes(&other.0)));\n            assert(result == choice_is_true(choice));\n        }\n\n        result\n    }",
      "start_line": 145,
      "end_line": 10,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq/Seq#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq/Seq#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "display_name": "to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn to_nat(limbs: &[u64]) -> nat {\n    seq_to_nat(limbs@.map(|i, x| x as nat))\n}",
      "start_line": 29,
      "end_line": 24,
      "is_libsignal": false,
      "caller_count": 42,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "display_name": "lemma_boundary_byte_combines_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "proof fn lemma_boundary_byte_combines_52(\n    low_limb: u64,\n    high_limb: u64,\n    byte: u8,\n    low_shift: nat,\n    low_bits: nat,\n)\n    requires\n        low_limb < pow2(52),\n        high_limb < pow2(52),\n        low_bits < 8,\n        low_shift + low_bits == 52,\n        byte == ((low_limb >> low_shift) | (high_limb << low_bits)) as u8,\n    ensures\n        byte as nat == (low_limb as nat / pow2(low_shift)) % pow2(low_bits) + (high_limb as nat\n            % pow2((8 - low_bits) as nat)) * pow2(low_bits),\n{\n    // Proof following docs_22_oct/lemma_boundary_byte_combines_52_proof.md\n    lemma2_to64();\n\n    // Establish that pow2 values fit in u64\n    assert(pow2(low_shift) <= u64::MAX as nat) by {\n        lemma_pow2_strictly_increases(low_shift, 64);\n    }\n\n    assert(pow2(low_bits) <= u64::MAX as nat) by {\n        lemma_pow2_strictly_increases(low_bits, 64);\n    }\n\n    // === STEP 1: Convert bit operations to arithmetic ===\n    let low_part = low_limb >> low_shift;\n    let high_part = high_limb << low_bits;\n\n    // Prove high_part doesn't overflow: high_limb * 2^low_bits <= u64::MAX\n    assert(high_limb as nat * pow2(low_bits) <= u64::MAX as nat) by {\n        // Worst case: high_limb = 2^52 - 1, low_bits = 7\n        // Need: 2^52 * 2^7 = 2^59 <= 2^64 - 1 ✓\n        assert(pow2(52) * pow2(7) <= pow2(64) - 1) by {\n            lemma_pow2_adds(52, 7);\n            lemma_pow2_strictly_increases(59, 64);\n        }\n        if low_bits < 7 {\n            lemma_pow2_strictly_increases(low_bits, 7);\n        }\n        lemma_mul_le(high_limb as nat, (pow2(52) - 1) as nat, pow2(low_bits), pow2(7));\n    }\n\n    assert(high_part == high_limb * (pow2(low_bits) as u64)) by {\n        lemma_u64_shl_is_mul(high_limb, low_bits as u64);\n    }\n\n    // === STEP 2: Prove OR equals addition ===\n    // Need preconditions for lemma_bit_or_is_plus:\n    // 1) low_part < 1u64 << low_bits\n    // 2) high_limb <= u64::MAX >> low_bits\n\n    // Subproof 2.1: Bound low_part\n    assert((low_part as nat) < pow2(low_bits)) by {\n        // low_part = low_limb / 2^low_shift (by shr)\n        lemma_u64_shr_is_div(low_limb, low_shift as u64);\n\n        // low_limb / 2^low_shift < 2^52 / 2^low_shift = 2^(52 - low_shift)\n        // Since low_shift + low_bits = 52, we have 52 - low_shift = low_bits\n        lemma_pow2_adds(low_shift, (52 - low_shift) as nat);\n\n        // Apply: low_limb < 2^52 = 2^low_shift * 2^(52-low_shift)\n        // Therefore: low_limb / 2^low_shift < 2^(52-low_shift) = 2^low_bits\n        lemma_pow2_pos(low_shift);\n        lemma_div_strictly_bounded(\n            low_limb as int,\n            pow2(low_shift) as int,\n            pow2((52 - low_shift) as nat) as int,\n        );\n    }\n\n    assert(low_part < 1u64 << low_bits) by {\n        assert(1u64 << low_bits == (pow2(low_bits) as u64)) by {\n            lemma_shift_is_pow2(low_bits);\n        }\n    }\n\n    // Subproof 2.2: Bound high_limb for shift\n    assert(high_limb <= (u64::MAX >> low_bits)) by {\n        // We proved: high_limb * 2^low_bits <= u64::MAX\n        // Conclude: high_limb <= u64::MAX / 2^low_bits\n        lemma_pow2_pos(low_bits);\n        lemma_mul_le_implies_div_le(high_limb as nat, pow2(low_bits), u64::MAX as nat);\n\n        // u64::MAX / 2^low_bits = u64::MAX >> low_bits\n        lemma_u64_shr_is_div(u64::MAX, low_bits as u64);\n    }\n\n    // Apply lemma_bit_or_is_plus\n    assert(low_part | high_part == low_part + high_part) by {\n        lemma_bit_or_is_plus(low_part, high_limb, low_bits as u64);\n    }\n\n    // === STEP 3: Express combined value ===\n    let combined = low_part + high_part;\n\n    let a = (low_limb as nat) / pow2(low_shift);\n    let b = high_limb as nat;\n    let k = low_bits;\n\n    // Prove combined as nat == a + b * pow2(k)\n    assert(combined as nat == a + b * pow2(k)) by {\n        lemma_u64_shr_is_div(low_limb, low_shift as u64);\n        lemma_u64_shl_is_mul(high_limb, low_bits as u64);\n    }\n\n    // === STEP 4: Apply modular bit partitioning ===\n\n    // Verify precondition: (a % 2^k) + ((b % 2^(8-k)) * 2^k) < 256\n    assert((a % pow2(k)) + ((b % pow2((8 - k) as nat)) * pow2(k)) < 256) by {\n        // Since a < pow2(k): a % pow2(k) = a\n        assert(a % pow2(k) == a) by {\n            lemma_small_mod(a, pow2(k));\n        }\n\n        // Key fact: pow2(k) * pow2(8 - k) = 256\n        assert(pow2(k) * pow2((8 - k) as nat) == 256) by {\n            lemma_pow2_adds(k, (8 - k) as nat);\n        }\n\n        // Get upper bound on b % pow2(8-k)\n        assert((b % pow2((8 - k) as nat)) < pow2((8 - k) as nat)) by {\n            lemma_mod_bound(b as int, pow2((8 - k) as nat) as int);\n        }\n\n        // Arithmetic: a + (b % pow2(8-k)) * pow2(k) <= (pow2(k) - 1) + (pow2(8-k) - 1) * pow2(k)\n        //           = pow2(k) * pow2(8-k) - 1 = 256 - 1 = 255 < 256\n        assert((pow2(k) - 1) + (pow2((8 - k) as nat) - 1) * pow2(k) == pow2((8 - k) as nat) * pow2(\n            k,\n        ) - 1) by (nonlinear_arith);\n\n        assert(a + (b % pow2((8 - k) as nat)) * pow2(k) < 256) by (nonlinear_arith)\n            requires\n                a <= pow2(k) - 1,\n                (b % pow2((8 - k) as nat)) <= pow2((8 - k) as nat) - 1,\n                (pow2(k) - 1) + (pow2((8 - k) as nat) - 1) * pow2(k) == 255,\n        ;\n    }\n\n    lemma_modular_bit_partitioning(a, b, k, 8);\n\n    assert(a % pow2(k) == a) by {\n        lemma_small_mod(a, pow2(k));\n    }\n\n    // === STEP 5: Connect to byte value ===\n    // byte = combined as u8 means byte as nat = combined % 256\n    assert((combined as nat) % pow2(8) == (combined as u8)) by {\n        lemma_u8_cast_is_mod_256(combined as u64);\n    }\n\n    // We know: combined as nat = a + b * pow2(k)\n    // Apply modular bit partitioning: (a + b * 2^k) % 256 = a + (b % 2^(8-k)) * 2^k\n    // This gives us the desired result\n}",
      "start_line": 387,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_expansion_mod_p().",
      "display_name": "lemma_binomial_expansion_mod_p",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_expansion_mod_p().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "proof fn lemma_binomial_expansion_mod_p(a: nat, p: nat)\n    requires\n        is_prime(p),\n    ensures\n        (pow((a + 1) as int, p) as nat) % p == (1 + (pow(a as int, p) as nat)) % p,\n{\n    lemma_partial_binomial_sum_mod_p(a, p, p);\n    axiom_binomial_theorem(a, p);\n}",
      "start_line": 495,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_mod_div().",
      "display_name": "lemma_assemble_mod_div",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_mod_div().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_assemble_mod_div(a: nat, d: nat, b: nat)\n    ensures\n        (a % pow2(d)) * pow2(b) + pow2(b + d) * (a / pow2(d)) == a * pow2(b),\n{\n    let pb = pow2(b);\n    let pd = pow2(d);\n    let pbd = pow2(b + d);\n\n    assert(pbd == pb * pd) by {\n        lemma_pow2_adds(b, d);\n    }\n\n    let amod = a % pd;\n    let adiv = a / pd;\n\n    assert(pbd * adiv == (pd * adiv) * pb) by {\n        lemma_mul_is_associative(pb as int, pd as int, adiv as int);\n        lemma_mul_is_commutative(pb as int, (pd * adiv) as int);\n    }\n\n    assert(amod * pb + (pd * adiv) * pb == (amod + pd * adiv) * pb) by {\n        lemma_mul_is_distributive_add_other_way(pb as int, amod as int, (pd * adiv) as int);\n    }\n\n    assert(amod + pd * adiv == a) by {\n        assert(pd > 0) by {\n            lemma_pow2_pos(d);\n        }\n        lemma_fundamental_div_mod(a as int, pd as int);\n    }\n\n}",
      "start_line": 22,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_2_val().",
      "display_name": "a0_2_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_2_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn a0_2_val(a: [u64; 5]) -> u64 {\n    a0_1_val(a) & mask51\n}",
      "start_line": 108,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_equals_spec_fe51_to_bytes().",
      "display_name": "lemma_as_bytes_equals_spec_fe51_to_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_equals_spec_fe51_to_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/as_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/as_bytes_lemmas.rs",
      "file_name": "as_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_as_bytes_equals_spec_fe51_to_bytes(fe: &FieldElement51, bytes: &[u8; 32])\n    requires\n        u8_32_as_nat(bytes) == u64_5_as_nat(fe.limbs) % p(),\n    ensures\n        seq_from32(bytes) == spec_fe51_to_bytes(fe),\n{\n    // Step 1: Derive that bytes is canonical (< p)\n    // This follows from x % p < p for any x\n    assert(u8_32_as_nat(bytes) < p()) by {\n        pow255_gt_19();\n        lemma_mod_is_mod_recursive(u64_5_as_nat(fe.limbs) as int, p() as int);\n    }\n\n    // Step 2: Prove element-wise equality between spec and bytes\n    lemma_spec_fe51_to_bytes_matches_array(fe, bytes);\n\n    // Step 3: Conclude sequence equality\n    assert(spec_fe51_to_bytes(fe).len() == 32);\n    assert(seq_from32(bytes).len() == 32);\n\n    assert forall|i: int| 0 <= i < 32 implies seq_from32(bytes)[i] == spec_fe51_to_bytes(fe)[i] by {\n        assert(seq_from32(bytes)[i] == bytes[i]);\n        assert(spec_fe51_to_bytes(fe)[i] == bytes[i]);\n    }\n\n    assert(seq_from32(bytes) =~= spec_fe51_to_bytes(fe));\n}",
      "start_line": 153,
      "end_line": 54,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_x25519_basepoint_u().",
      "display_name": "spec_x25519_basepoint_u",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_x25519_basepoint_u().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_x25519_basepoint_u() -> nat {\n    spec_field_element_from_bytes(&X25519_BASEPOINT.0)\n}",
      "start_line": 332,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#MulAssign#mul_assign().",
      "display_name": "mul_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#MulAssign#mul_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }",
      "start_line": 443,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_hi_limbs_bounded().",
      "display_name": "lemma_hi_limbs_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_hi_limbs_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "file_name": "scalar_lemmas_extra.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_hi_limbs_bounded(hi: &Scalar52, words: &[u64; 8], mask: u64)\n    requires\n        mask == (1u64 << 52) - 1u64,\n        hi.limbs[0] == (words[4] >> 4) & mask,\n        hi.limbs[1] == ((words[4] >> 56) | (words[5] << 8)) & mask,\n        hi.limbs[2] == ((words[5] >> 44) | (words[6] << 20)) & mask,\n        hi.limbs[3] == ((words[6] >> 32) | (words[7] << 32)) & mask,\n        hi.limbs[4] == words[7] >> 20,\n    ensures\n        forall|i: int| #![auto] 0 <= i < 5 ==> hi.limbs[i] < (1u64 << 52),\n{\n    lemma_borrow_and_mask_bounded(words[4] >> 4, mask);\n    lemma_borrow_and_mask_bounded((words[4] >> 56) | (words[5] << 8), mask);\n    lemma_borrow_and_mask_bounded((words[5] >> 44) | (words[6] << 20), mask);\n    lemma_borrow_and_mask_bounded((words[6] >> 32) | (words[7] << 32), mask);\n    let word7 = words[7];\n    assert(word7 >> 20 <= u64::MAX >> 20) by (bit_vector);\n    assert(u64::MAX >> 20 < (1u64 << 52)) by (bit_vector);\n}",
      "start_line": 520,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_geometric_double().",
      "display_name": "lemma_pow2_geometric_double",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_geometric_double().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_geometric_double(n: nat)\n    ensures\n        (pow2(n) - 1) * pow2(n) + (pow2(n) - 1) == pow2(2 * n) - 1,\n{\n    lemma2_to64();\n    lemma_pow2_adds(n, n);\n    assert(pow2(2 * n) == pow2(n) * pow2(n)) by {\n        assert(n + n == 2 * n);\n    }\n    // (2^n - 1) * 2^n + (2^n - 1)\n    // = 2^n * 2^n - 2^n + 2^n - 1\n    // = 2^(2n) - 1\n    lemma_mul_is_distributive_sub(pow2(n) as int, pow2(n) as int, 1);\n}",
      "start_line": 868,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_from_le_bytes().",
      "display_name": "u64_from_le_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_from_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub fn u64_from_le_bytes(bytes: [u8; 8]) -> (x: u64)\n    ensures\n        x as nat == bytes_seq_to_nat(seq_from8(&bytes)),\n{\n    u64::from_le_bytes(bytes)\n}",
      "start_line": 135,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_limbs_bounded_54().",
      "display_name": "lemma_one_limbs_bounded_54",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_limbs_bounded_54().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/constants_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/constants_lemmas.rs",
      "file_name": "constants_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_one_limbs_bounded_54()\n    ensures\n        fe51_limbs_bounded(&FieldElement51::ONE, 54),\n{\n    assert(fe51_limbs_bounded(&FieldElement51::ONE, 54)) by {\n        lemma_one_limbs_bounded();\n        assert((1u64 << 51) < (1u64 << 54)) by (bit_vector);\n    };\n}",
      "start_line": 54,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "display_name": "reduce",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn reduce(mut limbs: [u64; 5]) -> (r: FieldElement51)\n        ensures\n            r.limbs == spec_reduce(limbs),\n            forall|i: int| 0 <= i < 5 ==> r.limbs[i] < (1u64 << 52),\n            (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (r.limbs =~= limbs),\n            u64_5_as_nat(r.limbs) == u64_5_as_nat(limbs) - p() * (limbs[4] >> 51),\n            u64_5_as_nat(r.limbs) % p() == u64_5_as_nat(limbs) % p(),\n            u64_5_as_nat(r.limbs) < 2 * p(),\n    {\n        proof {\n            lemma_reduce_boundaries(limbs);\n            proof_reduce(limbs);\n            lemma_reduce_bound_2p(limbs);\n        }\n\n        // Since the input limbs are bounded by 2^64, the biggest\n        // carry-out is bounded by 2^13.\n        //\n        // The biggest carry-in is c4 * 19, resulting in\n        //\n        // 2^51 + 19*2^13 < 2^51.0000000001\n        //\n        // Because we don't need to canonicalize, only to reduce the\n        // limb sizes, it's OK to do a \"weak reduction\", where we\n        // compute the carry-outs in parallel.\n\n        let c0 = limbs[0] >> 51;\n        let c1 = limbs[1] >> 51;\n        let c2 = limbs[2] >> 51;\n        let c3 = limbs[3] >> 51;\n        let c4 = limbs[4] >> 51;\n\n        limbs[0] &= LOW_51_BIT_MASK;\n        limbs[1] &= LOW_51_BIT_MASK;\n        limbs[2] &= LOW_51_BIT_MASK;\n        limbs[3] &= LOW_51_BIT_MASK;\n        limbs[4] &= LOW_51_BIT_MASK;\n\n        limbs[0] += c4 * 19;\n        limbs[1] += c0;\n        limbs[2] += c1;\n        limbs[3] += c2;\n        limbs[4] += c3;\n\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51 { limbs }\n    }",
      "start_line": 856,
      "end_line": 14,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul().",
      "display_name": "lemma_pow2_mul_div_mod_small_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_mul_div_mod_small_mul(x: nat, px: nat, k: nat, s: nat, t: nat)\n    requires\n        x < pow2(px),\n        k <= s,\n        px <= t + s - k,\n    ensures\n        ((x * pow2(k)) / pow2(s)) % pow2(t) == x / pow2((s - k) as nat),\n{\n    let d = (s - k) as nat;\n\n    assert((x * pow2(k)) / pow2(s) == x / pow2(d)) by {\n        lemma_pow2_mul_div(x, k, s);\n    }\n\n    assert(pow2(d) > 0) by {\n        lemma_pow2_pos(d);\n    }\n\n    assert(x / pow2(d) < pow2(t)) by {\n        assert(x < pow2(d) * pow2(t)) by {\n            assert(pow2(d) * pow2(t) == pow2(d + t)) by {\n                lemma_pow2_adds(d, t);\n            }\n            assert(pow2(px) <= pow2(t + d)) by {\n                if (px < t + d) {\n                    lemma_pow2_strictly_increases(px, t + d);\n                }\n            }\n        }\n        assert(x / pow2(d) < pow2(t)) by {\n            lemma_multiply_divide_lt(x as int, pow2(d) as int, pow2(t) as int);\n        }\n    }\n\n    assert((x / pow2(d)) % pow2(t) == x / pow2(d)) by {\n        lemma_small_mod(x / pow2(d), pow2(t));\n    }\n}",
      "start_line": 494,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "display_name": "math_on_edwards_curve",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn math_on_edwards_curve(x: nat, y: nat) -> bool {\n    let p = p();\n    let d = spec_field_element(&EDWARDS_D);\n    let x2 = math_field_square(x);\n    let y2 = math_field_square(y);\n    let x2y2 = math_field_mul(x2, y2);\n\n    // -x² + y² = 1 + d·x²·y²\n    let lhs = math_field_sub(y2, x2);  // y² - x²\n    let rhs = math_field_add(1, math_field_mul(d, x2y2));  // 1 + d·x²·y²\n\n    lhs == rhs\n}",
      "start_line": 121,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 16,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 32 ==> #[trigger] self.bytes[i] == 0u8,\n    {\n        /* ORIGINAL CODE: self.bytes.zeroize(); */\n        crate::core_assumes::zeroize_bytes32(&mut self.bytes);\n    }",
      "start_line": 1193,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo zeroize 1.8.2 Vec#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo zeroize 1.8.2 Vec#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_u_zero_implies_identity_point().",
      "display_name": "lemma_u_zero_implies_identity_point",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_u_zero_implies_identity_point().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_u_zero_implies_identity_point(y: nat, u: nat)\n    requires\n        u == math_field_sub(math_field_square(y), 1),\n        u == 0,\n    ensures\n        math_field_square(y) == 1,\n        math_on_edwards_curve(0, y),\n        math_is_valid_y_coordinate(y),\n{\n    let p = p();\n    p_gt_2();\n    \n    let y2 = math_field_square(y);\n    \n    // Step 1: Prove y² = 1\n    // u = math_field_sub(y², 1) = 0\n    // Expand: (((y² % p) + p) - (1 % p)) % p = 0\n    // Since y² < p: (y² + p - 1) % p = 0\n    // Range: y² + p - 1 ∈ [p-1, 2p-1)\n    // Only multiple of p in this range is p, so y² + p - 1 = p, hence y² = 1\n    \n    lemma_mod_bound((y * y) as int, p as int);\n    assert(y2 < p);\n    lemma_small_mod(y2, p);\n    lemma_small_mod(1nat, p);\n    \n    // The key: math_field_sub(y2, 1) = 0 implies y2 = 1\n    // \n    // Proof: Let's compute math_field_sub(y2, 1) explicitly\n    // math_field_sub(y2, 1) = (((y2 % p) + p) - (1 % p)) % p\n    //                       = ((y2 + p) - 1) % p  [since y2 < p and 1 < p]\n    //                       = (y2 + p - 1) % p\n    //\n    // For y2 ∈ [0, p), we have y2 + p - 1 ∈ [p-1, 2p-1)\n    // This value mod p equals:\n    //   - 0 when y2 + p - 1 = p, i.e., y2 = 1\n    //   - p - 1 when y2 = 0 (value is p - 1)\n    //   - y2 - 1 when y2 >= 2 (value is y2 + p - 1, which mod p gives y2 - 1)\n    //\n    // Since u = 0, we must have y2 = 1.\n    \n    // First, let's show that the sum y2 + p - 1 is in [p-1, 2p-1)\n    let sum = (y2 + p - 1) as int;\n    assert(p as int - 1 <= sum) by { assert(y2 >= 0); };\n    assert(sum < 2 * p as int - 1) by { assert(y2 < p); };\n    \n    // For sum in [p-1, 2p-1), sum % p is:\n    // - sum - p if sum >= p\n    // - sum if sum < p\n    //\n    // sum >= p iff y2 + p - 1 >= p iff y2 >= 1\n    // sum < p iff y2 + p - 1 < p iff y2 < 1 iff y2 = 0\n    \n    assert(y2 == 1) by {\n        if y2 == 0 {\n            // sum = p - 1, and (p - 1) % p = p - 1 ≠ 0\n            assert(sum == p as int - 1);\n            assert(sum % p as int == (p - 1) as int) by {\n                lemma_small_mod((p - 1) as nat, p);\n            };\n            // This contradicts u = math_field_sub(y2, 1) = 0\n            assert(false);\n        } else if y2 >= 2 {\n            // sum = y2 + p - 1 >= p + 1\n            assert(sum >= p as int + 1);\n            // sum % p = sum - p = y2 - 1 >= 1\n            assert(sum % p as int == y2 as int - 1) by {\n                // sum = y2 + p - 1, sum - p = y2 - 1\n                // since 1 <= y2 - 1 < p - 1 < p, (y2 - 1) % p = y2 - 1\n                lemma_small_mod((y2 - 1) as nat, p);\n                lemma_mod_multiples_vanish(-1int, sum, p as int);\n            };\n            // y2 - 1 >= 1 ≠ 0, contradicts u = 0\n            assert(false);\n        }\n        // The only remaining case is y2 == 1\n    };\n    \n    // Step 2: Prove (0, y) is on the curve\n    // Curve: -x² + y² = 1 + d·x²·y²\n    // With x = 0: y² = 1 (which we just proved)\n    let d = spec_field_element(&EDWARDS_D);\n    \n    assert(math_field_square(0nat) == 0) by {\n        lemma_small_mod(0nat, p);\n    };\n    let x2 = math_field_square(0nat);\n    \n    assert(math_field_mul(x2, y2) == 0) by {\n        lemma_small_mod(0nat, p);\n    };\n    let x2y2 = math_field_mul(x2, y2);\n    \n    assert(math_field_mul(d, x2y2) == 0) by {\n        lemma_small_mod(0nat, p);\n    };\n    let d_x2y2 = math_field_mul(d, x2y2);\n    \n    // LHS: y² - 0 = y² = 1\n    assert(math_field_sub(y2, x2) == 1) by {\n        // math_field_sub(1, 0) = (1 + p) % p = 1\n        lemma_mod_multiples_vanish(1int, 1int, p as int);\n    };\n    \n    // RHS: 1 + 0 = 1\n    assert(math_field_add(1, d_x2y2) == 1) by {\n        lemma_small_mod(1nat, p);\n    };\n    \n    assert(math_on_edwards_curve(0, y));\n    \n    // Step 3: math_is_valid_y_coordinate(y) is true\n    // From the definition: when u % p == 0, it returns true directly\n    // u = math_field_sub(y2, 1) = 0, so u % p = 0\n    lemma_small_mod(0nat, p);\n    assert(u % p == 0);\n    // By definition of math_is_valid_y_coordinate, when u % p == 0, it's true\n    assert(math_is_valid_y_coordinate(y));\n}",
      "start_line": 937,
      "end_line": 49,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 12
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_divisible_by_prime().",
      "display_name": "lemma_binomial_divisible_by_prime",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_divisible_by_prime().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_binomial_divisible_by_prime(p: nat, k: nat)\n    requires\n        is_prime(p),\n        0 < k < p,\n    ensures\n        binomial(p, k) % p == 0,\n    decreases p,\n{\n    // Use Pascal's identity and induction\n    if p == 2 {\n        assert(k == 1);\n        assert(binomial(2, 1) == binomial(1, 0) + binomial(1, 1)) by {};\n        assert(binomial(1, 0) == 1);\n        assert(binomial(1, 1) == 1);\n        assert(binomial(2, 1) == 2);\n        assert(2nat % 2 == 0) by {\n            lemma_mod_self_0(2int);\n        };\n    } else {\n        lemma_binomial_prime_divisibility_helper(p, k);\n    }\n}",
      "start_line": 245,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_unary_negation().",
      "display_name": "lemma_mul_unary_negation",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_unary_negation().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "display_name": "from_montgomery",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn from_montgomery(&self) -> (result: Scalar52)\n        requires\n            limbs_bounded(self),\n        ensures\n            limbs_bounded(&result),\n            (to_nat(&result.limbs) * montgomery_radix()) % group_order() == to_nat(&self.limbs)\n                % group_order(),\n    {\n        let mut limbs = [0u128;9];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..5\n            invariant\n                forall|j: int| #![auto] 0 <= j < i ==> limbs[j] == self.limbs[j] as u128,\n                forall|j: int| #![auto] i <= j < 9 ==> limbs[j] == 0,\n        {\n            limbs[i] = self.limbs[i] as u128;\n        }\n        proof {\n            lemma_from_montgomery_is_product_with_one(self, &limbs);\n        }\n        let result = Scalar52::montgomery_reduce(&limbs);\n        proof {\n            lemma_from_montgomery_limbs_conversion(&limbs, &self.limbs);\n        }\n        result\n    }",
      "start_line": 1181,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "display_name": "lemma_pow2_div_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_div_mod(x: nat, k: nat, s: nat)\n    ensures\n        (x / pow2(k)) % pow2(s) == (x % pow2(s + k)) / pow2(k),\n{\n    let d = s + k;\n    let ps = pow2(s);\n    let pk = pow2(k);\n    let pd = pow2(d);\n\n    assert(pd > 0) by {\n        lemma_pow2_pos(d);\n    }\n\n    assert(pd == ps * pk == pk * ps) by {\n        lemma_pow2_adds(s, k);\n        lemma_mul_is_commutative(ps as int, pk as int);\n    }\n\n    assert(x == pd * (x / pd) + x % pd) by {\n        lemma_fundamental_div_mod(x as int, pd as int);\n    }\n\n    let x_div_pd = x / pd;\n    let x_mod_pd = x % pd;\n\n    assert(x_mod_pd < pd) by {\n        lemma_mod_bound(x as int, pd as int);\n    }\n\n    // x / pk = (pd * (x / pd) + x % pd) / pk\n    // ==\n    // (pd * (x / pd)) / pk + (x % pd) / pk\n    // ==\n    // (ps * (x / pd)) + (x % pd) / pk\n    assert(x / pk == ps * x_div_pd + x_mod_pd / pk) by {\n        assert((pd * x_div_pd + x_mod_pd) / pk == (pd * x_div_pd) / pk + x_mod_pd / pk) by {\n            lemma_mul_is_commutative(pd as int, x_div_pd as int);\n            lemma_bindary_sum_div_decomposition(x_mod_pd, x_div_pd, d, k);\n        }\n        assert((pd * x_div_pd) / pk == ps * x_div_pd) by {\n            assert(pd * x_div_pd == pk * (ps * x_div_pd)) by {\n                lemma_mul_is_associative(pk as int, ps as int, x_div_pd as int);\n            }\n            assert((pk * (ps * x_div_pd)) / pk == ps * x_div_pd) by {\n                lemma_div_multiples_vanish((ps * x_div_pd) as int, pk as int);\n            }\n        }\n    }\n\n    // (x / pk) % ps = ((ps * (x / pd)) + (x % pd) / pk ) % ps\n    // == <- (x % pd) < pd => (x % pd) / pk < pd / pk = ps\n    // ((ps * (x / pd)) % ps + (x % pd) / pk ) % ps\n    // ==\n    // (x % pd) / pk\n    assert((x / pk) % ps == x_mod_pd / pk) by {\n        assert(pk > 0) by {\n            lemma_pow2_pos(k);\n        }\n        // x_mod_pd < pd is known\n        assert(x_mod_pd / pk < ps) by {\n            assert(ps == pd / pk) by {\n                lemma_div_by_multiple(ps as int, pk as int);\n            }\n            lemma_div_by_multiple_is_strongly_ordered(\n                x_mod_pd as int,\n                pd as int,\n                ps as int,\n                pk as int,\n            );\n        }\n        // satisfies conditions for lemma_binary_sum_mod_decomposition\n        assert((ps * x_div_pd + x_mod_pd / pk) % ps == (ps * x_div_pd) % ps + (x_mod_pd / pk) % ps)\n            by {\n            lemma_binary_sum_mod_decomposition(x_mod_pd / pk, x_div_pd, s, s);\n        }\n        assert((ps * x_div_pd) % ps == 0) by {\n            lemma_mul_is_commutative(ps as int, x_div_pd as int);\n            lemma_mod_multiples_basic(x_div_pd as int, ps as int);\n        }\n        assert((x_mod_pd / pk) % ps == x_mod_pd / pk) by {\n            // x_mod_pd / pk < ps is known\n            lemma_small_mod(x_mod_pd / pk, ps);\n        }\n    }\n}",
      "start_line": 315,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iter/slice/Iter#Iterator#all().",
      "display_name": "all",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iter/slice/Iter#Iterator#all().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_div_u8().",
      "display_name": "lemma_pow2_mul_div_mod_small_div_u8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_div_u8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_mul_div_mod_small_div_u8(x: u8, k: nat, s: nat, t: nat)\n    requires\n        s <= k,\n        8 + k - s <= t,\n    ensures\n        ((x as nat * pow2(k)) / pow2(s)) % pow2(t) == x as nat * pow2((k - s) as nat),\n{\n    assert(x < pow2(8)) by {\n        lemma2_to64();  // pow2(8)\n    }\n    lemma_pow2_mul_div_mod_small_div(x as nat, 8, k, s, t);\n}",
      "start_line": 481,
      "end_line": 49,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c1_val().",
      "display_name": "c1_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c1_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn c1_val(a: [u64; 5]) -> u128 {\n    (c1_0_val(a) + ((c0_val(a) >> 51) as u64) as u128) as u128\n}",
      "start_line": 60,
      "end_line": 24,
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "display_name": "invsqrt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "curve25519-dalek/src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn invsqrt(&self) -> (result: (\n        Choice,\n        FieldElement,\n    ))\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n    // When self = 0: return (false, 0)\n\n            (spec_field_element(self) == 0) ==> (!choice_is_true(result.0) && spec_field_element(\n                &result.1,\n            ) == 0),\n            // When successful and self ≠ 0: r² * self ≡ 1 (mod p)\n            (choice_is_true(result.0)) ==> is_sqrt_ratio(&FieldElement::ONE, self, &result.1),\n            // When unsuccessful and self ≠ 0: r² * self ≡ i (mod p) [nonsquare case]\n            (!choice_is_true(result.0) && spec_field_element(self) != 0) ==> is_sqrt_ratio_times_i(\n                &FieldElement::ONE,\n                self,\n                &result.1,\n            ),\n    {\n        assume(false);\n        FieldElement::sqrt_ratio_i(&FieldElement::ONE, self)\n    }",
      "start_line": 992,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/reconstruct_radix_2w().",
      "display_name": "reconstruct_radix_2w",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/reconstruct_radix_2w().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn reconstruct_radix_2w(digits: Seq<i8>, w: nat) -> int\n    decreases digits.len(),\n{\n    if digits.len() == 0 {\n        0\n    } else {\n        (digits[0] as int) + pow2(w) * reconstruct_radix_2w(digits.skip(1), w)\n    }\n}",
      "start_line": 191,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_mod_is_id().",
      "display_name": "lemma_u8_times_pow2_mod_is_id",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_mod_is_id().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_u8_times_pow2_mod_is_id(a: u8, k: nat, s: nat)\n    requires\n        k + 8 <= s,\n    ensures\n        (pow2(k) * a) as nat % pow2(s) == pow2(k) * a,\n{\n    assert(pow2(k) * a < pow2(k + 8)) by {\n        lemma_pow2_mul_bound_u8(a, k);\n    }\n    if (k + 8 < s) {\n        assert(pow2(k + 8) < pow2(s)) by {\n            lemma_pow2_strictly_increases(k + 8, s);\n        }\n    }\n    assert(pow2(s) > 0) by {\n        lemma_pow2_pos(s);\n    }\n\n    assert((pow2(k) * a) as nat % pow2(s) == pow2(k) * a) by {\n        lemma_small_mod((pow2(k) * a) as nat, pow2(s));\n    }\n}",
      "start_line": 249,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "display_name": "fe51_limbs_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn fe51_limbs_bounded(fe: &FieldElement51, bit_limit: u64) -> bool {\n    forall|i: int| 0 <= i < 5 ==> fe.limbs[i] < (1u64 << bit_limit)\n}",
      "start_line": 27,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 49,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "display_name": "lemma_limb4_contribution_correctness_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub proof fn lemma_limb4_contribution_correctness_52(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[4] < (1u64 << 52),\n        bytes_match_limbs_packing_52(limbs, bytes),\n    ensures\n        limb4_byte_contribution_52(limbs, bytes) == ((limbs[4] as nat) % pow2(48)) * pow2(208),\n{\n    let l = ((limbs[4] as nat) % pow2(48));\n\n    // Paper proof:\n    // Limb 4 occupies bytes 26-31 (no boundary!) at position 2^208\n    // From the packing predicate: bytes[26..31] = limbs[4] >> 0, 8, 16, 24, 32, 40\n    // Therefore: bytes reconstruct limbs[4]\n    // And: limb4_contribution = Σ bytes[i] * 2^(i*8) = limbs[4] * 2^208\n    lemma2_to64();\n    lemma_shift_is_pow2(52);\n\n    // Step 1: Show bytes 26-31 encode limbs[4] using byte-shift arithmetic\n    lemma_shr_zero_is_id(limbs[4]);\n    lemma_byte_from_limb_shift_52(limbs[4], 0, bytes[26]);\n    lemma_byte_from_limb_shift_52(limbs[4], 8, bytes[27]);\n    lemma_byte_from_limb_shift_52(limbs[4], 16, bytes[28]);\n    lemma_byte_from_limb_shift_52(limbs[4], 24, bytes[29]);\n    lemma_byte_from_limb_shift_52(limbs[4], 32, bytes[30]);\n    lemma_byte_from_limb_shift_52(limbs[4], 40, bytes[31]);\n\n    // TODO: Prove limbs[4] < 2^48\n    //\n    // This bound is required because 6 bytes can only represent 48 bits.\n    // The structural constraint for 256-bit scalars is that limb 4 occupies\n    // only 48 bits (256 - 4*52 = 48), not the full 52 bits.\n    //\n    // However, scalar arithmetic operations use a 52-bit mask for all limbs,\n    // so this bound is not maintained by the implementation.\n    // See docs_22_oct/scalar_limb4_bound_issue.md for details.\n    //\n    // This assume is sound because:\n    // - The packing predicate guarantees bytes 26-31 encode limbs[4]\n    // - 6 bytes can only represent values < 2^48\n    // - Therefore limbs[4] must be < 2^48\n    // But we cannot formally derive this from the current preconditions.\n    assert(l < pow2(48)) by {\n        lemma_pow2_pos(48);\n        lemma_mod_bound(limbs[4] as int, pow2(48) as int);\n    }\n\n    assert forall|i: nat| 0 <= i <= 5 implies #[trigger] (limbs[4] as nat / pow2(i * 8)) % 256 == (l\n        / pow2(i * 8)) % 256 by {\n        assert(256 == pow2(8) && pow2(0) == 1) by {\n            lemma2_to64();\n        }\n        assert((limbs[4] as nat / pow2(i * 8)) % pow2(8) == (limbs[4] as nat % pow2(8 + i * 8))\n            / pow2(i * 8)) by {\n            lemma_pow2_div_mod(limbs[4] as nat, i * 8, 8);\n        }\n\n        assert((l / pow2(i * 8)) % pow2(8) == (l % pow2(8 + i * 8)) / pow2(i * 8)) by {\n            lemma_pow2_div_mod(l, i * 8, 8);\n        }\n\n        assert(l % pow2(8 + i * 8) == limbs[4] as nat % pow2(8 + i * 8)) by {\n            // 8 + i * 8 <= 48\n            let j = 8 + i * 8;\n            let d = (48 - j) as nat;\n            assert(pow2(48) == pow2(j) * pow2(d)) by {\n                lemma_pow2_adds(j, d);\n            }\n            assert(pow2(j) > 0 && pow2(d) > 0) by {\n                lemma_pow2_pos(j);\n                lemma_pow2_pos(d);\n            }\n            assert((limbs[4] as nat % (pow2(j) * pow2(d))) % pow2(j) == limbs[4] as nat % pow2(j))\n                by {\n                lemma_mod_mod(limbs[4] as int, pow2(j) as int, pow2(d) as int);\n            }\n\n        }\n    }\n\n    // Trigger forall\n    assert(bytes[26int + 0] as nat == (l / pow2(0 * 8)) % 256);\n    assert(bytes[26int + 1] as nat == (l / pow2(1 * 8)) % 256);\n    assert(bytes[26int + 2] as nat == (l / pow2(2 * 8)) % 256);\n    assert(bytes[26int + 3] as nat == (l / pow2(3 * 8)) % 256);\n    assert(bytes[26int + 4] as nat == (l / pow2(4 * 8)) % 256);\n    assert(bytes[26int + 5] as nat == (l / pow2(5 * 8)) % 256);\n\n    // Apply 6-byte reconstruction: bytes[26..31] = limbs[4]\n    lemma_6_bytes_reconstruct(l, bytes[26], bytes[27], bytes[28], bytes[29], bytes[30], bytes[31]);\n    let bytes_sum = bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat\n        * pow2(16) + bytes[29] as nat * pow2(24) + bytes[30] as nat * pow2(32) + bytes[31] as nat\n        * pow2(40);\n\n    assert(bytes_sum * pow2(208) == l * pow2(208));\n\n    assert(bytes_sum * pow2(208) == (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8)\n        + bytes[28] as nat * pow2(16) + bytes[29] as nat * pow2(24) + bytes[30] as nat * pow2(32)\n        + bytes[31] as nat * pow2(40)) * pow2(208));\n\n    assert((bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat * pow2(16)\n        + bytes[29] as nat * pow2(24) + bytes[30] as nat * pow2(32) + bytes[31] as nat * pow2(40))\n        * pow2(208) == (bytes[26] as nat * pow2(0) * pow2(208) + bytes[27] as nat * pow2(8) * pow2(\n        208,\n    ) + bytes[28] as nat * pow2(16) * pow2(208) + bytes[29] as nat * pow2(24) * pow2(208)\n        + bytes[30] as nat * pow2(32) * pow2(208) + bytes[31] as nat * pow2(40) * pow2(208))) by {\n        // Distribute pow2(208) across the sum using repeated application of distributivity\n        lemma_mul_is_distributive_add(\n            pow2(208) as int,\n            (bytes[26] as nat * pow2(0)) as int,\n            (bytes[27] as nat * pow2(8)) as int,\n        );\n        lemma_mul_is_distributive_add(\n            pow2(208) as int,\n            (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8)) as int,\n            (bytes[28] as nat * pow2(16)) as int,\n        );\n        lemma_mul_is_distributive_add(\n            pow2(208) as int,\n            (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat * pow2(\n                16,\n            )) as int,\n            (bytes[29] as nat * pow2(24)) as int,\n        );\n        lemma_mul_is_distributive_add(\n            pow2(208) as int,\n            (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat * pow2(16)\n                + bytes[29] as nat * pow2(24)) as int,\n            (bytes[30] as nat * pow2(32)) as int,\n        );\n        lemma_mul_is_distributive_add(\n            pow2(208) as int,\n            (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat * pow2(16)\n                + bytes[29] as nat * pow2(24) + bytes[30] as nat * pow2(32)) as int,\n            (bytes[31] as nat * pow2(40)) as int,\n        );\n    };\n\n    assert((bytes[26] as nat * pow2(0) * pow2(208) + bytes[27] as nat * pow2(8) * pow2(208)\n        + bytes[28] as nat * pow2(16) * pow2(208) + bytes[29] as nat * pow2(24) * pow2(208)\n        + bytes[30] as nat * pow2(32) * pow2(208) + bytes[31] as nat * pow2(40) * pow2(208)) == (\n    bytes[26] as nat * pow2(208) + bytes[27] as nat * pow2(216) + bytes[28] as nat * pow2(224)\n        + bytes[29] as nat * pow2(232) + bytes[30] as nat * pow2(240) + bytes[31] as nat * pow2(\n        248,\n    ))) by {\n        lemma_mul_is_associative(bytes[26] as int, pow2(0) as int, pow2(208) as int);\n        lemma_mul_is_associative(bytes[27] as int, pow2(8) as int, pow2(208) as int);\n        lemma_mul_is_associative(bytes[28] as int, pow2(16) as int, pow2(208) as int);\n        lemma_mul_is_associative(bytes[29] as int, pow2(24) as int, pow2(208) as int);\n        lemma_mul_is_associative(bytes[30] as int, pow2(32) as int, pow2(208) as int);\n        lemma_mul_is_associative(bytes[31] as int, pow2(40) as int, pow2(208) as int);\n\n        lemma_pow2_adds(0, 208);  // pow2(0) * pow2(208) = pow2(208)\n        lemma_pow2_adds(8, 208);  // pow2(8) * pow2(208) = pow2(216)\n        lemma_pow2_adds(16, 208);  // pow2(16) * pow2(208) = pow2(224)\n        lemma_pow2_adds(24, 208);  // pow2(24) * pow2(208) = pow2(232)\n        lemma_pow2_adds(32, 208);  // pow2(32) * pow2(208) = pow2(240)\n        lemma_pow2_adds(40, 208);\n    };\n}",
      "start_line": 1222,
      "end_line": 53,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "display_name": "math_field_sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn math_field_sub(a: nat, b: nat) -> nat {\n    (((a % p()) + p()) - (b % p())) as nat % p()\n}",
      "start_line": 99,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 25,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_low_bits_masks_fit_u64().",
      "display_name": "lemma_low_bits_masks_fit_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_low_bits_masks_fit_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mask_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mask_lemmas.rs",
      "file_name": "mask_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_low_bits_masks_fit_u64(k: nat)\n    requires\n        k <= 64,\n    ensures\n        low_bits_mask(k) <= u64::MAX,\n{\n    lemma_low_bits_mask_values();  // lbm(0) = 0, lbm(64) = 2^64\n    assert(low_bits_mask(64) <= u64::MAX) by (compute);\n    if (k < 64) {\n        lemma_low_bits_mask_increases(k, 64);\n    }\n}",
      "start_line": 54,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_mul_sub().",
      "display_name": "lemma_mul_sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_mul_sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_mul_sub(ci: int, cj: int, cj_0: int, k: nat)\n    ensures\n        pow2(k) * (ci - pow2(51) * (cj - cj_0)) == pow2(k) * ci - pow2(k + 51) * cj + pow2(k + 51)\n            * cj_0,\n{\n    // 2^k (ci - X) = 2^k ci - 2^k X\n    lemma_mul_is_distributive_sub(pow2(k) as int, ci, pow2(51) * (cj - cj_0));\n    // 2^k (2^51 * Y) = (2^k * 2^51) * Y\n    lemma_mul_is_associative(pow2(k) as int, pow2(51) as int, cj - cj_0);\n    // 2^k * 2^51 = 2^(k + 51)\n    lemma_pow2_adds(k, 51);\n    // 2^(k + 51) * (cj - cj_0) = 2^(k + 51) * cj - 2^(k + 51) * cj_0\n    lemma_mul_is_distributive_sub(pow2(k + 51) as int, cj, cj_0);\n}",
      "start_line": 88,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "display_name": "lemma_limb0_contribution_correctness_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub proof fn lemma_limb0_contribution_correctness_52(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[0] < (1u64 << 52),\n        bytes_match_limbs_packing_52(limbs, bytes),\n    ensures\n        limb0_byte_contribution_52(limbs, bytes) == (limbs[0] as nat) % pow2(52),\n{\n    // Limb 0 is stored in bytes 0-6\n    // - Bytes 0-5: full bytes containing limbs[0]'s bits 0-47 (48 bits total)\n    // - Byte 6 (low 4 bits): limbs[0]'s bits 48-51 (4 bits)\n    // Total: 48 + 4 = 52 bits, which matches limbs[0] < 2^52\n    //\n    // Strategy: Apply div-mod theorem at the 48-bit boundary\n    // limbs[0] = (limbs[0] % 2^48) + (limbs[0] / 2^48) * 2^48\n    lemma2_to64();\n    lemma_shift_is_pow2(52);\n    assert(pow2(8) == 256);\n\n    // Step 1: Show bytes 0-5 contribute (limbs[0] % 2^48)\n    // From bytes_match_limbs_packing_52, we know:\n    // bytes[0] = limbs[0] as u8\n    // bytes[1] = (limbs[0] >> 8) as u8\n    // ... and so on\n\n    // These bytes, when summed with their position weights, reconstruct limbs[0] % 2^48\n    let low_48_bits = bytes[0] as nat * pow2(0 * 8) + bytes[1] as nat * pow2(1 * 8)\n        + bytes[2] as nat * pow2(2 * 8) + bytes[3] as nat * pow2(3 * 8) + bytes[4] as nat * pow2(\n        4 * 8,\n    ) + bytes[5] as nat * pow2(5 * 8);\n\n    // Use lemma_byte_from_limb_shift_52 to establish arithmetic value of each byte\n    lemma_shr_zero_is_id(limbs[0]);\n    assert(bytes[0] == (limbs[0] >> 0) as u8);\n    lemma_byte_from_limb_shift_52(limbs[0], 0, bytes[0]);\n    assert(bytes[0] as nat == (limbs[0] as nat / pow2(0)) % 256);\n\n    lemma_byte_from_limb_shift_52(limbs[0], 8, bytes[1]);\n    assert(bytes[1] as nat == (limbs[0] as nat / pow2(8)) % 256);\n\n    lemma_byte_from_limb_shift_52(limbs[0], 16, bytes[2]);\n    assert(bytes[2] as nat == (limbs[0] as nat / pow2(16)) % 256);\n\n    lemma_byte_from_limb_shift_52(limbs[0], 24, bytes[3]);\n    assert(bytes[3] as nat == (limbs[0] as nat / pow2(24)) % 256);\n\n    lemma_byte_from_limb_shift_52(limbs[0], 32, bytes[4]);\n    assert(bytes[4] as nat == (limbs[0] as nat / pow2(32)) % 256);\n\n    lemma_byte_from_limb_shift_52(limbs[0], 40, bytes[5]);\n    assert(bytes[5] as nat == (limbs[0] as nat / pow2(40)) % 256);\n\n    // For each byte i (i=0..5), extraction from limbs[0] equals extraction from limbs[0] % 2^48\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 0, 48);\n    assert(bytes[0] as nat == ((limbs[0] as nat % pow2(48)) / pow2(0)) % 256);\n\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 1, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 2, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 3, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 4, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 5, 48);\n\n    // The modulo value fits in a valid range\n    lemma_pow2_pos(48);\n    assert(pow2(48) > 0);\n    let modulo_value = limbs[0] as nat % pow2(48);\n    assert(modulo_value < pow2(48)) by {\n        lemma_mod_bound(limbs[0] as int, pow2(48) as int);\n    }\n    assert(pow2(48) < pow2(64)) by {\n        lemma_pow2_strictly_increases(48, 64);\n    }\n\n    let limb0_low48 = modulo_value as u64;\n    assert(limb0_low48 as nat == modulo_value);\n    assert(limb0_low48 < pow2(48));\n\n    // Apply the 6-byte reconstruction lemma\n    lemma_6_bytes_reconstruct(\n        limb0_low48 as nat,\n        bytes[0],\n        bytes[1],\n        bytes[2],\n        bytes[3],\n        bytes[4],\n        bytes[5],\n    );\n\n    assert(low_48_bits == (limbs[0] as nat % pow2(48)));\n\n    // Step 2: Handle the contribution from byte 6's low 4 bits\n    // Since limbs[0] < 2^52, we have limbs[0] / 2^48 < 2^4 = 16\n    lemma_div_bound(limbs[0] as nat, 48, 52);\n    assert(limbs[0] as nat / pow2(48) < pow2(4));\n    lemma2_to64();\n    assert(pow2(4) == 16);\n\n    let high_4_bits_contribution = ((limbs[0] as nat / pow2(48)) % 16) * pow2(6 * 8);\n\n    // Since limbs[0]/2^48 < 16, taking % 16 is identity\n    assert((limbs[0] as nat / pow2(48)) % 16 == limbs[0] as nat / pow2(48));\n    assert(high_4_bits_contribution == (limbs[0] as nat / pow2(48)) * pow2(48));\n\n    // Step 3: Apply div-mod theorem\n    lemma_pow2_pos(48);\n    lemma_fundamental_div_mod(limbs[0] as int, pow2(48) as int);\n    assert(limbs[0] as nat == (limbs[0] as nat % pow2(48)) + (limbs[0] as nat / pow2(48)) * pow2(\n        48,\n    ));\n\n    // Step 4: Show this equals limb0_byte_contribution_52\n    assert(limb0_byte_contribution_52(limbs, bytes) == low_48_bits + high_4_bits_contribution);\n    assert(limb0_byte_contribution_52(limbs, bytes) == limbs[0] as nat);\n\n    // Since limbs[0] < 2^52, limbs[0] % 2^52 = limbs[0]\n    assert(limbs[0] as nat % pow2(52) == limbs[0] as nat) by {\n        lemma_small_mod(limbs[0] as nat, pow2(52));\n    }\n}",
      "start_line": 548,
      "end_line": 53,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_div_extracts_byte().",
      "display_name": "lemma_as_nat_prefix_div_extracts_byte",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_div_extracts_byte().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "file_name": "u8_32_as_nat_injectivity_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_as_nat_prefix_div_extracts_byte(bytes: &[u8; 32], i: nat)\n    requires\n        i < 32,\n    ensures\n        (as_nat_prefix(bytes, i + 1) / pow2(i * 8)) % pow2(8) == bytes[i as int] as nat,\n{\n    lemma2_to64();\n\n    // Step 1: Expand as_nat_prefix(bytes, i+1)\n    assert(as_nat_prefix(bytes, i + 1) == as_nat_prefix(bytes, i) + bytes[i as int] as nat * pow2(\n        (i * 8) as nat,\n    ));\n\n    // Step 2: Show that as_nat_prefix(bytes, i) < pow2(i*8)\n    assert(as_nat_prefix(bytes, i) < pow2((i * 8) as nat)) by {\n        lemma_as_nat_prefix_bounded(bytes, i);\n    }\n\n    // Step 3: Division of (LOW + bytes[i] * d) / d == bytes[i] when LOW < d\n    let low = as_nat_prefix(bytes, i);\n    let d = pow2((i * 8) as nat);\n    let byte_val = bytes[i as int] as nat;\n\n    // Since low < d, we have low / d == 0\n    assert(low / d == 0) by {\n        lemma_basic_div(low as int, d as int);\n    }\n\n    // Therefore: (low + byte_val * d) / d == byte_val\n    lemma_pow2_pos((i * 8) as nat);\n    assert(d > 0);\n\n    // Use division algebra: (d * x + b) / d == x when 0 < d and 0 <= b < d\n    // We have: 0 < d, 0 <= low < d, so we can apply the lemma\n    lemma_div_multiples_vanish_fancy(byte_val as int, low as int, d as int);\n    // This gives us: (d * byte_val + low) / d == byte_val\n\n    // Show that (low + byte_val * d) = (d * byte_val + low) by commutativity\n    assert(low + byte_val * d == d * byte_val + low) by {\n        lemma_mul_is_commutative(byte_val as int, d as int);\n    }\n    assert((low + byte_val * d) / d == byte_val);\n\n    // Step 4: bytes[i] < pow2(8), so bytes[i] % pow2(8) == bytes[i]\n    assert(byte_val % pow2(8) == byte_val) by {\n        lemma_u8_lt_pow2_8(bytes[i as int]);\n        lemma_small_mod(byte_val, pow2(8));\n    }\n}",
      "start_line": 248,
      "end_line": 51,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/Mul#mul().",
      "display_name": "mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/Mul#mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "curve25519-dalek/src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn mul(self, point: &MontgomeryPoint) -> (result: MontgomeryPoint)\n        ensures\n    // Delegates to point * self, which multiplies by the unreduced scalar using canonical lift\n\n            ({\n                let P = canonical_montgomery_lift(spec_montgomery_point(*point));\n                let n_unreduced = scalar_to_nat(self);\n                let R = montgomery_scalar_mul(P, n_unreduced);\n                spec_montgomery_point(result) == spec_u_coordinate(R)\n            }),",
      "start_line": 882,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul_signed().",
      "display_name": "edwards_scalar_mul_signed",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul_signed().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn edwards_scalar_mul_signed(point_affine: (nat, nat), n: int) -> (nat, nat) {\n    if n >= 0 {\n        edwards_scalar_mul(point_affine, n as nat)\n    } else {\n        let (x, y) = edwards_scalar_mul(point_affine, (-n) as nat);\n        (math_field_neg(x), y)\n    }\n}",
      "start_line": 741,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#MulAssign#mul_assign().",
      "display_name": "mul_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#MulAssign#mul_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn mul_assign(&mut self, scalar: &'b Scalar) {\n        let result = (self as &RistrettoPoint) * scalar;\n        *self = result;\n    }",
      "start_line": 923,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"NafLookupTable5({:?})\", self.0)\n    }",
      "start_line": 546,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/lemma_low_bits_mask_div2().",
      "display_name": "lemma_low_bits_mask_div2",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/lemma_low_bits_mask_div2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mask_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mask_lemmas.rs",
      "file_name": "mask_lemmas.rs",
      "parent_folder": "common_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "display_name": "pack",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn pack(&self) -> (result: Scalar)\n        requires\n            limbs_bounded(self),\n        ensures\n            bytes_to_nat(&result.bytes) == to_nat(&self.limbs) % pow2(256),\n            // VERIFICATION NOTE: If input is canonical (< group order), output satisfies Scalar invariants\n            to_nat(&self.limbs) < group_order() ==> is_canonical_scalar(&result),\n    {\n        let bytes = self.as_bytes();\n        proof {\n            lemma_five_limbs_equals_to_nat(&self.limbs);\n        }\n        let result = Scalar { bytes: bytes };\n        // VERIFICATION NOTE: TODO: Prove these follow from as_bytes() spec\n        // result.bytes is [u8; 32]\n        // group order is pow2(252) + 27742317777372353535851937790883648493nat\n        // if result.bytes[31] > 127, then when we apply bytes_to_nat, we'll end up with\n        // something large than group_order, contradiction\n        // bytes[31] * 2^(31*8) + ...\n        // 127 * 2^(31*8) == 57443731770074831323412168344153766786583156455220123566449660816425654157312\n        // group order is     7237005577332262213973186563042994240857116359379907606001950938285454250989\n        // which is smaller\n        // unfold with fuel 32\n        // Another approach is like lemma_nine_limbs_equals_slice128_to_nat,\n        // which shows that a recursive defn equals a large polynomial\n\n        proof {\n            if to_nat(&self.limbs) < group_order() {\n                use crate::lemmas::scalar_lemmas::lemma_scalar52_lt_pow2_256_if_canonical;\n\n                lemma_scalar52_lt_pow2_256_if_canonical(self);\n                lemma_small_mod(to_nat(&self.limbs), pow2(256));\n                assert(to_nat(&self.limbs) % pow2(256) == to_nat(&self.limbs));\n                assert(bytes_to_nat(&result.bytes) == to_nat(&self.limbs));\n\n                let v = bytes_to_nat(&result.bytes);\n\n                use crate::specs::core_specs::u8_32_as_nat;\n                assert(bytes_to_nat(&result.bytes) == u8_32_as_nat(&result.bytes));\n\n                assert(v == bytes_to_nat(&result.bytes));\n                assert(v < group_order());\n                {\n                    use crate::lemmas::scalar_lemmas::lemma_group_order_bound;\n                    lemma_group_order_bound();\n                    assert(group_order() < pow2(255));\n\n                    assert(v < pow2(255));  // by transitivity\n\n                    let b31: nat = result.bytes[31] as nat;\n                    if b31 >= 128 {\n                        // v ≥ b31*2^248 ≥ 2^255\n                        use vstd::arithmetic::power2::{pow2, lemma_pow2_adds, lemma2_to64};\n                        use vstd::arithmetic::mul::lemma_mul_inequality;\n\n                        // Use the lemma\n                        use crate::lemmas::scalar_lemmas::lemma_bytes_to_nat_lower_bound;\n                        lemma_bytes_to_nat_lower_bound(&result.bytes, 31);\n\n                        lemma_pow2_adds(7, 248);\n\n                        lemma2_to64();\n\n                        // Keep types consistent; either do it in `int`:\n                        assert((pow2(255) as nat) == 128 * (pow2(248) as nat));\n                        assert(v >= b31 * pow2(248));\n                        lemma_mul_inequality(128, b31 as int, pow2(248) as int);\n\n                        assert(b31 >= 128);\n                        assert(v >= pow2(255));\n                        assert(false);  // contradicts v < 2^255\n                    }\n                    assert(result.bytes[31] <= 127);\n\n                    assert(is_canonical_scalar(&result));\n                }\n            }\n        }\n        result\n    }",
      "start_line": 2739,
      "end_line": 12,
      "is_libsignal": false,
      "caller_count": 9,
      "callee_count": 16
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"{:?}([\\n\", stringify!(EdwardsBasepointTable))?;\n        for i in 0..32 {\n            write!(f, \"\\t{:?},\\n\", &self.0[i])?;\n        }\n        write!(f, \"])\")\n    }",
      "start_line": 2235,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_correct_after_loops().",
      "display_name": "lemma_sub_correct_after_loops",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_correct_after_loops().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub(crate) proof fn lemma_sub_correct_after_loops(\n    difference: Scalar52,\n    carry: u64,\n    a: &Scalar52,\n    b: &Scalar52,\n    difference_after_loop1: Scalar52,\n    borrow: u64,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        limbs_bounded(&difference),\n        limbs_bounded(&difference_after_loop1),\n        (carry >> 52) < 2,\n        -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order(),\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n            + seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ) + (carry >> 52) * pow2(52 * 5 as nat),\n        seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) - (borrow >> 63)\n            * pow2((52 * (5) as nat)),\n    ensures\n        to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int),\n{\n    assert(borrow >> 63 == 1 || borrow >> 63 == 0) by (bit_vector);\n    assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(&difference.limbs))\n        by {\n        assert(seq_u64_to_nat(difference.limbs@) == to_nat(&difference.limbs));\n        assert(difference.limbs@ == difference.limbs@.subrange(0, 5 as int));\n    }\n    assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs)) by {\n        assert(seq_u64_to_nat(b.limbs@) == to_nat(&b.limbs));\n        assert(b.limbs@ == b.limbs@.subrange(0, 5 as int));\n    }\n    assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs)) by {\n        assert(seq_u64_to_nat(a.limbs@) == to_nat(&a.limbs));\n        assert(a.limbs@ == a.limbs@.subrange(0, 5 as int));\n    }\n    if borrow >> 63 == 0 {\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) - (borrow >> 63) * pow2(\n            (52 * (5) as nat),\n        ));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)));\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) == to_nat(&difference.limbs));\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) >= 0);\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) < group_order());\n        lemma_small_mod((to_nat(&a.limbs) - to_nat(&b.limbs)) as nat, group_order());\n        assert(to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (\n        group_order() as int));\n    }\n    if borrow >> 63 == 1 {\n        assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            constants::L.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ));\n        assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n            == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ) - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) - pow2(\n            (52 * (5) as nat),\n        ));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ) - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) - pow2((52 * (5) as nat)));\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            a.limbs@.subrange(0, 5 as int),\n        ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ) + (carry >> 52) * pow2(52 * 5 as nat) - pow2((52 * (5) as nat)));\n        if carry >> 52 == 0 {\n            // Get a contradiction because the sides in the above equation have different signs\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n                a.limbs@.subrange(0, 5 as int),\n            ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) >= 0) by {\n                assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) >= group_order())\n                    by {\n                    lemma_l_equals_group_order();\n                };\n                assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs));\n                assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs));\n            };\n            assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) < pow2(\n                (52 * (5) as nat),\n            )) by {\n                assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(\n                    &difference.limbs,\n                ));\n                lemma_bound_scalar(&difference);\n            };\n            assert((carry >> 52) * pow2(52 * 5 as nat) == 0);\n            assert(false);\n        }\n        assert(carry >> 52 == 1);\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            a.limbs@.subrange(0, 5 as int),\n        ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ));\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + to_nat(&a.limbs)\n            - to_nat(&b.limbs) == to_nat(&difference.limbs));\n        assert(to_nat(&constants::L.limbs) == group_order()) by {\n            lemma_l_equals_group_order();\n        };\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order()) by {\n            lemma_l_equals_group_order();\n        };\n        assert(group_order() > 0);\n        calc! {\n            (==)\n            to_nat(&difference.limbs) as int; {}\n            group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs); {\n                assert(group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs) < group_order())\n                    by {\n                    assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n                        == to_nat(&difference_after_loop1.limbs)) by {\n                        assert(seq_u64_to_nat(difference_after_loop1.limbs@) == to_nat(\n                            &difference_after_loop1.limbs,\n                        ));\n                        assert(difference_after_loop1.limbs@\n                            == difference_after_loop1.limbs@.subrange(0, 5 as int));\n                    }\n                    assert(to_nat(&a.limbs) - to_nat(&b.limbs) == to_nat(\n                        &difference_after_loop1.limbs,\n                    ) - pow2((52 * (5) as nat)));\n                    lemma_bound_scalar(&difference_after_loop1);\n                };\n                lemma_small_mod(\n                    (group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) as nat,\n                    group_order(),\n                );\n            }\n            (group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int); {\n                lemma_mod_cancel(a, b);\n            }\n            (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int);\n        }\n    }\n}",
      "start_line": 1094,
      "end_line": 50,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_1_val().",
      "display_name": "a0_1_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_1_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn a0_1_val(a: [u64; 5]) -> u64 {\n    (a0_0_val(a) + carry_val(a) * 19) as u64\n}",
      "start_line": 100,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/limbs_bounded_exec().",
      "display_name": "limbs_bounded_exec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/limbs_bounded_exec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn limbs_bounded_exec(s: &Scalar52) -> bool {\n        s.limbs.iter().all(|&limb| limb < (1u64 << 52))\n    }",
      "start_line": 1258,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "display_name": "invert",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn invert(&self) -> (result: UnpackedScalar)\n        ensures\n            limbs_bounded(&result),\n            // Postcondition: result * self ≡ 1 (mod group_order)\n            to_nat(&result.limbs) * to_nat(&self.limbs) % group_order() == 1,\n    {\n        /* <ORIGINAL CODE>\n                self.as_montgomery().montgomery_invert().from_montgomery()\n        </ORIGINAL CODE> */\n        assume(limbs_bounded(self));\n        let mont = self.as_montgomery();\n        assume(limbs_bounded(&mont));\n        let inv = mont.montgomery_invert();\n        assume(limbs_bounded(&inv));\n        let result = inv.from_montgomery();\n\n        proof {\n            assume(limbs_bounded(&result));\n            assume(to_nat(&result.limbs) * to_nat(&self.limbs) % group_order() == 1);\n        }\n\n        result\n    }",
      "start_line": 2902,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_double().",
      "display_name": "edwards_double",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_double().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn edwards_double(x: nat, y: nat) -> (nat, nat) {\n    edwards_add(x, y, x, y)\n}",
      "start_line": 617,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_affine_niels().",
      "display_name": "as_affine_niels",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_affine_niels().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn as_affine_niels(&self) -> (result: AffineNielsPoint)\n        requires\n            edwards_point_limbs_bounded(*self),\n        ensures\n            affine_niels_corresponds_to_edwards(result, *self),\n    {\n        let recip = self.Z.invert();\n        // recip bounded by 54 from invert() postcondition\n\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        // x, y bounded by 54 from mul() postcondition\n\n        let xy = &x * &y;\n        // xy bounded by 54 from mul() postcondition\n\n        proof {\n            assume(fe51_limbs_bounded(&constants::EDWARDS_D2, 54));\n        }\n\n        let xy2d = &xy * &constants::EDWARDS_D2;\n\n        proof {\n            assume(sum_of_limbs_bounded(&y, &x, u64::MAX));  // for y_plus_x\n            assume(fe51_limbs_bounded(&y, 54) && fe51_limbs_bounded(&x, 54));  // for y_minus_x\n        }\n\n        let result = AffineNielsPoint { y_plus_x: &y + &x, y_minus_x: &y - &x, xy2d };\n\n        proof {\n            assume(affine_niels_corresponds_to_edwards(result, *self));\n        }\n\n        result\n    }",
      "start_line": 1141,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
      "start_line": 1266,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_precondition_implies_valid_sign_bit().",
      "display_name": "lemma_precondition_implies_valid_sign_bit",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_precondition_implies_valid_sign_bit().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_precondition_implies_valid_sign_bit(\n    bytes: &[u8; 32],\n    x: nat,\n    y: nat,\n)\n    requires\n        is_valid_compressed_edwards_y(bytes),  // decompress precondition\n        y == spec_field_element_from_bytes(bytes),  // Y from bytes\n        math_on_edwards_curve(x, y),  // (x, y) on curve\n        x < p(),  // X bounded\n    ensures\n        valid_compressed_for_sign_bit(bytes[31], x),\n{\n    // Goal: sign_bit == 1 ==> x % p() != 0\n    //\n    // Mathematical Proof:\n    //   sign_bit == 1  \n    //   ==> y² != 1        (contrapositive: y² == 1 ==> sign_bit == 0)\n    //   ==> x % p != 0     (from curve equation, if x = 0 then y² = 1)\n    \n    let sign_bit = bytes[31] >> 7;\n    let y_sq = math_field_square(y);\n    \n    assert(valid_compressed_for_sign_bit(bytes[31], x)) by {\n        if sign_bit == 1 {\n            // From is_valid_compressed_edwards_y: y² == 1 ==> sign_bit == 0\n            // Contrapositive: sign_bit == 1 ==> y² != 1\n            assert(y_sq != 1);\n            \n            // From curve equation and y² != 1, x must be non-zero\n            lemma_y_squared_neq_one_implies_x_nonzero(x, y);\n            assert(x % p() != 0);\n        }\n    };\n}",
      "start_line": 732,
      "end_line": 55,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma0_pow().",
      "display_name": "lemma0_pow",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma0_pow().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "file_name": "invert_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_lt().",
      "display_name": "lemma_mul_lt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_lt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_mul_lt(a1: nat, b1: nat, a2: nat, b2: nat)\n    requires\n        a1 < b1,\n        a2 < b2,\n    ensures\n        a1 * a2 < b1 * b2,\n{\n    if (a2 == 0) {\n        assert(b1 * b2 > 0) by {\n            // a * b != 0 <==> a != 0 /\\ b != 0\n            lemma_mul_nonzero(b1 as int, b2 as int);\n        }\n    } else {\n        // a1 < b1 /\\ a2 > 0 ==> a1 * a2 < b1 * a2\n        lemma_mul_strict_inequality(a1 as int, b1 as int, a2 as int);\n        // a2 < b2 /\\ b2 > 0 ==> a2 * b1 < b2 * b1\n        lemma_mul_strict_inequality(a2 as int, b2 as int, b1 as int);\n    }\n}",
      "start_line": 9,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_square_is_pow2().",
      "display_name": "lemma_square_is_pow2",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_square_is_pow2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_fits_u64().",
      "display_name": "lemma_u8_times_pow2_fits_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_fits_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_u8_times_pow2_fits_u64(a: u8, k: nat)\n    requires\n        k <= 56,\n    ensures\n        (a as u64) * pow2(k) <= u64::MAX,\n{\n    assert((a as u64) * pow2(k) <= (a as u64) * pow2(56)) by {\n        assert(pow2(k) <= pow2(56)) by {\n            if (k < 56) {\n                lemma_pow2_strictly_increases(k, 56);\n            }\n        }\n        lemma_mul_le(a as nat, a as nat, pow2(k), pow2(56));\n    }\n\n    lemma_pow2_mul_bound_u8(a, 56);\n    assert(pow2(64) - pow2(56) <= u64::MAX) by {\n        lemma2_to64_rest();\n    }\n\n}",
      "start_line": 272,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics().",
      "display_name": "lemma_mul_basics",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_sum_both_divisible().",
      "display_name": "lemma_mod_sum_both_divisible",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_sum_both_divisible().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_mod_sum_both_divisible(a: nat, b: nat, d: nat)\n    requires\n        d > 0,\n        a % d == 0,\n        b % d == 0,\n    ensures\n        (a + b) % d == 0,\n{\n    // Since a % d == 0 and b % d == 0, we have (0 + 0) % d == (a + b) % d\n    assert((a + b) % d == 0) by {\n        lemma_add_mod_noop(a as int, b as int, d as int);\n        assert((0 + 0) % d == 0) by (nonlinear_arith)\n            requires\n                d > 0,\n        ;\n    }\n}",
      "start_line": 135,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_new().",
      "display_name": "ct_option_new",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn ct_option_new<T>(value: T, choice: Choice) -> (result: CtOption<T>)\n    ensures\n        ct_option_has_value(result) == choice_is_true(choice),\n        ct_option_value(result) == value,\n{\n    CtOption::new(value, choice)\n}",
      "start_line": 159,
      "end_line": 21,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_sqrt().",
      "display_name": "canonical_sqrt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_sqrt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn canonical_sqrt(r: nat) -> nat\n    recommends\n        math_is_square(r),\n{\n    let s1 = math_sqrt(r);  // some square root\n    let s2 = math_field_neg(s1);  // the other root\n\n    if (s1 % 2 == 0) {\n        s1\n    } else {\n        s2\n    }\n}",
      "start_line": 61,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_product_square().",
      "display_name": "lemma_product_square",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_product_square().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_product_square(a: nat, b: nat)\n    ensures (a * b) * (a * b) == (a * a) * (b * b),\n{\n    // pow(a*b, 2) == pow(a, 2) * pow(b, 2)  [from lemma_pow_distributes]\n    lemma_pow_distributes(a as int, b as int, 2);\n    // pow(x, 2) == x * x  [from lemma_square_is_pow2]\n    lemma_square_is_pow2((a * b) as int);\n    lemma_square_is_pow2(a as int);\n    lemma_square_is_pow2(b as int);\n}",
      "start_line": 207,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_curve_semantics().",
      "display_name": "lemma_step1_curve_semantics",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_curve_semantics().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_step1_curve_semantics(\n    y: nat,      // spec_field_element(&Y)\n    x: nat,      // spec_field_element(&X) from sqrt_ratio_i\n    u_math: nat, // math_field_sub(y², 1)\n    v_math: nat, // math_field_add(d·y², 1)\n)\n    requires\n        // u and v are computed correctly\n        ({\n            let d = spec_field_element(&EDWARDS_D);\n            let y2 = math_field_square(y);\n            u_math == math_field_sub(y2, 1) &&\n            v_math == math_field_add(math_field_mul(d, y2), 1)\n        }),",
      "start_line": 806,
      "end_line": 41,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 13
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_verify_invert_correct().",
      "display_name": "lemma_verify_invert_correct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_verify_invert_correct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "proof fn lemma_verify_invert_correct(\n    x: Scalar52,\n)\n//     requires to_scalar(&x.limbs) != 0\n//    ensures (to_scalar(&x.limbs) * invert_spec(&x.limbs)) % group_order() == 1\n{\n    assume(false);\n\n}",
      "start_line": 38,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/lemma_p_is_odd().",
      "display_name": "lemma_p_is_odd",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/lemma_p_is_odd().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub proof fn lemma_p_is_odd()\n    ensures\n        p() % 2 == 1,\n{\n    // 2^255 is even\n    lemma_pow2_even(255);\n    assert(pow2(255) % 2 == 0);\n    \n    // 19 % 2 == 1\n    assert(19int % 2 == 1) by (compute);\n    \n    // p() = 2^255 - 19\n    // (even - odd) % 2 = (0 - 1) % 2 = (-1) % 2 = 1\n    // Using lemma_sub_mod_noop: (a - b) % m == ((a%m) - (b%m)) % m\n    lemma_sub_mod_noop(pow2(255) as int, 19int, 2int);\n    // (pow2(255) - 19) % 2 == ((pow2(255) % 2) - (19 % 2)) % 2 == (0 - 1) % 2 == (-1) % 2\n    \n    // -1 % 2 == 1 (in Verus, negative mod is handled correctly)\n    assert((-1int) % 2 == 1) by (compute);\n    \n    // Combine: p() % 2 == 1\n    pow255_gt_19();  // Ensure 2^255 > 19 so p() > 0\n}",
      "start_line": 44,
      "end_line": 28,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_scalar_mul().",
      "display_name": "montgomery_scalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_scalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn montgomery_scalar_mul(P: MontgomeryAffine, n: nat) -> MontgomeryAffine\n    decreases n,\n{\n    if n == 0 {\n        MontgomeryAffine::Infinity\n    } else {\n        montgomery_add(P, montgomery_scalar_mul(P, (n - 1) as nat))\n    }\n}",
      "start_line": 307,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_internal_correct().",
      "display_name": "lemma_mul_internal_correct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_internal_correct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_mul_internal_correct(a: &[u64; 5], b: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        forall|i: int| 0 <= i < 5 ==> b[i] < (1u64 << 52),\n        z[0] == (a[0] * b[0]),\n        z[1] == (a[0] * b[1]) + (a[1] * b[0]),\n        z[2] == (a[0] * b[2]) + (a[1] * b[1]) + (a[2] * b[0]),\n        z[3] == (a[0] * b[3]) + (a[1] * b[2]) + (a[2] * b[1]) + (a[3] * b[0]),\n        z[4] == (a[0] * b[4]) + (a[1] * b[3]) + (a[2] * b[2]) + (a[3] * b[1]) + (a[4] * b[0]),\n        z[5] == (a[1] * b[4]) + (a[2] * b[3]) + (a[3] * b[2]) + (a[4] * b[1]),\n        z[6] == (a[2] * b[4]) + (a[3] * b[3]) + (a[4] * b[2]),\n        z[7] == (a[3] * b[4]) + (a[4] * b[3]),\n        z[8] == (a[4] * b[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(b),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*b) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n    lemma_five_limbs_equals_to_nat(&b);\n}",
      "start_line": 138,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_inverse_field().",
      "display_name": "is_inverse_field",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_inverse_field().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_inverse_field(a: &FieldElement51, b: &FieldElement51) -> bool {\n    (spec_field_element(a) * spec_field_element(b)) % p() == 1\n}",
      "start_line": 410,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_scalar_subtract_no_overflow().",
      "display_name": "lemma_scalar_subtract_no_overflow",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_scalar_subtract_no_overflow().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_scalar_subtract_no_overflow(\n    carry: u64,\n    difference_limb: u64,\n    addend: u64,\n    i: u32,\n    l_value: &Scalar52,\n)\n    requires\n        i < 5,\n        difference_limb < (1u64 << 52),\n        addend == 0 || addend == l_value.limbs[i as int],\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n    ensures\n        (carry >> 52) + difference_limb + addend < (1u64 << 53),\n{\n    if i == 0 {\n        assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    } else if i == 1 {\n        assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n    } else if i == 2 {\n        assert(0x000000000014def9 < (1u64 << 52)) by (bit_vector);\n    } else if i == 3 {\n    } else {\n        assert(0x0000100000000000 < (1u64 << 52)) by (bit_vector);\n    }\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert(2 * (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}",
      "start_line": 232,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u64_5_as_nat_generic_radix().",
      "display_name": "u64_5_as_nat_generic_radix",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u64_5_as_nat_generic_radix().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/core_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/core_specs.rs",
      "file_name": "core_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn u64_5_as_nat_generic_radix(arr: [u64;5], radix: nat) -> nat {\n    (\n                          arr[0] +\n        pow2(1 * radix) * arr[1] +\n        pow2(2 * radix) * arr[2] +\n        pow2(3 * radix) * arr[3] +\n        pow2(4 * radix) * arr[4]\n    ) as nat\n}",
      "start_line": 105,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_sign_bit().",
      "display_name": "spec_field_element_sign_bit",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_sign_bit().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_field_element_sign_bit(fe: &FieldElement51) -> u8 {\n    ((spec_field_element(fe) % p()) % 2) as u8\n}",
      "start_line": 88,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_expansion().",
      "display_name": "lemma_radix51_telescoping_expansion",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_expansion().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_radix51_telescoping_expansion(\n    q0: int,\n    q1: int,\n    q2: int,\n    q3: int,\n    q4: int,\n    r0: int,\n    r1: int,\n    r2: int,\n    r3: int,\n    r4: int,\n)\n    requires\n        true,\n    ensures\n        (q0 * pow2(51) as int + r0 - 19) + (q1 * pow2(51) as int + r1 - q0) * pow2(51) as int + (q2\n            * pow2(51) as int + r2 - q1) * pow2(102) as int + (q3 * pow2(51) as int + r3 - q2)\n            * pow2(153) as int + (q4 * pow2(51) as int + r4 - q3) * pow2(204) as int + 19 == q4\n            * pow2(51) as int * pow2(204) as int + r0 + r1 * pow2(51) as int + r2 * pow2(102) as int\n            + r3 * pow2(153) as int + r4 * pow2(204) as int,\n{\n    // Establish power relationships: 2^51 * 2^k = 2^(51+k)\n    lemma_pow2_adds(51, 51);\n    lemma_pow2_adds(51, 102);\n    lemma_pow2_adds(51, 153);\n    lemma_pow2_adds(51, 204);\n\n    // Manually expand each multiplication and show the cancellations explicitly\n    let lhs = (q0 * pow2(51) as int + r0 - 19) + (q1 * pow2(51) as int + r1 - q0) * pow2(51) as int\n        + (q2 * pow2(51) as int + r2 - q1) * pow2(102) as int + (q3 * pow2(51) as int + r3 - q2)\n        * pow2(153) as int + (q4 * pow2(51) as int + r4 - q3) * pow2(204) as int + 19;\n\n    // Expand the multiplications using distributivity\n    assert((q1 * pow2(51) as int + r1 - q0) * pow2(51) as int == q1 * pow2(51) as int * pow2(\n        51,\n    ) as int + r1 * pow2(51) as int - q0 * pow2(51) as int) by {\n        lemma_mul_is_distributive_sub_other_way(pow2(51) as int, q1 * pow2(51) as int + r1, q0);\n        lemma_mul_is_distributive_add_other_way(pow2(51) as int, q1 * pow2(51) as int, r1);\n    }\n\n    assert((q2 * pow2(51) as int + r2 - q1) * pow2(102) as int == q2 * pow2(51) as int * pow2(\n        102,\n    ) as int + r2 * pow2(102) as int - q1 * pow2(102) as int) by {\n        lemma_mul_is_distributive_sub_other_way(pow2(102) as int, q2 * pow2(51) as int + r2, q1);\n        lemma_mul_is_distributive_add_other_way(pow2(102) as int, q2 * pow2(51) as int, r2);\n    }\n\n    assert((q3 * pow2(51) as int + r3 - q2) * pow2(153) as int == q3 * pow2(51) as int * pow2(\n        153,\n    ) as int + r3 * pow2(153) as int - q2 * pow2(153) as int) by {\n        lemma_mul_is_distributive_sub_other_way(pow2(153) as int, q3 * pow2(51) as int + r3, q2);\n        lemma_mul_is_distributive_add_other_way(pow2(153) as int, q3 * pow2(51) as int, r3);\n    }\n\n    assert((q4 * pow2(51) as int + r4 - q3) * pow2(204) as int == q4 * pow2(51) as int * pow2(\n        204,\n    ) as int + r4 * pow2(204) as int - q3 * pow2(204) as int) by {\n        lemma_mul_is_distributive_sub_other_way(pow2(204) as int, q4 * pow2(51) as int + r4, q3);\n        lemma_mul_is_distributive_add_other_way(pow2(204) as int, q4 * pow2(51) as int, r4);\n    }\n\n    // Now LHS equals (after substituting the expansions):\n    // = q0*2^51 + r0 - 19\n    //   + q1*2^51*2^51 + r1*2^51 - q0*2^51\n    //   + q2*2^51*2^102 + r2*2^102 - q1*2^102\n    //   + q3*2^51*2^153 + r3*2^153 - q2*2^153\n    //   + q4*2^51*2^204 + r4*2^204 - q3*2^204\n    //   + 19\n\n    // Use the power relationships to simplify products\n    assert(q1 * pow2(51) as int * pow2(51) as int == q1 * pow2(102) as int) by {\n        lemma_mul_is_associative(q1, pow2(51) as int, pow2(51) as int);\n    }\n    assert(q2 * pow2(51) as int * pow2(102) as int == q2 * pow2(153) as int) by {\n        lemma_mul_is_associative(q2, pow2(51) as int, pow2(102) as int);\n    }\n    assert(q3 * pow2(51) as int * pow2(153) as int == q3 * pow2(204) as int) by {\n        lemma_mul_is_associative(q3, pow2(51) as int, pow2(153) as int);\n    }\n\n    // Now we can see the cancellations more clearly:\n    // = (q0*2^51 - q0*2^51) + (q1*2^102 - q1*2^102) + (q2*2^153 - q2*2^153) + (q3*2^204 - q3*2^204)\n    //   + q4*2^51*2^204 + r0 + r1*2^51 + r2*2^102 + r3*2^153 + r4*2^204 + (-19 + 19)\n    // = q4*2^51*2^204 + r0 + r1*2^51 + r2*2^102 + r3*2^153 + r4*2^204\n\n    // The SMT solver should now see this is pure linear arithmetic\n}",
      "start_line": 39,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/try_into_32_bytes_array().",
      "display_name": "try_into_32_bytes_array",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/try_into_32_bytes_array().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub fn try_into_32_bytes_array(bytes: &[u8]) -> (result: Result<[u8; 32], TryFromSliceError>)\n    ensures\n// Success when length matches the target array size (32)\n\n        bytes@.len() == 32 ==> matches!(result, Ok(_)),\n        // Failure when length doesn't match\n        bytes@.len() != 32 ==> matches!(result, Err(_)),\n        // When successful, the array contains the same bytes as the input slice\n        match result {\n            Ok(arr) => arr@ == bytes@,\n            Err(_) => true,\n        },",
      "start_line": 33,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_value().",
      "display_name": "ct_option_value",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_value().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub uninterp spec fn ct_option_value<T>(opt: CtOption<T>) -> T;\n\n/// Wrapper function for CtOption::new\n#[verifier::external_body]\npub fn ct_option_new<T>(value: T, choice: Choice) -> (result: CtOption<T>)\n    ensures\n        ct_option_has_value(result) == choice_is_true(choice),\n        ct_option_value(result) == value,\n{\n    CtOption::new(value, choice)\n}",
      "start_line": 155,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_bindary_sum_div_decomposition().",
      "display_name": "lemma_bindary_sum_div_decomposition",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_bindary_sum_div_decomposition().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_bindary_sum_div_decomposition(a: nat, b: nat, s: nat, k: nat)\n    requires\n        a < pow2(s),\n    ensures\n        (a + b * pow2(s)) / pow2(k) == a / pow2(k) + (b * pow2(s)) / pow2(k),\n{\n    let ps = pow2(s);\n    let pk = pow2(k);\n    let x = a;\n    let y = b * ps;\n    let z = x + y;\n\n    assert(pk > 0) by {\n        lemma_pow2_pos(k);\n    }\n\n    assert(x == pk * (x / pk) + x % pk) by {\n        lemma_fundamental_div_mod(x as int, pk as int);\n    }\n\n    assert(y == pk * (y / pk) + y % pk) by {\n        lemma_fundamental_div_mod(y as int, pk as int);\n    }\n\n    assert(z % pk == x % pk + y % pk) by {\n        lemma_binary_sum_mod_decomposition(a, b, s, k);\n    }\n\n    assert(z == x + y == pk * (x / pk + y / pk) + z % pk) by {\n        lemma_mul_is_distributive_add(pk as int, (x / pk) as int, (y / pk) as int);\n    }\n\n    assert(z == pk * (z / pk) + z % pk) by {\n        lemma_fundamental_div_mod(z as int, pk as int);\n    }\n\n    assert(z / pk == x / pk + y / pk) by {\n        lemma_mul_equality_converse(pk as int, (z / pk) as int, (x / pk + y / pk) as int);\n    }\n}",
      "start_line": 137,
      "end_line": 49,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div().",
      "display_name": "lemma_pow2_mul_div",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_mul_div(x: nat, k: nat, s: nat)\n    requires\n        k <= s,\n    ensures\n        (x * pow2(k)) / pow2(s) == x / pow2((s - k) as nat),\n{\n    assert(pow2(k) > 0) by {\n        lemma_pow2_pos(k);\n    }\n\n    let d = (s - k) as nat;\n\n    assert(pow2(d) > 0) by {\n        lemma_pow2_pos(d);\n    }\n    assert(pow2(s) == pow2(k) * pow2(d)) by {\n        lemma_pow2_adds(k, d);\n    }\n    assert((x * pow2(k)) / pow2(s) == ((x * pow2(k)) / pow2(k) / pow2(d))) by {\n        lemma_div_denominator((x * pow2(k)) as int, pow2(k) as int, pow2(d) as int)\n    }\n    assert((x * pow2(k)) / pow2(k) == x) by {\n        lemma_div_by_multiple(x as int, pow2(k) as int);\n    }\n}",
      "start_line": 423,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/copy_from_slice().",
      "display_name": "copy_from_slice",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/copy_from_slice().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#to_bytes().",
      "display_name": "to_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#to_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub const fn to_bytes(&self) -> (result: [u8; 32])\n        ensures\n            result == self.0,\n    {\n        self.0\n    }",
      "start_line": 227,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_sum_equals_byte_nat().",
      "display_name": "lemma_sum_equals_byte_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_sum_equals_byte_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_sum_equals_byte_nat(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < pow2(51),\n        bytes_match_limbs_packing(limbs, bytes),\n    ensures\n        u8_32_as_nat(&bytes) == limb0_byte_contribution(limbs, bytes) + limb1_byte_contribution(\n            limbs,\n            bytes,\n        ) + limb2_byte_contribution(limbs, bytes) + limb3_byte_contribution(limbs, bytes)\n            + limb4_byte_contribution(limbs, bytes),\n{\n    lemma2_to64();\n\n    // Strategy: Show that the sum of contributions equals u8_32_as_nat(bytes)\n    // by proving that for boundary bytes, the split parts reconstruct the full byte.\n    //\n    // Boundary bytes:\n    // - Byte 6  = low 3 bits (limb0) + high 5 bits (limb1)\n    // - Byte 12 = low 6 bits (limb1) + high 2 bits (limb2)\n    // - Byte 19 = low 1 bit (limb2) + high 7 bits (limb3)\n    // - Byte 25 = low 4 bits (limb3) + high 4 bits (limb4)\n\n    // From bytes_match_limbs_packing, we know how bytes relate to limbs\n    // For each boundary byte, we need to prove it reconstructs correctly\n\n    // Define the boundary byte splits (bytes that span two limbs)\n    // Each boundary byte is split into a low part (from lower limb) and high part (from higher limb)\n    let byte6_low = ((limbs[0] as nat / pow2(48)) % 8) * pow2(6 * 8);\n    let byte6_high = ((limbs[1] as nat % pow2(5)) * 8) * pow2(6 * 8);\n\n    let byte12_low = ((limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(12 * 8);\n    let byte12_high = ((limbs[2] as nat % pow2(2)) * pow2(6)) * pow2(12 * 8);\n\n    let byte19_low = ((limbs[2] as nat / pow2(50)) % 2) * pow2(19 * 8);\n    let byte19_high = ((limbs[3] as nat % pow2(7)) * 2) * pow2(19 * 8);\n\n    let byte25_low = ((limbs[3] as nat / pow2(47)) % pow2(4)) * pow2(25 * 8);\n    let byte25_high = ((limbs[4] as nat % pow2(4)) * pow2(4)) * pow2(25 * 8);\n\n    // Prove each boundary byte reconstruction using lemma_boundary_byte_combines\n    // Then multiply both sides by pow2(byte_position * 8) and apply distributivity\n    // Byte 6: lemma_boundary_byte_combines proves bytes[6] == (limbs[0]/2^48)%8 + (limbs[1]%2^5)*8\n    // Multiply both sides by pow2(6*8): (a+b)*c = a*c + b*c by distributivity\n    //lemma_boundary_byte_combines(limbs[0], limbs[1], bytes[6], 48, 3);\n    assert(bytes[6] as nat == (limbs[0] as nat / pow2(48)) % 8 + (limbs[1] as nat % pow2(5)) * 8)\n        by {\n        lemma_boundary_byte_combines(limbs[0], limbs[1], bytes[6], 48, 3);\n    }\n    // Distributivity gives us: (a+b)*c == a*c + b*c\n    assert(bytes[6] as nat * pow2(6 * 8) == ((limbs[0] as nat / pow2(48)) % 8) * pow2(6 * 8) + ((\n    limbs[1] as nat % pow2(5)) * 8) * pow2(6 * 8)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(6 * 8) as int,\n            ((limbs[0] as nat / pow2(48)) % 8) as int,\n            ((limbs[1] as nat % pow2(5)) * 8) as int,\n        );\n    }\n    // Which exactly matches byte6_low + byte6_high by definition\n    assert(bytes[6] as nat * pow2(6 * 8) == byte6_low + byte6_high);\n\n    // Byte 12: lemma_boundary_byte_combines proves bytes[12] == (limbs[1]/2^45)%2^6 + (limbs[2]%2^2)*2^6\n    // Multiply both sides by pow2(12*8): (a+b)*c = a*c + b*c by distributivity\n    assert(bytes[12] as nat == (limbs[1] as nat / pow2(45)) % pow2(6) + (limbs[2] as nat % pow2(2))\n        * pow2(6)) by {\n        lemma_boundary_byte_combines(limbs[1], limbs[2], bytes[12], 45, 6);\n    }\n    // Distributivity gives us: (a+b)*c == a*c + b*c\n    assert(bytes[12] as nat * pow2(12 * 8) == ((limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(\n        12 * 8,\n    ) + ((limbs[2] as nat % pow2(2)) * pow2(6)) * pow2(12 * 8)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(12 * 8) as int,\n            ((limbs[1] as nat / pow2(45)) % pow2(6)) as int,\n            ((limbs[2] as nat % pow2(2)) * pow2(6)) as int,\n        );\n    }\n    // Which exactly matches byte12_low + byte12_high by definition\n    assert(bytes[12] as nat * pow2(12 * 8) == byte12_low + byte12_high);\n\n    // Byte 19: lemma_boundary_byte_combines proves bytes[19] == (limbs[2]/2^50)%2 + (limbs[3]%2^7)*2\n    // Multiply both sides by pow2(19*8): (a+b)*c = a*c + b*c by distributivity\n    assert(bytes[19] as nat == (limbs[2] as nat / pow2(50)) % 2 + (limbs[3] as nat % pow2(7)) * 2)\n        by {\n        lemma_boundary_byte_combines(limbs[2], limbs[3], bytes[19], 50, 1);\n    }\n    // Distributivity gives us: (a+b)*c == a*c + b*c\n    assert(bytes[19] as nat * pow2(19 * 8) == ((limbs[2] as nat / pow2(50)) % 2) * pow2(19 * 8) + ((\n    limbs[3] as nat % pow2(7)) * 2) * pow2(19 * 8)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(19 * 8) as int,\n            ((limbs[2] as nat / pow2(50)) % 2) as int,\n            ((limbs[3] as nat % pow2(7)) * 2) as int,\n        );\n    }\n    // Which exactly matches byte19_low + byte19_high by definition\n    assert(bytes[19] as nat * pow2(19 * 8) == byte19_low + byte19_high);\n\n    // Byte 25: lemma_boundary_byte_combines proves bytes[25] == (limbs[3]/2^47)%2^4 + (limbs[4]%2^4)*2^4\n    // Multiply both sides by pow2(25*8): (a+b)*c = a*c + b*c by distributivity\n    assert(bytes[25] as nat == (limbs[3] as nat / pow2(47)) % pow2(4) + (limbs[4] as nat % pow2(4))\n        * pow2(4)) by {\n        lemma_boundary_byte_combines(limbs[3], limbs[4], bytes[25], 47, 4);\n    }\n    // Distributivity gives us: (a+b)*c == a*c + b*c\n    assert(bytes[25] as nat * pow2(25 * 8) == ((limbs[3] as nat / pow2(47)) % pow2(4)) * pow2(\n        25 * 8,\n    ) + ((limbs[4] as nat % pow2(4)) * pow2(4)) * pow2(25 * 8)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(25 * 8) as int,\n            ((limbs[3] as nat / pow2(47)) % pow2(4)) as int,\n            ((limbs[4] as nat % pow2(4)) * pow2(4)) as int,\n        );\n    }\n    // Which exactly matches byte25_low + byte25_high by definition\n    assert(bytes[25] as nat * pow2(25 * 8) == byte25_low + byte25_high);\n\n    let after_split_25_pow2_first = (bytes[0] as nat) + (bytes[1] as nat) * pow2(1 * 8) + (\n    bytes[2] as nat) * pow2(2 * 8) + (bytes[3] as nat) * pow2(3 * 8) + (bytes[4] as nat) * pow2(\n        4 * 8,\n    ) + (bytes[5] as nat) * pow2(5 * 8) + byte6_low + byte6_high + (bytes[7] as nat) * pow2(7 * 8)\n        + (bytes[8] as nat) * pow2(8 * 8) + (bytes[9] as nat) * pow2(9 * 8) + (bytes[10] as nat)\n        * pow2(10 * 8) + (bytes[11] as nat) * pow2(11 * 8) + byte12_low + byte12_high + (\n    bytes[13] as nat) * pow2(13 * 8) + (bytes[14] as nat) * pow2(14 * 8) + (bytes[15] as nat)\n        * pow2(15 * 8) + (bytes[16] as nat) * pow2(16 * 8) + (bytes[17] as nat) * pow2(17 * 8) + (\n    bytes[18] as nat) * pow2(18 * 8) + byte19_low + byte19_high + (bytes[20] as nat) * pow2(20 * 8)\n        + (bytes[21] as nat) * pow2(21 * 8) + (bytes[22] as nat) * pow2(22 * 8) + (bytes[23] as nat)\n        * pow2(23 * 8) + (bytes[24] as nat) * pow2(24 * 8) + byte25_low + byte25_high + (\n    bytes[26] as nat) * pow2(26 * 8) + (bytes[27] as nat) * pow2(27 * 8) + (bytes[28] as nat)\n        * pow2(28 * 8) + (bytes[29] as nat) * pow2(29 * 8) + (bytes[30] as nat) * pow2(30 * 8) + (\n    bytes[31] as nat) * pow2(31 * 8);\n\n    assert(after_split_25_pow2_first == u8_32_as_nat(&bytes));\n\n    assert(bytes[0] as nat * pow2(0 * 8) == bytes[0] as nat * 1);\n    // The mathematical fact: after splitting boundary bytes, this equals the sum of limb contributions\n    assert(after_split_25_pow2_first == limb0_byte_contribution(limbs, bytes)\n        + limb1_byte_contribution(limbs, bytes) + limb2_byte_contribution(limbs, bytes)\n        + limb3_byte_contribution(limbs, bytes) + limb4_byte_contribution(limbs, bytes));\n}",
      "start_line": 2057,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/word_from_bytes().",
      "display_name": "word_from_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/word_from_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn word_from_bytes(bytes: &[u8; 64], word_idx: int) -> nat {\n    if !(0 <= word_idx && word_idx < 8) {\n        0\n    } else {\n        let base = word_idx * 8;\n        (bytes[(base + 0) as int] as nat) * pow2(0) + (bytes[(base + 1) as int] as nat) * pow2(8)\n            + (bytes[(base + 2) as int] as nat) * pow2(16) + (bytes[(base + 3) as int] as nat)\n            * pow2(24) + (bytes[(base + 4) as int] as nat) * pow2(32) + (bytes[(base\n            + 5) as int] as nat) * pow2(40) + (bytes[(base + 6) as int] as nat) * pow2(48) + (\n        bytes[(base + 7) as int] as nat) * pow2(56)\n    }\n}",
      "start_line": 131,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_rhs().",
      "display_name": "montgomery_rhs",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_rhs().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn montgomery_rhs(u: nat) -> nat {\n    let A = spec_field_element(&MONTGOMERY_A);\n    let u2 = math_field_mul(u, u);  // u^2\n    let u3 = math_field_mul(u2, u);  // u^3\n    let Au2 = math_field_mul(A, u2);  // A*u^2\n    math_field_add(math_field_add(u3, Au2), u)  // u^3 + A*u^2 + u\n\n}",
      "start_line": 49,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#to_bytes().",
      "display_name": "to_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#to_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
      "start_line": 228,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_fits_u64().",
      "display_name": "lemma_load8_at_plus_fits_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_fits_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_load8_at_plus_fits_u64(input: &[u8], i: usize, k: nat)\n    requires\n        i + k < input.len(),\n        0 < k <= 7,\n    ensures\n        load8_at_plus_version_rec(input, i, (k - 1) as nat) + pow2(k * 8) * input[i + k]\n            <= u64::MAX,\n{\n    let xk_1 = load8_at_plus_version_rec(input, i, (k - 1) as nat);\n    let v = input[i + k];\n\n    assert((xk_1 + pow2(k * 8) * v) <= u64::MAX) by {\n        assert(v <= u8::MAX);  // known\n        assert(pow2(8 * k) <= 0x100000000000000) by {\n            if (k < 7) {\n                lemma_pow2_strictly_increases(k * 8, 56);\n            }\n            lemma2_to64_rest();\n        }\n        assert(xk_1 < pow2(8 * k)) by {\n            lemma_load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n        }\n        assert(xk_1 <= 0x100000000000000 - 1);\n        assert(pow2(k * 8) * v <= 0x100000000000000 * u8::MAX) by {\n            lemma_mul_le(pow2(k * 8), 0x100000000000000, v as nat, u8::MAX as nat);\n        }\n        assert((0x100000000000000 - 1) + (0x100000000000000) * u8::MAX <= u64::MAX) by (compute);\n    }\n}",
      "start_line": 260,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_divides_linear_combo().",
      "display_name": "lemma_divides_linear_combo",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_divides_linear_combo().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_divides_linear_combo(x: nat, y: nat, k: nat, d: nat)\n    requires\n        d > 0,\n        x % d == 0,\n        y % d == 0,\n    ensures\n        (x + k * y) % d == 0,\n{\n    lemma_mul_mod_noop_right(k as int, y as int, d as int);\n    assert((k as int * y as int) % (d as int) == (k as int * (y as int % d as int)) % (d as int));\n    assert(y as int % d as int == 0int);\n    assert(k as int * (y as int % d as int) == k as int * 0int);\n    assert(k as int * 0int == 0int);\n    lemma_mod_self_0(d as int);\n    assert(0int % (d as int) == 0int);\n    assert(((k * y) as int) % (d as int) == 0int);\n    lemma_add_mod_noop(x as int, (k * y) as int, d as int);\n}",
      "start_line": 38,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_bytes().",
      "display_name": "as_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub const fn as_bytes(&self) -> (result: &[u8; 32])\n        ensures\n            result == &self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        &self.bytes\n    }",
      "start_line": 1492,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_multiscalar_mul().",
      "display_name": "straus_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "backend",
      "body": "pub fn straus_multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator,\n    J::Item: core::borrow::Borrow<EdwardsPoint>,\n{\n    use crate::traits::MultiscalarMul;\n\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 => {\n        //     vector::scalar_mul::straus::spec_avx2::Straus::multiscalar_mul::<I, J>(scalars, points)\n        // }\n        // #[cfg(all(curve25519_dalek_backend = \"simd\", nightly))]\n        // BackendKind::Avx512 => {\n        //     vector::scalar_mul::straus::spec_avx512ifma_avx512vl::Straus::multiscalar_mul::<I, J>(\n        //         scalars, points,\n        //     )\n        // }\n        BackendKind::Serial => {\n            serial::scalar_mul::straus::Straus::multiscalar_mul::<I, J>(scalars, points)\n        }\n    }\n}",
      "start_line": 187,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_seq_to_nat().",
      "display_name": "bytes_seq_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_seq_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn bytes_seq_to_nat(bytes: Seq<u8>) -> nat\n    decreases bytes.len(),\n{\n    if bytes.len() == 0 {\n        0\n    } else {\n        (bytes[0] as nat) + pow2(8) * bytes_seq_to_nat(bytes.skip(1))\n    }\n}",
      "start_line": 92,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 9,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_as_nat_32_mod_255().",
      "display_name": "lemma_as_nat_32_mod_255",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_as_nat_32_mod_255().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_as_nat_32_mod_255(bytes: &[u8; 32])\n    ensures\n        u8_32_as_nat(bytes) % pow2(255) == (bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (\n        bytes[2] * pow2(2 * 8)) + (bytes[3] * pow2(3 * 8)) + (bytes[4] * pow2(4 * 8)) + (bytes[5]\n            * pow2(5 * 8)) + (bytes[6] * pow2(6 * 8)) + (bytes[7] * pow2(7 * 8)) + (bytes[8] * pow2(\n            8 * 8,\n        )) + (bytes[9] * pow2(9 * 8)) + (bytes[10] * pow2(10 * 8)) + (bytes[11] * pow2(11 * 8)) + (\n        bytes[12] * pow2(12 * 8)) + (bytes[13] * pow2(13 * 8)) + (bytes[14] * pow2(14 * 8)) + (\n        bytes[15] * pow2(15 * 8)) + (bytes[16] * pow2(16 * 8)) + (bytes[17] * pow2(17 * 8)) + (\n        bytes[18] * pow2(18 * 8)) + (bytes[19] * pow2(19 * 8)) + (bytes[20] * pow2(20 * 8)) + (\n        bytes[21] * pow2(21 * 8)) + (bytes[22] * pow2(22 * 8)) + (bytes[23] * pow2(23 * 8)) + (\n        bytes[24] * pow2(24 * 8)) + (bytes[25] * pow2(25 * 8)) + (bytes[26] * pow2(26 * 8)) + (\n        bytes[27] * pow2(27 * 8)) + (bytes[28] * pow2(28 * 8)) + (bytes[29] * pow2(29 * 8)) + (\n        bytes[30] * pow2(30 * 8)) + ((bytes[31] as nat % pow2(7)) * pow2(31 * 8)),\n{\n    assert(u8_32_as_nat(bytes) == (bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (bytes[2]\n        * pow2(2 * 8)) + (bytes[3] * pow2(3 * 8)) + (bytes[4] * pow2(4 * 8)) + (bytes[5] * pow2(\n        5 * 8,\n    )) + (bytes[6] * pow2(6 * 8)) + (bytes[7] * pow2(7 * 8)) + (bytes[8] * pow2(8 * 8)) + (bytes[9]\n        * pow2(9 * 8)) + (bytes[10] * pow2(10 * 8)) + (bytes[11] * pow2(11 * 8)) + (bytes[12]\n        * pow2(12 * 8)) + (bytes[13] * pow2(13 * 8)) + (bytes[14] * pow2(14 * 8)) + (bytes[15]\n        * pow2(15 * 8)) + (bytes[16] * pow2(16 * 8)) + (bytes[17] * pow2(17 * 8)) + (bytes[18]\n        * pow2(18 * 8)) + (bytes[19] * pow2(19 * 8)) + (bytes[20] * pow2(20 * 8)) + (bytes[21]\n        * pow2(21 * 8)) + (bytes[22] * pow2(22 * 8)) + (bytes[23] * pow2(23 * 8)) + (bytes[24]\n        * pow2(24 * 8)) + (bytes[25] * pow2(25 * 8)) + (bytes[26] * pow2(26 * 8)) + (bytes[27]\n        * pow2(27 * 8)) + (bytes[28] * pow2(28 * 8)) + (bytes[29] * pow2(29 * 8)) + (bytes[30]\n        * pow2(30 * 8)) + (bytes[31] * pow2(31 * 8)) == pow2_sum(bytes, 0, 8, 30) + (bytes[31]\n        * pow2(31 * 8))) by {\n        assert(pow2(0) == 1) by {\n            lemma2_to64();\n        }\n        assert(bytes[0] == bytes[0] * pow2(0)) by {\n            lemma_mul_basics_3(bytes[0] as int);\n        }\n        reveal_with_fuel(pow2_sum, 31);\n    }\n    assert(u8_32_as_nat(bytes) % pow2(255) == (pow2_sum(bytes, 0, 8, 30) + bytes[31] * pow2(\n        31 * 8,\n    )) as nat % pow2(255));\n\n    assert((pow2_sum(bytes, 0, 8, 30) + bytes[31] * pow2(31 * 8)) as nat % pow2(255) == pow2_sum(\n        bytes,\n        0,\n        8,\n        30,\n    ) + (bytes[31] * pow2(31 * 8)) as nat % pow2(255)) by {\n        assert(pow2_sum(bytes, 0, 8, 30) < pow2(31 * 8)) by {\n            assert forall|i: nat| 0 <= i <= 30 implies bytes[i as int] < pow2(8) by {\n                lemma_u8_lt_pow2_8(bytes[i as int]);\n            }\n            lemma_pow2_sum_bounds(bytes, 0, 8, 30);\n        }\n        assert((pow2_sum(bytes, 0, 8, 30) + bytes[31] * pow2(31 * 8)) as nat % pow2(255)\n            == pow2_sum(bytes, 0, 8, 30) % pow2(255) + (bytes[31] * pow2(31 * 8)) as nat % pow2(\n            255,\n        )) by {\n            lemma_binary_sum_mod_decomposition(\n                pow2_sum(bytes, 0, 8, 30),\n                bytes[31] as nat,\n                31 * 8,\n                255,\n            );\n        }\n\n        assert(pow2_sum(bytes, 0, 8, 30) % pow2(255) == pow2_sum(bytes, 0, 8, 30)) by {\n            assert(pow2(31 * 8) < pow2(255)) by {\n                lemma_pow2_strictly_increases(31 * 8, 255);\n            }\n            lemma_small_mod(pow2_sum(bytes, 0, 8, 30), pow2(255));\n        }\n    }\n\n    assert((bytes[31] as nat * pow2(31 * 8)) % pow2(255) == ((bytes[31] as nat % pow2(7)) * pow2(\n        31 * 8,\n    ))) by {\n        lemma_pow2_mul_mod(bytes[31] as nat, 31 * 8, 255);\n    }\n}",
      "start_line": 423,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_basepoint_table().",
      "display_name": "is_valid_edwards_basepoint_table",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_basepoint_table().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_valid_edwards_basepoint_table(\n    table: EdwardsBasepointTable,\n    basepoint: (nat, nat),\n) -> bool {\n    // Each of the 32 LookupTables contains correct multiples of (16²)^i * B\n    forall|i: int|\n        #![trigger table.0[i]]\n        0 <= i < 32 ==> crate::window::is_valid_lookup_table_affine_coords(\n            table.0[i].0,\n            edwards_scalar_mul(basepoint, pow256(i as nat)),\n            8,\n        )\n}",
      "start_line": 86,
      "end_line": 50,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_limbs_encode_high_expr().",
      "display_name": "lemma_high_limbs_encode_high_expr",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_limbs_encode_high_expr().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "file_name": "scalar_lemmas_extra.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_high_limbs_encode_high_expr(hi: &[u64; 5], words: &[u64; 8], mask: u64)\n    requires\n        mask == (1u64 << 52) - 1u64,\n        hi[0] == (words[4] >> 4) & mask,\n        hi[1] == ((words[4] >> 56) | (words[5] << 8)) & mask,\n        hi[2] == ((words[5] >> 44) | (words[6] << 20)) & mask,\n        hi[3] == ((words[6] >> 32) | (words[7] << 32)) & mask,\n        hi[4] == words[7] >> 20,\n    ensures\n        five_limbs_to_nat_aux(*hi) == (words[4] >> 4) as nat + pow2(60) * (words[5] as nat) + pow2(\n            124,\n        ) * (words[6] as nat) + pow2(188) * (words[7] as nat),\n{\n    // Common mask equality used throughout\n    assert((1u64 << 52) - 1u64 == u64::MAX >> 12) by (bit_vector);\n\n    let limb0 = ((words[4] >> 4) & mask) as nat;\n    let limb1 = (((words[4] >> 56) | (words[5] << 8)) & mask) as nat;\n    let limb2 = (((words[5] >> 44) | (words[6] << 20)) & mask) as nat;\n    let limb3 = (((words[6] >> 32) | (words[7] << 32)) & mask) as nat;\n    let limb4 = (words[7] >> 20) as nat;\n\n    let masked_words_sum = limb0 + pow2(52) * limb1 + pow2(104) * limb2 + pow2(156) * limb3 + pow2(\n        208,\n    ) * limb4;\n\n    let unmasked_words_sum = (words[4] >> 4) as nat + pow2(60) * (words[5] as nat) + pow2(124) * (\n    words[6] as nat) + pow2(188) * (words[7] as nat);\n\n    let w4_high = (words[4] >> 56) as nat;\n    let w5_low = (words[5] & (u64::MAX >> 20)) as nat;\n    let w5_high = (words[5] >> 44) as nat;\n    let w6_low = (words[6] & (u64::MAX >> 32)) as nat;\n    let w6_high = (words[6] >> 32) as nat;\n    let w7_low = (words[7] & (u64::MAX >> 44)) as nat;\n    let w7_high = (words[7] >> 20) as nat;\n\n    // Limb 0 consists of word 4's bits 4 through 55.\n\n    // Limb 1 consists of word 4's top 8 bits and word 5's low 44 bits.\n    lemma_limb_from_adjacent_words(words[4], words[5], 56, 8, 20, limb1, w4_high, w5_low);\n\n    // Limb 2 consists of word 5's top 20 bits and word 6's low 32 bits.\n    lemma_limb_from_adjacent_words(words[5], words[6], 44, 20, 32, limb2, w5_high, w6_low);\n\n    // Limb 3 consists of word 6's top 32 bits and word 7's low 20 bits.\n    lemma_limb_from_adjacent_words(words[6], words[7], 32, 32, 44, limb3, w6_high, w7_low);\n\n    // Limb 4 consists of word 7's top 44 bits.\n\n    // Word 4 shifted by 4 equals limb 0 plus limb 1's contribution from word 4's high bits.\n    assert((words[4] >> 4) as nat == limb0 + pow2(52) * w4_high) by {\n        let w4 = words[4];\n        let low52 = (w4 >> 4) & mask;\n        let high8 = w4 >> 56;\n\n        assert(((w4 >> 4) & (u64::MAX >> 12)) < (1u64 << 52)) by (bit_vector);\n        assert(high8 <= u64::MAX >> 52) by {\n            assert((w4 >> 56) <= u64::MAX >> 56) by (bit_vector);\n            assert(u64::MAX >> 56 <= u64::MAX >> 52) by (bit_vector);\n        }\n        assert((w4 >> 4) == ((w4 >> 4) & (u64::MAX >> 12)) | ((w4 >> 56) << 52)) by (bit_vector);\n        lemma_bit_or_is_plus(low52, high8, 52);\n        vstd::bits::lemma_u64_mul_pow2_le_max_iff_max_shr(high8, 52, u64::MAX);\n        vstd::bits::lemma_u64_shl_is_mul(high8, 52);\n    };\n\n    // Word 5's contribution at scale 2^60 equals its low 44 bits plus its high 20 bits.\n    assert(pow2(60) * (words[5] as nat) == pow2(60) * w5_low + pow2(104) * w5_high) by {\n        lemma_word_contribution_decomposition(words[5], 60, 44, 20, w5_low, w5_high);\n    };\n\n    // Word 6's contribution at scale 2^124 equals its low 32 bits plus its high 32 bits.\n    assert(pow2(124) * (words[6] as nat) == pow2(124) * w6_low + pow2(156) * w6_high) by {\n        lemma_word_contribution_decomposition(words[6], 124, 32, 32, w6_low, w6_high);\n    };\n\n    // Word 7's contribution at scale 2^188 equals its low 20 bits plus its high 44 bits.\n    assert(pow2(188) * (words[7] as nat) == pow2(188) * w7_low + pow2(208) * w7_high) by {\n        lemma_word_contribution_decomposition(words[7], 188, 20, 44, w7_low, w7_high);\n    };\n\n    assert(limb0 + pow2(52) * (w4_high + pow2(8) * w5_low) + pow2(104) * (w5_high + pow2(20)\n        * w6_low) + pow2(156) * (w6_high + pow2(32) * w7_low) + pow2(208) * w7_high\n        == unmasked_words_sum) by {\n        broadcast use group_mul_is_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 8);\n        lemma_pow2_adds(104, 20);\n        lemma_pow2_adds(156, 32);\n    };\n    assert(masked_words_sum == unmasked_words_sum);\n}",
      "start_line": 403,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc string/String#AsRef#as_ref().",
      "display_name": "as_ref",
      "symbol": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc string/String#AsRef#as_ref().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "curve25519-dalek/build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_extraction_commutes_with_mod().",
      "display_name": "lemma_byte_extraction_commutes_with_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_extraction_commutes_with_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_byte_extraction_commutes_with_mod(x: nat, k: nat, m: nat)\n    requires\n        k * 8 + 8\n            <= m,  // The byte we're extracting is entirely below the modulo boundary\n\n    ensures\n        (x / pow2(k * 8)) % 256 == ((x % pow2(m)) / pow2(k * 8)) % 256,\n{\n    // Call the generalized version with b=8 (byte size)\n    lemma_chunk_extraction_commutes_with_mod(x, k, 8, m);\n\n    // Establish that pow2(8) == 256\n    lemma2_to64();\n}",
      "start_line": 224,
      "end_line": 53,
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_versions_equivalent().",
      "display_name": "lemma_load8_at_versions_equivalent",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_versions_equivalent().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_load8_at_versions_equivalent(input: &[u8], i: usize, k: nat)\n    requires\n        k <= 7,\n    ensures\n        load8_at_or_version_rec(input, i, k) == load8_at_plus_version_rec(input, i, k),\n    decreases k,\n{\n    if (k == 0) {\n        // trivial\n    } else {\n        lemma_load8_at_versions_equivalent(input, i, (k - 1) as nat);\n        let prev = load8_at_plus_version_rec(input, i, (k - 1) as nat);\n        assert(prev < (1u64 << 8 * k)) by {\n            lemma_load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n            lemma_shift_is_pow2(8 * k);\n        }\n        let v = input[i + k];\n        assert(v <= (u64::MAX >> ((k * 8) as u64))) by {\n            assert(v <= u8::MAX);\n            assert(u64::MAX >> ((k * 8) as u64) >= u64::MAX >> 56) by {\n                lemma_shr_nonincreasing(u64::MAX, k * 8, 56);\n            }\n            assert(u8::MAX <= u64::MAX >> 56) by (compute);\n        }\n        lemma_bit_or_is_plus(prev, input[i + k] as u64, (8 * k) as u64);\n    }\n}",
      "start_line": 232,
      "end_line": 48,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo proptest 1.9.0 runner/test_runner/TestRunner#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo proptest 1.9.0 runner/test_runner/TestRunner#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_with_prime().",
      "display_name": "lemma_gcd_with_prime",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_with_prime().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_gcd_with_prime(a: nat, prime: nat)\n    requires\n        is_prime(prime),\n        a % prime != 0,\n    ensures\n        spec_gcd(a % prime, prime) == 1,\n{\n    let a_red = a % prime;\n    let g = spec_gcd(a_red, prime);\n\n    assert(a_red < prime) by {\n        lemma_mod_bound(a as int, prime as int);\n    };\n\n    lemma_gcd_divides_both(a_red, prime);\n    lemma_gcd_positive(a_red, prime);\n\n    if g != 1 {\n        // g | prime and g > 1 implies g == prime (by primality)\n        assert(g == prime) by {\n            lemma_mod_is_zero_when_divisible(prime, g);\n            if g < prime {\n                assert(false);\n            }  // contradicts is_prime\n\n        };\n\n        // But g | a_red with a_red < prime and a_red != 0 is impossible\n        assert(a_red % prime == a_red) by {\n            lemma_small_mod(a_red, prime);\n        };\n        assert(false);\n    }\n}",
      "start_line": 155,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConstantTimeEq#ct_eq().",
      "display_name": "ct_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConstantTimeEq#ct_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn ct_eq(&self, other: &Self) -> (result: Choice)\n        ensures\n            choice_is_true(result) == (self.bytes == other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Verus compatibility instead of direct subtle call\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.bytes.ct_eq(&other.bytes)\n         </ORIGINAL CODE> */\n        ct_eq_bytes32(&self.bytes, &other.bytes)\n    }",
      "start_line": 434,
      "end_line": 13,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs",
      "file_name": "precomputed_straus.rs",
      "parent_folder": "scalar_mul",
      "body": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self {\n            static_lookup_tables: static_points\n                .into_iter()\n                .map(|P| NafLookupTable8::<AffineNielsPoint>::from(P.borrow()))\n                .collect(),\n        }\n    }",
      "start_line": 34,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_to_nat_gen_u64_prefix_matches_bytes().",
      "display_name": "lemma_words_to_nat_gen_u64_prefix_matches_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_to_nat_gen_u64_prefix_matches_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "file_name": "scalar_lemmas_extra.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_words_to_nat_gen_u64_prefix_matches_bytes(\n    words: &[u64; 8],\n    bytes: &[u8; 64],\n    count: int,\n)\n    requires\n        0 <= count <= 8,\n        forall|k: int| #![auto] 0 <= k < 8 ==> words@[k] as nat == word_from_bytes(bytes, k),\n    ensures\n        words_to_nat_gen_u64(words, count, 64) == words_from_bytes_to_nat(bytes, count),\n    decreases count,\n{\n    reveal_with_fuel(words_to_nat_gen_u64, 9);\n    reveal_with_fuel(words_from_bytes_to_nat, 9);\n}",
      "start_line": 260,
      "end_line": 61,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_internal_no_overflow().",
      "display_name": "lemma_square_internal_no_overflow",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_internal_no_overflow().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_square_internal_no_overflow()\n    ensures\n        (1u128 << 105) + (1u128 << 105) == (1u128 << 106),\n        (1u128 << 105) + (1u128 << 104) < (1u128 << 106),\n        (1u128 << 104) * 2 == (1u128 << 105),\n        (1u128 << 106) + (1u128 << 104) < (1u128 << 107),\n{\n    assert((1u128 << 105) + (1u128 << 105) == (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 105) + (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 104) * 2 == (1u128 << 105)) by (bit_vector);\n    assert((1u128 << 106) + (1u128 << 104) < (1u128 << 107)) by (bit_vector);\n}",
      "start_line": 74,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"CompressedEdwardsY: {:?}\", self.as_bytes())\n    }",
      "start_line": 212,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_pow2k_to_field_element().",
      "display_name": "lemma_pow2k_to_field_element",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_pow2k_to_field_element().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "file_name": "invert_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_pow2k_to_field_element(fe: &FieldElement51, result: &FieldElement51, k: nat)\n    requires\n        k > 0,  // Required by lemma0_pow and lemma_pow_positive\n        // From pow2k postcondition (limb-level):\n        u64_5_as_nat(result.limbs) % p() == (pow(u64_5_as_nat(fe.limbs) as int, k) as nat) % p(),\n    ensures\n// Derived field-level postcondition:\n\n        spec_field_element(result) == (pow(spec_field_element(fe) as int, k) as nat) % p(),\n{\n    // Key insight: Both sides are already \"% p()\" by definition\n    // - spec_field_element(result) = u64_5_as_nat(result.limbs) % p()  (by definition)\n    // - spec_field_element(fe) = u64_5_as_nat(fe.limbs) % p()          (by definition)\n    assert(p() > 0) by {\n        pow255_gt_19();\n    }\n\n    // From requires: u64_5_as_nat(result.limbs) % p() == (pow(u64_5_as_nat(fe.limbs), k) as nat) % p()\n    // By definition: spec_field_element(result) == u64_5_as_nat(result.limbs) % p()\n    // Therefore: spec_field_element(result) == (pow(u64_5_as_nat(fe.limbs), k) as nat) % p()\n    assert(spec_field_element(result) == (pow(u64_5_as_nat(fe.limbs) as int, k) as nat) % p());\n\n    // Show that pow(spec_field_element(fe), k) % p() == pow(u64_5_as_nat(fe.limbs), k) % p()\n    // This follows from lemma_pow_mod_noop: pow(b % m, e) % m == pow(b, e) % m\n    assert(pow(spec_field_element(fe) as int, k) % (p() as int) == pow(\n        u64_5_as_nat(fe.limbs) as int,\n        k,\n    ) % (p() as int)) by {\n        lemma_pow_mod_noop(u64_5_as_nat(fe.limbs) as int, k, p() as int);\n    }\n\n    // Prove pow results are non-negative to justify int-to-nat casts\n    assert(pow(u64_5_as_nat(fe.limbs) as int, k) >= 0) by {\n        lemma_pow_nonnegative(u64_5_as_nat(fe.limbs) as int, k);\n    }\n\n    assert(pow(spec_field_element(fe) as int, k) >= 0) by {\n        lemma_pow_nonnegative(spec_field_element(fe) as int, k);\n    }\n\n    // Complete the chain:\n    // spec_field_element(result) == (pow(u64_5_as_nat(fe.limbs), k) as nat) % p()  (proven above)\n    // pow(spec_field_element(fe), k) % p() == pow(u64_5_as_nat(fe.limbs), k) % p()  (proven above)\n    // Both powers are non-negative, so int % and nat % give the same result\n    // Therefore: spec_field_element(result) == (pow(spec_field_element(fe), k) as nat) % p() ✅\n}",
      "start_line": 31,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/l51_bit_mask_lt().",
      "display_name": "l51_bit_mask_lt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/l51_bit_mask_lt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub proof fn l51_bit_mask_lt()\n    ensures\n        mask51 == low_bits_mask(51),\n        mask51 < (1u64 << 51) as nat,\n{\n    lemma2_to64_rest();\n    assert(mask51 < (1u64 << 51) as nat) by (compute);\n}",
      "start_line": 73,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#as_deref().",
      "display_name": "as_deref",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#as_deref().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "curve25519-dalek/build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "display_name": "mul_by_pow_2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn mul_by_pow_2(&self, k: u32) -> (result: EdwardsPoint)\n        requires\n            k > 0,\n            edwards_point_limbs_bounded(*self),\n    {\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert!(k > 0);\n        let mut r: CompletedPoint;\n        let mut s = self.as_projective();\n        for _ in 0..(k - 1) {\n            proof {\n                assume(is_valid_projective_point(s));\n                assume(sum_of_limbs_bounded(&s.X, &s.Y, u64::MAX));\n                assume(fe51_limbs_bounded(&s.X, 54));\n                assume(fe51_limbs_bounded(&s.Y, 54));\n                assume(fe51_limbs_bounded(&s.Z, 54));\n            }\n            r = s.double();\n            proof {\n                assume(fe51_limbs_bounded(&r.X, 54));\n                assume(fe51_limbs_bounded(&r.Y, 54));\n                assume(fe51_limbs_bounded(&r.Z, 54));\n            }\n            s = r.as_projective();\n        }\n        // Unroll last iteration so we can go directly as_extended()\n        proof {\n            assume(is_valid_projective_point(s));\n            assume(sum_of_limbs_bounded(&s.X, &s.Y, u64::MAX));\n            assume(fe51_limbs_bounded(&s.X, 54));\n            assume(fe51_limbs_bounded(&s.Y, 54));\n            assume(fe51_limbs_bounded(&s.Z, 54));\n        }\n        s.double().as_extended()\n    }",
      "start_line": 2271,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_two_factoring_51().",
      "display_name": "lemma_two_factoring_51",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_two_factoring_51().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_two_factoring_51(k: nat, ai: u64)\n    ensures\n        pow2(k + 51) * ai == pow2(k) * (pow2(51) * ai),\n{\n    lemma_two_factoring(k, 51, ai);\n}",
      "start_line": 18,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "display_name": "lemma_load8_at_limb_X",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_load8_at_limb_X(\n    input: &[u8],\n    i: usize,\n    k: nat,\n    j_div: nat,\n    j_id: nat,\n    j_shift: nat,\n)\n    requires\n        i + 7 < input.len(),\n        k <= 12,\n        forall|j: nat| 0 <= j < j_div ==> pow2_mul_div_mod_small_mul_u8_t51_cond(k, j),\n        forall|j: nat| j_div <= j < j_id ==> pow2_mul_div_mod_small_div_u8_t51_cond(k, j),\n        forall|j: nat| j_id <= j < j_shift ==> pow2_mul_div_mod_close_mod_u8_t51_cond(k, j),\n        forall|j: nat| j_shift <= j < 8 ==> pow2_mul_div_mod_small_mod_u8_t51_cond(k, j),\n    ensures\n        forall|j: nat|\n            0 <= j < j_div ==> #[trigger] ((input[(i + j) as int] * pow2(j * 8)) as u64 / (pow2(\n                k,\n            ) as u64)) % (pow2(51) as u64) == (input[(i + j) as int]) as nat / pow2(\n                (k - j * 8) as nat,\n            ),\n        forall|j: nat|\n            j_div <= j < j_id ==> #[trigger] ((input[(i + j) as int] * pow2(j * 8)) as u64 / (pow2(\n                k,\n            ) as u64)) % (pow2(51) as u64) == (input[(i + j) as int]) * pow2((j * 8 - k) as nat),\n        forall|j: nat|\n            j_id <= j < j_shift ==> #[trigger] ((input[(i + j) as int] * pow2(j * 8)) as u64 / (\n            pow2(k) as u64)) % (pow2(51) as u64) == (input[(i + j) as int] as nat % pow2(\n                (51 - (j * 8 - k)) as nat,\n            )) * pow2((j * 8 - k) as nat),\n        forall|j: nat|\n            j_shift <= j < 8 ==> #[trigger] ((input[(i + j) as int] * pow2(j * 8)) as u64 / (pow2(\n                k,\n            ) as u64)) % (pow2(51) as u64) == 0,\n        (spec_load8_at(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64),\n{\n    let p51 = pow2(51) as u64;\n\n    assert(0 < pow2(k) <= u64::MAX) by {\n        lemma_pow2_pos(k);\n        lemma_pow2_le_max64(k);\n    }\n\n    let pk = pow2(k) as u64;\n\n    lemma_load8_at_limb_base(input, i, k as u64);\n\n    // first: all div, no mul\n    assert forall|j: nat| 0 <= j < j_div implies #[trigger] ((input[(i + j) as int] * pow2(\n        j * 8,\n    )) as u64 / pk) % p51 == (input[(i + j) as int]) as nat / pow2((k - j * 8) as nat) by {\n        assert(pow2_mul_div_mod_small_mul_u8_t51_cond(k, j));  // trigger forall\n        lemma_pow2_mul_div_mod_small_mul_u8(input[(i + j) as int], j * 8, k, 51);\n    }\n\n    // (product >> k) < 2^51\n    assert forall|j: nat| j_div <= j < j_id implies #[trigger] ((input[(i + j) as int] * pow2(\n        j * 8,\n    )) as u64 / pk) % p51 == (input[(i + j) as int]) * pow2((j * 8 - k) as nat) by {\n        assert(pow2_mul_div_mod_small_div_u8_t51_cond(k, j));  // trigger forall\n        lemma_pow2_mul_div_mod_small_div_u8(input[(i + j) as int], j * 8, k, 51);\n    }\n\n    // partial shift\n    assert forall|j: nat| j_id <= j < j_shift implies #[trigger] ((input[(i + j) as int] * pow2(\n        j * 8,\n    )) as u64 / pk) % p51 == (input[(i + j) as int] as nat % pow2((51 - (j * 8 - k)) as nat))\n        * pow2((j * 8 - k) as nat) by {\n        assert(pow2_mul_div_mod_close_mod_u8_t51_cond(k, j));  // trigger forall\n        lemma_pow2_mul_div_mod_close_mod_u8(input[(i + j) as int], j * 8, k, 51);\n    }\n\n    // zero\n    assert forall|j: nat| j_shift <= j < 8 implies #[trigger] ((input[(i + j) as int] * pow2(\n        j * 8,\n    )) as u64 / pk) % p51 == 0 by {\n        assert(pow2_mul_div_mod_small_mod_u8_t51_cond(k, j));  // trigger forall\n        lemma_pow2_mul_div_mod_small_mod_u8(input[(i + j) as int], j * 8, k, 51);\n    }\n}",
      "start_line": 735,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 13
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "display_name": "lemma_to_bytes_reduction",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_to_bytes_reduction(input_limbs: [u64; 5], final_limbs: [u64; 5], q: u64)\n    requires\n        forall|i: int| 0 <= i < 5 ==> input_limbs[i] < (1u64 << 52),\n        q == 0 || q == 1,\n        u64_5_as_nat(input_limbs) >= p() <==> q == 1,\n        u64_5_as_nat(input_limbs) < 2 * p(),  // From reduce()'s postcondition\n        final_limbs == reduce_with_q_spec(input_limbs, q),\n    ensures\n        forall|i: int| 0 <= i < 5 ==> final_limbs[i] < (1u64 << 51),\n        u64_5_as_nat(final_limbs) == u64_5_as_nat(input_limbs) % p(),\n{\n    // Extract intermediate values from the spec\n    let l0 = (input_limbs[0] + 19 * q) as u64;\n    let l1 = (input_limbs[1] + (l0 >> 51)) as u64;\n    let l0_masked = (l0 & mask51) as u64;\n    let l2 = (input_limbs[2] + (l1 >> 51)) as u64;\n    let l1_masked = (l1 & mask51) as u64;\n    let l3 = (input_limbs[3] + (l2 >> 51)) as u64;\n    let l2_masked = (l2 & mask51) as u64;\n    let l4 = (input_limbs[4] + (l3 >> 51)) as u64;\n    let l3_masked = (l3 & mask51) as u64;\n    let l4_masked = (l4 & mask51) as u64;\n\n    // Part 1: Prove that all final limbs are bounded by 2^51\n    l51_bit_mask_lt();\n    lemma_masked_lt_51(l0);\n    lemma_masked_lt_51(l1);\n    lemma_masked_lt_51(l2);\n    lemma_masked_lt_51(l3);\n    lemma_masked_lt_51(l4);\n\n    // Part 2: Prove that u64_5_as_nat(final_limbs) == u64_5_as_nat(input_limbs) % p()\n    // Strategy: Show that the carry propagation computes u64_5_as_nat(input_limbs) + 19*q - 2^255*q\n    //           which equals u64_5_as_nat(input_limbs) - q*(2^255 - 19) = u64_5_as_nat(input_limbs) - q*p()\n\n    // Use lemma_div_and_mod_51 to relate the shift and mask operations to division and modulo\n    lemma_div_and_mod_51(l0 >> 51, l0 & mask51, l0);\n\n    lemma_div_and_mod_51(l1 >> 51, l1 & mask51, l1);\n\n    lemma_div_and_mod_51(l2 >> 51, l2 & mask51, l2);\n\n    lemma_div_and_mod_51(l3 >> 51, l3 & mask51, l3);\n\n    lemma_div_and_mod_51(l4 >> 51, l4 & mask51, l4);\n\n    // Define the carries for readability\n    let c0 = l0 >> 51;\n    let c1 = l1 >> 51;\n    let c2 = l2 >> 51;\n    let c3 = l3 >> 51;\n    let c4 = l4 >> 51;\n\n    // Express l0, l1, l2, l3, l4 in terms of input_limbs\n    // Note: Need to prove the casts don't affect the values (no overflow)\n    assert(19 * q < 20) by {}\n    assert((1u64 << 52) + 20 < u64::MAX) by (compute);\n\n    // Similar reasoning for other limbs - the carries are small enough\n    // l0 < 2^52 + 20, so l0 >> 51 <= 2\n    // l1 = input_limbs[1] + (l0 >> 51) < 2^52 + 2 < u64::MAX\n    lemma_shr_le_u64(l0, ((1u64 << 52) + 20) as u64, 51);\n    assert((((1u64 << 52) + 20) as u64) >> 51 == 2) by (compute);\n\n    lemma_shr_le_u64(l1, ((1u64 << 52) + 2) as u64, 51);\n    assert((((1u64 << 52) + 2) as u64) >> 51 == 2) by (compute);\n\n    lemma_shr_le_u64(l2, ((1u64 << 52) + 2) as u64, 51);\n\n    lemma_shr_le_u64(l3, ((1u64 << 52) + 2) as u64, 51);\n\n    // Now use the telescoping lemma to relate u64_5_as_nat(input_limbs) + 19*q to u64_5_as_nat(final_limbs) + c4*2^255\n    // The division-mod relationships give us the preconditions needed:\n\n    // All final_limbs are bounded by 2^51 (already proven above)\n    lemma_reduction_telescoping(\n        input_limbs,\n        final_limbs,\n        q,\n        c0 as int,\n        c1 as int,\n        c2 as int,\n        c3 as int,\n        c4 as int,\n    );\n\n    // Prove that c4 == q\n    lemma_carry_out_equals_q(input_limbs, q);\n\n    // Therefore: u64_5_as_nat(input_limbs) + 19*q = u64_5_as_nat(final_limbs) + q*2^255\n    // Rearranging: u64_5_as_nat(final_limbs) = u64_5_as_nat(input_limbs) + 19*q - q*2^255\n    //                                    = u64_5_as_nat(input_limbs) - q*(2^255 - 19)\n    //                                    = u64_5_as_nat(input_limbs) - q*p()\n\n    pow255_gt_19();\n\n    // Case analysis on q\n    if q == 0 {\n        // u64_5_as_nat(final_limbs) = u64_5_as_nat(input_limbs) - 0*p() = u64_5_as_nat(input_limbs)\n        // Since q == 0, we have u64_5_as_nat(input_limbs) < p()\n        // For values < p, x % p = x\n        // Since u64_5_as_nat(input_limbs) < p(), we have u64_5_as_nat(input_limbs) % p() = u64_5_as_nat(input_limbs)\n        lemma_pow2_pos(255);\n        lemma_small_mod(u64_5_as_nat(input_limbs), p());\n\n    } else {\n        // q == 1\n        // u64_5_as_nat(final_limbs) = u64_5_as_nat(input_limbs) - 1*p() = u64_5_as_nat(input_limbs) - p()\n        // Need to prove: u64_5_as_nat(input_limbs) % p() = u64_5_as_nat(input_limbs) - p()\n        // This holds when p <= u64_5_as_nat(input_limbs) < 2*p\n        // We have u64_5_as_nat(input_limbs) >= p() (from q==1) and u64_5_as_nat(input_limbs) < 2*p() (from precondition)\n        // For values in [p, 2*p), x % p = x - p\n        lemma_fundamental_div_mod(u64_5_as_nat(input_limbs) as int, p() as int);\n        lemma_pow2_pos(255);\n\n        // Since p <= u64_5_as_nat < 2*p, the quotient is 1\n        lemma_div_strictly_bounded(u64_5_as_nat(input_limbs) as int, p() as int, 2);\n\n        // From div-mod: x = d * (x/d) + (x%d)\n        // lemma_fundamental_div_mod establishes this with multiplication on the left\n        let x = u64_5_as_nat(input_limbs) as int;\n        let divisor = p() as int;\n        let quotient = x / divisor;\n        let remainder = x % divisor;\n\n        // From lemma_fundamental_div_mod: x == divisor * quotient + remainder\n        // Convert to: x == quotient * divisor + remainder\n        assert(divisor * quotient == quotient * divisor) by {\n            lemma_mul_is_commutative(divisor, quotient);\n        }\n\n        // We proved quotient == 1\n\n        // Convert back to original terms\n    }\n}",
      "start_line": 561,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "display_name": "lemma_pow_nonnegative",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow_nonnegative(base: int, n: nat)\n    requires\n        base >= 0,\n    ensures\n        pow(base, n) >= 0,\n{\n    if base > 0 {\n        // Delegate to vstd's lemma_pow_positive for the positive case\n        lemma_pow_positive(base, n);\n    } else {\n        // base == 0 case\n        if n == 0 {\n            // pow(0, 0) == 1 >= 0\n            lemma_pow0(0);\n        } else {\n            // pow(0, n) == 0 >= 0 for n > 0\n            lemma0_pow(n);\n        }\n    }\n}",
      "start_line": 917,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 12,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_biconditional().",
      "display_name": "lemma_q_biconditional",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_biconditional().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_q_biconditional(limbs: [u64; 5], q: u64)\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 52),\n        u64_5_as_nat(limbs) < 2 * p(),  // Tight bound from reduce()\n        q == compute_q_spec(limbs),\n        q as nat == (u64_5_as_nat(limbs) + 19) / pow2(255),\n        q == 0 || q == 1,\n    ensures\n        u64_5_as_nat(limbs) >= p() <==> q == 1,\n        u64_5_as_nat(limbs) < p() <==> q == 0,\n{\n    pow255_gt_19();\n    lemma2_to64();\n    lemma_pow2_pos(255);\n\n    // The key insight: with u64_5_as_nat(limbs) < 2*p() and p() < 2^255, we have two cases:\n    // Case 1: u64_5_as_nat(limbs) < p() ⟺ u64_5_as_nat(limbs) + 19 < 2^255 ⟺ q = 0\n    // Case 2: p() ≤ u64_5_as_nat(limbs) < 2*p() ⟺ 2^255 ≤ u64_5_as_nat(limbs) + 19 < 2*2^255 ⟺ q = 1\n\n    // Forward direction: u64_5_as_nat(limbs) < p() ==> q == 0\n    if u64_5_as_nat(limbs) < p() {\n        lemma_div_strictly_bounded((u64_5_as_nat(limbs) + 19) as int, pow2(255) as int, 1);\n    }\n    // Backward direction: q == 0 ==> u64_5_as_nat(limbs) < p()\n\n    if q == 0 {\n        lemma_fundamental_div_mod((u64_5_as_nat(limbs) + 19) as int, pow2(255) as int);\n        lemma_mod_bound((u64_5_as_nat(limbs) + 19) as int, pow2(255) as int);\n    }\n    // Forward direction: u64_5_as_nat(limbs) >= p() ==> q == 1\n\n    if u64_5_as_nat(limbs) >= p() {\n        // Since q is 0 or 1, and we know u64_5_as_nat + 19 >= 2^255, q cannot be 0\n        if q == 0 {\n            lemma_fundamental_div_mod((u64_5_as_nat(limbs) + 19) as int, pow2(255) as int);\n            lemma_mod_bound((u64_5_as_nat(limbs) + 19) as int, pow2(255) as int);\n        }\n    }\n    // Backward direction: q == 1 ==> u64_5_as_nat(limbs) >= p()\n\n    if q == 1 {\n        lemma_fundamental_div_mod((u64_5_as_nat(limbs) + 19) as int, pow2(255) as int);\n    }\n}",
      "start_line": 508,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 1 <= i < 32 ==> #[trigger] self.0[i] == 0u8,\n            self.0[0]\n                == 1u8,\n    // VERIFICATION NOTE: this \"zeroize\" leaves one bit equal to 1\n\n    {\n        /* ORIGINAL CODE:\n            self.0.zeroize();\n            self.0[0] = 1;\n        */\n        crate::core_assumes::zeroize_bytes32(&mut self.0);\n        self.0[0] = 1;\n    }",
      "start_line": 871,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb0().",
      "display_name": "lemma_load8_at_limb0",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb0().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_load8_at_limb0(input: &[u8])\n    requires\n        0 + 7 < input.len(),\n    ensures\n        (spec_load8_at(input, 0) as u64) & mask51 == (input[0] * pow2(0 * 8)) + (input[1] * pow2(\n            1 * 8,\n        )) + (input[2] * pow2(2 * 8)) + (input[3] * pow2(3 * 8)) + (input[4] * pow2(4 * 8)) + (\n        input[5] * pow2(5 * 8)) + ((input[6] as nat % pow2(3)) * pow2(6 * 8)),\n{\n    let i = 0;\n    let k = 0;\n\n    let j_div = 0;\n    let j_id = 6;\n    let j_shift = 7;\n\n    assert(spec_load8_at(input, 0) as u64 == (spec_load8_at(input, 0) as u64 >> 0)) by {\n        lemma_shr_zero_is_id(spec_load8_at(input, 0) as u64);\n    }\n\n    lemma_load8_at_limb_X(input, i, k, j_div, j_id, j_shift);\n\n    // Sanity check\n    assert((spec_load8_at(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n        / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n    pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64));\n\n    assert(pow2(0) == 1) by {\n        lemma2_to64();\n    }\n\n    broadcast use lemma_div_basics_2;  // x / 1 = x\n\n}",
      "start_line": 825,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn default() -> (result: EdwardsPoint)\n        ensures\n            is_identity_edwards_point(result),\n    {\n        EdwardsPoint::identity()\n    }",
      "start_line": 857,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_add().",
      "display_name": "lemma_u64_5_as_nat_add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "file_name": "u64_5_as_nat_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_u64_5_as_nat_add(a: [u64; 5], b: [u64; 5])\n    requires\n        forall|i: int| 0 <= i < 5 ==> b[i] as nat + a[i] as nat <= u64::MAX,\n    ensures\n        u64_5_as_nat(\n            [\n                (a[0] + b[0]) as u64,\n                (a[1] + b[1]) as u64,\n                (a[2] + b[2]) as u64,\n                (a[3] + b[3]) as u64,\n                (a[4] + b[4]) as u64,\n            ],\n        ) == u64_5_as_nat(a) + u64_5_as_nat(b),\n{\n    let c: [u64; 5] = [\n        (a[0] + b[0]) as u64,\n        (a[1] + b[1]) as u64,\n        (a[2] + b[2]) as u64,\n        (a[3] + b[3]) as u64,\n        (a[4] + b[4]) as u64,\n    ];\n    // distribute pow2\n    assert(u64_5_as_nat(c) == (a[0] + b[0]) + pow2(51) * a[1] + pow2(51) * b[1] + pow2(102) * a[2]\n        + pow2(102) * b[2] + pow2(153) * a[3] + pow2(153) * b[3] + pow2(204) * a[4] + pow2(204)\n        * b[4]) by {\n        lemma_mul_is_distributive_add(pow2(1 * 51) as int, a[1] as int, b[1] as int);\n        lemma_mul_is_distributive_add(pow2(2 * 51) as int, a[2] as int, b[2] as int);\n        lemma_mul_is_distributive_add(pow2(3 * 51) as int, a[3] as int, b[3] as int);\n        lemma_mul_is_distributive_add(pow2(4 * 51) as int, a[4] as int, b[4] as int);\n    }\n}",
      "start_line": 119,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Neg#neg().",
      "display_name": "neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Neg#neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn neg(\n        self,\n    ) -> EdwardsPoint/* requires clause in NegSpecImpl for &EdwardsPoint above:\n           requires fe51_limbs_bounded(&self.X, 51) && fe51_limbs_bounded(&self.T, 51)\n        */\n     {\n        /* ORIGINAL CODE\n        EdwardsPoint {\n            X: -(&self.X),\n            Y: self.Y,\n            Z: self.Z,\n            T: -(&self.T),\n        }\n        */\n        // REFACTORED: Use explicit Neg::neg() calls instead of operator shortcuts\n        // to avoid Verus panic\n        use core::ops::Neg;\n        EdwardsPoint { X: Neg::neg(&self.X), Y: self.Y, Z: self.Z, T: Neg::neg(&self.T) }\n    }",
      "start_line": 1583,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes_verus().",
      "display_name": "hash_from_bytes_verus",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes_verus().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn hash_from_bytes_verus(input: &[u8]) -> (result: Scalar)\n        ensures\n            is_random_bytes(input) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        use crate::core_assumes as assumes;\n        let hash_bytes: [u8; 64] = assumes::sha512_hash_bytes(input);\n        Scalar::from_hash_verus(hash_bytes)\n    }",
      "start_line": 1374,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "display_name": "main",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "curve25519-dalek/build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "body": "fn main() {\n    let target_arch = match std::env::var(\"CARGO_CFG_TARGET_ARCH\") {\n        Ok(arch) => arch,\n        _ => \"\".to_string(),\n    };\n\n    let curve25519_dalek_bits = match std::env::var(\"CARGO_CFG_CURVE25519_DALEK_BITS\").as_deref() {\n        Ok(\"32\") => DalekBits::Dalek32,\n        Ok(\"64\") => DalekBits::Dalek64,\n        _ => deterministic::determine_curve25519_dalek_bits(&target_arch),\n    };\n\n    println!(\"cargo:rustc-cfg=curve25519_dalek_bits=\\\"{curve25519_dalek_bits}\\\"\");\n\n    if rustc_version::version_meta()\n        .expect(\"failed to detect rustc version\")\n        .channel\n        == rustc_version::Channel::Nightly\n    {\n        println!(\"cargo:rustc-cfg=nightly\");\n    }\n\n    let rustc_version = rustc_version::version().expect(\"failed to detect rustc version\");\n    if rustc_version.major == 1 && rustc_version.minor <= 64 {\n        // Old versions of Rust complain when you have an `unsafe fn` and you use `unsafe {}` inside,\n        // so for those we want to apply the `#[allow(unused_unsafe)]` attribute to get rid of that warning.\n        println!(\"cargo:rustc-cfg=allow_unused_unsafe\");\n    }\n\n    // Backend overrides / defaults\n    let curve25519_dalek_backend =\n        match std::env::var(\"CARGO_CFG_CURVE25519_DALEK_BACKEND\").as_deref() {\n            Ok(\"fiat\") => \"fiat\",\n            Ok(\"serial\") => \"serial\",\n            Ok(\"simd\") => {\n                // simd can only be enabled on x86_64 & 64bit target_pointer_width\n                match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n                    true => \"simd\",\n                    // If override is not possible this must result to compile error\n                    // See: issues/532\n                    false => panic!(\"Could not override curve25519_dalek_backend to simd\"),\n                }\n            }\n            // default between serial / simd (if potentially capable)\n            _ => match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n                true => \"simd\",\n                false => \"serial\",\n            },\n        };\n    println!(\"cargo:rustc-cfg=curve25519_dalek_backend=\\\"{curve25519_dalek_backend}\\\"\");\n}",
      "start_line": 23,
      "end_line": 8,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#basepoint().",
      "display_name": "basepoint",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#basepoint().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn basepoint(&self) -> (result: EdwardsPoint)\n        ensures\n            is_well_formed_edwards_point(result),\n            // The result is the Ed25519 basepoint B\n            edwards_point_as_affine(result) == spec_ed25519_basepoint(),\n    {\n        // self.0[0].select(1) = 1*(16^2)^0*B\n        // but as an `AffineNielsPoint`, so add identity to convert to extended.\n        /* ORIGINAL CODE:\n            (&EdwardsPoint::identity() + &self.0[0].select(1)).as_extended()\n        */\n        /* REFACTORED FOR ASSERTIONS: */\n        let identity = EdwardsPoint::identity();\n        let selected = self.0[0].select(1);\n        proof {\n            // Preconditions for addition\n            assume(is_well_formed_edwards_point(identity));\n            assume(sum_of_limbs_bounded(&identity.Z, &identity.Z, u64::MAX));\n            assume(fe51_limbs_bounded(&selected.y_plus_x, 54));\n            assume(fe51_limbs_bounded(&selected.y_minus_x, 54));\n            assume(fe51_limbs_bounded(&selected.xy2d, 54));\n        }\n        let completed = &identity + &selected;\n        proof {\n            // Preconditions for as_extended\n            assume(fe51_limbs_bounded(&completed.X, 54));\n            assume(fe51_limbs_bounded(&completed.Y, 54));\n            assume(fe51_limbs_bounded(&completed.Z, 54));\n            assume(fe51_limbs_bounded(&completed.T, 54));\n        }\n        let result = completed.as_extended();\n        proof {\n            assume(is_well_formed_edwards_point(result));\n            assume(edwards_point_as_affine(result) == spec_ed25519_basepoint());\n        }\n        result\n    }",
      "start_line": 2012,
      "end_line": 17,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "display_name": "lemma_mod_bound",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "is_libsignal": false,
      "caller_count": 42,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_unfold().",
      "display_name": "lemma_pow2_unfold",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_unfold().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c3_val().",
      "display_name": "c3_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c3_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn c3_val(a: [u64; 5]) -> u128 {\n    (c3_0_val(a) + ((c2_val(a) >> 51) as u64) as u128) as u128\n}",
      "start_line": 68,
      "end_line": 24,
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_is_zero().",
      "display_name": "lemma_mod_is_zero",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_is_zero().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/negate_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/negate_lemmas.rs",
      "file_name": "negate_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "display_name": "pow",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 43,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_projective().",
      "display_name": "is_valid_lookup_table_projective",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_projective().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "pub open spec fn is_valid_lookup_table_projective<const N: usize>(\n    table: [ProjectiveNielsPoint; N],\n    P: EdwardsPoint,\n    size: nat,\n) -> bool {\n    &&& table.len() == size\n    &&& forall|j: int|\n        0 <= j < size ==> projective_niels_point_as_affine_edwards(#[trigger] table[j])\n            == edwards_scalar_mul(edwards_point_as_affine(P), (j + 1) as nat)\n}",
      "start_line": 47,
      "end_line": 50,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo rustc_version 0.4.1 version().",
      "display_name": "version",
      "symbol": "rust-analyzer cargo rustc_version 0.4.1 version().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "curve25519-dalek/build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"{:?}(\", stringify!(LookupTable))?;\n\n        for x in self.0.iter() {\n            write!(f, \"{:?}\", x)?;\n        }\n\n        write!(f, \")\")\n    }",
      "start_line": 321,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "display_name": "pow2k",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    pub fn pow2k(&self, mut k: u32) -> (r: FieldElement51)\n        requires\n            k > 0,  // debug_assert!( k > 0 );\n            forall|i: int|\n                0 <= i < 5 ==> self.limbs[i] < 1u64 << 54  // 51 + b for b = 3\n            ,\n        ensures/*  VERIFICATION NOTE: spec updated\n         - spec needs cleanup\n         - proof needs completed: one assume left */\n    // Actual bound: 2^51 + 2^13 < 2^52 (from carry propagation in reduction)\n\n            forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 52,\n            // 52-bit implies 54-bit (for compatibility with callers)\n            forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 54,\n            u64_5_as_nat(r.limbs) % p() == pow(\n                u64_5_as_nat(self.limbs) as int,\n                pow2(k as nat),\n            ) as nat % p(),\n    {\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert!( k > 0 );\n\n        /// Multiply two 64-bit integers with 128 bits of output.\n        /* VERIFICATION NOTE: manually moved outside */\n        /* #[inline(always)]\n        fn m(x: u64, y: u64) -> u128 {\n            (x as u128) * (y as u128)\n        }\n        */\n        let mut a: [u64; 5] = self.limbs;\n\n        let ghost k0 = k;\n        // pre-loop invariant, i = 0\n        proof {\n            assert(u64_5_as_nat(a) == pow(u64_5_as_nat(self.limbs) as int, pow2(0))) by {\n                lemma2_to64();  // pow2(0) = 1\n                lemma_pow1(u64_5_as_nat(self.limbs) as int);\n            }\n        }\n        loop\n            invariant_except_break\n        // Conservative: input could be 54-bit, but after first iteration it's 52-bit\n\n                forall|j: int| 0 <= j < 5 ==> a[j] < 1u64 << 54,\n                u64_5_as_nat(a) % p() == pow(\n                    u64_5_as_nat(self.limbs) as int,\n                    pow2((k0 - k) as nat),\n                ) as nat % p(),\n                0 < k <= k0,\n            ensures\n                k == 0,\n                forall|j: int| 0 <= j < 5 ==> a[j] < 1u64 << 52,\n                // 52-bit implies 54-bit (for compatibility)\n                forall|j: int| 0 <= j < 5 ==> a[j] < 1u64 << 54,\n                u64_5_as_nat(a) % p() == pow(\n                    u64_5_as_nat(self.limbs) as int,\n                    pow2(k0 as nat),\n                ) as nat % p(),\n            decreases k,\n        {\n            proof {\n                let ghost i = (k0 - k) as nat;\n\n                lemma_pow2k_loop_boundary(a);\n                lemma_pow2k_loop_value(a, self.limbs, i);\n            }\n\n            // Precondition: assume input limbs a[i] are bounded as\n            //\n            // a[i] < 2^(51 + b)\n            //\n            // where b is a real parameter measuring the \"bit excess\" of the limbs.\n            // Precomputation: 64-bit multiply by 19.\n            //\n            // This fits into a u64 whenever 51 + b + lg(19) < 64.\n            //\n            // Since 51 + b + lg(19) < 51 + 4.25 + b\n            //                       = 55.25 + b,\n            // this fits if b < 8.75.\n            let a3_19 = 19 * a[3];\n            let a4_19 = 19 * a[4];\n\n            // Multiply to get 128-bit coefficients of output.\n            //\n            // The 128-bit multiplications by 2 turn into 1 slr + 1 slrd each,\n            // which doesn't seem any better or worse than doing them as precomputations\n            // on the 64-bit inputs.\n            let c0: u128 = m(a[0], a[0]) + 2 * (m(a[1], a4_19) + m(a[2], a3_19));\n            let mut c1: u128 = m(a[3], a3_19) + 2 * (m(a[0], a[1]) + m(a[2], a4_19));\n            let mut c2: u128 = m(a[1], a[1]) + 2 * (m(a[0], a[2]) + m(a[4], a3_19));\n            let mut c3: u128 = m(a[4], a4_19) + 2 * (m(a[0], a[3]) + m(a[1], a[2]));\n            let mut c4: u128 = m(a[2], a[2]) + 2 * (m(a[0], a[4]) + m(a[1], a[3]));\n\n            // Same bound as in multiply:\n            //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n            //         < 2^(102 + lg(1 + 4*19) + 2*b)\n            //         < 2^(108.27 + 2*b)\n            //\n            // The carry (c[i] >> 51) fits into a u64 when\n            //    108.27 + 2*b - 51 < 64\n            //    2*b < 6.73\n            //    b < 3.365.\n            //\n            // So we require b < 3 to ensure this fits.\n            #[cfg(not(verus_keep_ghost))]\n            {\n                debug_assert!(a[0] < (1 << 54));\n                debug_assert!(a[1] < (1 << 54));\n                debug_assert!(a[2] < (1 << 54));\n                debug_assert!(a[3] < (1 << 54));\n                debug_assert!(a[4] < (1 << 54));\n            }\n\n            // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n\n            // Casting to u64 and back tells the compiler that the carry is bounded by 2^64, so\n            // that the addition is a u128 + u64 rather than u128 + u128.\n            c1 += ((c0 >> 51) as u64) as u128;\n            a[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n            c2 += ((c1 >> 51) as u64) as u128;\n            a[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n            c3 += ((c2 >> 51) as u64) as u128;\n            a[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n            c4 += ((c3 >> 51) as u64) as u128;\n            a[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n            let carry: u64 = (c4 >> 51) as u64;\n            a[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n            // To see that this does not overflow, we need a[0] + carry * 19 < 2^64.\n            //\n            // c4 < a2^2 + 2*a0*a4 + 2*a1*a3 + (carry from c3)\n            //    < 2^(102 + 2*b + lg(5)) + 2^64.\n            //\n            // When b < 3 we get\n            //\n            // c4 < 2^110.33  so that carry < 2^59.33\n            //\n            // so that\n            //\n            // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n            //\n            // and there is no overflow.\n            a[0] += carry * 19;\n\n            // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n            a[1] += a[0] >> 51;\n            a[0] &= LOW_51_BIT_MASK;\n\n            // Now all a[i] < 2^(51 + epsilon) < 2^52 and a = self^(2^k).\n            proof {\n                // After masking and carry propagation:\n                // a[0] is masked to 51 bits: a[0] < 2^51 < 2^52\n                // a[2], a[3], a[4] were masked earlier, so < 2^51 < 2^52\n                // a[1] < 2^51 + 2^13 < 2^52 (from old masked value + carry)\n                // GAP: proving these bounds requires tracking mask effects through the loop\n                // TODO:\n                assume(forall|j: int| 0 <= j < 5 ==> a[j] < (1u64 << 52));\n            }\n\n            k -= 1;\n            if k == 0 {\n                break ;\n            }\n        }\n\n        FieldElement51 { limbs: a }\n    }",
      "start_line": 1126,
      "end_line": 17,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/factorial().",
      "display_name": "factorial",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/factorial().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub open spec fn factorial(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        1\n    } else {\n        n * factorial((n - 1) as nat)\n    }\n}",
      "start_line": 221,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_sqrt_m1_squared().",
      "display_name": "axiom_sqrt_m1_squared",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_sqrt_m1_squared().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "file_name": "sqrt_ratio_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn axiom_sqrt_m1_squared()\n    ensures (spec_sqrt_m1() * spec_sqrt_m1()) % p() == (p() - 1),\n{\n    admit();\n}",
      "start_line": 78,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "display_name": "optional_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<RistrettoPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<RistrettoPoint>>,\n    {\n        let extended_points = points.into_iter().map(|opt_P| opt_P.map(|P| P.0));\n\n        EdwardsPoint::optional_multiscalar_mul(scalars, extended_points).map(RistrettoPoint)\n    }",
      "start_line": 996,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_multiply_by_base_power_addition().",
      "display_name": "lemma_multiply_by_base_power_addition",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_multiply_by_base_power_addition().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/invert_lemmas.rs",
      "file_name": "invert_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_multiply_by_base_power_addition(\n    x: nat,\n    self_fe: &FieldElement51,\n    t21: &FieldElement51,\n)\n    requires\n        x == spec_field_element(self_fe),\n        spec_field_element(t21) == (pow(x as int, (p() - 2) as nat) as nat) % p(),\n    ensures\n        (spec_field_element(t21) * x) % p() == (pow(x as int, (p() - 1) as nat) as nat) % p(),\n{\n    // First, show that x == (pow(x, 1) as nat) % p()\n    // This holds because x = spec_field_element(self_fe) is already reduced: x < p()\n    assert(x == (pow(x as int, 1) as nat) % p()) by {\n        // pow(x, 1) = x\n        assert(pow(x as int, 1) == x) by {\n            lemma_pow1(x as int);\n        }\n\n        // Since x < p() (from spec_field_element definition), we have x % p() = x\n        assert(x < p()) by {\n            // spec_field_element(fe) = spec_field_element_as_nat(fe) % p()\n            // By the fundamental property of modulo, any value n % m is in the range [0, m)\n            assert(p() > 0) by {\n                pow255_gt_19();\n            }\n            lemma_mod_bound(spec_field_element_as_nat(self_fe) as int, p() as int);\n        }\n\n        // For any n < m, we have n % m = n\n        assert(x % p() == x) by {\n            lemma_small_mod(x, p());\n        }\n    }\n\n    // Prove p() > 2 (required for valid exponent p-2)\n    assert(p() > 2) by {\n        p_gt_2();\n    }\n\n    // Apply modular power addition: (x^(p-2) % p) * (x^1 % p) % p == x^(p-1) % p\n    assert((spec_field_element(t21) * x) % p() == (pow(x as int, (p() - 1) as nat) as nat) % p())\n        by {\n        // spec_field_element(t21) == (pow(x, p-2) as nat) % p() (from requires)\n        // x == (pow(x, 1) as nat) % p() (proven above)\n        // Therefore: t21 * x == ((pow(x, p-2) as nat) % p()) * ((pow(x, 1) as nat) % p())\n        // Simplify the exponent: (p - 2) + 1 = p - 1\n        assert(((p() - 2) + 1) as nat == (p() - 1) as nat);\n\n        // Apply lemma_modular_power_addition\n        lemma_modular_power_addition(x, (p() - 2) as nat, 1, p());\n    }\n}",
      "start_line": 232,
      "end_line": 51,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/Mul#mul().",
      "display_name": "mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/Mul#mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn mul(self, basepoint_table: &'a RistrettoBasepointTable) -> RistrettoPoint {\n        RistrettoPoint(self * &basepoint_table.0)\n    }",
      "start_line": 1096,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "display_name": "bytes_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn bytes_to_nat(bytes: &[u8; 32]) -> nat {\n    u8_32_as_nat(bytes)\n}",
      "start_line": 64,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 29,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_identity_edwards_point().",
      "display_name": "is_identity_edwards_point",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_identity_edwards_point().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_identity_edwards_point(point: crate::edwards::EdwardsPoint) -> bool {\n    let x = spec_field_element(&point.X);\n    let y = spec_field_element(&point.Y);\n    let z = spec_field_element(&point.Z);\n\n    z != 0 && x == 0 && y == z\n}",
      "start_line": 205,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_diff_factor().",
      "display_name": "lemma_mod_diff_factor",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_diff_factor().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_mod_diff_factor(a: int, b: int, m: int)\n    requires\n        m > 0,\n    ensures\n        (b - a * m) % m == b % m,\n{\n    // (b - a * m) % m == (b % m - (a * m) % m) % m\n    lemma_sub_mod_noop(b, a * m, m);\n    // (a * m) % m == 0\n    lemma_mod_multiples_basic(a, m);\n    // b % m % m = b % m\n    lemma_mod_twice(b, m);\n}",
      "start_line": 56,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_even().",
      "display_name": "lemma_pow2_even",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_even().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_even(n: nat)\n    requires\n        n >= 1,\n    ensures\n        pow2(n) % 2 == 0,\n    decreases n,\n{\n    if n == 1 {\n        assert(pow2(1) == 2) by {\n            lemma2_to64();\n        };\n        assert(2int % 2int == 0) by { lemma_mod_self_0(2) };\n    } else {\n        let m = (n - 1) as nat;\n        lemma_pow2_adds(1, m);\n        assert(pow2(n) == pow2(1) * pow2(m));\n        assert(pow2(1) == 2) by { lemma2_to64() };\n\n        lemma_mul_mod_noop_right(2 as int, pow2(m) as int, 2 as int);\n\n        lemma_pow2_even(m);\n\n        assert((2 * (pow2(m) as int % 2)) % 2 == 0);\n        assert(pow2(n) as int % 2 == 0);\n    }\n}",
      "start_line": 805,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo proptest 1.9.0 array/uniform5().",
      "display_name": "uniform5",
      "symbol": "rust-analyzer cargo proptest 1.9.0 array/uniform5().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_is_ordered_by_denominator().",
      "display_name": "lemma_div_is_ordered_by_denominator",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_is_ordered_by_denominator().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_spec_load8_at_fits_u64().",
      "display_name": "lemma_spec_load8_at_fits_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_spec_load8_at_fits_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_spec_load8_at_fits_u64(input: &[u8], i: usize)\n    requires\n        i + 7 < input.len(),\n    ensures\n        spec_load8_at(input, i) <= u64::MAX,\n{\n    lemma_load8_at_plus_version_is_spec(input, i);\n    lemma_load8_at_plus_fits_u64(input, i, 7);\n}",
      "start_line": 290,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "display_name": "mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn mul(self, _rhs: &'b Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n    {\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) == to_nat(&result_unpacked.limbs) % pow2(256))\n                by {\n                assert(group_order() < pow2(256)) by {\n                    lemma_group_order_bound();\n                    lemma_pow2_strictly_increases(255, 256);\n                }\n                lemma_small_mod(to_nat(&result_unpacked.limbs), pow2(256));\n            }\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n            * bytes_to_nat(&_rhs.bytes)) % group_order());\n        /* </MODIFIED CODE> */\n        /* <ORIGINAL CODE>\n         let result = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n\n        result\n    }",
      "start_line": 551,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base_clamped().",
      "display_name": "mul_base_clamped",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base_clamped().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_base_clamped(bytes: [u8; 32]) -> (result: Self)\n        ensures\n            is_well_formed_edwards_point(result),\n            // Functional correctness: result = [clamped_scalar] * B where B is the basepoint\n            edwards_point_as_affine(result) == edwards_scalar_mul(\n                spec_ed25519_basepoint(),\n                spec_scalar(&Scalar { bytes: spec_clamp_integer(bytes) }),\n            ),",
      "start_line": 1775,
      "end_line": 28,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#is_canonical().",
      "display_name": "is_canonical",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#is_canonical().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn is_canonical(&self) -> (result: Choice)\n        ensures\n    // Result is true iff the scalar satisfies Scalar invariants #1 and #2\n\n            choice_is_true(result) == is_canonical_scalar(self),\n    {\n        let x = &self.reduce();\n        let result = self.ct_eq(x);\n\n        proof {\n            lemma_is_canonical_correctness(&self.bytes, &x.bytes);\n        }\n        result\n    }",
      "start_line": 2608,
      "end_line": 20,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_u64_max_shifting().",
      "display_name": "lemma_u64_max_shifting",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_u64_max_shifting().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_u64_max_shifting(k: nat)\n    requires\n        1 <= k < 64,\n    ensures\n        u64::MAX >> k < 1u64 << (64 - k),\n    decreases 64 - k,\n{\n    let M = u64::MAX;\n\n    // recursion base case\n    if (k == 63) {\n        assert(u64::MAX >> 63 < 1u64 << 1) by (compute);\n    } else {\n        // M >> (k + 1) < 1 << (63 - k)\n        lemma_u64_max_shifting(k + 1);\n\n        // M >> (k + 1) = (M >> k) >> 1\n        lemma_shr_by_sum(M, k, 1);\n\n        // precondition\n        lemma2_to64_rest();  // pow2(63)\n        lemma_pow2_strictly_increases((63 - k) as nat, (64 - k) as nat);\n\n        assert(1u64 * pow2((64 - k) as nat) <= 1u64 * pow2(63)) by {\n            if (k == 1) {\n                // 64 - k = 63\n                // tautology\n            } else {\n                // 64 - k < 63\n                lemma_pow2_strictly_increases((64 - k) as nat, 63);\n            }\n            lemma_mul_le(1u64 as nat, 1u64 as nat, pow2((64 - k) as nat), pow2(63));\n        }\n        assert(1u64 * pow2(63) <= u64::MAX) by (compute);\n\n        // 1 << 64 - k = (1 << 63 - k) << 1\n        lemma_shl_by_sum(1u64, (63 - k) as nat, 1);\n\n        // (M >> k) >> 1 = (M >> k) / pow2(1);\n        lemma_u64_shr_is_div(M >> k, 1);\n\n        // lemma_u64_shl_is_mul(x, n) precondition: x * pow2(n) <= u64::MAX\n        assert((1u64 << ((63 - k))) * pow2(1) <= u64::MAX) by {\n            lemma_shift_is_pow2((63 - k) as nat);\n            lemma_pow2_adds((63 - k) as nat, 1);\n        }\n\n        // (1 << 63 - k) << 1 = (1 << 63 - k) * pow2(1);\n        lemma_u64_shl_is_mul(1u64 << ((63 - k)), 1);\n\n        lemma2_to64();  // pow2(1) = 2\n\n        assert((1u64 << ((64 - k) as u64)) / 2 == (1u64 << ((63 - k) as u64))) by {\n            lemma_div_multiples_vanish((1u64 << (63 - k) as u64) as int, 2);\n        }\n    }\n}",
      "start_line": 205,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_cancellation_mod_prime().",
      "display_name": "lemma_cancellation_mod_prime",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_cancellation_mod_prime().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "proof fn lemma_cancellation_mod_prime(a: nat, b: nat, prime: nat)\n    requires\n        is_prime(prime),\n        (a * b) % prime == b % prime,\n        b % prime != 0,\n    ensures\n        a % prime == 1,\n{\n    // a * b ≡ b (mod p)\n    // a * b - b ≡ 0 (mod p)\n    // (a - 1) * b ≡ 0 (mod p)\n    // Since p is prime and b % p != 0, by Euclid's lemma: (a - 1) % p == 0\n    // So a ≡ 1 (mod p)\n    if a == 0 {\n        // 0 * b = 0 ≡ b (mod p) means b % p == 0, contradiction\n        assert((a * b) % prime == 0) by {\n            lemma_mul_basics(b as int);\n            lemma_small_mod(0nat, prime);\n        };\n        assert(b % prime == 0);\n    }\n    // (a * b - b) % prime == 0\n    // We need a >= 1 for a * b >= b when b > 0\n\n    assert(a >= 1);\n\n    // (a - 1) * b = a * b - b\n    assert((a - 1) * b == a * b - b) by {\n        lemma_mul_is_distributive_sub_other_way(b as int, a as int, 1);\n    };\n\n    // ((a - 1) * b) % prime == 0\n    if a == 1 {\n        // Done: a % prime == 1 % prime == 1 (since prime > 1)\n        lemma_small_mod(1nat, prime);\n    } else {\n        // a > 1\n        // b > 0 because b % prime != 0\n        // If b == 0, then b % prime == 0 (since 0 % anything == 0)\n        assert(b > 0) by {\n            if b == 0 {\n                lemma_small_mod(0nat, prime);\n                // 0 % prime == 0, but we have b % prime != 0, contradiction\n            }\n        };\n\n        assert(a * b >= b) by {\n            // a >= 1 and b > 0, so a * b >= 1 * b = b\n            lemma_mul_increases(a as int, b as int);\n            // gives b <= a * b\n        };\n\n        lemma_mod_sub_eq(a * b, b, prime);\n        assert(((a * b - b) as nat) % prime == 0);\n        assert((((a - 1) as nat) * b) % prime == 0);\n\n        // By Euclid's lemma: (a - 1) % prime == 0 or b % prime == 0\n        lemma_euclid_prime((a - 1) as nat, b, prime);\n        // b % prime != 0, so (a - 1) % prime == 0\n\n        assert(((a - 1) as nat) % prime == 0);\n        // a = (a - 1) + 1\n        // a % prime = ((a - 1) + 1) % prime = (0 + 1) % prime = 1\n        assert(a % prime == 1) by {\n            lemma_mod_adds((a - 1) as int, 1, prime as int);\n            lemma_small_mod(1nat, prime);\n        };\n    }\n}",
      "start_line": 1617,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/Neg#neg().",
      "display_name": "neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/Neg#neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn neg(self) -> RistrettoPoint {\n        RistrettoPoint(-&self.0)\n    }",
      "start_line": 909,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "display_name": "p_gt_2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub proof fn p_gt_2()\n    ensures\n        p() > 2,\n        (p() - 2) > 0,\n{\n    lemma2_to64();  // 2^5 = 32\n    lemma_pow2_strictly_increases(5, 255);  // 2^255 > 2^5 = 32\n}",
      "start_line": 29,
      "end_line": 20,
      "is_libsignal": false,
      "caller_count": 26,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_direct().",
      "display_name": "lemma_radix51_telescoping_direct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_direct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_radix51_telescoping_direct(\n    limbs: [u64; 5],\n    q0: int,\n    q1: int,\n    q2: int,\n    q3: int,\n    q4: int,\n    r0: int,\n    r1: int,\n    r2: int,\n    r3: int,\n    r4: int,\n)\n    requires\n        limbs[0] as int + 19 == q0 * pow2(51) as int + r0,\n        limbs[1] as int + q0 == q1 * pow2(51) as int + r1,\n        limbs[2] as int + q1 == q2 * pow2(51) as int + r2,\n        limbs[3] as int + q2 == q3 * pow2(51) as int + r3,\n        limbs[4] as int + q3 == q4 * pow2(51) as int + r4,\n        0 <= r0 < pow2(51) as int,\n        0 <= r1 < pow2(51) as int,\n        0 <= r2 < pow2(51) as int,\n        0 <= r3 < pow2(51) as int,\n        0 <= r4 < pow2(51) as int,\n    ensures\n        q4 == (u64_5_as_nat(limbs) as int + 19) / pow2(255) as int,\n{\n    // Establish power-of-2 relationships: 2^51 * 2^k = 2^(51+k)\n    lemma_pow2_pos(51);\n    lemma_pow2_adds(51, 51);\n    lemma_pow2_adds(51, 102);\n    lemma_pow2_adds(51, 153);\n    lemma_pow2_adds(51, 204);\n\n    // Step 1: Express value = u64_5_as_nat(limbs) + 19 in radix-51 form\n    let value = limbs[0] as int + limbs[1] as int * pow2(51) as int + limbs[2] as int * pow2(\n        102,\n    ) as int + limbs[3] as int * pow2(153) as int + limbs[4] as int * pow2(204) as int + 19;\n\n    assert(u64_5_as_nat(limbs) == (limbs[0] as nat) + pow2(51) * (limbs[1] as nat) + pow2(102) * (\n    limbs[2] as nat) + pow2(153) * (limbs[3] as nat) + pow2(204) * (limbs[4] as nat));\n\n    assert((limbs[0] as nat) + pow2(51) * (limbs[1] as nat) + pow2(102) * (limbs[2] as nat) + pow2(\n        153,\n    ) * (limbs[3] as nat) + pow2(204) * (limbs[4] as nat) == limbs[0] as nat + (limbs[1] as nat)\n        * pow2(51) + (limbs[2] as nat) * pow2(102) + (limbs[3] as nat) * pow2(153) + (\n    limbs[4] as nat) * pow2(204)) by {\n        lemma_mul_is_commutative(pow2(51) as int, limbs[1] as int);\n        lemma_mul_is_commutative(pow2(102) as int, limbs[2] as int);\n        lemma_mul_is_commutative(pow2(153) as int, limbs[3] as int);\n        lemma_mul_is_commutative(pow2(204) as int, limbs[4] as int);\n    }\n\n    // Step 2: Solve for each limb using the division theorem equations\n\n    // Step 3: Expand limbs[i] * 2^(51*i) using distributivity\n    assert((q1 * pow2(51) as int + r1 - q0) * pow2(51) as int == q1 * pow2(51) as int * pow2(\n        51,\n    ) as int + r1 * pow2(51) as int - q0 * pow2(51) as int) by {\n        lemma_mul_is_distributive_sub_other_way(pow2(51) as int, q1 * pow2(51) as int + r1, q0);\n        lemma_mul_is_distributive_add_other_way(pow2(51) as int, q1 * pow2(51) as int, r1);\n    }\n\n    assert((q2 * pow2(51) as int + r2 - q1) * pow2(102) as int == q2 * pow2(51) as int * pow2(\n        102,\n    ) as int + r2 * pow2(102) as int - q1 * pow2(102) as int) by {\n        lemma_mul_is_distributive_sub_other_way(pow2(102) as int, q2 * pow2(51) as int + r2, q1);\n        lemma_mul_is_distributive_add_other_way(pow2(102) as int, q2 * pow2(51) as int, r2);\n    }\n\n    assert((q3 * pow2(51) as int + r3 - q2) * pow2(153) as int == q3 * pow2(51) as int * pow2(\n        153,\n    ) as int + r3 * pow2(153) as int - q2 * pow2(153) as int) by {\n        lemma_mul_is_distributive_sub_other_way(pow2(153) as int, q3 * pow2(51) as int + r3, q2);\n        lemma_mul_is_distributive_add_other_way(pow2(153) as int, q3 * pow2(51) as int, r3);\n    }\n\n    assert((q4 * pow2(51) as int + r4 - q3) * pow2(204) as int == q4 * pow2(51) as int * pow2(\n        204,\n    ) as int + r4 * pow2(204) as int - q3 * pow2(204) as int) by {\n        lemma_mul_is_distributive_sub_other_way(pow2(204) as int, q4 * pow2(51) as int + r4, q3);\n        lemma_mul_is_distributive_add_other_way(pow2(204) as int, q4 * pow2(51) as int, r4);\n    }\n\n    // Step 4: Define remainder and observe telescoping\n    // When we substitute and expand, intermediate q_i terms cancel, leaving only q4 and remainders\n    let remainder = r0 + r1 * pow2(51) as int + r2 * pow2(102) as int + r3 * pow2(153) as int + r4\n        * pow2(204) as int;\n\n    assert(limbs[0] as int + limbs[1] as int * pow2(51) as int + limbs[2] as int * pow2(102) as int\n        + limbs[3] as int * pow2(153) as int + limbs[4] as int * pow2(204) as int + 19 == (q0\n        * pow2(51) as int + r0 - 19) + (q1 * pow2(51) as int + r1 - q0) * pow2(51) as int + (q2\n        * pow2(51) as int + r2 - q1) * pow2(102) as int + (q3 * pow2(51) as int + r3 - q2) * pow2(\n        153,\n    ) as int + (q4 * pow2(51) as int + r4 - q3) * pow2(204) as int + 19);\n\n    // After algebraic simplification (intermediate terms cancel), we get: value = q4 * 2^255 + remainder\n    lemma_radix51_telescoping_expansion(q0, q1, q2, q3, q4, r0, r1, r2, r3, r4);\n\n    assert(q4 * pow2(51) as int * pow2(204) as int == q4 * pow2(255) as int) by {\n        lemma_mul_is_associative(q4, pow2(51) as int, pow2(204) as int);\n    }\n\n    // Step 5: Apply uniqueness of division to conclude q4 = value / 2^255\n    lemma_radix51_remainder_bound(r0, r1, r2, r3, r4);\n    lemma_pow2_pos(255);\n    lemma_fundamental_div_mod(value, pow2(255) as int);\n    lemma_div_multiples_vanish_fancy(q4, remainder, pow2(255) as int);\n}",
      "start_line": 138,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 12
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "display_name": "iter",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 9,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo proptest 1.9.0 config/test_runner/Config#with_cases().",
      "display_name": "with_cases",
      "symbol": "rust-analyzer cargo proptest 1.9.0 config/test_runner/Config#with_cases().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "display_name": "lemma2_to64",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 78,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "display_name": "conditional_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }",
      "start_line": 730,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 9,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "display_name": "conditional_select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }",
      "start_line": 661,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c1_0_val().",
      "display_name": "c1_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c1_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn c1_0_val(a: [u64; 5]) -> u128 {\n    (a[3] * (19 * a[3]) + 2 * (a[0] * a[1] + a[2] * (19 * a[4]))) as u128\n}",
      "start_line": 40,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "backend",
      "body": "    pub fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: core::borrow::Borrow<EdwardsPoint>,\n    {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match get_selected_backend() {\n            // #[cfg(curve25519_dalek_backend = \"simd\")]\n            // BackendKind::Avx2 =>\n            //     VartimePrecomputedStraus::Avx2(vector::scalar_mul::precomputed_straus::spec_avx2::VartimePrecomputedStraus::new(static_points)),\n            // #[cfg(all(curve25519_dalek_backend = \"simd\", nightly))]\n            // BackendKind::Avx512 =>\n            //     VartimePrecomputedStraus::Avx512ifma(vector::scalar_mul::precomputed_straus::spec_avx512ifma_avx512vl::VartimePrecomputedStraus::new(static_points)),\n            BackendKind::Serial => VartimePrecomputedStraus::Scalar(\n                serial::scalar_mul::precomputed_straus::VartimePrecomputedStraus::new(\n                    static_points,\n                ),\n            ),\n        }\n    }",
      "start_line": 126,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#PartialEq#eq().",
      "display_name": "eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#PartialEq#eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn eq(&self, other: &Self) -> (result: bool)\n        ensures\n            result == (self.bytes == other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Choice::into\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let result = self.ct_eq(other).into();\n         </ORIGINAL CODE> */\n        let choice = self.ct_eq(other);\n        assert(choice_is_true(choice) == (self.bytes == other.bytes));\n        let result = choice_into(choice);\n        assert(result == choice_is_true(choice));\n        assert(result == (self.bytes == other.bytes));\n\n        result\n    }",
      "start_line": 413,
      "end_line": 10,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from2().",
      "display_name": "seq_from2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub open spec fn seq_from2(b: &[u8; 2]) -> Seq<u8> {\n    Seq::new(2, |i: int| b[i])\n}",
      "start_line": 66,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#as_bytes().",
      "display_name": "as_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#as_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
      "start_line": 233,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "display_name": "proof_negate",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/negate_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/negate_lemmas.rs",
      "file_name": "negate_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn proof_negate(limbs: [u64; 5])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51),\n        all_neg_limbs_positive(limbs),\n    ensures\n        forall|i: int| 0 <= i < 5 ==> spec_negate(limbs)[i] < (1u64 << 52),\n        // Assume we start with l = (l0, l1, l2, l3, l4).\n        // Using c0 = 2^51 - 19 and c = 2^51 - 1, we can see that\n        // ( 36028797018963664u64 - l0,\n        //   36028797018963952u64 - l1,\n        //   36028797018963952u64 - l2,\n        //   36028797018963952u64 - l3,\n        //   36028797018963952u64 - l4 )\n        // is just 16 * (c0, c, c, c, c) - l (in vector notation)\n        // Further, u64_5_as_nat((c0, c, c, c, c)) = p, so\n        // u64_5_as_nat(16 * (c0, c, c, c, c) - l) is 16p - u64_5_as_nat(l)\n        // We know u64_5_as_nat(reduce(v)) = u64_5_as_nat(v) - p * (v4 >> 51) for any v.\n        // This gives us the identity\n        // u64_5_as_nat(negate(l)) = u64_5_as_nat(reduce(16 * (c0, c, c, c, c) - l))\n        //                   = 16p - u64_5_as_nat(l) - p * ((16c - l4) >> 51)\n        // Note that (16c - l4) >> 51 is either 14 or 15, in either case < 16.\n        u64_5_as_nat(spec_negate(limbs)) == 16 * p() - u64_5_as_nat(limbs) - p() * ((\n        36028797018963952u64 - limbs[4]) as u64 >> 51),\n        (u64_5_as_nat(spec_negate(limbs)) + u64_5_as_nat(limbs)) % p() == 0,\n{\n    proof_reduce(pre_reduce_limbs(limbs));\n\n    let c0 = (pow2(51) - 19);\n    let c = (pow2(51) - 1);\n    lemma2_to64_rest();  // get pow2(51)\n    // solver knows 36028797018963664u64 == 16 * c0\n    // solver knows 36028797018963952u64 == 16 * c;\n\n    lemma_neg_no_underflow(limbs);\n\n    // Introduce 16p as a vector\n    let v = [(16 * c0) as u64, (16 * c) as u64, (16 * c) as u64, (16 * c) as u64, (16 * c) as u64];\n\n    assert(u64_5_as_nat(v) == 16 * p()) by {\n        // by definition of u64_5_as_nat\n        assert(u64_5_as_nat(v) == 16 * c0 + pow2(51) * (16 * c) + pow2(102) * (16 * c) + pow2(153)\n            * (16 * c) + pow2(204) * (16 * c));\n\n        // solver can reorder factors and pull out 16 on its own\n        // ...\n\n        // Write out `c`s and sum up powers\n        assert(p() == c0 + pow2(51) * c + pow2(102) * c + pow2(153) * c + pow2(204) * c) by {\n            lemma_pow2_adds(51, 51);\n            lemma_pow2_adds(51, 102);\n            lemma_pow2_adds(51, 153);\n            lemma_pow2_adds(51, 204);\n        }\n    }\n\n    let l0 = limbs[0];\n    let l1 = limbs[1];\n    let l2 = limbs[2];\n    let l3 = limbs[3];\n    let l4 = limbs[4];\n\n    assert(u64_5_as_nat(\n        [\n            (16 * c0 - l0) as u64,\n            (16 * c - l1) as u64,\n            (16 * c - l2) as u64,\n            (16 * c - l3) as u64,\n            (16 * c - l4) as u64,\n        ],\n    ) == u64_5_as_nat(v) - u64_5_as_nat(limbs)) by {\n        lemma_u64_5_as_nat_sub(v, limbs);\n    }\n\n    let k = (16 * c - l4) as u64 >> 51;\n\n    assert(16 * p() - u64_5_as_nat(limbs) - p() * k + u64_5_as_nat(limbs) == p() * (16 - k)) by {\n        lemma_mul_is_distributive_sub(p() as int, 16, k as int)\n    }\n\n    assert((p() * (16 - k)) as nat % p() == 0) by {\n        assert(k <= 16) by {\n            assert(k <= (16 * pow2(51)) as u64 >> 51) by {\n                lemma_shr_le_u64((16 * c - l4) as u64, (16 * pow2(51)) as u64, 51);\n            }\n            // 16 * 2^51 / 2^51 = 16\n            assert(((16 * 0x8000000000000) as u64 >> 51) == 16) by (compute);\n        }\n        lemma_mod_multiples_basic((16 - k) as int, p() as int);\n    }\n}",
      "start_line": 39,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "display_name": "lemma_mul_is_associative",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "is_libsignal": false,
      "caller_count": 51,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_lemmas/lemmas/lemma_sum_bounds().",
      "display_name": "lemma_sum_bounds",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_lemmas/lemmas/lemma_sum_bounds().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/sum_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/sum_lemmas.rs",
      "file_name": "sum_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_sum_bounds(coefs: Seq<nat>, k: nat, s: nat)\n    requires\n        k <= coefs.len(),\n        forall|i: nat|\n            0 <= i <= k ==> #[trigger] coefs[i as int] <= pow2((i + 1) * s) - pow2(i * s),\n    ensures\n        seq_sum(coefs, k) <= pow2((k + 1) * s) - 1,\n    decreases k,\n{\n    if (k == 0) {\n        assert(pow2(0) == 1) by {\n            lemma2_to64();\n        }\n    } else {\n        assert(seq_sum(coefs, k) == seq_sum(coefs, (k - 1) as nat) + coefs[k as int]) by {\n            reveal_with_fuel(seq_sum, 1);\n        }\n\n        assert(seq_sum(coefs, (k - 1) as nat) <= pow2(k * s) - 1) by {\n            lemma_sum_bounds(coefs, (k - 1) as nat, s);\n        }\n\n        // \"requires\" for i = k\n        assert(coefs[k as int] <= pow2((k + 1) * s) - pow2(k * s));\n\n        assert((pow2((k + 1) * s) - pow2(k * s)) + (pow2(k * s) - 1) == pow2((k + 1) * s) - 1) by {\n            assert(pow2((k + 1) * s) >= pow2(k * s)) by {\n                if (s > 0) {\n                    assert((k + 1) * s == k * s + s) by {\n                        lemma_mul_is_distributive_add_other_way(s as int, k as int, 1);\n                    }\n                    lemma_pow2_strictly_increases(k * s, (k + 1nat) * s);\n                }\n            }\n\n            assert(pow2((k + 1) * s) >= 1) by {\n                assert(1 == pow2(0)) by {\n                    lemma2_to64();\n                }\n                if (s > 0) {\n                    assert(0 < (k + 1) * s) by {\n                        lemma_mul_strictly_positive((k + 1) as int, s as int);\n                    }\n                    lemma_pow2_strictly_increases(0, (k + 1nat) * s);\n                }\n            }\n        }\n    }\n}",
      "start_line": 28,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_divides_both().",
      "display_name": "lemma_gcd_divides_both",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_divides_both().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_gcd_divides_both(a: nat, b: nat)\n    ensures\n        a % spec_gcd(a, b) == 0 || spec_gcd(a, b) == 0,\n        b % spec_gcd(a, b) == 0 || spec_gcd(a, b) == 0,\n    decreases b,\n{\n    let g = spec_gcd(a, b);\n\n    if b == 0 {\n        if a > 0 {\n            lemma_mod_self_0(a as int);\n        }\n    } else {\n        let r = a % b;\n        lemma_gcd_divides_both(b, r);\n\n        if g > 0 {\n            lemma_fundamental_div_mod(a as int, b as int);\n            lemma_divides_linear_combo(r, b, a / b, g);\n            assert((r + (a / b) * b) == a) by {\n                lemma_mul_is_commutative((a / b) as int, b as int);\n            };\n        }\n    }\n}",
      "start_line": 79,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits_warning().",
      "display_name": "determine_curve25519_dalek_bits_warning",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits_warning().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "curve25519-dalek/build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "body": "    fn determine_curve25519_dalek_bits_warning(cause: &str) {\n        println!(\"cargo:warning=\\\"Defaulting to curve25519_dalek_bits=32: {cause}\\\"\");\n    }",
      "start_line": 93,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_sum_equals_byte_nat_52().",
      "display_name": "lemma_sum_equals_byte_nat_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_sum_equals_byte_nat_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub proof fn lemma_sum_equals_byte_nat_52(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 52),\n        bytes_match_limbs_packing_52(limbs, bytes),\n    ensures\n        limb0_byte_contribution_52(limbs, bytes) + limb1_byte_contribution_52(limbs, bytes)\n            + limb2_byte_contribution_52(limbs, bytes) + limb3_byte_contribution_52(limbs, bytes)\n            + limb4_byte_contribution_52(limbs, bytes) == u8_32_as_nat(&bytes),\n{\n    // The sum lemma is actually straightforward because u8_32_as_nat\n    // is just the sum of all bytes weighted by their positions, and the\n    // limb contribution functions partition this sum.\n    //\n    // Limb 0 contributes: bytes[0-5] fully + low 4 bits of byte 6\n    // Limb 1 contributes: high 4 bits of byte 6 + bytes[7-12] fully\n    // Limb 2 contributes: bytes[13-18] fully + low 4 bits of byte 19\n    // Limb 3 contributes: high 4 bits of byte 19 + bytes[20-25] fully\n    // Limb 4 contributes: bytes[26-31] fully\n    //\n    // When we add these up, each byte is counted exactly once, and the\n    // boundary bytes (6 and 19) are correctly split between adjacent limbs.\n    //\n    // The proof follows by expanding the definitions and grouping terms.\n    lemma2_to64();\n    lemma_shift_is_pow2(52);\n\n    // Prove limbs are bounded by pow2(52)\n    assert(forall|i: int| 0 <= i < 5 ==> limbs[i] < pow2(52)) by {\n        assert((1u64 << 52) == pow2(52)) by {\n            lemma_shift_is_pow2(52);\n        }\n    }\n\n    // Key: at the boundaries (bytes 6 and 19), the limb contributions partition\n    // the byte value correctly using the predicate bytes_match_limbs_packing_52\n\n    // From the predicate, we know:\n    // bytes[6] == ((limbs[0] >> 48) | (limbs[1] << 4)) as u8\n    // bytes[19] == ((limbs[2] >> 48) | (limbs[3] << 4)) as u8\n\n    // This ensures that:\n    // - Limb 0's high 4 bits + Limb 1's low 4 bits = byte 6\n    // - Limb 2's high 4 bits + Limb 3's low 4 bits = byte 19\n\n    // Define the boundary byte splits\n    let byte6_low = ((limbs[0] as nat / pow2(48)) % 16) * pow2(6 * 8);\n    let byte6_high = ((limbs[1] as nat % pow2(4)) * 16) * pow2(6 * 8);\n\n    let byte19_low = ((limbs[2] as nat / pow2(48)) % 16) * pow2(19 * 8);\n    let byte19_high = ((limbs[3] as nat % pow2(4)) * 16) * pow2(19 * 8);\n\n    // Prove each boundary byte reconstruction using lemma_boundary_byte_combines_52\n    // Byte 6: lemma_boundary_byte_combines_52 proves bytes[6] == (limbs[0]/2^48)%16 + (limbs[1]%2^4)*16\n    assert(bytes[6] as nat == (limbs[0] as nat / pow2(48)) % 16 + (limbs[1] as nat % pow2(4)) * 16)\n        by {\n        lemma_boundary_byte_combines_52(limbs[0], limbs[1], bytes[6], 48, 4);\n    }\n    // Distributivity gives us: (a+b)*c == a*c + b*c\n    assert(bytes[6] as nat * pow2(6 * 8) == ((limbs[0] as nat / pow2(48)) % 16) * pow2(6 * 8) + ((\n    limbs[1] as nat % pow2(4)) * 16) * pow2(6 * 8)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(6 * 8) as int,\n            ((limbs[0] as nat / pow2(48)) % 16) as int,\n            ((limbs[1] as nat % pow2(4)) * 16) as int,\n        );\n    }\n    assert(bytes[6] as nat * pow2(6 * 8) == byte6_low + byte6_high);\n\n    // Byte 19: same pattern\n    assert(bytes[19] as nat == (limbs[2] as nat / pow2(48)) % 16 + (limbs[3] as nat % pow2(4)) * 16)\n        by {\n        lemma_boundary_byte_combines_52(limbs[2], limbs[3], bytes[19], 48, 4);\n    }\n    assert(bytes[19] as nat * pow2(19 * 8) == ((limbs[2] as nat / pow2(48)) % 16) * pow2(19 * 8) + (\n    (limbs[3] as nat % pow2(4)) * 16) * pow2(19 * 8)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(19 * 8) as int,\n            ((limbs[2] as nat / pow2(48)) % 16) as int,\n            ((limbs[3] as nat % pow2(4)) * 16) as int,\n        );\n    }\n    assert(bytes[19] as nat * pow2(19 * 8) == byte19_low + byte19_high);\n\n    // Construct the expression with split boundary bytes\n    let after_split = (bytes[0] as nat) + (bytes[1] as nat) * pow2(1 * 8) + (bytes[2] as nat)\n        * pow2(2 * 8) + (bytes[3] as nat) * pow2(3 * 8) + (bytes[4] as nat) * pow2(4 * 8) + (\n    bytes[5] as nat) * pow2(5 * 8) + byte6_low + byte6_high + (bytes[7] as nat) * pow2(7 * 8) + (\n    bytes[8] as nat) * pow2(8 * 8) + (bytes[9] as nat) * pow2(9 * 8) + (bytes[10] as nat) * pow2(\n        10 * 8,\n    ) + (bytes[11] as nat) * pow2(11 * 8) + (bytes[12] as nat) * pow2(12 * 8) + (bytes[13] as nat)\n        * pow2(13 * 8) + (bytes[14] as nat) * pow2(14 * 8) + (bytes[15] as nat) * pow2(15 * 8) + (\n    bytes[16] as nat) * pow2(16 * 8) + (bytes[17] as nat) * pow2(17 * 8) + (bytes[18] as nat)\n        * pow2(18 * 8) + byte19_low + byte19_high + (bytes[20] as nat) * pow2(20 * 8) + (\n    bytes[21] as nat) * pow2(21 * 8) + (bytes[22] as nat) * pow2(22 * 8) + (bytes[23] as nat)\n        * pow2(23 * 8) + (bytes[24] as nat) * pow2(24 * 8) + (bytes[25] as nat) * pow2(25 * 8) + (\n    bytes[26] as nat) * pow2(26 * 8) + (bytes[27] as nat) * pow2(27 * 8) + (bytes[28] as nat)\n        * pow2(28 * 8) + (bytes[29] as nat) * pow2(29 * 8) + (bytes[30] as nat) * pow2(30 * 8) + (\n    bytes[31] as nat) * pow2(31 * 8);\n\n    assert(bytes[0] as nat * pow2(0 * 8) == bytes[0] as nat * 1);\n    assert(after_split == u8_32_as_nat(&bytes));\n\n    // The mathematical fact: after splitting boundary bytes, this equals the sum of limb contributions\n    assert(after_split == limb0_byte_contribution_52(limbs, bytes) + limb1_byte_contribution_52(\n        limbs,\n        bytes,\n    ) + limb2_byte_contribution_52(limbs, bytes) + limb3_byte_contribution_52(limbs, bytes)\n        + limb4_byte_contribution_52(limbs, bytes));\n}",
      "start_line": 276,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 12
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Sub#sub().",
      "display_name": "sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Sub#sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn sub(self, other: &'b AffineNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PM = &Y_plus_X * &other.y_minus_x;\n        let MP = &Y_minus_X * &other.y_plus_x;\n        let Txy2d = &self.T * &other.xy2d;\n        let Z2 = &self.Z + &self.Z;\n\n        CompletedPoint {\n            X: &PM - &MP,\n            Y: &PM + &MP,\n            Z: &Z2 - &Txy2d,\n            T: &Z2 + &Txy2d,\n        }\n    }",
      "start_line": 818,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_bounded().",
      "display_name": "lemma_r_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_r_bounded(r: Scalar52)\n    requires\n        r == (Scalar52 {\n            limbs: [\n                0x000f48bd6721e6ed,\n                0x0003bab5ac67e45a,\n                0x000fffffeb35e51b,\n                0x000fffffffffffff,\n                0x00000fffffffffff,\n            ],\n        }),",
      "start_line": 1848,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective().",
      "display_name": "as_projective",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub(crate) const fn as_projective(&self) -> (result: ProjectivePoint)\n        requires\n            edwards_point_limbs_bounded(*self),\n        ensures\n            result.X == self.X,\n            result.Y == self.Y,\n            result.Z == self.Z,\n            fe51_limbs_bounded(&result.X, 54) && fe51_limbs_bounded(&result.Y, 54)\n                && fe51_limbs_bounded(&result.Z, 54),\n    {\n        let result = ProjectivePoint { X: self.X, Y: self.Y, Z: self.Z };\n        result\n    }",
      "start_line": 1125,
      "end_line": 38,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_breakdown().",
      "display_name": "lemma_mod_breakdown",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_breakdown().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "file_name": "u8_32_as_nat_injectivity_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_truncate_middle().",
      "display_name": "lemma_truncate_middle",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_truncate_middle().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_byte_shr_7_is_bit().",
      "display_name": "lemma_byte_shr_7_is_bit",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_byte_shr_7_is_bit().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "proof fn lemma_byte_shr_7_is_bit(b: u8)\n    ensures (b >> 7) == 0 || (b >> 7) == 1,\n{\n    assert((b >> 7) == 0 || (b >> 7) == 1) by (bit_vector);\n}",
      "start_line": 473,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_valid_naf().",
      "display_name": "is_valid_naf",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_valid_naf().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn is_valid_naf(naf: Seq<i8>, w: nat) -> bool {\n    forall|i: int|\n        0 <= i < naf.len() ==> {\n            let digit = (#[trigger] naf[i]) as int;\n            // Each nonzero digit is odd and within bound\n            (digit == 0 || (digit % 2 != 0 && -pow2((w - 1) as nat) < digit && digit < pow2(\n                (w - 1) as nat,\n            ))) &&\n            // At most one nonzero in any w consecutive digits\n            forall|j: int|\n                1 <= j < w && #[trigger] (i + j) < naf.len() ==> !(digit != 0 && (naf[#[trigger] (i\n                    + j)] as int) != 0)\n        }\n}",
      "start_line": 173,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_unmasked_limbs().",
      "display_name": "compute_unmasked_limbs",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_unmasked_limbs().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs_u64.rs",
      "file_name": "field_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn compute_unmasked_limbs(input_limbs: [u64; 5], q: u64) -> [u64; 5] {\n    let l0 = (input_limbs[0] + 19 * q) as u64;\n    let l1 = (input_limbs[1] + (l0 >> 51)) as u64;\n    let l2 = (input_limbs[2] + (l1 >> 51)) as u64;\n    let l3 = (input_limbs[3] + (l2 >> 51)) as u64;\n    let l4 = (input_limbs[4] + (l3 >> 51)) as u64;\n    [l0, l1, l2, l3, l4]\n}",
      "start_line": 144,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#unwrap().",
      "display_name": "unwrap",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#unwrap().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_low_limbs_encode_low_expr().",
      "display_name": "lemma_low_limbs_encode_low_expr",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_low_limbs_encode_low_expr().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "file_name": "scalar_lemmas_extra.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_low_limbs_encode_low_expr(lo: &[u64; 5], words: &[u64; 8], mask: u64)\n    requires\n        mask == (1u64 << 52) - 1u64,\n        lo[0] == words[0] & mask,\n        lo[1] == ((words[0] >> 52) | (words[1] << 12)) & mask,\n        lo[2] == ((words[1] >> 40) | (words[2] << 24)) & mask,\n        lo[3] == ((words[2] >> 28) | (words[3] << 36)) & mask,\n        lo[4] == ((words[3] >> 16) | (words[4] << 48)) & mask,\n    ensures\n        five_limbs_to_nat_aux(*lo) == (words[0] as nat) + pow2(64) * (words[1] as nat) + pow2(128)\n            * (words[2] as nat) + pow2(192) * (words[3] as nat) + pow2(256) * ((words[4]\n            & 0xf) as nat),\n{\n    // Common mask equality used throughout\n    assert((1u64 << 52) - 1u64 == u64::MAX >> 12) by (bit_vector);\n\n    let masked_words_sum = ((words[0] & mask) as nat) + pow2(52) * ((((words[0] >> 52) | (words[1]\n        << 12)) & mask) as nat) + pow2(104) * ((((words[1] >> 40) | (words[2] << 24))\n        & mask) as nat) + pow2(156) * ((((words[2] >> 28) | (words[3] << 36)) & mask) as nat)\n        + pow2(208) * ((((words[3] >> 16) | (words[4] << 48)) & mask) as nat);\n\n    let unmasked_words_sum = (words[0] as nat) + pow2(64) * (words[1] as nat) + pow2(128) * (\n    words[2] as nat) + pow2(192) * (words[3] as nat) + pow2(256) * ((words[4] & 0xf) as nat);\n\n    let limb1 = (((words[0] >> 52) | (words[1] << 12)) & mask) as nat;\n    let limb2 = (((words[1] >> 40) | (words[2] << 24)) & mask) as nat;\n    let limb3 = (((words[2] >> 28) | (words[3] << 36)) & mask) as nat;\n    let limb4 = (((words[3] >> 16) | (words[4] << 48)) & mask) as nat;\n\n    let w0_low = ((words[0] & mask) as nat);\n    let w0_high = (words[0] >> 52) as nat;\n\n    let w1_low = ((words[1] & (u64::MAX >> 24)) as nat);\n    let w1_high = (words[1] >> 40) as nat;\n    let w2_low = ((words[2] & (u64::MAX >> 36)) as nat);\n    let w2_high = (words[2] >> 28) as nat;\n    let w3_low = ((words[3] & (u64::MAX >> 48)) as nat);\n    let w3_high = (words[3] >> 16) as nat;\n    let w4_low = (words[4] & 0xf) as nat;\n\n    // Limb 1 consists of word 0's top 12 bits and word 1's low 40 bits.\n    lemma_limb_from_adjacent_words(words[0], words[1], 52, 12, 24, limb1, w0_high, w1_low);\n    // Limb 2 consists of word 1's top 24 bits and word 2's low 28 bits.\n    lemma_limb_from_adjacent_words(words[1], words[2], 40, 24, 36, limb2, w1_high, w2_low);\n    // Limb 3 consists of word 2's top 36 bits and word 3's low 16 bits.\n    lemma_limb_from_adjacent_words(words[2], words[3], 28, 36, 48, limb3, w2_high, w3_low);\n    // Limb 4 consists of word 3's top 48 bits and word 4's low 4 bits.\n    assert(limb4 == w3_high + pow2(48) * w4_low) by {\n        let w3 = words[3];\n        let w4 = words[4];\n        let high48 = w3 >> 16;\n        let low4 = w4 & 0xf;\n\n        assert(((w3 >> 16) | (w4 << 48)) & (u64::MAX >> 12) == (w3 >> 16) | ((w4 & 0xf) << 48))\n            by (bit_vector);\n        assert((w3 >> 16) < (1u64 << 48)) by (bit_vector);\n        assert((w4 & 0xf) <= u64::MAX >> 48) by (bit_vector);\n        assert(((w3 >> 16) | ((w4 & 0xf) << 48)) < (1u64 << 52)) by (bit_vector);\n        lemma_bit_or_is_plus(high48, low4, 48);\n        vstd::bits::lemma_u64_mul_pow2_le_max_iff_max_shr(low4, 48, u64::MAX);\n        vstd::bits::lemma_u64_shl_is_mul(low4, 48);\n    };\n    // Word 0 equals its low 52 bits plus its top 12 bits shifted by 52.\n    assert(words[0] as nat == w0_low + pow2(52) * w0_high) by {\n        let w0 = words[0];\n        let high = w0 >> 52;\n        let low = w0 & mask;\n\n        assert((w0 & (u64::MAX >> 12)) < (1u64 << 52)) by (bit_vector);\n        assert((w0 >> 52) <= u64::MAX >> 52) by (bit_vector);\n        lemma_decompose(w0, mask);\n        lemma_bit_or_is_plus(low, high, 52);\n    };\n    // Word 1's contribution at scale 2^64 equals its low 40 bits plus its high 24 bits.\n    assert(pow2(64) * (words[1] as nat) == pow2(64) * w1_low + pow2(104) * w1_high) by {\n        lemma_word_contribution_decomposition(words[1], 64, 40, 24, w1_low, w1_high);\n    };\n    // Word 2's contribution at scale 2^128 equals its low 28 bits plus its high 36 bits.\n    assert(pow2(128) * (words[2] as nat) == pow2(128) * w2_low + pow2(156) * w2_high) by {\n        lemma_word_contribution_decomposition(words[2], 128, 28, 36, w2_low, w2_high);\n    };\n    // Word 3's contribution at scale 2^192 equals its low 16 bits plus its high 48 bits.\n    assert(pow2(192) * (words[3] as nat) == pow2(192) * w3_low + pow2(208) * w3_high) by {\n        lemma_word_contribution_decomposition(words[3], 192, 16, 48, w3_low, w3_high);\n    };\n\n    assert(w0_low + pow2(52) * (w0_high + pow2(12) * w1_low) + pow2(104) * (w1_high + pow2(24)\n        * w2_low) + pow2(156) * (w2_high + pow2(36) * w3_low) + pow2(208) * (w3_high + pow2(48)\n        * w4_low) == unmasked_words_sum) by {\n        broadcast use group_mul_is_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 12);\n        lemma_pow2_adds(104, 24);\n        lemma_pow2_adds(156, 36);\n        lemma_pow2_adds(208, 48);\n    };\n    assert(masked_words_sum == unmasked_words_sum);\n}",
      "start_line": 303,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat_rec().",
      "display_name": "bytes_to_nat_rec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat_rec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn bytes_to_nat_rec(bytes: &[u8; 32], index: int) -> nat\n    decreases 32 - index,\n{\n    u8_32_as_nat_rec(bytes, index as nat)\n}",
      "start_line": 69,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_carry_bounded_after_mask().",
      "display_name": "lemma_carry_bounded_after_mask",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_carry_bounded_after_mask().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_carry_bounded_after_mask(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) <= 1,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n\n    lemma_pow2_pos(52);\n    lemma_shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}",
      "start_line": 278,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_div_and_mod_51().",
      "display_name": "lemma_div_and_mod_51",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_div_and_mod_51().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_div_and_mod_51(ai: u64, bi: u64, v: u64)\n    requires\n        ai == v >> 51,\n        bi == v & mask51,\n    ensures\n        ai == v / (pow2(51) as u64),\n        bi == v % (pow2(51) as u64),\n        v == ai * pow2(51) + bi,\n{\n    l51_bit_mask_lt();  // mask51 == low_bits_mask(51)\n    lemma_div_and_mod(ai, bi, v, 51);\n}",
      "start_line": 113,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb1_byte_contribution().",
      "display_name": "limb1_byte_contribution",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb1_byte_contribution().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "spec fn limb1_byte_contribution(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    // Byte 6 high 5 bits (limbs[1]'s bits 0-4)\n    ((limbs[1] as nat % pow2(5)) * 8) * pow2(6 * 8) + bytes[7] as nat * pow2(7 * 8)\n        + bytes[8] as nat * pow2(8 * 8) + bytes[9] as nat * pow2(9 * 8) + bytes[10] as nat * pow2(\n        10 * 8,\n    ) + bytes[11] as nat * pow2(11 * 8)\n        +\n    // Byte 12 low 6 bits (limbs[1]'s bits 45-50)\n    ((limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(12 * 8)\n}",
      "start_line": 172,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "display_name": "lemma_limb4_contribution_correctness",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_limb4_contribution_correctness(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[3] < pow2(51),  // Need limb 3 for boundary byte 25\n        limbs[4] < pow2(51),\n        bytes_match_limbs_packing(limbs, bytes),\n    ensures\n        limb4_byte_contribution(limbs, bytes) == limbs[4] as nat * pow2(204),\n{\n    // Limb 4 stored in bytes 25-31, positioned at 2^204\n    // - Byte 25 (high 4 bits): limbs[4]'s bits 0-3\n    // - Bytes 26-31: limbs[4]'s bits 4-51 (48 bits, but only 47 used)\n    // Total: 4 + 47 = 51 bits (limbs[4] < 2^51)\n    lemma2_to64();\n    lemma_pow2_adds(200, 4);  // 2^204 = 2^200 * 2^4\n\n    // Stabilization placeholders\n    assert(pow2(0) == pow2(0 * 8));\n    assert(pow2(8) == pow2(1 * 8));\n    assert(pow2(16) == pow2(2 * 8));\n    assert(pow2(24) == pow2(3 * 8));\n    assert(pow2(32) == pow2(4 * 8));\n\n    // KEY INSIGHT: From bytes_match_limbs_packing:\n    // bytes[26] = (limbs[4] >> 4) as u8\n    // bytes[27] = (limbs[4] >> 12) as u8\n    // ... and so on\n    //\n    // So limb4_byte_contribution is:\n    //   (limbs[4] % 2^4) * 16 * 2^200 +             // Low 4 bits at position 2^204\n    //   (limbs[4] >> 4 ... >> 44) * positions       // High 47 bits at position 2^208\n    //\n    // This is limbs[4] * 2^204!\n\n    // Step 1: Extract arithmetic values for bytes 26-31\n    // These bytes come from limbs[4] >> 4, 12, 20, 28, 36, 44\n    lemma_byte_from_limb_shift(limbs[4], 4, bytes[26]);\n    assert(bytes[26] as nat == (limbs[4] as nat / pow2(4)) % 256);\n\n    lemma_byte_from_limb_shift(limbs[4], 12, bytes[27]);\n\n    lemma_byte_from_limb_shift(limbs[4], 20, bytes[28]);\n\n    lemma_byte_from_limb_shift(limbs[4], 28, bytes[29]);\n\n    lemma_byte_from_limb_shift(limbs[4], 36, bytes[30]);\n\n    lemma_byte_from_limb_shift(limbs[4], 44, bytes[31]);\n\n    // Step 2: Prove that bytes[26-31] reconstruct (limbs[4] / 2^4) at position 2^208\n    //\n    // From lemma_byte_from_limb_shift, we have:\n    // bytes[26] as nat == (limbs[4] / pow2(4)) % 256\n    // bytes[27] as nat == (limbs[4] / pow2(12)) % 256\n    // bytes[28] as nat == (limbs[4] / pow2(20)) % 256\n    // bytes[29] as nat == (limbs[4] / pow2(28)) % 256\n    // bytes[30] as nat == (limbs[4] / pow2(36)) % 256\n    // bytes[31] as nat == (limbs[4] / pow2(44)) % 256\n    //\n    // The key insight: these bytes extract consecutive 8-bit chunks from (limbs[4] / 2^4)\n\n    // First, rewrite the byte extractions in terms of (limbs[4] / 2^4)\n    // bytes[26] == (limbs[4] / 2^4) / 2^0 % 256\n    lemma_pow2_adds(0, 4);\n    assert(pow2(4) * pow2(0) == pow2(4));\n    lemma_div_denominator(limbs[4] as int, pow2(4) as int, pow2(0) as int);\n\n    // bytes[27] == (limbs[4] / 2^12) % 256 == (limbs[4] / 2^4) / 2^8 % 256\n    lemma_pow2_adds(4, 8);\n    lemma_div_denominator(limbs[4] as int, pow2(4) as int, pow2(8) as int);\n\n    // bytes[28] == (limbs[4] / 2^20) % 256 == (limbs[4] / 2^4) / 2^16 % 256\n    lemma_pow2_adds(4, 16);\n    lemma_div_denominator(limbs[4] as int, pow2(4) as int, pow2(16) as int);\n\n    // bytes[29] == (limbs[4] / 2^28) % 256 == (limbs[4] / 2^4) / 2^24 % 256\n    lemma_pow2_adds(4, 24);\n    lemma_div_denominator(limbs[4] as int, pow2(4) as int, pow2(24) as int);\n\n    // bytes[30] == (limbs[4] / 2^36) % 256 == (limbs[4] / 2^4) / 2^32 % 256\n    lemma_pow2_adds(4, 32);\n    lemma_pow2_pos(32);\n    lemma_div_denominator(limbs[4] as int, pow2(4) as int, pow2(32) as int);\n\n    // bytes[31] == (limbs[4] / 2^44) % 256 == (limbs[4] / 2^4) / 2^40 % 256\n    lemma_pow2_adds(4, 40);\n    lemma_pow2_pos(40);\n    lemma_div_denominator(limbs[4] as int, pow2(4) as int, pow2(40) as int);\n\n    // Since limbs[4] < 2^51, we have limbs[4] / 2^4 < 2^47\n    lemma_div_bound(limbs[4] as nat, 4, 51);\n\n    // The value (limbs[4] / 2^4) is 47 bits, and we have 6 bytes (48 bits capacity)\n    // So we can directly use it without modulo truncation!\n    let high_value = limbs[4] as nat / pow2(4);\n\n    // Prove high_value < 2^48 (we have 2^47, which is less than 2^48)\n    assert(high_value < pow2(47));\n    assert(pow2(47) < pow2(48)) by {\n        lemma_pow2_adds(47, 1);\n        assert(pow2(48) == pow2(47) * 2);\n    }\n\n    // Now apply lemma_6_bytes_reconstruct\n    lemma_6_bytes_reconstruct(\n        high_value,\n        bytes[26],\n        bytes[27],\n        bytes[28],\n        bytes[29],\n        bytes[30],\n        bytes[31],\n    );\n\n    // This gives us:\n    assert(bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat * pow2(16)\n        + bytes[29] as nat * pow2(24) + bytes[30] as nat * pow2(32) + bytes[31] as nat * pow2(40)\n        == high_value);\n\n    // Now multiply both sides by 2^208 to get the bytes at their actual positions\n    lemma_mul_is_distributive_add(\n        pow2(208) as int,\n        (bytes[26] as nat * pow2(0)) as int,\n        (bytes[27] as nat * pow2(8)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(208) as int,\n        (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8)) as int,\n        (bytes[28] as nat * pow2(16)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(208) as int,\n        (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat * pow2(\n            16,\n        )) as int,\n        (bytes[29] as nat * pow2(24)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(208) as int,\n        (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat * pow2(16)\n            + bytes[29] as nat * pow2(24)) as int,\n        (bytes[30] as nat * pow2(32)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(208) as int,\n        (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat * pow2(16)\n            + bytes[29] as nat * pow2(24) + bytes[30] as nat * pow2(32)) as int,\n        (bytes[31] as nat * pow2(40)) as int,\n    );\n\n    // Distribute the multiplication into each term\n    lemma_mul_is_associative(bytes[26] as int, pow2(0) as int, pow2(208) as int);\n    lemma_mul_is_associative(bytes[27] as int, pow2(8) as int, pow2(208) as int);\n    lemma_mul_is_associative(bytes[28] as int, pow2(16) as int, pow2(208) as int);\n    lemma_mul_is_associative(bytes[29] as int, pow2(24) as int, pow2(208) as int);\n    lemma_mul_is_associative(bytes[30] as int, pow2(32) as int, pow2(208) as int);\n    lemma_mul_is_associative(bytes[31] as int, pow2(40) as int, pow2(208) as int);\n\n    // Simplify using pow2 addition: 2^208 * 2^k = 2^(208+k)\n    lemma_pow2_adds(208, 0);\n\n    lemma_pow2_adds(208, 8);\n\n    lemma_pow2_adds(208, 16);\n\n    lemma_pow2_adds(208, 24);\n\n    lemma_pow2_adds(208, 32);\n\n    lemma_pow2_adds(208, 40);\n\n    // Final result\n    assert(bytes[26] as nat * pow2(26 * 8) + bytes[27] as nat * pow2(27 * 8) + bytes[28] as nat\n        * pow2(28 * 8) + bytes[29] as nat * pow2(29 * 8) + bytes[30] as nat * pow2(30 * 8)\n        + bytes[31] as nat * pow2(31 * 8) == high_value * pow2(208));\n\n    // Step 3: Handle boundary byte\n    // Low 4 bits (byte 25 high part): (limbs[4] % 2^4) * 16 * 2^200 = (limbs[4] % 2^4) * 2^204\n\n    assert(16 * pow2(200) == pow2(204)) by {\n        lemma_pow2_adds(200, 4);\n    }\n\n    // From the proof above, we have:\n    let high_bytes_sum = bytes[26] as nat * pow2(26 * 8) + bytes[27] as nat * pow2(27 * 8)\n        + bytes[28] as nat * pow2(28 * 8) + bytes[29] as nat * pow2(29 * 8) + bytes[30] as nat\n        * pow2(30 * 8) + bytes[31] as nat * pow2(31 * 8);\n\n    let high_value_at_position = (limbs[4] as nat / pow2(4)) * pow2(208);\n\n    // Substitute into contribution\n    let contribution = limb4_byte_contribution(limbs, bytes);\n    assert(contribution == ((limbs[4] as nat % pow2(4)) * 16) * pow2(200) + high_bytes_sum);\n\n    assert(contribution == ((limbs[4] as nat % pow2(4)) * 16) * pow2(200) + high_value_at_position);\n\n    // Step 3: Prove the reconstruction identity for limbs[4]\n    // limbs[4] = (limbs[4] % 2^4) + (limbs[4] / 2^4) * 2^4\n    // This is just the fundamental div-mod property!\n\n    lemma_pow2_pos(4);\n    lemma_fundamental_div_mod(limbs[4] as int, pow2(4) as int);\n    assert(pow2(4) * (limbs[4] as nat / pow2(4)) == (limbs[4] as nat / pow2(4)) * pow2(4)) by {\n        lemma_mul_is_commutative(pow2(4) as int, (limbs[4] as nat / pow2(4)) as int);\n    }\n\n    // Step 4: Now connect the contribution to limbs[4] * 2^204\n    // We have: contribution = ((limbs[4] % 2^4) * 16) * 2^200 + (limbs[4] / 2^4) * 2^208\n\n    // First, simplify the low term: ((limbs[4] % 2^4) * 16) * 2^200 = (limbs[4] % 2^4) * (16 * 2^200) = (limbs[4] % 2^4) * 2^204\n    // We proved earlier that 16 * 2^200 = 2^204\n    let low_part = (limbs[4] as nat % pow2(4));\n    assert(((limbs[4] as nat % pow2(4)) * 16) * pow2(200) == low_part * (16 * pow2(200))) by {\n        lemma_mul_is_associative(low_part as int, 16, pow2(200) as int);\n    }\n\n    // So contribution = (limbs[4] % 2^4) * 2^204 + (limbs[4] / 2^4) * 2^208\n    assert(contribution == low_part * pow2(204) + (limbs[4] as nat / pow2(4)) * pow2(208));\n\n    // Rewrite using 2^208 = 2^204 * 2^4\n    lemma_pow2_adds(204, 4);\n\n    assert(contribution == low_part * pow2(204) + (limbs[4] as nat / pow2(4)) * (pow2(204) * pow2(\n        4,\n    )));\n\n    // Apply associativity to move pow2(204) to the left\n    let high_part = limbs[4] as nat / pow2(4);\n\n    assert(high_part * (pow2(204) * pow2(4)) == (high_part * pow2(204)) * pow2(4)) by {\n        lemma_mul_is_associative(high_part as int, pow2(204) as int, pow2(4) as int);\n    }\n    assert((high_part * pow2(204)) * pow2(4) == pow2(204) * high_part * pow2(4)) by {\n        lemma_mul_is_commutative((high_part * pow2(204)) as int, pow2(4) as int);\n    }\n    assert(pow2(204) * high_part * pow2(4) == pow2(204) * (high_part * pow2(4))) by {\n        lemma_mul_is_associative(pow2(204) as int, high_part as int, pow2(4) as int);\n    }\n\n    // Now factor out pow2(204)\n    assert(contribution == low_part * pow2(204) + pow2(204) * (high_part * pow2(4)));\n\n    // Use distributivity to factor out pow2(204)\n    assert(contribution == pow2(204) * (low_part + high_part * pow2(4))) by {\n        lemma_mul_is_distributive_add(\n            pow2(204) as int,\n            low_part as int,\n            (high_part * pow2(4)) as int,\n        );\n    }\n\n    // The part in parentheses equals limbs[4] by our reconstruction identity!\n    assert(contribution == limbs[4] as nat * pow2(204)) by {\n        lemma_mul_is_commutative(pow2(204) as int, limbs[4] as int);\n    }\n\n}",
      "start_line": 1663,
      "end_line": 46,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/spec_clamp_integer().",
      "display_name": "spec_clamp_integer",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/spec_clamp_integer().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_clamp_integer(bytes: [u8; 32]) -> [u8; 32] {\n    // Build the result array element by element\n    [\n        bytes[0] & 0b1111_1000,  // Clear low 3 bits of byte 0\n        bytes[1],\n        bytes[2],\n        bytes[3],\n        bytes[4],\n        bytes[5],\n        bytes[6],\n        bytes[7],\n        bytes[8],\n        bytes[9],\n        bytes[10],\n        bytes[11],\n        bytes[12],\n        bytes[13],\n        bytes[14],\n        bytes[15],\n        bytes[16],\n        bytes[17],\n        bytes[18],\n        bytes[19],\n        bytes[20],\n        bytes[21],\n        bytes[22],\n        bytes[23],\n        bytes[24],\n        bytes[25],\n        bytes[26],\n        bytes[27],\n        bytes[28],\n        bytes[29],\n        bytes[30],\n        (bytes[31] & 0b0111_1111) | 0b0100_0000,  // Clear bit 7 and set bit 6 of byte 31\n    ]\n}",
      "start_line": 122,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb2().",
      "display_name": "lemma_load8_at_limb2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_load8_at_limb2(input: &[u8])\n    requires\n        12 + 7 < input.len(),\n    ensures\n        ((spec_load8_at(input, 12) as u64) >> 6) & mask51 == (input[12] as nat / pow2(6)) + (\n        input[13] * pow2((1 * 8 - 6) as nat)) + (input[14] * pow2((2 * 8 - 6) as nat)) + (input[15]\n            * pow2((3 * 8 - 6) as nat)) + (input[16] * pow2((4 * 8 - 6) as nat)) + (input[17]\n            * pow2((5 * 8 - 6) as nat)) + (input[18] * pow2((6 * 8 - 6) as nat)) + ((\n        input[19] as nat % pow2(1)) * pow2((7 * 8 - 6) as nat)),\n{\n    let i = 12;\n    let k = 6;\n\n    let j_div = 1;\n    let j_id = 7;\n    let j_shift = 8;\n\n    lemma_load8_at_limb_X(input, i, k, j_div, j_id, j_shift);\n\n    // Sanity check\n    assert((spec_load8_at(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n        / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n    pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64));\n}",
      "start_line": 909,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Index#index().",
      "display_name": "index",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Index#index().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn index(&self, _index: usize) -> (result: &u8)\n        requires\n            _index < 32,\n        ensures\n            result == &self.bytes[_index as int],\n    {\n        &(self.bytes[_index])\n    }",
      "start_line": 452,
      "end_line": 13,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_wide_to_nat().",
      "display_name": "bytes_wide_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_wide_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn bytes_wide_to_nat(bytes: &[u8; 64]) -> nat {\n    // Convert bytes to nat in little-endian order using recursive helper\n    bytes_wide_to_nat_rec(bytes, 0)\n}",
      "start_line": 76,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq/Seq#skip().",
      "display_name": "skip",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq/Seq#skip().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "specs",
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c2_val().",
      "display_name": "c2_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c2_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn c2_val(a: [u64; 5]) -> u128 {\n    (c2_0_val(a) + ((c1_val(a) >> 51) as u64) as u128) as u128\n}",
      "start_line": 64,
      "end_line": 24,
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/spec_mul_internal().",
      "display_name": "spec_mul_internal",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/spec_mul_internal().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "relative_path": "curve25519-dalek/src/specs/scalar_specs_u64.rs",
      "file_name": "scalar_specs_u64.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_mul_internal(a: &Scalar52, b: &Scalar52) -> [u128; 9]\n    recommends\n        limbs_bounded(a),\n        limbs_bounded(b),\n{\n    [\n        ((a.limbs[0] as u128) * (b.limbs[0] as u128)) as u128,\n        ((a.limbs[0] as u128) * (b.limbs[1] as u128) + (a.limbs[1] as u128) * (\n        b.limbs[0] as u128)) as u128,\n        ((a.limbs[0] as u128) * (b.limbs[2] as u128) + (a.limbs[1] as u128) * (b.limbs[1] as u128)\n            + (a.limbs[2] as u128) * (b.limbs[0] as u128)) as u128,\n        ((a.limbs[0] as u128) * (b.limbs[3] as u128) + (a.limbs[1] as u128) * (b.limbs[2] as u128)\n            + (a.limbs[2] as u128) * (b.limbs[1] as u128) + (a.limbs[3] as u128) * (\n        b.limbs[0] as u128)) as u128,\n        ((a.limbs[0] as u128) * (b.limbs[4] as u128) + (a.limbs[1] as u128) * (b.limbs[3] as u128)\n            + (a.limbs[2] as u128) * (b.limbs[2] as u128) + (a.limbs[3] as u128) * (\n        b.limbs[1] as u128) + (a.limbs[4] as u128) * (b.limbs[0] as u128)) as u128,\n        ((a.limbs[1] as u128) * (b.limbs[4] as u128) + (a.limbs[2] as u128) * (b.limbs[3] as u128)\n            + (a.limbs[3] as u128) * (b.limbs[2] as u128) + (a.limbs[4] as u128) * (\n        b.limbs[1] as u128)) as u128,\n        ((a.limbs[2] as u128) * (b.limbs[4] as u128) + (a.limbs[3] as u128) * (b.limbs[3] as u128)\n            + (a.limbs[4] as u128) * (b.limbs[2] as u128)) as u128,\n        ((a.limbs[3] as u128) * (b.limbs[4] as u128) + (a.limbs[4] as u128) * (\n        b.limbs[3] as u128)) as u128,\n        ((a.limbs[4] as u128) * (b.limbs[4] as u128)) as u128,\n    ]\n}",
      "start_line": 212,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo generic-array 0.14.7 GenericArray#as_slice().",
      "display_name": "as_slice",
      "symbol": "rust-analyzer cargo generic-array 0.14.7 GenericArray#as_slice().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#push().",
      "display_name": "push",
      "symbol": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#push().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 is_capable_simd().",
      "display_name": "is_capable_simd",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 is_capable_simd().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "curve25519-dalek/build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "body": "fn is_capable_simd(arch: &str, bits: DalekBits) -> bool {\n    arch == \"x86_64\" && bits == DalekBits::Dalek64\n}",
      "start_line": 76,
      "end_line": 19,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash().",
      "display_name": "from_hash",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn from_hash<D>(hash: D) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64>,\n\n        ensures\n    //is_random_digest(&hash) ==> is_random_scalar(&result),\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut output = [0u8;64];\n        output.copy_from_slice(hash.finalize().as_slice());\n        Scalar::from_bytes_mod_order_wide(&output)\n    }",
      "start_line": 1425,
      "end_line": 21,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/pow2_mul_div_mod_small_mul_u8_t51_cond().",
      "display_name": "pow2_mul_div_mod_small_mul_u8_t51_cond",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/pow2_mul_div_mod_small_mul_u8_t51_cond().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn pow2_mul_div_mod_small_mul_u8_t51_cond(k: nat, j: nat) -> bool {\n    (j * 8 <= k) && (8 <= 51 + k - 8 * j)\n}",
      "start_line": 712,
      "end_line": 56,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#Index#index().",
      "display_name": "index",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#Index#index().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn index(&self, _index: usize) -> (result: &u64)\n        requires\n            _index < 5,\n        ensures\n            result == &(self.limbs[_index as int]),\n    {\n        &(self.limbs[_index])\n    }",
      "start_line": 90,
      "end_line": 13,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_difference_zero().",
      "display_name": "lemma_mod_difference_zero",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_difference_zero().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "proof fn lemma_mod_difference_zero(a: int, b: int, m: int)\n    requires\n        m > 0,\n        a % m == 0,\n        b % m == 0,\n    ensures\n        (a - b) % m == 0,\n{\n    // By lemma_sub_mod_noop: (a - b) % m == ((a % m) - (b % m)) % m\n    lemma_sub_mod_noop(a, b, m);\n    // Since a % m == 0 and b % m == 0: (a - b) % m == (0 - 0) % m == 0\n    lemma_small_mod(0nat, m as nat);\n}",
      "start_line": 1204,
      "end_line": 35,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_lemmas/lemmas/seq_sum().",
      "display_name": "seq_sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_lemmas/lemmas/seq_sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/sum_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/sum_lemmas.rs",
      "file_name": "sum_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub open spec fn seq_sum(coefs: Seq<nat>, k: nat) -> nat\n    decreases k,\n{\n    if (k == 0) {\n        coefs[0]\n    } else {\n        seq_sum(coefs, (k - 1) as nat) + coefs[k as int]\n    }\n}",
      "start_line": 18,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "display_name": "pow22501",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "curve25519-dalek/src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "    fn pow22501(&self) -> (result: (FieldElement, FieldElement))\n        requires\n            fe51_limbs_bounded(self, 54),\n        ensures\n    // Bounded limbs (maintained by all field operations)\n\n            fe51_limbs_bounded(&result.0, 54),\n            fe51_limbs_bounded(&result.1, 54),\n            // Mathematical values\n            spec_field_element(&result.0) == (pow(\n                spec_field_element(self) as int,\n                (pow2(250) - 1) as nat,\n            ) as nat) % p(),\n            spec_field_element(&result.1) == (pow(spec_field_element(self) as int, 11) as nat)\n                % p(),\n    {\n        // Instead of managing which temporary variables are used\n        // for what, we define as many as we need and leave stack\n        // allocation to the compiler\n        //\n        // Each temporary variable t_i is of the form (self)^e_i.\n        // Squaring t_i corresponds to multiplying e_i by 2,\n        // so the pow2k function shifts e_i left by k places.\n        // Multiplying t_i and t_j corresponds to adding e_i + e_j.\n        //\n        // Temporary t_i                      Nonzero bits of e_i\n        let t0 = self.square();  // 1         e_0 = 2^1\n        // NOTE: Changing the code!!!\n        // NOTE: We are now using the intermediate variable t0_sq to track the postcondition of the first square.\n        // NOTE: This is a workaround to allow us to prove the postcondition of the second square.\n        // NOTE: I'm struggling to prove that t0.square().square() is the same as t0_sq.square().\n        // Break apart chained call to track intermediate postcondition\n        // NOTE: Using intermediate variable t0_sq to track the postcondition\n        let t0_sq = t0.square();  // e = 4 (intermediate step)\n        // let t1 = t0.square().square();  // 3         e_1 = 2^3 = 8\n        let t1 = t0_sq.square();  // 3         e_1 = 2^3 = 8\n        let t2 = self * &t1;  // 3,0       e_2 = 2^3 + 2^0 = 9\n        let t3 = &t0 * &t2;  // 3,1,0\n        let t4 = t3.square();  // 4,2,1\n        let t5 = &t2 * &t4;  // 4,3,2,1,0\n        let t6 = t5.pow2k(5);  // 9,8,7,6,5\n        let t7 = &t6 * &t5;  // 9,8,7,6,5,4,3,2,1,0\n        let t8 = t7.pow2k(10);  // 19..10\n        let t9 = &t8 * &t7;  // 19..0\n        let t10 = t9.pow2k(20);  // 39..20\n        let t11 = &t10 * &t9;  // 39..0\n        let t12 = t11.pow2k(10);  // 49..10\n        let t13 = &t12 * &t7;  // 49..0\n        let t14 = t13.pow2k(50);  // 99..50\n        let t15 = &t14 * &t13;  // 99..0\n        let t16 = t15.pow2k(100);  // 199..100\n        let t17 = &t16 * &t15;  // 199..0\n        let t18 = t17.pow2k(50);  // 249..50\n        let t19 = &t18 * &t13;  // 249..0\n\n        proof {\n            // Assert the field operation postconditions that the lemma requires\n            pow255_gt_19();  // Prove p() > 0\n\n            // Square operation postconditions (from .square() method ensures clause)\n            assert(u64_5_as_nat(t0.limbs) % p() == pow(u64_5_as_nat(self.limbs) as int, 2) as nat\n                % p());\n            assert(u64_5_as_nat(t0_sq.limbs) % p() == pow(u64_5_as_nat(t0.limbs) as int, 2) as nat\n                % p());\n            assert(u64_5_as_nat(t1.limbs) % p() == pow(u64_5_as_nat(t0_sq.limbs) as int, 2) as nat\n                % p());\n\n            // For mul operations, use lemma to convert from field_mul to direct multiplication\n            assert(u64_5_as_nat(t2.limbs) % p() == (u64_5_as_nat(self.limbs) * u64_5_as_nat(\n                t1.limbs,\n            )) % p()) by {\n                lemma_mul_mod_noop_general(\n                    u64_5_as_nat(self.limbs) as int,\n                    u64_5_as_nat(t1.limbs) as int,\n                    p() as int,\n                );\n            };\n            assert(u64_5_as_nat(t3.limbs) % p() == (u64_5_as_nat(t0.limbs) * u64_5_as_nat(t2.limbs))\n                % p()) by {\n                lemma_mul_mod_noop_general(\n                    u64_5_as_nat(t0.limbs) as int,\n                    u64_5_as_nat(t2.limbs) as int,\n                    p() as int,\n                );\n            };\n\n            // Use lemma to prove t3 = x^11 and all intermediate steps\n            lemma_pow22501_prove_t3(\n                self.limbs,\n                t0.limbs,\n                t0_sq.limbs,\n                t1.limbs,\n                t2.limbs,\n                t3.limbs,\n            );\n\n            let base = u64_5_as_nat(self.limbs) as int;\n\n            // Prove t19 = x^(2^250-1) using explicit lemma\n\n            // Multiplication: t5 = t2 * t4\n            assert(u64_5_as_nat(t5.limbs) % p() == (u64_5_as_nat(t2.limbs) * u64_5_as_nat(t4.limbs))\n                % p()) by {\n                lemma_mul_mod_noop_general(\n                    u64_5_as_nat(t2.limbs) as int,\n                    u64_5_as_nat(t4.limbs) as int,\n                    p() as int,\n                );\n            };\n\n            // Multiplication: t7 = t6 * t5\n            assert(u64_5_as_nat(t7.limbs) % p() == (u64_5_as_nat(t6.limbs) * u64_5_as_nat(t5.limbs))\n                % p()) by {\n                lemma_mul_mod_noop_general(\n                    u64_5_as_nat(t6.limbs) as int,\n                    u64_5_as_nat(t5.limbs) as int,\n                    p() as int,\n                );\n            };\n\n            // Multiplication: t9 = t8 * t7\n            assert(u64_5_as_nat(t9.limbs) % p() == (u64_5_as_nat(t8.limbs) * u64_5_as_nat(t7.limbs))\n                % p()) by {\n                lemma_mul_mod_noop_general(\n                    u64_5_as_nat(t8.limbs) as int,\n                    u64_5_as_nat(t7.limbs) as int,\n                    p() as int,\n                );\n            };\n\n            // Multiplication: t11 = t10 * t9\n            assert(u64_5_as_nat(t11.limbs) % p() == (u64_5_as_nat(t10.limbs) * u64_5_as_nat(\n                t9.limbs,\n            )) % p()) by {\n                lemma_mul_mod_noop_general(\n                    u64_5_as_nat(t10.limbs) as int,\n                    u64_5_as_nat(t9.limbs) as int,\n                    p() as int,\n                );\n            };\n\n            // Multiplication: t13 = t12 * t7\n            assert(u64_5_as_nat(t13.limbs) % p() == (u64_5_as_nat(t12.limbs) * u64_5_as_nat(\n                t7.limbs,\n            )) % p()) by {\n                lemma_mul_mod_noop_general(\n                    u64_5_as_nat(t12.limbs) as int,\n                    u64_5_as_nat(t7.limbs) as int,\n                    p() as int,\n                );\n            };\n\n            // Multiplication: t15 = t14 * t13\n            assert(u64_5_as_nat(t15.limbs) % p() == (u64_5_as_nat(t14.limbs) * u64_5_as_nat(\n                t13.limbs,\n            )) % p()) by {\n                lemma_mul_mod_noop_general(\n                    u64_5_as_nat(t14.limbs) as int,\n                    u64_5_as_nat(t13.limbs) as int,\n                    p() as int,\n                );\n            };\n\n            // Multiplication: t17 = t16 * t15\n            assert(u64_5_as_nat(t17.limbs) % p() == (u64_5_as_nat(t16.limbs) * u64_5_as_nat(\n                t15.limbs,\n            )) % p()) by {\n                lemma_mul_mod_noop_general(\n                    u64_5_as_nat(t16.limbs) as int,\n                    u64_5_as_nat(t15.limbs) as int,\n                    p() as int,\n                );\n            };\n\n            // Multiplication: t19 = t18 * t13\n            assert(u64_5_as_nat(t19.limbs) % p() == (u64_5_as_nat(t18.limbs) * u64_5_as_nat(\n                t13.limbs,\n            )) % p()) by {\n                lemma_mul_mod_noop_general(\n                    u64_5_as_nat(t18.limbs) as int,\n                    u64_5_as_nat(t13.limbs) as int,\n                    p() as int,\n                );\n            };\n\n            // Use our comprehensive lemma to prove t19 = x^(2^250-1)\n            lemma_pow22501_prove_t19(\n                self.limbs,\n                t0.limbs,\n                t1.limbs,\n                t2.limbs,\n                t3.limbs,\n                t4.limbs,\n                t5.limbs,\n                t6.limbs,\n                t7.limbs,\n                t8.limbs,\n                t9.limbs,\n                t10.limbs,\n                t11.limbs,\n                t12.limbs,\n                t13.limbs,\n                t14.limbs,\n                t15.limbs,\n                t16.limbs,\n                t17.limbs,\n                t18.limbs,\n                t19.limbs,\n            );\n\n            // Bridge from u64_5_as_nat postconditions to spec_field_element postconditions\n            // The previous proof established:\n            //assert(u64_5_as_nat(t19.limbs) % p() == (pow(u64_5_as_nat(self.limbs) as int, (pow2(250) - 1) as nat) as nat) % p());\n            //assert(u64_5_as_nat(t3.limbs) % p() == (pow(u64_5_as_nat(self.limbs) as int, 11) as nat) % p());\n\n            // Use bridge lemma to prove the spec_field_element postconditions\n            lemma_bridge_pow_as_nat_to_spec(&t19, self, (pow2(250) - 1) as nat);\n            lemma_bridge_pow_as_nat_to_spec(&t3, self, 11);\n\n            // Bounded limbs: all field operations (mul, square, pow2k) maintain the bound < 2^54\n            // t19 is the result of mul (&t18 * &t13), so it inherits the bound from mul's postcondition\n            // t3 is the result of mul (&t0 * &t2), so it inherits the bound from mul's postcondition\n            assert(fe51_limbs_bounded(&t19, 54));\n            assert(fe51_limbs_bounded(&t3, 54));\n        }\n\n        (t19, t3)\n    }",
      "start_line": 293,
      "end_line": 16,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 13
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "display_name": "as_radix_2w",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn as_radix_2w(&self, w: usize) -> (result:\n        [i8; 64])\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            4 <= w <= 8,\n            // For w=4 (radix 16), top bit must be clear\n            w == 4 ==> self.bytes[31] <= 127,\n        ensures\n            ({\n                let digits_count = if w < 8 {\n                    (256 + (w as int) - 1) / (w as int)\n                } else {\n                    (256 + (w as int) - 1) / (w as int) + 1\n                };\n                // Result digits are in valid range for the given window size\n                is_valid_radix_2w(&result, w as nat, digits_count as nat)\n                    &&\n                // Reconstruction property: digits reconstruct the scalar value\n                reconstruct_radix_2w(result@.take(digits_count), w as nat) == scalar_to_nat(\n                    self,\n                ) as int\n            }),",
      "start_line": 2326,
      "end_line": 30,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_strong().",
      "display_name": "lemma_fermat_strong",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_strong().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_fermat_strong(a: nat, p: nat)\n    requires\n        is_prime(p),\n    ensures\n        (pow(a as int, p) as nat) % p == a % p,\n    decreases a,\n{\n    if a == 0 {\n        assert(pow(0int, p) == 0) by {\n            if p == 0 {\n                reveal(pow);\n            } else {\n                reveal(pow);\n                lemma_mul_basics(pow(0int, (p - 1) as nat));\n            }\n        };\n        lemma_small_mod(0nat, p);\n    } else {\n        let am1 = (a - 1) as nat;\n\n        lemma_fermat_strong(am1, p);\n        assert((pow(am1 as int, p) as nat) % p == am1 % p);\n\n        lemma_binomial_expansion_mod_p(am1, p);\n\n        assert(am1 + 1 == a);\n        assert((pow(a as int, p) as nat) % p == (1 + (pow(am1 as int, p) as nat)) % p);\n\n        let pow_am1_p = pow(am1 as int, p) as nat;\n        let am1_pow_mod = pow_am1_p % p;\n        assert(am1_pow_mod == am1 % p);\n        let pow_am1_p_int = pow_am1_p as int;\n        let p_int = p as int;\n        let am1_int = am1 as int;\n\n        lemma_mod_adds(1, pow_am1_p_int, p_int);\n        lemma_small_mod(1nat, p);\n        assert(1int % p_int == 1);\n        assert(pow_am1_p_int % p_int == am1_pow_mod as int);\n        assert(am1_pow_mod as int == (am1 % p) as int);\n        lemma_mod_adds(1, am1_int, p_int);\n        assert((1 + pow_am1_p_int) % p_int == (1 + am1_int) % p_int);\n        assert((1 + pow_am1_p) % p == (1 + am1) % p);\n\n        assert((1 + am1) == a);\n    }\n}",
      "start_line": 446,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c4_val().",
      "display_name": "c4_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c4_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn c4_val(a: [u64; 5]) -> u128 {\n    (c4_0_val(a) + ((c3_val(a) >> 51) as u64) as u128) as u128\n}",
      "start_line": 72,
      "end_line": 24,
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/valid_compressed_for_sign_bit().",
      "display_name": "valid_compressed_for_sign_bit",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/valid_compressed_for_sign_bit().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub open spec fn valid_compressed_for_sign_bit(repr_byte_31: u8, x_sqrt: nat) -> bool {\n    let sign_bit = repr_byte_31 >> 7;\n    // If sign_bit == 1, x_sqrt must be non-zero to produce a valid result\n    sign_bit == 1 ==> x_sqrt % p() != 0\n}",
      "start_line": 579,
      "end_line": 47,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_u8().",
      "display_name": "lemma_pow2_mul_bound_u8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_u8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_mul_bound_u8(a: u8, k: nat)\n    ensures\n        pow2(k) * a <= pow2(k + 8) - pow2(k),\n        a * pow2(k) <= pow2(k + 8) - pow2(k),\n        pow2(k + 8) - pow2(k) < pow2(k + 8),\n{\n    assert(a < pow2(8)) by {\n        lemma2_to64();\n    }\n\n    lemma_pow2_mul_bound_general(a as nat, 8, k);\n}",
      "start_line": 124,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "display_name": "elligator_ristretto_flavor",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn elligator_ristretto_flavor(r_0: &FieldElement) -> RistrettoPoint {\n        let i = &constants::SQRT_M1;\n        let d = &constants::EDWARDS_D;\n        let one_minus_d_sq = &constants::ONE_MINUS_EDWARDS_D_SQUARED;\n        let d_minus_one_sq = &constants::EDWARDS_D_MINUS_ONE_SQUARED;\n        let mut c = constants::MINUS_ONE;\n\n        let one = FieldElement::ONE;\n\n        let r = i * &r_0.square();\n        let N_s = &(&r + &one) * one_minus_d_sq;\n        let D = &(&c - &(d * &r)) * &(&r + d);\n\n        let (Ns_D_is_sq, mut s) = FieldElement::sqrt_ratio_i(&N_s, &D);\n        let mut s_prime = &s * r_0;\n        let s_prime_is_pos = !s_prime.is_negative();\n        s_prime.conditional_negate(s_prime_is_pos);\n\n        s.conditional_assign(&s_prime, !Ns_D_is_sq);\n        c.conditional_assign(&r, !Ns_D_is_sq);\n\n        let N_t = &(&(&c * &(&r - &one)) * d_minus_one_sq) - &D;\n        let s_sq = s.square();\n\n        use crate::backend::serial::curve_models::CompletedPoint;\n\n        // The conversion from W_i is exactly the conversion from P1xP1.\n        RistrettoPoint(\n            CompletedPoint {\n                X: &(&s + &s) * &D,\n                Z: &N_t * &constants::SQRT_AD_MINUS_ONE,\n                Y: &FieldElement::ONE - &s_sq,\n                T: &FieldElement::ONE + &s_sq,\n            }\n            .as_extended(),\n        )\n    }",
      "start_line": 655,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb2_byte_contribution().",
      "display_name": "limb2_byte_contribution",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb2_byte_contribution().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "spec fn limb2_byte_contribution(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    // Byte 12 high 2 bits (limbs[2]'s bits 0-1)\n    ((limbs[2] as nat % pow2(2)) * pow2(6)) * pow2(12 * 8) + bytes[13] as nat * pow2(13 * 8)\n        + bytes[14] as nat * pow2(14 * 8) + bytes[15] as nat * pow2(15 * 8) + bytes[16] as nat\n        * pow2(16 * 8) + bytes[17] as nat * pow2(17 * 8) + bytes[18] as nat * pow2(18 * 8)\n        +\n    // Byte 19 low 1 bit (limbs[2]'s bit 50)\n    ((limbs[2] as nat / pow2(50)) % 2) * pow2(19 * 8)\n}",
      "start_line": 185,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_positive().",
      "display_name": "lemma_gcd_positive",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_positive().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_gcd_positive(a: nat, b: nat)\n    requires\n        a > 0 || b > 0,\n    ensures\n        spec_gcd(a, b) > 0,\n    decreases b,\n{\n    if b == 0 {\n        // gcd(a, 0) = a, and a > 0 by requirement\n        assert(a > 0);\n    } else {\n        // gcd(a, b) = gcd(b, a % b)\n        // b > 0, so we can apply induction\n        lemma_gcd_positive(b, a % b);\n    }\n}",
      "start_line": 106,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_canonical_bytes_high_bit_clear().",
      "display_name": "lemma_canonical_bytes_high_bit_clear",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_canonical_bytes_high_bit_clear().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_canonical_bytes_high_bit_clear(bytes: &[u8; 32])\n    requires\n        bytes_to_nat(bytes) < group_order(),\n    ensures\n        bytes[31] <= 127,\n{\n    lemma_group_order_bound();\n    // bytes_to_nat < group_order < 2^255\n    if bytes[31] >= 128 {\n        // bytes_to_nat >= bytes[31] * 2^248 >= 128 * 2^248 = 2^255\n        lemma_bytes_to_nat_lower_bound(bytes, 31);\n        lemma_pow2_adds(7, 248);\n        lemma2_to64();\n        lemma_mul_inequality(128, bytes[31] as int, pow2(248) as int);\n        // contradiction: bytes_to_nat >= 2^255 > group_order\n    }\n}",
      "start_line": 2016,
      "end_line": 50,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_limb_bounds_established().",
      "display_name": "lemma_step1_limb_bounds_established",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_limb_bounds_established().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/edwards_lemmas/decompress_lemmas.rs",
      "file_name": "decompress_lemmas.rs",
      "parent_folder": "edwards_lemmas",
      "body": "pub proof fn lemma_step1_limb_bounds_established()\n    ensures\n        // ONE has 51-bit and 54-bit bounded limbs\n        fe51_limbs_bounded(&FieldElement51::ONE, 51),\n        fe51_limbs_bounded(&FieldElement51::ONE, 54),\n        // EDWARDS_D has 54-bit bounded limbs\n        fe51_limbs_bounded(&EDWARDS_D, 54),\n{\n    use crate::lemmas::field_lemmas::constants_lemmas::*;\n    use crate::lemmas::edwards_lemmas::constants_lemmas::*;\n    \n    lemma_one_limbs_bounded();\n    lemma_one_limbs_bounded_54();\n    lemma_edwards_d_limbs_bounded_54();\n}",
      "start_line": 783,
      "end_line": 49,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_0_bounded().",
      "display_name": "lemma_c_i_0_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_0_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_c_i_0_bounded(a: [u64; 5], bound: u64)\n    requires\n        19 * bound <= u64::MAX,\n        forall|i: int| 0 <= i < 5 ==> a[i] < bound,\n    ensures\n        ci_0_val_boundaries(a, bound),\n{\n    lemma_term_product_bounds(a, bound);\n}",
      "start_line": 166,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_boundary_spec().",
      "display_name": "pow2k_loop_boundary_spec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_boundary_spec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn pow2k_loop_boundary_spec(a: [u64; 5]) -> bool {\n    &&& 19 * (1u64 << 54) <= u64::MAX\n    &&& 77 * ((1u64 << 54) * (1u64 << 54)) <= u128::MAX\n    &&& term_product_bounds_spec(a, 1u64 << 54)\n    &&& ci_0_val_boundaries(a, 1u64 << 54)\n    &&& ci_val_boundaries(a)\n    &&& ai_val_boundaries(a)\n    &&& pow2k_loop_return(a)[0] < 1u64 << 54\n    &&& pow2k_loop_return(a)[1] < 1u64 << 54\n    &&& pow2k_loop_return(a)[2] < 1u64 << 54\n    &&& pow2k_loop_return(a)[3] < 1u64 << 54\n    &&& pow2k_loop_return(a)[4] < 1u64 << 54\n}",
      "start_line": 222,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_divides_linear_combo_sub().",
      "display_name": "lemma_divides_linear_combo_sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_divides_linear_combo_sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_divides_linear_combo_sub(x: nat, y: nat, k: nat, d: nat)\n    requires\n        d > 0,\n        x % d == 0,\n        y % d == 0,\n        x >= k * y,\n    ensures\n        ((x - k * y) as nat) % d == 0,\n{\n    lemma_mul_mod_noop_right(k as int, y as int, d as int);\n    assert((k as int * y as int) % (d as int) == (k as int * (y as int % d as int)) % (d as int));\n    assert(y as int % d as int == 0int);\n    assert(k as int * (y as int % d as int) == k as int * 0int);\n    assert(k as int * 0int == 0int);\n    lemma_mod_self_0(d as int);\n    assert(0int % (d as int) == 0int);\n    assert(((k * y) as int) % (d as int) == 0int);\n    lemma_sub_mod_noop(x as int, (k * y) as int, d as int);\n}",
      "start_line": 58,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_left_right_shift().",
      "display_name": "lemma_left_right_shift",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_left_right_shift().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_left_right_shift(v: u64, sl: u64, sr: u64)\n    requires\n        sr <= sl < 64,\n        v * pow2(sl as nat) <= u64::MAX,\n    ensures\n        (v << sl) >> sr == v << (sl - sr),\n{\n    let d = (sl - sr) as nat;\n\n    assert(v << sl == v * pow2(sl as nat)) by {\n        lemma_u64_shl_is_mul(v, sl);\n    }\n\n    assert(pow2(sl as nat) == pow2(d) * pow2(sr as nat)) by {\n        lemma_pow2_adds(d, sr as nat);\n    }\n\n    let w = (v * pow2(sl as nat)) as nat;\n\n    assert(w as u64 >> sr == w / pow2(sr as nat)) by {\n        lemma_u64_shr_is_div(w as u64, sr);\n    }\n\n    assert(w == pow2(sr as nat) * (v * pow2(d))) by {\n        lemma_mul_is_associative(v as int, pow2(d) as int, pow2(sr as nat) as int);\n    }\n\n    assert(pow2(sr as nat) > 0) by {\n        lemma_pow2_pos(sr as nat);\n    }\n\n    assert(w / pow2(sr as nat) == v * pow2(d)) by {\n        lemma_div_multiples_vanish((v * pow2(d)) as int, pow2(sr as nat) as int);\n    }\n\n    assert(v * pow2(d) == v << (d as u64)) by {\n        lemma_u64_shl_is_mul(v, d as u64);\n    }\n}",
      "start_line": 263,
      "end_line": 36,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"CompressedRistretto: {:?}\", self.as_bytes())\n    }",
      "start_line": 1157,
      "end_line": 11,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_u_from_edwards_y().",
      "display_name": "montgomery_u_from_edwards_y",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_u_from_edwards_y().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/montgomery_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/montgomery_specs.rs",
      "file_name": "montgomery_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn montgomery_u_from_edwards_y(y: nat) -> nat {\n    let denom = math_field_sub(1, y);\n    if denom == 0 {\n        0\n    } else {\n        let numerator = math_field_add(1, y);\n        math_field_mul(numerator, math_field_inv(denom))\n    }\n}",
      "start_line": 242,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb4().",
      "display_name": "lemma_load8_at_limb4",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb4().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_load8_at_limb4(input: &[u8])\n    requires\n        24 + 7 < input.len(),\n    ensures\n        ((spec_load8_at(input, 24) as u64) >> 12) & mask51 == (input[25] as nat / pow2(4)) + (\n        input[26] * pow2((2 * 8 - 12) as nat)) + (input[27] * pow2((3 * 8 - 12) as nat)) + (\n        input[28] * pow2((4 * 8 - 12) as nat)) + (input[29] * pow2((5 * 8 - 12) as nat)) + (\n        input[30] * pow2((6 * 8 - 12) as nat)) + ((input[31] as nat % pow2(7)) * pow2(\n            (7 * 8 - 12) as nat,\n        )),\n{\n    let i = 24;\n    let k = 12;\n\n    let j_div = 2;\n    let j_id = 7;\n    let j_shift = 8;\n\n    lemma_load8_at_limb_X(input, i, k, j_div, j_id, j_shift);\n\n    // Sanity check\n    assert((spec_load8_at(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n        / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n    pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64));\n\n    // First term too small, swallowed by div\n    assert(input[24] as nat / pow2(12) == 0) by {\n        assert(input[24] < pow2(8) < pow2(12)) by {\n            assert(input[24] < pow2(8)) by {\n                lemma_u8_lt_pow2_8(input[24]);\n            }\n            assert(pow2(8) < pow2(12)) by {\n                lemma_pow2_strictly_increases(8, 12);\n            }\n        }\n\n        lemma_basic_div(input[24] as int, pow2(12) as int);\n    }\n}",
      "start_line": 982,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_le_max64().",
      "display_name": "lemma_pow2_le_max64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_le_max64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_le_max64(k: nat)\n    requires\n        k < 64,\n    ensures\n        pow2(k) <= u64::MAX,\n{\n    lemma2_to64();\n    lemma2_to64_rest();\n}",
      "start_line": 25,
      "end_line": 33,
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_general().",
      "display_name": "lemma_pow2_mul_bound_general",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_general().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_pow2_mul_bound_general(a: nat, s: nat, k: nat)\n    requires\n        a < pow2(s),\n    ensures\n        pow2(k) * a <= pow2(k + s) - pow2(k),\n        a * pow2(k) <= pow2(k + s) - pow2(k),\n        pow2(k + s) - pow2(k) < pow2(k + s),\n{\n    assert(a <= pow2(s) - 1);  // x < y <=> x <= y - 1\n\n    lemma_mul_le(a as nat, (pow2(s) - 1) as nat, pow2(k), pow2(k));\n    assert((pow2(s) - 1) * pow2(k) == pow2(k + s) - pow2(k)) by {\n        lemma_mul_is_distributive_sub(pow2(k) as int, pow2(s) as int, 1);\n        lemma_pow2_adds(k, s);\n    }\n\n    lemma_mul_is_commutative(a as int, pow2(k) as int);\n\n    assert(pow2(k) > 0) by {\n        lemma_pow2_pos(k);\n    }\n}",
      "start_line": 101,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_sum_factor().",
      "display_name": "lemma_mod_sum_factor",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_sum_factor().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_mod_sum_factor(a: int, b: int, m: int)\n    requires\n        m > 0,\n    ensures\n        (a * m + b) % m == b % m,\n{\n    // (a * m + b) % m == ((a * m) % m + b % m) % m\n    lemma_add_mod_noop(a * m, b, m);\n    // (a * m) % m == 0\n    lemma_mod_multiples_basic(a, m);\n    // b % m % m = b % m\n    lemma_mod_twice(b, m);\n}",
      "start_line": 42,
      "end_line": 34,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/lemma_hash_is_canonical().",
      "display_name": "lemma_hash_is_canonical",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/lemma_hash_is_canonical().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "curve25519-dalek/src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub proof fn lemma_hash_is_canonical<H>(\n    point1: &MontgomeryPoint,\n    point2: &MontgomeryPoint,\n    state: H,\n)\n    requires\n// The two points represent the same field element (same canonical value)\n\n        spec_field_element_from_bytes(&point1.0) == spec_field_element_from_bytes(&point2.0),\n    ensures\n// Points with equal field element values hash to the same state\n\n        spec_state_after_hash_montgomery(state, point1) == spec_state_after_hash_montgomery(\n            state,\n            point2,\n        ),\n{\n    // Get canonical byte sequences\n    let ghost canonical_seq1 = spec_fe51_to_bytes(&spec_fe51_from_bytes(&point1.0));\n    let ghost canonical_seq2 = spec_fe51_to_bytes(&spec_fe51_from_bytes(&point2.0));\n\n    // Convert to arrays for use with hash_determinism_axiom\n    let ghost canonical1 = seq_to_array_32(canonical_seq1);\n    let ghost canonical2 = seq_to_array_32(canonical_seq2);\n\n    assume(canonical_seq1 == canonical_seq2);\n    assert(canonical1@ == canonical2@);\n\n}",
      "start_line": 210,
      "end_line": 37,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bytes_to_nat_lower_bound().",
      "display_name": "lemma_bytes_to_nat_lower_bound",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bytes_to_nat_lower_bound().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_bytes_to_nat_lower_bound(bytes: &[u8; 32], index: usize)\n    requires\n        index < 32,\n    ensures\n        bytes_to_nat(bytes) >= (bytes[index as int] as nat) * pow2((index * 8) as nat),\n{\n    // bytes_to_nat is defined recursively as a sum of non-negative terms\n    // Therefore the sum is >= any individual term\n    use crate::specs::core_specs::u8_32_as_nat;\n    assert(bytes_to_nat(bytes) == u8_32_as_nat(bytes));\n    lemma_bytes_to_nat_rec_bound(bytes, 0, index);\n}",
      "start_line": 1586,
      "end_line": 44,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_is_fourth_root().",
      "display_name": "lemma_sqrt_m1_is_fourth_root",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_is_fourth_root().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/unused_sqrt_ratio_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/unused_sqrt_ratio_lemmas.rs",
      "file_name": "unused_sqrt_ratio_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_sqrt_m1_is_fourth_root()\n    ensures is_fourth_root_of_unity(spec_sqrt_m1()),\n{\n    // i⁴ = (i²)² = (-1)² = 1\n    // Note: would need axiom_sqrt_m1_squared() from main file\n    assume(is_fourth_root_of_unity(spec_sqrt_m1()));\n}",
      "start_line": 65,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_rec_is_bounded().",
      "display_name": "lemma_load8_at_plus_version_rec_is_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_rec_is_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_load8_at_plus_version_rec_is_bounded(input: &[u8], i: usize, k: nat)\n    requires\n        k <= 7,\n    ensures\n        load8_at_plus_version_rec(input, i, k) < pow2(8 * (k + 1)),\n    decreases k,\n{\n    assert(u8::MAX < pow2(8)) by {\n        lemma2_to64();\n    }\n\n    if (k == 0) {\n        // just needs the the pre-if assert\n    } else {\n        // k > 0\n        // Let f(k) := load8_at_plus_version_rec(input, i, k)\n        // IH: f(k - 1) < pow2(8 * k)\n        assert(load8_at_plus_version_rec(input, i, (k - 1) as nat) < pow2(8 * k)) by {\n            lemma_load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n        }\n\n        let c = (input[i + k] as u64);\n        assert(c < pow2(8));\n\n        // f(k) = f(k - 1) + c * pow2(8 * k)\n        assert(c << (8 * k) == c * pow2(8 * k)) by {\n            assert((input[i + k] as u64) * pow2(8 * k) <= u64::MAX) by {\n                assert(u64::MAX == pow2(64) - 1) by {\n                    lemma2_to64_rest();\n                }\n                assert(c * pow2(8 * k) < pow2(64)) by {\n                    assert(c * pow2(8 * k) < pow2(8) * pow2(8 * k)) by {\n                        lemma_mul_strict_inequality(c as int, pow2(8) as int, pow2(8 * k) as int);\n                    }\n                    assert(pow2(8) * pow2(8 * k) <= pow2(64)) by {\n                        assert(pow2(8 * k) <= pow2(56)) by {\n                            if (k < 7) {\n                                lemma_pow2_strictly_increases(8 * k, 56);\n                            }\n                        }\n                        lemma_pow2_pos(8);\n                        lemma_mul_inequality(pow2(8 * k) as int, pow2(56) as int, pow2(8) as int);\n                        lemma_pow2_adds(8, 56);\n                    }\n                }\n            }\n            lemma_u64_shl_is_mul(c, (8 * k) as u64);\n        }\n\n        // f(k - 1) < 1 * 2^(8k)\n        // c <= 2^8 - 1\n        // f(k -1) + c * 2^8k < 2^8 * 2^8k = 2^(8 * (k + 1))\n\n        assert(load8_at_plus_version_rec(input, i, k) < pow2(8 * k) + c * pow2(8 * k));\n\n        assert(pow2(8 * k) + c * pow2(8 * k) <= pow2(8 * (k + 1))) by {\n            // x + c * x == c ( x + 1 )\n            assert(pow2(8 * k) + c * pow2(8 * k) == pow2(8 * k) * (c + 1)) by {\n                lemma_mul_is_distributive_add(pow2(8 * k) as int, c as int, 1);\n            }\n            assert(c + 1 <= pow2(8));\n\n            assert(pow2(8 * k) * (c + 1) <= pow2(8 * (k + 1))) by {\n                lemma_mul_inequality((c + 1) as int, pow2(8) as int, pow2(8 * k) as int);\n                lemma_pow2_adds(8, 8 * k);\n                lemma_mul_is_distributive_add(8, 1, k as int);\n            }\n        }\n    }\n}",
      "start_line": 59,
      "end_line": 56,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_reorder_mul().",
      "display_name": "lemma_reorder_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_reorder_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_reorder_mul(a: int, b: int)\n    ensures\n        2 * (a * (19 * b)) == 19 * (2 * (a * b)),\n{\n    // 2*( a * (19 * b)) = (2 * a) * (19 * b)\n    lemma_mul_is_associative(2, a, 19 * b);\n    // (2 * a) * (19 * b) = (19 * b) * (2 * a) = 19 * (b * (2 * a))\n    lemma_mul_is_associative(19, b, 2 * a);\n    // (b * (2 * a)) = (b * (a * 2)) = 2 * (a * b)\n    lemma_mul_is_associative(b, a, 2);\n}",
      "start_line": 24,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_add_multiples_vanish().",
      "display_name": "lemma_mod_add_multiples_vanish",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_add_multiples_vanish().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitwise_or_l_zero_is_id().",
      "display_name": "lemma_bitwise_or_l_zero_is_id",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitwise_or_l_zero_is_id().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/bit_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/bit_lemmas.rs",
      "file_name": "bit_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_bitwise_or_l_zero_is_id(a: u64)\n    ensures\n        0 | a == a,\n{\n    assert(0 | a == a) by (bit_vector);\n}",
      "start_line": 21,
      "end_line": 43,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_corresponds_to_edwards().",
      "display_name": "affine_niels_corresponds_to_edwards",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_corresponds_to_edwards().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn affine_niels_corresponds_to_edwards(\n    niels: AffineNielsPoint,\n    point: EdwardsPoint,\n) -> bool {\n    let x_proj = spec_field_element(&point.X);\n    let y_proj = spec_field_element(&point.Y);\n    let z_proj = spec_field_element(&point.Z);\n    let d = spec_field_element(&EDWARDS_D);\n\n    // Compute affine coordinates x = X/Z, y = Y/Z\n    let z_inv = math_field_inv(z_proj);\n    let x = math_field_mul(x_proj, z_inv);\n    let y = math_field_mul(y_proj, z_inv);\n\n    let y_plus_x_niels = spec_field_element(&niels.y_plus_x);\n    let y_minus_x_niels = spec_field_element(&niels.y_minus_x);\n    let xy2d_niels = spec_field_element(&niels.xy2d);\n\n    // Check the relationships\n    &&& y_plus_x_niels == math_field_add(y, x)\n    &&& y_minus_x_niels == math_field_sub(y, x)\n    &&& xy2d_niels == math_field_mul(math_field_mul(math_field_mul(x, y), 2), d)\n}",
      "start_line": 477,
      "end_line": 53,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_mod().",
      "display_name": "lemma_mod_mod",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_sub().",
      "display_name": "edwards_sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn edwards_sub(x1: nat, y1: nat, x2: nat, y2: nat) -> (nat, nat) {\n    edwards_add(x1, y1, math_field_neg(x2), y2)\n}",
      "start_line": 647,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/IsIdentity#is_identity().",
      "display_name": "is_identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/IsIdentity#is_identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "curve25519-dalek/src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn is_identity(&self) -> bool {\n        self.ct_eq(&T::identity()).into()\n    }",
      "start_line": 45,
      "end_line": 19,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#to_bytes().",
      "display_name": "to_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#to_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub const fn to_bytes(&self) -> (result: [u8; 32])\n        ensures\n            result == self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        self.bytes\n    }",
      "start_line": 1473,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#to_montgomery().",
      "display_name": "to_montgomery",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#to_montgomery().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn to_montgomery(&self) -> (result: MontgomeryPoint)\n        requires\n            fe51_limbs_bounded(&self.X, 54),\n            // Y and Z need 51-bit bounds so U = Z + Y is 52-bit bounded (< 54 for mul)\n            fe51_limbs_bounded(&self.Y, 51) && fe51_limbs_bounded(&self.Z, 51),\n            sum_of_limbs_bounded(&self.Z, &self.Y, u64::MAX),\n        ensures\n            montgomery_corresponds_to_edwards(result, *self),\n    {\n        // We have u = (1+y)/(1-y) = (Z+Y)/(Z-Y).\n        //\n        // The denominator is zero only when y=1, the identity point of\n        // the Edwards curve.  Since 0.invert() = 0, in this case we\n        // compute the 2-torsion point (0,0).\n        proof {\n            // 51-bit bounded implies 54-bit bounded (for sub precondition)\n            assert((1u64 << 51) < (1u64 << 54)) by (bit_vector);\n            assert(fe51_limbs_bounded(&self.Y, 54));\n            assert(fe51_limbs_bounded(&self.Z, 54));\n        }\n        let U = &self.Z + &self.Y;\n        let W = &self.Z - &self.Y;\n        // W bounded by 54 from sub() postcondition\n        // U bounded by 52 from add() postcondition (51-bit inputs → 52-bit output)\n        proof {\n            assert(fe51_limbs_bounded(&U, 52));  // from add postcondition\n            assert((1u64 << 52) < (1u64 << 54)) by (bit_vector);\n            assert(fe51_limbs_bounded(&U, 54));\n        }\n        let u = &U * &W.invert();\n        let result = MontgomeryPoint(u.as_bytes());\n        proof {\n            assume(montgomery_corresponds_to_edwards(result, *self));\n        }\n        result\n    }",
      "start_line": 1186,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_smaller_than_pow256().",
      "display_name": "lemma_group_order_smaller_than_pow256",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_smaller_than_pow256().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_group_order_smaller_than_pow256()\n    ensures\n        group_order() < pow2(256),\n{\n    lemma_group_order_bound();\n    lemma_pow2_strictly_increases(255, 256);\n}",
      "start_line": 1839,
      "end_line": 51,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo rand 0.8.5 thread/rngs/thread_rng().",
      "display_name": "thread_rng",
      "symbol": "rust-analyzer cargo rand 0.8.5 thread/rngs/thread_rng().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a2_0_val().",
      "display_name": "a2_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a2_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn a2_0_val(a: [u64; 5]) -> u64 {\n    (c2_val(a) as u64) & mask51\n}",
      "start_line": 88,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/from_bytes_non_canonical_example().",
      "display_name": "from_bytes_non_canonical_example",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/from_bytes_non_canonical_example().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn from_bytes_non_canonical_example() {\n        let bytes: [u8; 32] = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 17,\n        ];\n\n        let s = Scalar52::from_bytes(&bytes);\n\n        let result_nat = to_nat_exec(&s.limbs);\n        let l = group_order_exec();\n\n        // OLD Postcondition 3: to_nat(&s.limbs) < group_order() - DOES NOT HOLD\n        assert!(\n            &result_nat >= &l,\n            \"This example demonstrates result >= L: {} >= {}\",\n            result_nat,\n            l\n        );\n    }",
      "start_line": 1453,
      "end_line": 40,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/load8_at().",
      "display_name": "load8_at",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/load8_at().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "pub(super) const fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == spec_load8_at(input, i),\n{\n    proof {\n        lemma_load8_at_rec_version_is_exec(input, i);\n        lemma_load8_at_versions_equivalent(input, i, 7);\n        lemma_load8_at_plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}",
      "start_line": 136,
      "end_line": 29,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "display_name": "batch_invert",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn batch_invert(inputs: &mut [Scalar]) -> (result:\n        Scalar)/* <VERIFICATION NOTE>\n     Refactored for Verus: Index loops instead of iterators, manual Vec construction, ..\n    </VERIFICATION NOTE> */\n\n        ensures\n    // Result is the modular inverse of the product of all original inputs\n\n            is_inverse_of_nat(&result, product_of_scalars(old(inputs)@)),\n            // Each input is replaced with its inverse\n            forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ),\n    {\n        // This code is essentially identical to the FieldElement\n        // implementation, and is documented there.  Unfortunately,\n        // it's not easy to write it generically, since here we want\n        // to use `UnpackedScalar`s internally, and `Scalar`s\n        // externally, but there's no corresponding distinction for\n        // field elements.\n        let n = inputs.len();\n        let one_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(limbs_bounded(&one_unpacked));\n        }\n\n        let one: UnpackedScalar = one_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&one));\n        }\n\n        /* <VERIFICATION NOTE>\n         Build vec manually instead of vec![one; n] for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let mut scratch = vec![one; n];\n         </ORIGINAL CODE> */\n        let mut scratch = Vec::new();\n        for _ in 0..n {\n            scratch.push(one);\n        }\n\n        // Keep an accumulator of all of the previous products\n        let acc_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(scratch.len() == n);\n            assume(limbs_bounded(&acc_unpacked));\n        }\n\n        let mut acc = acc_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        /* <VERIFICATION NOTE>\n         Rewritten with index loop instead of .zip() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         for (input, scratch) in inputs.iter_mut().zip(scratch.iter_mut()) {\n             *scratch = acc;\n        //     // Avoid unnecessary Montgomery multiplication in second pass by\n        //     // keeping inputs in Montgomery form\n             let tmp = input.unpack().as_montgomery();\n             *input = tmp.pack();\n             acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n         }\n        </ORIGINAL CODE> */\n        for i in 0..n\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                limbs_bounded(&acc),\n        {\n            scratch[i] = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = input_unpacked.as_montgomery();\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n\n            proof {\n                assume(limbs_bounded(&acc));\n            }\n        }\n\n        proof {\n            // Assert that all scratch elements have bounded limbs\n            assume(forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]));\n        }\n\n        // acc is nonzero iff all inputs are nonzero\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert!(acc.pack() != Scalar::ZERO);\n\n        // Compute the inverse of all products\n        // ORIGINAL CODE: acc = acc.montgomery_invert().from_montgomery();\n        acc = acc.montgomery_invert();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        acc = acc.from_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // We need to return the product of all inverses later\n        let ret = acc.pack();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        /* <VERIFICATION NOTE>\n         Manual reverse loop instead of .rev() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.iter().rev()) {\n             let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n             *input = UnpackedScalar::montgomery_mul(&acc, scratch).pack();\n             acc = tmp;\n         }\n        </ORIGINAL CODE> */\n        let mut i: usize = n;\n        while i > 0\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                i <= n,\n                limbs_bounded(&acc),\n                forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]),\n            decreases i,\n        {\n            i -= 1;\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input_unpacked);\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = UnpackedScalar::montgomery_mul(&acc, &scratch[i]).pack();\n            acc = tmp;\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        #[cfg(not(verus_keep_ghost))]\n        Zeroize::zeroize(&mut scratch);\n\n        proof {\n            // Assume the postconditions\n            assume(is_inverse_of_nat(&ret, product_of_scalars(old(inputs)@)));\n            assume(forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ));\n        }\n\n        ret\n    }",
      "start_line": 1605,
      "end_line": 24,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_not().",
      "display_name": "choice_not",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_not().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn choice_not(a: Choice) -> (c: Choice)\n    ensures\n        choice_is_true(c) == !choice_is_true(a),\n{\n    use core::ops::Not;\n    a.not()\n}",
      "start_line": 131,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_multiples_distinct_mod_prime().",
      "display_name": "lemma_multiples_distinct_mod_prime",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_multiples_distinct_mod_prime().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_multiples_distinct_mod_prime(a: nat, i: nat, j: nat, p: nat)\n    requires\n        is_prime(p),\n        a % p != 0,\n        1 <= i < j < p,\n    ensures\n        (a * i) % p != (a * j) % p,\n{\n    // Proof by contradiction\n    if (a * i) % p == (a * j) % p {\n        // Then (a * j - a * i) % p == 0\n        // a * (j - i) % p == 0\n        // Since p is prime and a % p != 0, we need (j - i) % p == 0\n        // But 0 < j - i < p, so (j - i) % p = j - i != 0\n        // Contradiction\n        let diff = (j - i) as nat;\n        assert(0 < diff < p);\n\n        // (a * j) % p == (a * i) % p means (a * j - a * i) % p == 0\n        // a * j - a * i = a * (j - i)\n        assert(a * j - a * i == a * diff) by {\n            lemma_mul_is_distributive_sub(a as int, j as int, i as int);\n        };\n\n        // Show (a * diff) % p == 0\n        assert((a * diff) % p == 0) by {\n            // (a * j) % p == (a * i) % p\n            // ((a * j) - (a * i)) % p == 0\n            lemma_mod_sub_eq(a * j, a * i, p);\n        };\n\n        // But a % p != 0 and 0 < diff < p means diff % p == diff != 0\n        assert(diff % p == diff) by {\n            lemma_small_mod(diff, p);\n        };\n        assert(diff % p != 0);\n\n        // By Euclid's lemma, since (a * diff) % p == 0 and p is prime,\n        // either a % p == 0 or diff % p == 0\n        lemma_euclid_prime(a, diff, p);\n        // Both are false, contradiction\n        assert(false);\n    }\n}",
      "start_line": 1219,
      "end_line": 48,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_word_contribution_decomposition().",
      "display_name": "lemma_word_contribution_decomposition",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_word_contribution_decomposition().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "relative_path": "curve25519-dalek/src/lemmas/scalar_lemmas_extra.rs",
      "file_name": "scalar_lemmas_extra.rs",
      "parent_folder": "lemmas",
      "body": "pub proof fn lemma_word_contribution_decomposition(\n    word: u64,\n    scale: nat,\n    split_pos: u64,\n    mask_shift: u64,\n    low_part: nat,\n    high_part: nat,\n)\n    requires\n        split_pos > 0 && split_pos < 64,\n        mask_shift + split_pos == 64,\n        low_part == (word & (u64::MAX >> mask_shift)) as nat,\n        high_part == (word >> split_pos) as nat,\n    ensures\n        pow2(scale) * (word as nat) == pow2(scale) * low_part + pow2(scale + split_pos as nat)\n            * high_part,\n{\n    let low_mask = u64::MAX >> mask_shift;\n    let low = word & low_mask;\n    let high = word >> split_pos;\n\n    // Low part is bounded\n    assert((word & low_mask) < (1u64 << split_pos)) by (bit_vector)\n        requires\n            split_pos > 0 && split_pos < 64 && mask_shift + split_pos == 64 && low_mask == u64::MAX\n                >> mask_shift,\n    ;\n\n    // High part is bounded\n    assert((word >> split_pos) <= u64::MAX >> split_pos) by (bit_vector)\n        requires\n            split_pos > 0 && split_pos < 64,\n    ;\n\n    // Word decomposes into low | (high << split_pos)\n    assert(word == (word & low_mask) | ((word >> split_pos) << split_pos)) by (bit_vector)\n        requires\n            split_pos > 0 && split_pos < 64 && mask_shift + split_pos == 64 && low_mask == u64::MAX\n                >> mask_shift,\n    ;\n\n    lemma_bit_or_is_plus(low, high, split_pos);\n    vstd::bits::lemma_u64_mul_pow2_le_max_iff_max_shr(high, split_pos, u64::MAX);\n    vstd::bits::lemma_u64_shl_is_mul(high, split_pos);\n\n    // pow2(scale) * (pow2(split_pos) * high_part) == pow2(scale + split_pos) * high_part\n    assert(pow2(scale) * (pow2(split_pos as nat) * high_part) == pow2(scale + split_pos as nat)\n        * high_part) by {\n        assert(pow2(scale) * (pow2(split_pos as nat) * high_part) == (pow2(scale) * pow2(\n            split_pos as nat,\n        )) * high_part) by (nonlinear_arith);\n        lemma_pow2_adds(scale, split_pos as nat);\n    }\n    // Final ensures: pow2(scale) * word == pow2(scale) * low_part + pow2(scale + split_pos) * high_part\n    assert(pow2(scale) * (word as nat) == pow2(scale) * low_part + pow2(scale + split_pos as nat)\n        * high_part) by {\n        broadcast use group_mul_is_distributive;\n\n    };\n\n}",
      "start_line": 46,
      "end_line": 51,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_nonnegative().",
      "display_name": "lemma_mul_nonnegative",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_nonnegative().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow22501_t19_lemma.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow22501_t19_lemma.rs",
      "file_name": "pow22501_t19_lemma.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#size_hint().",
      "display_name": "size_hint",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#size_hint().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_mul_upper_bound().",
      "display_name": "lemma_mul_upper_bound",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_mul_upper_bound().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_mul_upper_bound(a: nat, x: nat, b: nat)\n    requires\n        x <= b,\n    ensures\n        a * x <= a * b,\n{\n    // This follows from the monotonicity of multiplication for non-negative numbers\n    // If x <= b, then a * x <= a * b for any a >= 0\n    // Verus's SMT solver should handle this automatically with integer arithmetic\n    if a == 0 {\n    } else {\n        // For a > 0: x <= b implies a*x <= a*b\n        // This is a basic property of multiplication that the SMT solver understands\n        lemma_mul_inequality(x as int, b as int, a as int);\n    }\n}",
      "start_line": 205,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod_converse().",
      "display_name": "lemma_fundamental_div_mod_converse",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod_converse().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_0123().",
      "display_name": "lemma_from_bytes_as_nat_0123",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_0123().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_from_bytes_as_nat_0123(bytes: &[u8; 32])\n    ensures\n        (spec_load8_at(bytes, 0) as u64 & mask51) + pow2(51) * ((spec_load8_at(bytes, 6) as u64\n            >> 3) & mask51) + pow2(102) * ((spec_load8_at(bytes, 12) as u64 >> 6) & mask51) + pow2(\n            153,\n        ) * ((spec_load8_at(bytes, 19) as u64 >> 1) & mask51) == (bytes[0] * pow2(0 * 8)) + (\n        bytes[1] * pow2(1 * 8)) + (bytes[2] * pow2(2 * 8)) + (bytes[3] * pow2(3 * 8)) + (bytes[4]\n            * pow2(4 * 8)) + (bytes[5] * pow2(5 * 8)) + (bytes[6] * pow2(6 * 8)) + (bytes[7] * pow2(\n            7 * 8,\n        )) + (bytes[8] * pow2(8 * 8)) + (bytes[9] * pow2(9 * 8)) + (bytes[10] * pow2(10 * 8)) + (\n        bytes[11] * pow2(11 * 8)) + (bytes[12] * pow2(12 * 8)) + (bytes[13] * pow2(13 * 8)) + (\n        bytes[14] * pow2(14 * 8)) + (bytes[15] * pow2(15 * 8)) + (bytes[16] * pow2(16 * 8)) + (\n        bytes[17] * pow2(17 * 8)) + (bytes[18] * pow2(18 * 8)) + (bytes[19] * pow2(19 * 8)) + (\n        bytes[20] * pow2(20 * 8)) + (bytes[21] * pow2(21 * 8)) + (bytes[22] * pow2(22 * 8)) + (\n        bytes[23] * pow2(23 * 8)) + (bytes[24] * pow2(24 * 8)) + ((bytes[25] as nat % pow2(4))\n            * pow2((25 * 8) as nat)),\n{\n    assert((spec_load8_at(bytes, 0) as u64 & mask51) + pow2(51) * ((spec_load8_at(bytes, 6) as u64\n        >> 3) & mask51) + pow2(102) * ((spec_load8_at(bytes, 12) as u64 >> 6) & mask51) == (bytes[0]\n        * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (bytes[2] * pow2(2 * 8)) + (bytes[3] * pow2(\n        3 * 8,\n    )) + (bytes[4] * pow2(4 * 8)) + (bytes[5] * pow2(5 * 8)) + (bytes[6] * pow2(6 * 8)) + (bytes[7]\n        * pow2(7 * 8)) + (bytes[8] * pow2(8 * 8)) + (bytes[9] * pow2(9 * 8)) + (bytes[10] * pow2(\n        10 * 8,\n    )) + (bytes[11] * pow2(11 * 8)) + (bytes[12] * pow2(12 * 8)) + (bytes[13] * pow2(13 * 8)) + (\n    bytes[14] * pow2(14 * 8)) + (bytes[15] * pow2(15 * 8)) + (bytes[16] * pow2(16 * 8)) + (bytes[17]\n        * pow2(17 * 8)) + (bytes[18] * pow2(18 * 8)) + ((bytes[19] as nat % pow2(1)) * pow2(\n        (19 * 8) as nat,\n    ))) by {\n        lemma_from_bytes_as_nat_012(bytes);\n    }\n\n    assert(((spec_load8_at(bytes, 19) as u64) >> 1) & mask51 == (bytes[19] as nat / pow2(1)) + (\n    bytes[20] * pow2((1 * 8 - 1) as nat)) + (bytes[21] * pow2((2 * 8 - 1) as nat)) + (bytes[22]\n        * pow2((3 * 8 - 1) as nat)) + (bytes[23] * pow2((4 * 8 - 1) as nat)) + (bytes[24] * pow2(\n        (5 * 8 - 1) as nat,\n    )) + ((bytes[25] as nat % pow2(4)) * pow2((6 * 8 - 1) as nat))) by {\n        lemma_load8_at_limb3(bytes);\n    }\n\n    assert(pow2(153) * (((spec_load8_at(bytes, 19) as u64) >> 1) & mask51) == pow2(153) * (\n    bytes[19] as nat / pow2(1)) + pow2(153) * (bytes[20] * pow2((1 * 8 - 1) as nat)) + pow2(153) * (\n    bytes[21] * pow2((2 * 8 - 1) as nat)) + pow2(153) * (bytes[22] * pow2((3 * 8 - 1) as nat))\n        + pow2(153) * (bytes[23] * pow2((4 * 8 - 1) as nat)) + pow2(153) * (bytes[24] * pow2(\n        (5 * 8 - 1) as nat,\n    )) + pow2(153) * ((bytes[25] as nat % pow2(4)) * pow2((6 * 8 - 1) as nat))) by {\n        lemma_mul_distributive_7_terms(\n            pow2(153) as int,\n            (bytes[19] as nat / pow2(1)) as int,\n            (bytes[20] * pow2((1 * 8 - 1) as nat)) as int,\n            (bytes[21] * pow2((2 * 8 - 1) as nat)) as int,\n            (bytes[22] * pow2((3 * 8 - 1) as nat)) as int,\n            (bytes[23] * pow2((4 * 8 - 1) as nat)) as int,\n            (bytes[24] * pow2((5 * 8 - 1) as nat)) as int,\n            ((bytes[25] as nat % pow2(4)) * pow2((6 * 8 - 1) as nat)) as int,\n        );\n    }\n\n    assert(((bytes[19] as nat % pow2(1)) * pow2((19 * 8) as nat)) + pow2(153) * (bytes[19] as nat\n        / pow2(1)) == bytes[19] * pow2(19 * 8)) by {\n        lemma_assemble_mod_div(bytes[19] as nat, 1, 19 * 8)\n    }\n\n    assert(pow2(153) * (bytes[20] * pow2((1 * 8 - 1) as nat)) + pow2(153) * (bytes[21] * pow2(\n        (2 * 8 - 1) as nat,\n    )) + pow2(153) * (bytes[22] * pow2((3 * 8 - 1) as nat)) + pow2(153) * (bytes[23] * pow2(\n        (4 * 8 - 1) as nat,\n    )) + pow2(153) * (bytes[24] * pow2((5 * 8 - 1) as nat)) + pow2(153) * ((bytes[25] as nat % pow2(\n        4,\n    )) * pow2((6 * 8 - 1) as nat)) == (bytes[20] * pow2(20 * 8)) + (bytes[21] * pow2(21 * 8)) + (\n    bytes[22] * pow2(22 * 8)) + (bytes[23] * pow2(23 * 8)) + (bytes[24] * pow2(24 * 8)) + ((\n    bytes[25] as nat % pow2(4)) * pow2((25 * 8) as nat))) by {\n        lemma_assemble_pow_a_pow(bytes[20] as nat, 19, 1, 1);\n        lemma_assemble_pow_a_pow(bytes[21] as nat, 19, 2, 1);\n        lemma_assemble_pow_a_pow(bytes[22] as nat, 19, 3, 1);\n        lemma_assemble_pow_a_pow(bytes[23] as nat, 19, 4, 1);\n        lemma_assemble_pow_a_pow(bytes[24] as nat, 19, 5, 1);\n        lemma_assemble_pow_a_pow(bytes[25] as nat % pow2(4), 19, 6, 1);\n    }\n}",
      "start_line": 229,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_edwards_identity().",
      "display_name": "math_is_edwards_identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_edwards_identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn math_is_edwards_identity(x: nat, y: nat) -> bool {\n    x % p() == 0 && y % p() == 1\n}",
      "start_line": 197,
      "end_line": 42,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/compressed_edwards_y_corresponds_to_edwards().",
      "display_name": "compressed_edwards_y_corresponds_to_edwards",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/compressed_edwards_y_corresponds_to_edwards().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/edwards_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/edwards_specs.rs",
      "file_name": "edwards_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn compressed_edwards_y_corresponds_to_edwards(\n    compressed: CompressedEdwardsY,\n    point: EdwardsPoint,\n) -> bool {\n    let (x_affine, y_affine) = edwards_point_as_affine(point);\n    // The y-coordinate in the compressed form matches the affine y-coordinate\n    spec_field_element_from_bytes(&compressed.0)\n        == y_affine\n    // The sign bit matches the sign of the affine x-coordinate\n     && (compressed.0[31] >> 7) == (((x_affine % crate::specs::field_specs_u64::p()) % 2) as u8)\n}",
      "start_line": 358,
      "end_line": 61,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#From#from().",
      "display_name": "from",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#From#from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "curve25519-dalek/src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    fn from(P: &'a EdwardsPoint) -> (result:\n        Self)/*\n    VERIFICATION NOTE: similar to Add and Mul traits,\n    we want from_req from above to apply here, but Verus does not yet support this\n    */\n\n        ensures\n            is_valid_lookup_table_affine(result.0, *P, 8 as nat),\n    {\n        /* ORIGINAL CODE: for generic $name, $size, and conv_range.\n\n         let mut points = [P.as_affine_niels(); $size];\n                // XXX batch inversion would be good if perf mattered here\n                for j in $conv_range {\n                    points[j + 1] = (P + &points[j]).as_extended().as_affine_niels()\n                }\n                $name(points)\n\n        In our instantiation we have $name = LookupTable, $size = 8, and conv_range = 0..7.\n        */\n        // Assume preconditions from FromSpecImpl::from_spec_req\n        proof {\n            assume(edwards_point_limbs_bounded(*P));\n        }\n\n        let mut points = [P.as_affine_niels();8];\n        // XXX batch inversion would be good if perf mattered here\n        for j in 0..7 {\n            // ORIGINAL CODE:\n            // points[j + 1] = (P + &points[j]).as_extended().as_affine_niels()\n            // For Verus: unroll to assume preconditions for intermediate operations\n            proof {\n                // Preconditions for P (left-hand side of addition)\n                assume(is_well_formed_edwards_point(*P));\n                assume(sum_of_limbs_bounded(&P.Z, &P.Z, u64::MAX));  // for Z2 = &P.Z + &P.Z in add\n                // Preconditions for &points[j] (right-hand side - AffineNielsPoint)\n                assume(fe51_limbs_bounded(&&points[j as int].y_plus_x, 54));\n                assume(fe51_limbs_bounded(&&points[j as int].y_minus_x, 54));\n                assume(fe51_limbs_bounded(&&points[j as int].xy2d, 54));\n            }\n            let sum = P + &points[j];\n            proof {\n                // Preconditions for sum.as_extended()\n                assume(fe51_limbs_bounded(&sum.X, 54));\n                assume(fe51_limbs_bounded(&sum.Y, 54));\n                assume(fe51_limbs_bounded(&sum.Z, 54));\n                assume(fe51_limbs_bounded(&sum.T, 54));\n            }\n            let extended = sum.as_extended();\n            proof {\n                // Preconditions for extended.as_affine_niels()\n                assume(edwards_point_limbs_bounded(extended));\n            }\n            points[j + 1] = extended.as_affine_niels()\n        }\n        let result = LookupTable(points);\n        proof {\n            assume(is_valid_lookup_table_affine(result.0, *P, 8 as nat));\n        }\n        result\n    }",
      "start_line": 450,
      "end_line": 12,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#bits_le().",
      "display_name": "bits_le",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#bits_le().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn bits_le(&self) -> (result: [bool; 256])\n        ensures\n            bits_to_nat(&result) == bytes_to_nat(&self.bytes),\n    {\n        let mut bits = [false;256];\n        let mut i: usize = 0;\n\n        while i < 256\n            invariant\n                i <= 256,\n                bits.len() == 256,\n                self.bytes.len() == 32,\n            decreases 256 - i,\n        {\n            // As i runs from 0..256, the bottom 3 bits index the bit, while the upper bits index\n            // the byte. Since self.bytes is little-endian at the byte level, this is\n            // little-endian on the bit level\n            let byte_idx = i >> 3;  // Divide by 8 to get byte index\n            let bit_idx = (i & 7) as u8;  // Modulo 8 to get bit position within byte\n\n            // Prove bounds using shift and mask lemmas\n            proof {\n                assert(i < 256);\n\n                // Prove i >> 3 = i / 8 using shift lemma\n                lemma_u64_shr_is_div(i as u64, 3);\n                // pow2(3) = 8\n                lemma2_to64();\n                assert(byte_idx < 32);\n\n                // Prove i & 7 = i % 8 using mask lemma\n                lemma_u64_low_bits_mask_is_mod(i as u64, 3);\n                // low_bits_mask(3) = 7 and pow2(3) = 8\n                lemma2_to64();\n                assert(bit_idx < 8);\n            }\n\n            bits[i] = ((self.bytes[byte_idx] >> bit_idx) & 1u8) == 1;\n            i += 1;\n        }\n\n        proof {\n            assume(bits_to_nat(&bits) == bytes_to_nat(&self.bytes));\n        }\n\n        bits\n    }",
      "start_line": 1934,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field_add_16p_no_overflow().",
      "display_name": "lemma_field_add_16p_no_overflow",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field_add_16p_no_overflow().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/add_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/add_lemmas.rs",
      "file_name": "add_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_field_add_16p_no_overflow(lhs: &FieldElement51, rhs: &FieldElement51)\n    requires\n        fe51_limbs_bounded(lhs, 54),\n        fe51_limbs_bounded(rhs, 54),\n    ensures\n// Adding 16p constants won't overflow\n\n        lhs.limbs[0] <= u64::MAX - 36028797018963664u64,\n        lhs.limbs[1] <= u64::MAX - 36028797018963952u64,\n        lhs.limbs[2] <= u64::MAX - 36028797018963952u64,\n        lhs.limbs[3] <= u64::MAX - 36028797018963952u64,\n        lhs.limbs[4] <= u64::MAX - 36028797018963952u64,\n        rhs.limbs[0] < 36028797018963664u64,\n        rhs.limbs[1] < 36028797018963952u64,\n        rhs.limbs[2] < 36028797018963952u64,\n        rhs.limbs[3] < 36028797018963952u64,\n        rhs.limbs[4] < 36028797018963952u64,\n{\n    let c0 = 36028797018963664u64;  // 16 * (2^51 - 19)\n    let c = 36028797018963952u64;  // 16 * (2^51 - 1)\n\n    // Bound lhs limbs so adding the constants cannot overflow a u64\n    assert(lhs.limbs[0] <= u64::MAX - c0) by {\n        assert(((1u64 << 54) - 1) <= u64::MAX - c0) by (compute);\n    }\n    assert(lhs.limbs[1] <= u64::MAX - c) by {\n        assert(((1u64 << 54) - 1) <= u64::MAX - c) by (compute);\n    }\n    assert(lhs.limbs[2] <= u64::MAX - c) by {\n        assert(((1u64 << 54) - 1) <= u64::MAX - c) by (compute);\n    }\n    assert(lhs.limbs[3] <= u64::MAX - c) by {\n        assert(((1u64 << 54) - 1) <= u64::MAX - c) by (compute);\n    }\n    assert(lhs.limbs[4] <= u64::MAX - c) by {\n        assert(((1u64 << 54) - 1) <= u64::MAX - c) by (compute);\n    }\n\n    // Bound rhs limbs to be less than the constants\n    assert(rhs.limbs[0] < c0) by {\n        assert((1u64 << 54) <= c0) by (compute);\n    }\n    assert(rhs.limbs[1] < c) by {\n        assert((1u64 << 54) <= c) by (compute);\n    }\n    assert(rhs.limbs[2] < c) by {\n        assert((1u64 << 54) <= c) by (compute);\n    }\n    assert(rhs.limbs[3] < c) by {\n        assert((1u64 << 54) <= c) by (compute);\n    }\n    assert(rhs.limbs[4] < c) by {\n        assert((1u64 << 54) <= c) by (compute);\n    }\n}",
      "start_line": 47,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#ConditionallySelectable#conditional_select().",
      "display_name": "conditional_select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#ConditionallySelectable#conditional_select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::conditional_select(&a.Y_plus_X, &b.Y_plus_X, choice),\n            Y_minus_X: FieldElement::conditional_select(&a.Y_minus_X, &b.Y_minus_X, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T2d: FieldElement::conditional_select(&a.T2d, &b.T2d, choice),\n        }\n    }",
      "start_line": 364,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#encode_253_bits().",
      "display_name": "encode_253_bits",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#encode_253_bits().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    pub fn encode_253_bits(data: &[u8; 32]) -> Option<RistrettoPoint> {\n        if data.len() != 32 {\n            return None;\n        }\n\n        let fe = FieldElement::from_bytes(data);\n        let p = RistrettoPoint::elligator_ristretto_flavor(&fe);\n        Some(p)\n    }",
      "start_line": 75,
      "end_line": 27,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_product_of_field_elems().",
      "display_name": "spec_product_of_field_elems",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_product_of_field_elems().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn spec_product_of_field_elems(fields: Seq<FieldElement51>) -> nat\n    decreases fields.len(),\n{\n    if fields.len() == 0 {\n        1\n    } else {\n        (spec_product_of_field_elems(fields.skip(1)) * spec_field_element(&fields[0])) % p()\n    }\n}",
      "start_line": 421,
      "end_line": 45,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_neg_one().",
      "display_name": "lemma_sqrt_m1_neq_neg_one",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_neg_one().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/sqrt_ratio_lemmas.rs",
      "file_name": "sqrt_ratio_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_sqrt_m1_neq_neg_one()\n    ensures\n        spec_sqrt_m1() % p() != (p() - 1) as nat,\n{\n    pow255_gt_19();\n    \n    // Step 1: i² = p - 1 (which is -1 mod p)\n    assert((spec_sqrt_m1() * spec_sqrt_m1()) % p() == (p() - 1)) by {\n        axiom_sqrt_m1_squared();\n    };\n    \n    // Step 2: p > 2\n    assert(p() > 2) by {\n        p_gt_2();\n    };\n    \n    // Step 3: (p-1) * (p-1) % p = 1 (since (p-1)² ≡ (-1)² ≡ 1 mod p)\n    let pm1: nat = (p() - 1) as nat;\n    assert(pm1 < p());\n    assert((pm1 * pm1) % p() == 1nat) by {\n        lemma_square_of_complement(1, p());\n        lemma_small_mod(1, p());\n    };\n    \n    // Step 4: Key connection - a² % p == (a % p)² % p\n    // Using lemma_mul_mod_noop_general\n    let i = spec_sqrt_m1();\n    assert((i * i) % p() == ((i % p()) * (i % p())) % p()) by {\n        lemma_mul_mod_noop_general(i as int, i as int, p() as int);\n    };\n    \n    // Step 5: Since (pm1*pm1) % p = 1 ≠ p - 1 = i² % p (because p > 2), we have i % p ≠ pm1\n    assert(pm1 != 1);  // Because p > 2\n    \n    // Therefore if spec_sqrt_m1() % p() == pm1:\n    // i² % p = ((i % p) * (i % p)) % p = (pm1 * pm1) % p = 1\n    // But i² % p = p - 1\n    // So 1 == p - 1, but p > 2, contradiction\n}",
      "start_line": 174,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_1().",
      "display_name": "step_1",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_1().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "curve25519-dalek/src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub(super) fn step_1(repr: &CompressedRistretto) -> (Choice, Choice, FieldElement) {\n        // Step 1. Check s for validity:\n        // 1.a) s must be 32 bytes (we get this from the type system)\n        // 1.b) s < p\n        // 1.c) s is nonnegative\n        //\n        // Our decoding routine ignores the high bit, so the only\n        // possible failure for 1.b) is if someone encodes s in 0..18\n        // as s+p in 2^255-19..2^255-1.  We can check this by\n        // converting back to bytes, and checking that we get the\n        // original input, since our encoding routine is canonical.\n\n        let s = FieldElement::from_bytes(repr.as_bytes());\n        let s_bytes_check = s.as_bytes();\n        let s_encoding_is_canonical = s_bytes_check[..].ct_eq(repr.as_bytes());\n        let s_is_negative = s.is_negative();\n\n        (s_encoding_is_canonical, s_is_negative, s)\n    }",
      "start_line": 274,
      "end_line": 25,
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "display_name": "from_canonical_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "curve25519-dalek/src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn from_canonical_bytes(bytes: [u8; 32]) -> (result: CtOption<Scalar>)\n        ensures\n            bytes_to_nat(&bytes) < group_order() ==> ct_option_has_value(result),\n            bytes_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result),\n            ct_option_has_value(result) ==> bytes_to_nat(&ct_option_value(result).bytes)\n                % group_order() == bytes_to_nat(&bytes) % group_order(),\n    {\n        /* <ORIGINAL CODE>\n          let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let high_byte_shifted = bytes[31] >> 7;\n        let high_bit_unset = ct_eq_u8(&high_byte_shifted, &0);\n        /* </MODIFIED CODE> */\n\n        let candidate = Scalar { bytes };\n        let is_canonical = candidate.is_canonical();\n\n        /* <ORIGINAL CODE>\n          CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n          </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let condition = choice_and(high_bit_unset, is_canonical);\n        let result = ct_option_new(candidate, condition);\n        /* </MODIFIED CODE> */\n\n        // Capture the high byte value for proof (avoids Verus interpreter issues)\n        let ghost high_byte: u8 = bytes[31];\n\n        proof {\n            if bytes_to_nat(&bytes) < group_order() {\n                use crate::lemmas::scalar_lemmas::lemma_canonical_bytes_high_bit_clear;\n                lemma_canonical_bytes_high_bit_clear(&candidate.bytes);\n                assert(high_byte >> 7 == 0) by (bit_vector)\n                    requires\n                        high_byte <= 127,\n                ;\n            }\n            // ct_option_value(result) == candidate and candidate.bytes == bytes\n\n            assert(ct_option_value(result).bytes == bytes);\n        }\n\n        result\n    }",
      "start_line": 326,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_multiscalar_mul().",
      "display_name": "vartime_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "curve25519-dalek/src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn vartime_multiscalar_mul<I>(&self, static_scalars: I) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n    {\n        use core::iter;\n\n        Self::vartime_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            iter::empty::<Scalar>(),\n            iter::empty::<Self::Point>(),\n        )\n    }",
      "start_line": 317,
      "end_line": 31,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        /* ORIGINAL CODE: self.limbs.zeroize(); */\n        crate::core_assumes::zeroize_limbs5(&mut self.limbs);\n    }",
      "start_line": 125,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "display_name": "math_field_inv",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/specs/field_specs.rs",
      "relative_path": "curve25519-dalek/src/specs/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "specs",
      "body": "pub open spec fn math_field_inv(a: nat) -> nat {\n    if a % p() == 0 {\n        0  // Convention: inverse of 0 is defined as 0\n\n    } else {\n        spec_mod_inverse(a, p())\n    }\n}",
      "start_line": 125,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 31,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_sub_eq_implies_zero().",
      "display_name": "lemma_mod_sub_eq_implies_zero",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_sub_eq_implies_zero().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "file_name": "number_theory_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "proof fn lemma_mod_sub_eq_implies_zero(x: int, y: int, m: int)\n    requires\n        m > 0,\n        x % m == y % m,\n    ensures\n        (x - y) % m == 0,\n{\n    // By lemma_sub_mod_noop: (x - y) % m == ((x % m) - (y % m)) % m\n    lemma_sub_mod_noop(x, y, m);\n    // Since x % m == y % m, we have (x - y) % m == (r - r) % m == 0 % m == 0\n    lemma_small_mod(0nat, m as nat);\n}",
      "start_line": 750,
      "end_line": 39,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c3_0_val().",
      "display_name": "c3_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c3_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn c3_0_val(a: [u64; 5]) -> u128 {\n    (a[4] * (19 * a[4]) + 2 * (a[0] * a[3] + a[1] * a[2])) as u128\n}",
      "start_line": 48,
      "end_line": 26,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "display_name": "double",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    pub fn double(&self) -> (result: CompletedPoint)\n        requires\n            is_valid_projective_point(*self),\n            // preconditions for arithmetic traits\n            fe51_limbs_bounded(&self.X, 54),\n            fe51_limbs_bounded(&self.Y, 54),\n            fe51_limbs_bounded(&self.Z, 54),\n            sum_of_limbs_bounded(&self.X, &self.Y, u64::MAX),\n        ensures\n            is_valid_completed_point(result),\n            // The result represents the affine doubling of self\n            completed_point_as_affine_edwards(result) == ({\n                let (x, y) = projective_point_as_affine_edwards(*self);\n                edwards_double(x, y)\n            }),",
      "start_line": 524,
      "end_line": 18,
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "curve25519-dalek/src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn default() -> (result: CompressedEdwardsY)\n        ensures\n    // Identity point has y = 1 and sign bit = 0\n\n            spec_field_element_from_bytes(&result.0) == 1,\n            (result.0[31] >> 7) == 0,\n    {\n        CompressedEdwardsY::identity()\n    }",
      "start_line": 775,
      "end_line": 15,
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn identity() -> (result: ProjectivePoint)\n        ensures\n            result == identity_projective_point_edwards(),\n    {\n        ProjectivePoint { X: FieldElement::ZERO, Y: FieldElement::ONE, Z: FieldElement::ONE }\n    }",
      "start_line": 238,
      "end_line": 16,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select_u8().",
      "display_name": "select_u8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select_u8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn select_u8(a: &u8, b: &u8, c: Choice) -> (res: u8)\n    ensures\n        !choice_is_true(c) ==> res == *a,\n        choice_is_true(c) ==> res == *b,\n{\n    u8::conditional_select(a, b, c)\n}",
      "start_line": 66,
      "end_line": 17,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/slice128_to_nat_exec().",
      "display_name": "slice128_to_nat_exec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/slice128_to_nat_exec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn slice128_to_nat_exec(limbs: &[u128; 9]) -> BigUint {\n        let mut result = BigUint::zero();\n        let radix = BigUint::from(1u128 << 52);\n        for i in (0..9).rev() {\n            result = result * &radix + BigUint::from(limbs[i]);\n        }\n        result\n    }",
      "start_line": 1232,
      "end_line": 32,
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_by_minus_one_is_negation().",
      "display_name": "lemma_mul_by_minus_one_is_negation",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_by_minus_one_is_negation().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "relative_path": "curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_lemmas",
      "body": "pub proof fn lemma_mul_by_minus_one_is_negation(a: nat, m: nat)\n    requires m > 0,\n    ensures (a * ((m - 1) as nat)) % m == ((m - a % m) as nat) % m,\n{\n    let a_mod = a % m;\n    let m_minus_1: nat = (m - 1) as nat;\n    let neg_a: nat = (m - a_mod) as nat;\n    \n    lemma_mod_bound(a as int, m as int);  // a_mod < m\n    \n    // Step 1: a * (m-1) = a*m - a [distributive]\n    assert(a * m_minus_1 == a * m - a) by {\n        lemma_mul_is_distributive_sub(a as int, m as int, 1int);\n    };\n    \n    // Step 2: (a*m) % m = 0\n    assert((a * m) % m == 0) by {\n        lemma_mod_multiples_basic(a as int, m as int);\n    };\n    \n    // Step 3: (a*m - a) % m = (0 - a_mod) % m [by sub_mod_noop]\n    assert(((a * m) as int - a as int) % (m as int) == (0int - a_mod as int) % (m as int)) by {\n        lemma_sub_mod_noop((a * m) as int, a as int, m as int);\n    };\n    \n    // Step 4: (0 - a_mod) % m = (m - a_mod) % m [add m to get positive representative]\n    assert((0int - a_mod as int) % (m as int) == (m as int - a_mod as int) % (m as int)) by {\n        lemma_mod_add_multiples_vanish(-(a_mod as int), m as int);\n    };\n    \n    // Step 5: Connect int form to nat form\n    assert((m as int - a_mod as int) % (m as int) == (neg_a as int) % (m as int));\n    \n    // Step 6: Show a*m >= a (so subtraction is non-negative)\n    assert((a as int) * (m as int) >= a as int) by {\n        lemma_mul_inequality(1int, m as int, a as int);\n        lemma_mul_is_commutative(1int, a as int);\n        lemma_mul_is_commutative(m as int, a as int);\n    };\n    \n    // Step 7: Connect nat % nat form\n    assert((a * m_minus_1) as int == (a as int) * (m as int) - (a as int));\n    assert((a * m_minus_1) as int >= 0);\n    assert((a * m_minus_1) % m == neg_a % m);\n}",
      "start_line": 298,
      "end_line": 48,
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    }
  ],
  "links": [
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub_new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub_new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub_new().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub_new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub_new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_extended_coord_when_z_is_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_extended_coord_when_z_is_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_extended_coord_when_z_is_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_extended_coord_when_z_is_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_extended_coord_when_z_is_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_nonzero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_nonzero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_y_squared_neq_one_implies_x_nonzero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_x_zero_implies_y_squared_one().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_y_squared_neq_one_implies_x_nonzero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_y_squared_neq_one_implies_x_nonzero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_y_squared_neq_one_implies_x_nonzero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_loop2_invariant().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_loop2_invariant().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_identity_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_is_zero_when_divisible().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_is_zero_when_divisible().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_is_zero_when_divisible().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strict_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_left_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nat_is_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_k().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_nine_limbs_two_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_bounded_scalar52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_nine_limbs_two_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_nine_limbs_two_bounded().",
      "target": "rust-analyzer cargo proptest 1.9.0 traits/strategy/Strategy#prop_map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Hash#hash().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Hash#hash().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Hash#hash().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_to_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Hash#hash().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Hash#hash().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core array/Hash#hash().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_basics_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field_add_16p_no_overflow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_sub_constants_equal_16p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_sum_factor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_twice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sub_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_quotient_of_squares().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_quotient_of_squares().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_quotient_of_squares().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_quotient_of_squares().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_quotient_of_squares().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_product_of_squares_eq_square_of_product().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_quotient_of_squares().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_quotient_of_squares().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_equals_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_montgomery_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c2_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_1_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c3_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_val_boundaries().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c4_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_boundary_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_shift_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ai_val_boundaries().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/carry_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_2_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_shr_51_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_0_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_0_val_boundaries().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c1_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_masked_lt_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a4_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a1_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/term_product_bounds_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a2_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a3_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_term_product_bounds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_product_of_squares_eq_square_of_product().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_product_of_squares_eq_square_of_product().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_product_of_squares_eq_square_of_product().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_product_of_squares_eq_square_of_product().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_product_of_squares_eq_square_of_product().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_product_of_squares_eq_square_of_product().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_product_of_squares_eq_square_of_product().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_from_montgomery_limbs_conversion().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_from_montgomery_limbs_conversion().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_five_limbs_equals_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_from_montgomery_limbs_conversion().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/nine_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_from_montgomery_limbs_conversion().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_from_montgomery_limbs_conversion().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_from_montgomery_limbs_conversion().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_nine_limbs_equals_slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#efgh().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#zip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#decode_253_bits().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#elligator_ristretto_flavor_inverse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t3_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t3().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t3_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t3().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_pow2k_step().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t3_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t3().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_geometric_mul_step().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t3_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t3().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t3_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t3().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t3_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t3().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t3_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t3().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#part1().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/wrapping_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#part1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/m().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_carry_bounded_after_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_loop2_invariant().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_correct_after_loops().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_borrow_and_mask_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_loop1_invariant().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_scalar_subtract_no_overflow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/completed_point_as_affine_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_add_affine_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_add_projective_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_completed_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_spec_load8_at_fits_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_as_nat_32_mod_255().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_nonnegative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_pow2k_step().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_congruent().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_multiplies().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_geometric_mul_step().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_geometric().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a1_1_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_1_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a1_1_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a1_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/m().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/bits_to_nat_rec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_close_mod_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_close_mod_u8().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_close_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_close_mod_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_limbs_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_negate_generic().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_mul_si_vi_and_reorder().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_5_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_mul_si_vi_and_reorder().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_mul_si_vi_and_reorder().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_quad_prod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_affine_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/axiom_ed25519_basepoint_table_valid().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_basepoint_table().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/axiom_ed25519_basepoint_table_valid().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_ed25519_basepoint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/bytes_match_limbs_packing_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb1_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_byte_from_limb_shift_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_is_sqrt_ratio_to_math_field().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_curve_semantics().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_u_zero_implies_identity_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_failure_means_invalid_y().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_left().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_valid_y_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/math_on_montgomery_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/math_on_montgomery_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/math_on_montgomery_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/math_on_montgomery_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_one_of_fourth_roots().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fourth_root_of_unity_values().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_one_of_fourth_roots().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "target": "rust-analyzer cargo rand 0.8.5 thread/rngs/ThreadRng#RngCore#fill_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "target": "rust-analyzer cargo rand 0.8.5 thread/rngs/thread_rng().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#enumerate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#xcoset4().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#elligator_ristretto_flavor_inverse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_fourth_root_of_unity().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_fourth_root_of_unity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_equals_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_equals_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_five_limbs_equals_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_equals_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_equals_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_equals_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_equals_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_equals_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_equals_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/five_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_equals_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Debug#fmt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Debug#fmt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Debug#fmt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_general_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_general_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_general_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_general_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_general_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_general_bound().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_general_bound().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_general_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq_lib/Seq#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_general_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_close_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/pow2_MUL_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_close_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_close_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_distributes_over_neg_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_distributes_over_neg_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_distributes_over_neg_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_distributes_over_neg_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_distributes_over_neg_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_distributes_over_neg_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_add_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_distributes_over_neg_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_distributes_over_neg_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb3_byte_contribution().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/lookup_table_projective_limbs_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/lookup_table_projective_limbs_bounded().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_add_fe51_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field51_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/test_canonical_scalar_generator().",
      "target": "rust-analyzer cargo proptest 1.9.0 runner/test_runner/TestRunner#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/test_canonical_scalar_generator().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#copied().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/test_canonical_scalar_generator().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_canonical_scalar52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/test_canonical_scalar_generator().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#unwrap().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/test_canonical_scalar_generator().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/group_order_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/test_canonical_scalar_generator().",
      "target": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#Clone#clone().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/test_canonical_scalar_generator().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/to_nat_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/test_canonical_scalar_generator().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/first().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/test_canonical_scalar_generator().",
      "target": "rust-analyzer cargo num-bigint 0.4.6 convert/biguint/BigUint#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/test_canonical_scalar_generator().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#enumerate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/test_canonical_scalar_generator().",
      "target": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#to_u64_digits().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/test_canonical_scalar_generator().",
      "target": "rust-analyzer cargo proptest 1.9.0 config/test_runner/Config#Default#default().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/test_canonical_scalar_generator().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/test_canonical_scalar_generator().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#unwrap_or().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_mul_v0_and_reorder().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_5_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_mul_v0_and_reorder().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_truncate_middle().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_affine_niels_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/edwards_y_from_montgomery_u().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/edwards_y_from_montgomery_u().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/edwards_y_from_montgomery_u().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/edwards_y_from_montgomery_u().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#as_affine().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#as_affine().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_montgomery_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#as_affine().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#as_affine().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#as_affine().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#as_affine().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#as_affine().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_square_matches_math_field_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_square_matches_math_field_square().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_square_matches_math_field_square().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_square_matches_math_field_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_square_matches_math_field_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_u8().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_u8().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_sign_bit_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_sign_bit_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_sign_bit_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sign_bit_after_conditional_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/reduce_with_q_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_unmasked_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_limb_from_adjacent_words().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bit_or_is_plus().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_limb_from_adjacent_words().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_to_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from4().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_to_le_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/to_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_to_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_ed25519_basepoint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Identity#identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/spec_montgomery().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Identity#identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_zero_case().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_zero_case().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_zero_case().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_zero_case().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma0_pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_zero_case().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_zero_case().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_zero_case().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_is_mod_recursive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_projective_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_projective_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_projective_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_point_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_projective_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_negate_projective_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_by_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_by_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_by_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_by_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_by_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_by_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_by_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_canonical_scalar52().",
      "target": "rust-analyzer cargo proptest 1.9.0 traits/strategy/Strategy#prop_map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_canonical_scalar52().",
      "target": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#to_u64_digits().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_canonical_scalar52().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/first().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_canonical_scalar52().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#copied().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_canonical_scalar52().",
      "target": "rust-analyzer cargo proptest 1.9.0 traits/arbitrary/any().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_canonical_scalar52().",
      "target": "rust-analyzer cargo proptest 1.9.0 collection/vec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_canonical_scalar52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/group_order_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_canonical_scalar52().",
      "target": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#from_bytes_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_canonical_scalar52().",
      "target": "rust-analyzer cargo num-bigint 0.4.6 convert/biguint/BigUint#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_canonical_scalar52().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#unwrap_or().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_sqrt_m1_not_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/axiom_p_is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_square_mod_p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_quotient_of_squares().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_neg_sqrt_m1_not_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_sqrt_m1_squared().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_shift_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c2_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_shift_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_shr_51_fits_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_shift_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_shift_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c4_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_shift_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_val_boundaries().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_shift_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c1_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_shift_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c3_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_shift_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_0_val_boundaries().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_completed_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_valid_y_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/edwards_lemmas/lemmas/lemma_edwards_d_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_square_matches_math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_field_element_value().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_case_analysis().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_sqrt_ratio().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#expect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/copy_from_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#finalize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#update().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_cofactor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sign_bit_one_implies_x_nonzero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/binomial_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/binomial_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/binomial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_montgomery_affine().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/math_on_montgomery_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple_is_strongly_ordered().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_le_max64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_is_ordered_by_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_u8_cast_is_mod_256().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bit_or_is_plus().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_quad_prod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/carry_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c4_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_assign_generic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/negate_projective_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_negate_generic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/identity_affine_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/negate_affine_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_u16().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/lookup_table_projective_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/identity_projective_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_sum_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/zeroize_bytes32().",
      "target": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_decomposition_prefix_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_sum_factor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/lemma_u8_32_as_nat_equals_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_rec_suffix_divisible().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/as_nat_prefix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_point_as_affine_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_point_as_affine_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_point_as_affine_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_point_as_affine_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_point_as_affine_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_negate_field_element().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_negate_field_element().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_p58_lemma/field_lemmas/lemmas/lemma_pow_p58_prove().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_pow2k_step().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_p58_lemma/field_lemmas/lemmas/lemma_pow_p58_prove().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_p58_lemma/field_lemmas/lemmas/lemma_pow_p58_prove().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_p58_lemma/field_lemmas/lemmas/lemma_pow_p58_prove().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_p58_lemma/field_lemmas/lemmas/lemma_pow_p58_prove().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_p58_lemma/field_lemmas/lemmas/lemma_pow_p58_prove().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_p58_lemma/field_lemmas/lemmas/lemma_pow_p58_prove().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_p58_lemma/field_lemmas/lemmas/lemma_pow_p58_prove().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_p58_lemma/field_lemmas/lemmas/lemma_pow_p58_prove().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_p58_lemma/field_lemmas/lemmas/lemma_pow_p58_prove().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_p58_lemma/field_lemmas/lemmas/lemma_pow_p58_prove().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_p58_lemma/field_lemmas/lemmas/lemma_pow_p58_prove().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_geometric_mul_step().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_p58_lemma/field_lemmas/lemmas/lemma_pow_p58_prove().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_low_recombine().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_low_recombine().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_low_recombine().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_low_recombine().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_low_recombine().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_seq_u64_to_nat_subrange_extend().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_seq_u64_to_nat_subrange_extend().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_seq_u64_to_nat_subrange_extend().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_seq_u64_to_nat_subrange_extend().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq_lib/Seq#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_nine_limbs_one_canonical().",
      "target": "rust-analyzer cargo proptest 1.9.0 traits/strategy/Strategy#prop_map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_nine_limbs_one_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_canonical_scalar52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_nine_limbs_one_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_nine_limbs_one_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_bounded_scalar52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/check_equals_u_times_fourth_root().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/check_equals_u_times_fourth_root().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fourth_root_of_unity_values().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_sqrt_ratio().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_sqrt_ratio().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_canonical_bytes_equal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_to_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_compute_q().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/reduce_with_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/bytes_match_limbs_packing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limbs_to_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_montgomery_lift().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_rhs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_montgomery_lift().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_sqrt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_montgomery_lift().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_u_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_montgomery_lift().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoBasepointTable#basepoint().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#basepoint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c0_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c0_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_add_projective_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_add_projective_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_niels_point_as_affine_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_add_projective_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_add_fe51_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field51_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow252().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow252().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow252().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_scalar_mul_u().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/spec_clamp_integer().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/clamp_integer().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_montgomery_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/spec_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/spec_montgomery().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_x25519_basepoint_u().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow2_260_greater_than_2_group_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow2_260_greater_than_2_group_order().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow2_260_greater_than_2_group_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow252().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow2_260_greater_than_2_group_order().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow2_260_greater_than_2_group_order().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_4_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_4_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_4_terms().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_3_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat_rec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Debug#fmt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Debug#fmt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Debug#fmt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#coset4().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#vartime_double_scalar_mul_basepoint().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/vartime_double_base_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow252().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_five_limbs_equals_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/five_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_into().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_into().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimeMultiscalarMul#vartime_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimeMultiscalarMul#optional_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimeMultiscalarMul#vartime_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#expect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimeMultiscalarMul#vartime_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_cofactor().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_cofactor().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_p_minus_1_div_4().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_left().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_p_minus_1_div_4().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_p_minus_1_div_4().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_p_minus_1_div_4().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_p_minus_1_div_4().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_p_minus_1_div_4().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/product_of_scalars().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/product_of_scalars().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq/Seq#skip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/product_of_scalars().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_left_right_shift().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_basic_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_nonincreasing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_multiply_divide_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitwise_or_l_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_le_max64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bit_or_is_plus().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitwise_or_r_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_decreases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#elligator_ristretto_flavor_inverse().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#elligator_ristretto_flavor_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#to_jacobi_quartic_ristretto().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_sqrt_m1_not_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_sqrt_m1_not_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_square_mod_p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_multiply_by_i_flips_sign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_sqrt_m1_squared().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_multiply_by_i_flips_sign().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_multiply_by_i_flips_sign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_by_minus_one_is_negation().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_multiply_by_i_flips_sign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_multiply_by_i_flips_sign().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_left().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_multiply_by_i_flips_sign().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_multiply_by_i_flips_sign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_multiply_by_i_flips_sign().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_twice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_multiply_by_i_flips_sign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_product_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_multiply_by_i_flips_sign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#from_uniform_bytes_single_elligator().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#from_uniform_bytes_single_elligator().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/word_from_bytes_partial().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/word_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/word_from_bytes_partial().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_plus_ver_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_plus_ver_div_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_fits_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_plus_ver_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_plus_ver_div_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_rec_is_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_plus_ver_div_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_plus_ver_div_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/load8_at_plus_version_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_plus_ver_div_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_fits_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_plus_ver_div_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_le_max64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/completed_point_as_affine_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/completed_point_as_affine_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/completed_point_as_affine_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_cast_then_mod_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_1_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_boundary_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a2_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c3_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_diff_factor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a1_1_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_squared().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a3_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c1_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a1_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c1_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nat_is_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_div_and_mod_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c2_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_return().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/l51_bit_mask_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/carry_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c0_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c4_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c2_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a4_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_2_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c4_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_reorder_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c3_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_mul_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_nonzero_mod_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_nonzero_mod_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_nonzero_mod_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#Identity#identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_strictly_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple_is_strongly_ordered().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_strictly_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/lemma_u8_32_as_nat_equals_rec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/lemma_u8_32_as_nat_equals_rec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bytes_to_nat_rec_bound().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bytes_to_nat_rec_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_u16().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_u16().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_niels_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#expect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#to_radix_2w_size_hint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#by_ref().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#size_hint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core map/adapters/iter/Map#Iterator#fold().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#cmp().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core map/adapters/iter/Map#Iterator#next().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_projective_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_point_as_affine_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_to_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_to_nat_gen_u32().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/copy_from_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#unwrap_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#digest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core array/Default#default().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#elligator_ristretto_flavor_inverse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#enumerate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_0_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/as_nat_prefix().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_montgomery_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_scalar_mul_u().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_x25519_basepoint_u().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/spec_montgomery().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/spec_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#to_montgomery().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limbs_to_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_compute_q().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/reduce_with_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/bit_arrange().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_bridge_pow_as_nat_to_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_p58_lemma/field_lemmas/lemmas/lemma_pow_p58_prove().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_term_product_bounds().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_m().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_term_product_bounds().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/term_product_bounds_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_term_product_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_equal_to_minus_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/clamp_integer().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/spec_clamp_integer().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/clamp_integer().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_clamped_integer().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_power_addition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_exponent_arithmetic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/lemma_fermat_for_p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_power_chain().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_multiply_by_base_power_addition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/inv_montgomery_radix().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_point_as_affine_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_point_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_point_as_affine_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_point_as_affine_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/nine_limbs_to_nat_aux().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_div_and_mod_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_two_factoring_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/l51_bit_mask_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_basic_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_boundaries().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#random().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_uniform_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_from_bytes_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/word_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_from_bytes_to_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_square_mod_noop().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_square_mod_noop().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_square_mod_noop().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_left().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_square_mod_noop().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_square_mod_noop().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_bounded_scalar52().",
      "target": "rust-analyzer cargo proptest 1.9.0 array/uniform5().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_bounded_scalar52().",
      "target": "rust-analyzer cargo proptest 1.9.0 traits/strategy/Strategy#prop_map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Identity#identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/identity_projective_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Sum#sum().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#fold().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Sum#sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_le_max64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/zeroize_limbs5().",
      "target": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_x_zero_implies_y_squared_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_x_zero_implies_y_squared_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_x_zero_implies_y_squared_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_x_zero_implies_y_squared_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_x_zero_implies_y_squared_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_by_zero_is_zero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_x_zero_implies_y_squared_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_x_zero_implies_y_squared_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_x_zero_implies_y_squared_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_x_zero_implies_y_squared_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_x_zero_implies_y_squared_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_x_zero_implies_y_squared_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_x_zero_implies_y_squared_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_x_zero_implies_y_squared_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shifted_lt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_le_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shifted_lt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_u64_max_shifting().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shifted_lt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/projective_represents_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/projective_represents_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb0_byte_contribution_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_neg_square_eq().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_neg_square_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_neg_square_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_square_of_complement().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_neg_square_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_neg_square_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_neg_square_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_neg_square_eq().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_self_0().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_ratio_check_structure().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sqrt_ratio_exponent().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_ratio_check_structure().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/check_equals_u_times_fourth_root().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_ratio_check_structure().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_ratio_check_structure().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/to_nat_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_from_bytes().",
      "target": "rust-analyzer cargo proptest 1.9.0 array/uniform32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/bytes_to_nat_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_from_bytes().",
      "target": "rust-analyzer cargo proptest 1.9.0 traits/arbitrary/any().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/limbs_bounded_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_by_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_by_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_by_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_by_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_by_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_by_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#sum_of_slice().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#sum_of_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#sum_of_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_congruent_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#sum_of_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/sum_of_scalars().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#sum_of_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_unmasked_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_compute_q().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_le_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_to_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_to_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_to_le_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/to_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fourth_root_of_unity_values().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fourth_root_of_unity_values().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_produces_valid_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_produces_valid_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_produces_valid_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_produces_valid_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_produces_valid_point().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_produces_valid_point().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_produces_valid_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_inv_one().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_produces_valid_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_square_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_produces_valid_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_composition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_composition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_composition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_composition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_int_nat_mod_equiv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_composition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_multiplies().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_composition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_completed_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_point_as_affine_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/completed_point_as_affine_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_projective_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_to_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_point_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_swap_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_swap_u64().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_swap().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_failure_means_invalid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_failure_means_invalid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_failure_means_invalid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_valid_y_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_failure_means_invalid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_failure_means_invalid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_no_square_root_when_times_i().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_failure_means_invalid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_failure_means_invalid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_failure_means_invalid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_failure_means_invalid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_failure_means_invalid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/spec_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_bytes_wide_to_nat_rec_matches_word_partial().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_bytes_wide_to_nat_rec_matches_word_partial().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_wide_to_nat_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_bytes_wide_to_nat_rec_matches_word_partial().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_bytes_wide_to_nat_rec_matches_word_partial().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/word_from_bytes_partial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#zip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#vartime_double_scalar_mul_basepoint().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#vartime_double_scalar_mul_basepoint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#new().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/negate_projective_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_square_of().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_square_of().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_point_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_from_limb_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_from_limb_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_from_limb_shift().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_u8_cast_is_mod_256().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/variable_base_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/variable_base_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/get_selected_backend().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_sub_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_left().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_unique().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_sqrt_m1_squared().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_i_inverse_is_neg_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_field_element_sign_bit().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_byte_shr_7_is_bit().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_field_element_sign_bit().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_field_element_sign_bit().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_field_element_sign_bit().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_field_element_sign_bit().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_sign_bit_correct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_field_element_sign_bit().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_field_element_sign_bit().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_negate_affine_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_valid_compressed_enables_sign_proof().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_valid_compressed_enables_sign_proof().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_valid_compressed_enables_sign_proof().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/valid_compressed_for_sign_bit().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_exponent_arithmetic().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_exponent_arithmetic().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_exponent_arithmetic().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_exponent_arithmetic().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_exponent_arithmetic().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_factors_congruent_implies_products_congruent().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_masked_lt_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_le_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_plus_one().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strict_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_u64_max_shifting().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_negate_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#Zeroize#zeroize().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter_mut().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#Zeroize#zeroize().",
      "target": "rust-analyzer cargo zeroize 1.8.2 IterMut#Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/pippenger_optional_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#size_hint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_optional_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#by_ref().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_nondecreasing().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_nondecreasing().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_nondecreasing().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_nondecreasing().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_by_sum().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_nondecreasing().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_nondecreasing().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_nondecreasing().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_le_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_nondecreasing().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_nondecreasing().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_to_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/pow2_MUL_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/pow2_MUL_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/pow2_MUL_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/pow2_MUL_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/pow2_MUL_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_telescoping().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_telescoping().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_telescoping().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_telescoping().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_telescoping().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_telescoping().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_telescoping().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_telescoping().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_of_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_of_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_of_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_multiples_vanish_fancy().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_two_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_two_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/slice128_to_nat_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_two_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/group_order_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_two_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/montgomery_radix_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_two_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/limbs_bounded_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_two_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_nine_limbs_two_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_two_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/to_nat_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/bits_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/bits_to_nat_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_add_then_shift().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_add_then_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_add_then_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_add_then_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_multiply_divide_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_add_then_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_subtracts().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_div().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/pow2_MUL_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_div().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mod_cancel().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mod_cancel().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_add_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mod_cancel().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_setup().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_setup().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_setup().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_setup().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_setup().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_setup().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_setup().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_add_affine_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_add_affine_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_point_as_affine_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_add_affine_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_u64_to_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq_lib/Seq#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_u64_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_power_addition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_power_addition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_power_addition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_power_addition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_power_addition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_int_nat_mod_equiv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_power_addition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#From#from().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_to_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_to_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_to_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_to_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/spec_mul_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_internal_no_overflow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_internal_correct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/m().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Zeroize#zeroize().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_lemmas/lemmas/lemma_rr_equals_radix_squared().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_lemmas/lemmas/lemma_rr_equals_radix_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_lemmas/lemmas/lemma_rr_equals_radix_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/five_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_lemmas/lemmas/lemma_rr_equals_radix_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_five_limbs_equals_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_lemmas/lemmas/lemma_rr_equals_radix_squared().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_lemmas/lemmas/lemma_rr_equals_radix_squared().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_lemmas/lemmas/lemma_rr_equals_radix_squared().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_lemmas/lemmas/lemma_rr_equals_radix_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_lemmas/lemmas/lemma_rr_equals_radix_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_5_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_5_terms().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_4_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_5_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01234().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_mod_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01234().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_7_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01234().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_pow_a_pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01234().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01234().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_0123().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01234().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb4().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01234().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_flipped_sign_becomes_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_flipped_sign_becomes_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_multiply_by_i_flips_sign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_flipped_sign_becomes_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_flipped_sign_becomes_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_double_neg_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_flipped_sign_becomes_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_flipped_sign_becomes_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_twice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_flipped_sign_becomes_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_flipped_sign_becomes_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_flipped_sign_becomes_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_flipped_sign_becomes_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_flipped_sign_becomes_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_flipped_sign_becomes_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_flipped_sign_becomes_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_self_0().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_flipped_sign_becomes_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_distributes_over_neg_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_seq_eq_implies_array_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_pow_a_pow().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_pow_a_pow().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_pow_a_pow().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_pow_a_pow().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_pow_a_pow().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_exponent_arithmetic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_zero_case().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_equals_math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_nine_limbs_equals_slice128_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/nine_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_nine_limbs_equals_slice128_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_masked_lt_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shifted_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_boundaries().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/compressed_edwards_y_corresponds_to_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#unwrap_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_012().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_012().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_012().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_mod_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_012().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_012().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_012().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_pow_a_pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_012().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_8_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_wide_to_nat_rec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_p_mod_8_eq_5().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_p_mod_8_eq_5().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_p_mod_8_eq_5().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_p_mod_8_eq_5().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_p_mod_8_eq_5().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_p_mod_8_eq_5().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_p_mod_8_eq_5().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_left().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_or().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#BitOr#bitor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_or().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_fourth_roots_are_exactly_four().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_one_of_fourth_roots().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_fourth_roots_are_exactly_four().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_fourth_root_of_unity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_cancellation().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_cancellation().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_cancellation().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_cancellation().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_cancellation().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_sub_eq_implies_zero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_cancellation().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_cancellation().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_cancellation().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_cancellation().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_to_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_to_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits_warning().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits().",
      "target": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc string/String#AsRef#as_ref().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits().",
      "target": "rust-analyzer cargo std https://github.com/rust-lang/rust/library/std env/var().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_to_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_equals_spec_fe51_to_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_valid_branch().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_produces_valid_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_valid_branch().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_compressed_edwards_y().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_valid_branch().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_negation_preserves_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_valid_branch().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_valid_branch().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_valid_branch().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_valid_branch().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_precondition_implies_valid_sign_bit().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_valid_branch().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_valid_branch().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_valid_branch().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_field_element_sign_bit().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_valid_branch().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_valid_branch().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_valid_branch().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_sign_bit().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_valid_branch().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_select_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_select_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_5_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_mul_si_vi_and_reorder().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_squared().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_squared().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_sum_factor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_squared().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_squared().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_mul_v0_and_reorder().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow0().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_multiply_step().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Identity#identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/identity_affine_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_to_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_to_le_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/to_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_to_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#is_torsion_free().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/IsIdentity#is_identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bound_scalar().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bound_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bound_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_general_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bound_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_remainder_bound().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_remainder_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_remainder_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_remainder_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#Zeroize#zeroize().",
      "target": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_geometric().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_geometric().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_geometric().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_geometric().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/slice128_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb1().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_inv_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_inv_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_inv_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_property().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_inv_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_inv_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_neg_sqrt_m1_not_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_neg_sqrt_m1_not_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_neg_sqrt_m1_not_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_square_mod_p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Zeroize#zeroize().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Zeroize#zeroize().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/spec_montgomery().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Zeroize#zeroize().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/zeroize_bytes32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_eq().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow0().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_eq().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_eq().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/factorial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_eq().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/product_of_multiples().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_eq().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_eq().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_nonnegative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_twice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_add_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_is_zero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_self_0().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple_is_strongly_ordered().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime_helper().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_left().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_nonincreasing().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_le_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_nonincreasing().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_by_sum().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/edwards_lemmas/lemmas/lemma_edwards_d_limbs_bounded_54().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/edwards_lemmas/lemmas/lemma_edwards_d_limbs_bounded_54().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/edwards_lemmas/lemmas/lemma_edwards_d_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MultiscalarMul#multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/has_inv_mod_p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#size_hint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#by_ref().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_assign_generic().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#non_adjacent_form().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/nine_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/five_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_internal_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_internal_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_five_limbs_equals_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_nine_limbs_equals_slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_double_neg_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_double_neg_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_self_0().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_mod_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_extended_gcd().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_mod_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_gcd().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_bridge_pow_as_nat_to_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_bridge_pow_as_nat_to_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_bridge_pow_as_nat_to_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_bridge_pow_as_nat_to_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_bridge_pow_as_nat_to_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_bridge_pow_as_nat_to_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_bridge_pow_as_nat_to_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field51_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field51_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field51_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field51_add().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_add_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field51_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_add_fe51_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field51_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field51_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field51_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field51_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduce_cancels_r().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduce_cancels_r().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduce_cancels_r().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduce_cancels_r().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_factors_congruent_implies_products_congruent().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduce_cancels_r().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_ed25519_basepoint().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_common_divisor_divides_gcd().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_common_divisor_divides_gcd().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_common_divisor_divides_gcd().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_common_divisor_divides_gcd().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_gcd().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_common_divisor_divides_gcd().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sign_bit_after_conditional_negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sign_bit_after_conditional_negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/lemma_p_is_odd().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sign_bit_after_conditional_negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sign_bit_after_conditional_negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sign_bit_after_conditional_negate().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sign_bit_after_conditional_negate().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb4_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb1_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb0_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/five_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb2_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_sum_equals_byte_nat_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/bytes_match_limbs_packing_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb3_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/get_selected_backend().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_to_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from16().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_to_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_to_le_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/to_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_power_chain().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_power_chain().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_power_chain().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_power_chain().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_exponent_arithmetic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_power_chain().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_power_chain().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_pow2k_to_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_power_chain().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_power_chain().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_power_chain().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_power_chain().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_power_chain().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_power_chain().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_composition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_power_chain().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/group_order_exec().",
      "target": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#One#one().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/group_order_exec().",
      "target": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#parse_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/group_order_exec().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#unwrap().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/product_of_multiples().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/factorial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_cancellation().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_strong().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strictly_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_to_nat_gen_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_sum_simplify().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow2_260_greater_than_2_group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_sum_simplify().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_sum_simplify().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_sum_simplify().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_sum_simplify().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_sum_simplify().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_sum_simplify().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_wide_to_nat_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_from_bytes_to_nat_wide().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/word_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_low_recombine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_to_nat_gen_u64_prefix_matches_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduce_cancels_r().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_low_limbs_encode_low_expr().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_limbs_encode_high_expr().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_multiply_divide_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduced_sum_congruent().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_equals_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_spec_load8_at_fits_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_bytes_wide_to_nat_rec_matches_word_partial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_five_limbs_equals_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bound_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_wide_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_to_nat_gen_u64_bound_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod_converse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_hi_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_equals_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_from_bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_lo_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_plus_ver_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics_4().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_le_max64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_fits_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_low_bits_masks_fit_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/load8_at_plus_version_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_mul_distributes_over_add().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_mul_distributes_over_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_mul_distributes_over_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_mul_distributes_over_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_mul_distributes_over_add().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_mul_distributes_over_add().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_add_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_mul_distributes_over_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_le_implies_div_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_le_implies_div_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_is_ordered().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/axiom_binomial_theorem().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/axiom_binomial_theorem().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/binomial_sum().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_congruent_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_congruent_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_add_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_twice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_stage_division_theorem().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_stage_division_theorem().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_stage_division_theorem().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_stage_division_theorem().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_even_nonnegative().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_even_nonnegative().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_cancels_negatives().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_even_nonnegative().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_even_nonnegative().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_nonnegative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/five_limbs_to_nat_aux().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/BasepointTable#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/clamp_integer().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_extended_gcd_is_gcd().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_gcd().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_extended_gcd_is_gcd().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_extended_gcd().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#TryFrom#try_from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#from_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_u_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_rhs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_u_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_is_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/VartimeEdwardsPrecomputation#VartimePrecomputedMultiscalarMul#new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_to_nat_gen_u64_bound_le().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_to_nat_gen_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_to_nat_gen_u64_bound_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_to_nat_gen_u64_bound_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_to_nat_gen_u64_bound_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_to_nat_gen_u64_bound_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_upper_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_to_nat_gen_u64_bound_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_to_nat_gen_u64_bound_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_bezout_identity().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_bezout_identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_extended_gcd().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_bezout_identity().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_bezout_identity().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_bezout_identity().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#expect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/montgomery_radix_exec().",
      "target": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#One#one().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_carry_propagation_is_division().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_is_ordered_by_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_strictly_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics_3().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_basics_3().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_inverse_of_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_inverse_of_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#to_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#unwrap().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#from_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#decompress().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#unwrap().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_encode().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_lemmas/lemmas/lemma_rr_equals_radix_squared().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_montgomery_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_is_canonical_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_is_canonical_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_canonical_bytes_equal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_is_canonical_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_is_canonical_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_is_canonical_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod_converse_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduced_sum_congruent().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_factors_congruent_implies_products_congruent().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduced_sum_congruent().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduced_sum_congruent().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduced_sum_congruent().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_add_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduced_sum_congruent().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduced_sum_congruent().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduced_sum_congruent().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduced_sum_congruent().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduced_sum_congruent().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_montgomery_reduced_sum_congruent().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_montgomery_inverse().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_montgomery_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/inv_montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_montgomery_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_montgomery_inverse().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_montgomery_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_montgomery_inverse().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#random().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#random().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#random().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_edwards_identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Sum#sum().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#fold().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Sum#sum().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#fold().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Sum#sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Sum#sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb0_byte_contribution().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb2_byte_contribution_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Identity#identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ai_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a2_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ai_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_2_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ai_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ai_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a1_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ai_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a3_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ai_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a4_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ai_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/carry_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ai_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_1_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_bit_partitioning().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_bit_partitioning().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_bit_partitioning().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_bit_partitioning().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_bit_partitioning().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_return().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_2_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_return().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a4_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_return().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a3_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_return().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a1_1_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_return().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a2_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_shr_51_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_shr_51_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#ConditionallySelectable#conditional_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_montgomery_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_equals_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#product_of_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#product_of_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_congruent_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#product_of_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#product_of_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/product_of_scalars().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#product_of_slice().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_scalar_subtract_no_overflow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_carry_bounded_after_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_shr_51_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_shr_51_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_shr_51_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_is_ordered().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_sub_eq().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_sub_eq().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_sub_eq().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_sub_eq().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_unary_negation().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_sub_eq().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strictly_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/read_le_u64_into().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/read_le_u64_into().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/read_le_u64_into().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_from_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#ValidityCheck#is_valid().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#ValidityCheck#is_valid().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#ValidityCheck#is_valid().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#ValidityCheck#is_valid().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#ValidityCheck#is_valid().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_loop1_invariant().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_loop1_invariant().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_loop1_invariant().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_property().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_twice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_left().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_unique().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_inv_of_product().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/axiom_p_is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_div_and_mod_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_telescoping().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/l51_bit_mask_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_multiples_vanish_fancy().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_as_nat_bound_from_51bit_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_masked_lt_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_projective_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_completed_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/completed_point_as_affine_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_success_means_valid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_success_means_valid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_success_means_valid_y().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_success_means_valid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_success_means_valid_y().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_success_means_valid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_success_means_valid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_success_means_valid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_valid_y_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_success_means_valid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_success_means_valid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_square_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_success_means_valid_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#update().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core default/Default#default().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_property().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_inverse_correct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_property().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_left().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_property().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/axiom_p_is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_property().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_mod_inverse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_property().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_property().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_property().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_property().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_with_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_is_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_equals_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_equals_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_five_limbs_equals_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_equals_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_equals_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/five_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_equals_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_equals_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_equals_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_equals_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_completed_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_completed_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_completed_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_completed_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb0().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_7_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_mod_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_pow_a_pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_is_odd().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_is_odd().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_is_odd().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_add_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_is_odd().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_even().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_pow2k_step().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_pow2k_step().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_pow2k_step().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_pow2k_step().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_congruent().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_pow2k_step().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_multiplies().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_equals_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_smaller_than_pow256().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_factors_congruent_implies_products_congruent().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg_no_underflow().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg_no_underflow().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/all_neg_limbs_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg_no_underflow().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg_no_underflow().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb4_byte_contribution().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_p_radix_representation().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_p_radix_representation().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_p_radix_representation().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_q_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_q_arr().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_from_le_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/from_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_from_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from16().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_from_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_some().",
      "target": "rust-analyzer cargo subtle 2.6.1 CtOption#is_some().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_some().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_some().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_has_value().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_correctness().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/bytes_to_nat_exec().",
      "target": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#Zero#zero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/bytes_to_nat_exec().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/bytes_to_nat_exec().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/bytes_to_nat_exec().",
      "target": "rust-analyzer cargo num-bigint 0.4.6 convert/biguint/BigUint#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pre_reduce_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sqrt_ratio_exponent().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/lemma_inverse_unique_core().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/lemma_inverse_unique_core().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/lemma_inverse_unique_core().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/lemma_inverse_unique_core().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_and_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_and_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_and_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_and_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_and_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_and_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_and_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_five_limbs_equals_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/five_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_five_limbs_equals_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a3_0_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c3_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_valid_radix_2w().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb2_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/bytes_match_limbs_packing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_from_limb_shift().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_extraction_commutes_with_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_sqrt_ratio_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_sqrt_ratio_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_valid_branch().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_compressed_edwards_y().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_sign_bit().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_valid_y_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/as_nat_prefix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_lt_pow2_8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_projective_niels_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_niels_corresponds_to_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_projective_niels_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_sub_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_loop_bounds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_equals_group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_loop_invariant().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_carry_and_sum_bounds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_sum_simplify().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_value_properties().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_negation_preserves_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_square_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_negation_preserves_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_negation_preserves_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_negation_preserves_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_neg_square_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_negation_preserves_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/pow2_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_square_mod_p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_swap().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_swap_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_swap().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption_factorial().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption_factorial().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/binomial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption_factorial().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strictly_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption_factorial().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_factorial_relation().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption_factorial().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption_factorial().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_equality_converse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption_factorial().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/factorial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption_factorial().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_factorial_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_encode().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core array/Default#default().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_encode().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#digest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_encode().",
      "target": "rust-analyzer cargo generic-array 0.14.7 GenericArray#as_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/affine_projective_point_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_projective_point_montgomery().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/affine_projective_point_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/affine_projective_point_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/reconstruct_radix_16().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/reconstruct_radix_2w().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_and().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_8_terms().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_7_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_8_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_8_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a4_0_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c4_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_7_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_7_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_7_terms().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_6_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sub_limbs().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_affine_niels_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_affine_niels_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_corresponds_to_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_decompose().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_decompose().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_decompose().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_decompose().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/zeroize_bool().",
      "target": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod_aux().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod_aux().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_pow2_preserves_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod_aux().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_basic_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod_aux().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod_aux().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod_aux().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod_aux().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/binomial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_n_1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption_factorial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/bit_arrange().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/reduce_with_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/identity_affine_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#zip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_low_bits_mask_increases().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_low_bits_mask_increases().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/lemma_low_bits_mask_values().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_low_bits_mask_increases().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/lemma_low_bits_mask_unfold().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_low_bits_mask_increases().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/lemma_low_bits_mask_div2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_valid_y_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_valid_y_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_valid_y_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_valid_y_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_valid_y_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_valid_y_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_valid_y_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg_no_underflow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/bytes_match_limbs_packing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb3_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_extraction_commutes_with_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_5_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_from_limb_shift().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_pow2_preserves_decomposition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/pow2_MUL_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_pow2_preserves_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_pow2_preserves_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple_is_strongly_ordered().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_pow2_preserves_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_pow2_preserves_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_pow2_preserves_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_decomposition_prefix_rec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_decomposition_prefix_rec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/as_nat_prefix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_decomposition_prefix_rec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_valid_radix_16().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_valid_radix_2w().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_byte_from_limb_shift_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/bytes_match_limbs_packing_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_extraction_commutes_with_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb2_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_limbs_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq/Seq#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_sub_constants_equal_16p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_sub_constants_equal_16p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_sub_constants_equal_16p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_factorial_relation().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/binomial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_factorial_relation().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/factorial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_base().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/l51_bit_mask_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_base().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_spec_load8_at_fits_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_base().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_le_max64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_montgomery_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_ed25519_basepoint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/identity_projective_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_limbs5().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_limbs5().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_to_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_seq_eq_implies_array_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_equals_spec_fe51_to_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_bytes32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_equals_math_field_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_zero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_equals_math_field_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_equals_math_field_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_equals_math_field_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_equals_math_field_inv().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_equals_math_field_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_equals_math_field_inv().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_equals_math_field_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_property().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_equals_math_field_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_equals_math_field_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_unique().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoBasepointTable#create().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#create().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_affine().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_affine_coords().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_affine().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_internal_correct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/spec_mul_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/m().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_internal_no_overflow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_bound().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_strictly_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/to_nat_exec().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/to_nat_exec().",
      "target": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#Zero#zero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/to_nat_exec().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/to_nat_exec().",
      "target": "rust-analyzer cargo num-bigint 0.4.6 convert/biguint/BigUint#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_completed_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_from_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_from_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from4().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_from_le_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/from_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_inverse_field_of_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_inverse_field_of_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_extraction_commutes_with_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_from_limb_shift().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_5_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/bytes_match_limbs_packing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb1_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/sum_of_scalars().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/sum_of_scalars().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq/Seq#skip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/sum_of_scalars().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_montgomery_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_montgomery_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_montgomery_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_u_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/spec_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/spec_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/variable_base_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_ed25519_basepoint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#mul_base().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/VartimeEdwardsPrecomputation#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#optional_mixed_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_none().",
      "target": "rust-analyzer cargo subtle 2.6.1 CtOption#is_none().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_none().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_has_value().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_none().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_is_binary().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_is_binary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_is_binary().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_is_binary().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_is_binary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_is_binary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_is_binary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_is_division().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_is_binary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_is_binary().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_is_binary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_strictly_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb3_byte_contribution_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_rec_version_is_exec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/load8_at_or_version_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_constants_lemmas/field_lemmas/lemmas/lemma_zero_field_element_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_constants_lemmas/field_lemmas/lemmas/lemma_zero_field_element_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_constants_lemmas/field_lemmas/lemmas/lemma_zero_field_element_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_byte_from_limb_shift_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_byte_from_limb_shift_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_bounded_shr_51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_bounded_shr_51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_bounded_shr_51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_bounded_shr_51().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_strictly_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/radix_16_all_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/radix_16_digit_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_plus_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_plus_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_plus_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_plus_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_plus_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics_3().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_partial_binomial_sum_mod_p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/binomial_sum().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_partial_binomial_sum_mod_p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_partial_binomial_sum_mod_p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_divisible_by_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_partial_binomial_sum_mod_p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_partial_binomial_sum_mod_p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_left().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_partial_binomial_sum_mod_p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_partial_binomial_sum_mod_p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_partial_binomial_sum_mod_p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_nonnegative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_partial_binomial_sum_mod_p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_partial_binomial_sum_mod_p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_partial_binomial_sum_mod_p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/binomial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_partial_binomial_sum_mod_p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_le_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_is_ordered().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_le_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_le_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Zeroize#zeroize().",
      "target": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/m().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_sum_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_niels_corresponds_to_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul_u8().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#PartialEq#eq().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_lt_pow2_8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_lt_pow2_8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_all_carries_bounded_by_3().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_bounded_shr_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_all_carries_bounded_by_3().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_all_carries_bounded_by_3().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_all_carries_bounded_by_3().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_setup().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_niels_point_as_affine_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_niels_point_as_affine_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_niels_point_as_affine_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_niels_point_as_affine_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_niels_point_as_affine_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb3_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_byte_from_limb_shift_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/bytes_match_limbs_packing_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_constants/lizard/test_lizard_constants().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_constants/lizard/test_lizard_constants().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_constants/lizard/test_lizard_constants().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_from_le_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/from_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_from_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_from_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_sum_bounds().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/pow2_sum().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_sum_bounds().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics_3().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_m().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mult_maps_to_nonzero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_nonzero_mod_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mult_maps_to_nonzero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mult_maps_to_nonzero().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mult_maps_to_nonzero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mult_maps_to_nonzero().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/m().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_52_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_6_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_6_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_6_terms().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_5_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_uniform_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_uniform_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/copy_from_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_uniform_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_to_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/completed_point_as_affine_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_completed_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/edwards_lemmas/lemmas/lemma_edwards_d_limbs_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01234().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb4_byte_contribution_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/axiom_p_is_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/axiom_p_is_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_affine_coords().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_affine_coords().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_point_as_affine_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_affine_coords().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_two_factoring().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_two_factoring().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_two_factoring().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_to_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_to_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_to_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_point_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec_aux().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec_aux().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec_aux().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec_aux().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec_aux().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec_aux().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec_aux().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_extract_byte_at_index().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_extract_byte_at_index().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_extract_byte_at_index().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/as_nat_prefix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_extract_byte_at_index().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_extract_byte_at_index().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_extract_byte_at_index().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_div_extracts_byte().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_extract_byte_at_index().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_extract_byte_at_index().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_multiply_step().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_multiply_step().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_multiply_step().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_multiply_step().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_multiply_step().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_multiplies().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_multiply_step().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_multiply_step().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_unfold().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_multiply_step().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_multiply_step().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_multiply_step().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_multiply_step().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_bound().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow252().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_bound().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_bound().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_equals_group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_bytes32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_loop_invariant().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_loop_invariant().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_loop_invariant().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_compute_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_compute_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_all_carries_bounded_by_3().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_compute_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_is_binary().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_compute_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_biconditional().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_compute_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_compute_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_bytes32().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_bytes32().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_constants_lemmas/field_lemmas/lemmas/lemma_zero_limbs_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/identity_affine_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Default#default().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Default#default().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/identity_projective_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_le_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_q_arr().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_projective_u_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_projective_u_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_projective_u_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_as_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_inv_witness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_lo_limbs_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_borrow_and_mask_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_constants_lemmas/field_lemmas/lemmas/lemma_zero_limbs_bounded_54().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_constants_lemmas/field_lemmas/lemmas/lemma_zero_limbs_bounded_54().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_constants_lemmas/field_lemmas/lemmas/lemma_zero_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq/Seq#skip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/vartime_double_base_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/vartime_double_base_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/get_selected_backend().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/load8_at_plus_version_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_rec_is_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_is_sqrt_ratio_to_math_field().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_is_sqrt_ratio_to_math_field().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_left().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_is_sqrt_ratio_to_math_field().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_is_sqrt_ratio_to_math_field().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_is_sqrt_ratio_to_math_field().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_is_sqrt_ratio_to_math_field().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_is_sqrt_ratio_to_math_field().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_ratio_exponent_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sqrt_ratio_exponent().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_ratio_exponent_value().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_factorial_coprime_to_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/factorial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_factorial_coprime_to_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_factorial_coprime_to_prime().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_factorial_coprime_to_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#non_adjacent_form().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_valid_naf().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#non_adjacent_form().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_from_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#non_adjacent_form().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/wrapping_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#non_adjacent_form().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#non_adjacent_form().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Product#product().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Product#product().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Product#product().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Product#product().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#product_of_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_to_nat_gen_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_cast_then_mod_51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_cast_then_mod_51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_square_of_complement().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_square_of_complement().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_add_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_square_of_complement().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_square_of_complement().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_square_of_complement().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_square_of_complement().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_twice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_square_of_complement().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_nonnegative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_square_of_complement().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_square_of_complement().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_square_of_complement().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_3_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_3_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/montgomery_reduce_non_canonical_product_fails_postcondition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/slice128_to_nat_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/montgomery_reduce_non_canonical_product_fails_postcondition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/to_nat_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/montgomery_reduce_non_canonical_product_fails_postcondition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/group_order_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/montgomery_reduce_non_canonical_product_fails_postcondition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/montgomery_reduce_non_canonical_product_fails_postcondition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/limbs_bounded_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/montgomery_reduce_non_canonical_product_fails_postcondition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/montgomery_radix_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_hash().",
      "target": "rust-analyzer cargo generic-array 0.14.7 GenericArray#as_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_hash().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_uniform_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_hash().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#finalize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_hash().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/copy_from_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_add_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_add_sub_rearrange().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_mul_distributes_over_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_masked_lt_51().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/l51_bit_mask_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_masked_lt_51().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_masked_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_affine_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/lemma_fermat_for_p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/lemma_fermat_for_p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/axiom_p_is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/lemma_fermat_for_p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_little_theorem().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/lemma_fermat_for_p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#push().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo subtle 2.6.1 From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_not().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_inverse_field().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#create().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#create().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#create().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#create().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_basepoint_table().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#create().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#create().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#create().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#Default#default().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/spec_state_after_hash_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/spec_state_after_hash_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_to_array_32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/spec_state_after_hash_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/spec_state_after_hash().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/spec_state_after_hash_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_to_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_from_bytes_to_nat_wide().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_from_bytes_to_nat_wide().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_from_bytes_to_nat_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/word_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_from_bytes_to_nat_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_from_bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_from_bytes_to_nat_wide().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb3().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb3().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb3().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_prime_divisibility_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_prime_divisibility_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/binomial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_prime_divisibility_helper().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_prime_divisibility_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_absorption().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_prime_divisibility_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_prime_divisibility_helper().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_prime_divisibility_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime_helper().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime_helper().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime_helper().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime_helper().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_difference_zero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime_helper().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime_helper().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime_helper().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime_helper().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_0_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c0_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_0_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c4_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_0_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c3_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_0_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c2_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_0_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c1_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_chunk_extraction_commutes_with_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_chunk_extraction_commutes_with_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_chunk_extraction_commutes_with_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_chunk_extraction_commutes_with_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_chunk_extraction_commutes_with_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_field_element_value().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_field_element_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_field_element_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_field_element_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_field_element_value().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/differential_add_and_double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/differential_add_and_double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_projective_u_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/differential_add_and_double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_montgomery_lift().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/differential_add_and_double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_u_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/differential_add_and_double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/differential_add_and_double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/differential_add_and_double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_u_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/differential_add_and_double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c3_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c4_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c2_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_val_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c1_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/reconstruct_radix_16().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/radix_16_all_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_valid_radix_16().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/top_half().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/bot_half().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_rec_suffix_divisible().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_rec_suffix_divisible().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_breakdown().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_rec_suffix_divisible().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_rec_suffix_divisible().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_rec_suffix_divisible().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_sum_both_divisible().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_rec_suffix_divisible().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_rec_suffix_divisible().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_rec_suffix_divisible().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_unique().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_unique().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_unique().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_property().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_unique().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/lemma_inverse_unique_core().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_unique().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_unique().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/negate_affine_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_niels_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_niels_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_niels_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_niels_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_montgomery_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ValidityCheck#is_valid().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ValidityCheck#is_valid().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ValidityCheck#is_valid().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#ValidityCheck#is_valid().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ValidityCheck#is_valid().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ValidityCheck#is_valid().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_little_theorem().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_little_theorem().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_little_theorem().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_little_theorem().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_product_of_multiples_mod_eq_factorial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_little_theorem().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_little_theorem().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_little_theorem().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_factorial_coprime_to_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_little_theorem().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_cancellation_mod_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_little_theorem().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_little_theorem().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_little_theorem().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/factorial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_little_theorem().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/product_of_multiples().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Neg#neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow0().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_and().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#BitAnd#bitand().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_and().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_inverse_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_inverse_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_self_0().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_inverse_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_gcd().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_inverse_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_inverse_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_extended_gcd().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_inverse_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_inverse_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_left().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_inverse_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_inverse_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_bezout_identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_inverse_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_mod_inverse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_inverse_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_extended_gcd_is_gcd().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_inverse_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_inverse_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_add_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_inverse_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_twice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_equals_spec_fe51_to_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_bytes32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_to_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_five_limbs_equals_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_scalar_mul_u().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_sqrt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_scalar_mul_u().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_scalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_scalar_mul_u().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_affine_u().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_scalar_mul_u().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_rhs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_canonical_bytes_equal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_extract_byte_at_index().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_canonical_bytes_equal().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_canonical_bytes_equal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_scalar52_lt_pow2_256_if_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_scalar52_lt_pow2_256_if_canonical().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_scalar52_lt_pow2_256_if_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_scalar52_lt_pow2_256_if_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_scalar52_lt_pow2_256_if_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_as_nat_bound_from_51bit_limbs().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_as_nat_bound_from_51bit_limbs().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_as_nat_bound_from_51bit_limbs().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_as_nat_bound_from_51bit_limbs().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_as_nat_bound_from_51bit_limbs().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_geometric_sum_5_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_as_nat_bound_from_51bit_limbs().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_mul_upper_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_as_nat_bound_from_51bit_limbs().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_as_nat_bound_from_51bit_limbs().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from16().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq/Seq#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb1_byte_contribution_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_congruent().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_congruent().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mod_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mod_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mod_u8().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_lemmas/lemmas/u8_32_as_nat_le_pow2_256().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_lemmas/lemmas/u8_32_as_nat_le_pow2_256().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_lt_pow2_8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_lemmas/lemmas/u8_32_as_nat_le_pow2_256().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_lemmas/lemmas/u8_32_as_nat_le_pow2_256().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_lemmas/lemmas/u8_32_as_nat_le_pow2_256().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_lemmas/lemmas/u8_32_as_nat_le_pow2_256().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_lemmas/lemmas/u8_32_as_nat_le_pow2_256().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/clamp_integer().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_carry_and_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strict_inequality_converse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_carry_and_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_carry_and_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_carry_and_sum_bounds().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_p_mod_8_eq_5().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_sqrt_ratio_times_i().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_negate_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/negate_field().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_sqrt_ratio().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_or().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_one_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/limbs_bounded_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_one_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/to_nat_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_one_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/slice128_to_nat_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_one_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/group_order_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_one_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/arb_nine_limbs_one_canonical().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_one_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/prop_montgomery_reduce_one_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/montgomery_radix_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_divisibility_factor().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_breakdown().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/sha512_hash_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/sha512_hash_bytes().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#finalize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/sha512_hash_bytes().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#update().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/sha512_hash_bytes().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/sha512_hash_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_from_limb_shift().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb0_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_extraction_commutes_with_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/bytes_match_limbs_packing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/m().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#part2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/spec_mul_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#part1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_fourth_power_is_fourth_root().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_fourth_power_is_fourth_root().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_fourth_root_of_unity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_fourth_power_is_fourth_root().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#from_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/try_into_32_bytes_array().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#optional_mixed_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_swap_montgomery_projective().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_swap().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_swap_montgomery_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_negation_preserves_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_valid_y_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_decompress_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_square_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb0_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb4_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_sum_equals_byte_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb3_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb0_contribution_correctness().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/bytes_match_limbs_packing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb2_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb1_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_sqrt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_is_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_sqrt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#to_jacobi_quartic_ristretto().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#to_jacobi_quartic_ristretto().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#to_jacobi_quartic_ristretto().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#to_jacobi_quartic_ristretto().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_add_sub_rearrange().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_add_sub_rearrange().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_add_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_add_sub_rearrange().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_add_sub_rearrange().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_add_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_add_sub_rearrange().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_add_sub_rearrange().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_add_sub_rearrange().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_algebra_lemmas/field_lemmas/lemmas/lemma_field_add_sub_rearrange().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/pow2_MUL_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sub_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_low_bits_masks_fit_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_geometric_mul_step().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_geometric_mul_step().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_geometric_mul_step().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_geometric_mul_step().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_geometric_mul_step().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_projective_point_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/bits_be_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/zeroize_bool().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_montgomery_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_swap_montgomery_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_scalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_montgomery_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_u_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_montgomery_lift().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/differential_add_and_double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_montgomery_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_montgomery_lift().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_scalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_u_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_montgomery_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_wide_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_smaller_than_pow256().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_compressed_edwards_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_compressed_edwards_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/pippenger_optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/get_selected_backend().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/pippenger_optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from4().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq/Seq#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_int_nat_mod_equiv().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_int_nat_mod_equiv().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod_converse_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_to_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_factorial_positive().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/factorial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_factorial_positive().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strictly_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/clamp_integer().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_montgomery_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_montgomery_lift().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_valid_montgomery_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_scalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_u_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/spec_clamp_integer().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_factors_congruent_implies_products_congruent().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_is_odd().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_one().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_distributes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod_converse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_assign_u64().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_assign_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_sqrt_m1_squared().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_single_stage_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_setup().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_single_stage_division().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_single_stage_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_bounded_shr_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_n_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/binomial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_to_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_to_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_le_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_le_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nat_is_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nat_is_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma0_pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nat_is_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nat_is_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nat_is_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_montgomery_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_montgomery_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_montgomery_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/inv_montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_montgomery_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_montgomery_inverse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_montgomery_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_montgomery_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_geometric_sum_5_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_geometric_sum_5_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_geometric_sum_5_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_geometric_sum_5_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limbs_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limbs_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limbs_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limbs_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limbs_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/bytes_match_limbs_packing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#TryFrom#try_from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#from_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_unwrap().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_unwrap().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_has_value().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_unwrap().",
      "target": "rust-analyzer cargo subtle 2.6.1 CtOption#unwrap().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_unwrap().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_value().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a1_0_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c1_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#ConditionallySelectable#conditional_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_corresponds_to_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_montgomery_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/is_equal_to_minus_one().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_zero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_zero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/field_inv_zero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#hash_from_bytes().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#update().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#hash_from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_hash().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#hash_from_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core default/Default#default().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Identity#identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_sum_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Zeroize#zeroize().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Zeroize#zeroize().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_masked_lt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_masked_lt().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_masked_lt().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_masked_lt().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_masked_lt().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#is_small_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/IsIdentity#is_identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#is_small_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_cofactor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_square().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_square().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_unfold().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_square().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_square().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_direct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_single_stage_division().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_setup().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_stage_division_theorem().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_is_division().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_all_carries_bounded_by_3().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#decompress().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_bit_partitioning().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_u8_cast_is_mod_256().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_le_implies_div_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_strictly_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bit_or_is_plus().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_expansion_mod_p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_expansion_mod_p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_expansion_mod_p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_expansion_mod_p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_partial_binomial_sum_mod_p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_expansion_mod_p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/axiom_binomial_theorem().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_mod_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_mod_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_mod_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_mod_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_mod_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_mod_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_mod_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_2_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_1_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_equals_spec_fe51_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_equals_spec_fe51_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_equals_spec_fe51_to_bytes().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_is_mod_recursive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_equals_spec_fe51_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_equals_spec_fe51_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_equals_spec_fe51_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_equals_spec_fe51_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_to_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_equals_spec_fe51_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_x25519_basepoint_u().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_hi_limbs_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_borrow_and_mask_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_geometric_double().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_geometric_double().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_geometric_double().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_geometric_double().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_from_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_from_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_from_le_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/from_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_limbs_bounded_54().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_limbs_bounded_54().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_boundaries().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_multiply_divide_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Zeroize#zeroize().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/zeroize_bytes32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_u_zero_implies_identity_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_u_zero_implies_identity_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_u_zero_implies_identity_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_u_zero_implies_identity_point().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_u_zero_implies_identity_point().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_u_zero_implies_identity_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_u_zero_implies_identity_point().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_u_zero_implies_identity_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_u_zero_implies_identity_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_u_zero_implies_identity_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_u_zero_implies_identity_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_valid_y_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_u_zero_implies_identity_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_divisible_by_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_prime_divisibility_helper().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_divisible_by_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_divisible_by_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/binomial().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_divisible_by_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_divisible_by_prime().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_self_0().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_from_montgomery_limbs_conversion().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_bindary_sum_div_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple_is_strongly_ordered().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_div_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_div_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_div_u8().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c1_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c1_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c1_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_sqrt_ratio().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_sqrt_ratio_times_i().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/reconstruct_radix_2w().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/reconstruct_radix_2w().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq/Seq#skip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_mod_is_id().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_mod_is_id().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_mod_is_id().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_mod_is_id().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_mod_is_id().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb4_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/bytes_match_limbs_packing_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_byte_from_limb_shift_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_low_bits_masks_fit_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/lemma_low_bits_mask_values().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_low_bits_masks_fit_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_low_bits_mask_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_low_bits_masks_fit_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_mul_sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_mul_sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_mul_sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_mul_sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_extraction_commutes_with_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb0_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_byte_from_limb_shift_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/bytes_match_limbs_packing_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_div_extracts_byte().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_div_extracts_byte().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_div_extracts_byte().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_div_extracts_byte().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_multiples_vanish_fancy().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_div_extracts_byte().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_div_extracts_byte().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/as_nat_prefix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_div_extracts_byte().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_basic_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_div_extracts_byte().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_lt_pow2_8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_div_extracts_byte().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_div_extracts_byte().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_u_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_montgomery_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#bits_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_scalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_montgomery_lift().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul_signed().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul_signed().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_scalar52_lt_pow2_256_if_canonical().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bytes_to_nat_lower_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_five_limbs_equals_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_correct_after_loops().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_correct_after_loops().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bound_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_correct_after_loops().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_correct_after_loops().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_correct_after_loops().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_equals_group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_correct_after_loops().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_correct_after_loops().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_correct_after_loops().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_1_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/carry_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_1_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a0_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/limbs_bounded_exec().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/limbs_bounded_exec().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iter/slice/Iter#Iterator#all().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_affine_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_affine_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_affine_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_corresponds_to_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_affine_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_affine_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Zeroize#zeroize().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_precondition_implies_valid_sign_bit().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_y_squared_neq_one_implies_x_nonzero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_precondition_implies_valid_sign_bit().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_precondition_implies_valid_sign_bit().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_precondition_implies_valid_sign_bit().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/valid_compressed_for_sign_bit().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_precondition_implies_valid_sign_bit().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_compressed_edwards_y().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_precondition_implies_valid_sign_bit().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_precondition_implies_valid_sign_bit().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_lt().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_nonzero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_lt().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strict_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_fits_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_fits_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_fits_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_sum_both_divisible().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_add_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_value().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_has_value().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_new().",
      "target": "rust-analyzer cargo subtle 2.6.1 CtOption#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_sqrt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_is_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_sqrt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_sqrt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/canonical_sqrt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_product_square().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_distributes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_product_square().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_square_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_curve_semantics().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_success_means_valid_y().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_curve_semantics().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_curve_semantics().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_curve_semantics().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_curve_semantics().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_curve_semantics().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_curve_semantics().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_valid_y_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_curve_semantics().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_curve_semantics().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_curve_semantics().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_curve_semantics().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_curve_semantics().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_curve_semantics().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_sqrt_ratio_implies_on_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/lemma_p_is_odd().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_even().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/lemma_p_is_odd().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/lemma_p_is_odd().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/lemma_p_is_odd().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/lemma_p_is_odd().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_scalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_nine_limbs_equals_slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_internal_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_internal_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/five_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/nine_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_five_limbs_equals_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_inverse_field().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_inverse_field().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u64_5_as_nat_generic_radix().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_sign_bit().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_sign_bit().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_expansion().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_expansion().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_expansion().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_expansion().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_expansion().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_bindary_sum_div_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_bindary_sum_div_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_bindary_sum_div_decomposition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_bindary_sum_div_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_bindary_sum_div_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_bindary_sum_div_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_equality_converse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb4_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb1_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb2_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb0_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb3_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/bytes_match_limbs_packing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/word_from_bytes().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_rhs().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_rhs().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_rhs().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_fits_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_rec_is_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_fits_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/load8_at_plus_version_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_fits_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_divides_linear_combo().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_self_0().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_divides_linear_combo().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_add_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_divides_linear_combo().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/get_selected_backend().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_seq_to_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq/Seq#skip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_seq_to_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_as_nat_32_mod_255().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_as_nat_32_mod_255().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_as_nat_32_mod_255().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_as_nat_32_mod_255().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics_3().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_as_nat_32_mod_255().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_as_nat_32_mod_255().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_lt_pow2_8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_as_nat_32_mod_255().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_as_nat_32_mod_255().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_sum_bounds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_as_nat_32_mod_255().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_as_nat_32_mod_255().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/pow2_sum().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_as_nat_32_mod_255().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_basepoint_table().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/pow256().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_basepoint_table().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_affine_coords().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_edwards_basepoint_table().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_limbs_encode_high_expr().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_limbs_encode_high_expr().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_limbs_encode_high_expr().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_word_contribution_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_limbs_encode_high_expr().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_limbs_encode_high_expr().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/five_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_limbs_encode_high_expr().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_limb_from_adjacent_words().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_high_limbs_encode_high_expr().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bit_or_is_plus().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_extraction_commutes_with_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_extraction_commutes_with_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_extraction_commutes_with_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_chunk_extraction_commutes_with_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_versions_equivalent().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_nonincreasing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_versions_equivalent().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bit_or_is_plus().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_versions_equivalent().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_versions_equivalent().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/load8_at_plus_version_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_versions_equivalent().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/load8_at_or_version_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_versions_equivalent().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_rec_is_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_with_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_gcd().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_with_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_is_zero_when_divisible().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_with_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_with_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_divides_both().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_with_prime().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_with_prime().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_with_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_bytes32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#new().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#new().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_to_nat_gen_u64_prefix_matches_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_to_nat_gen_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_to_nat_gen_u64_prefix_matches_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/word_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_words_to_nat_gen_u64_prefix_matches_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/words_from_bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_pow2k_to_field_element().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_pow2k_to_field_element().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_pow2k_to_field_element().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_pow2k_to_field_element().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_pow2k_to_field_element().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_pow2k_to_field_element().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_pow2k_to_field_element().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/l51_bit_mask_lt().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/l51_bit_mask_lt().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_projective_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_two_factoring_51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_two_factoring_51().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_two_factoring().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/pow2_mul_div_mod_small_mul_u8_t51_cond().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_div_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/pow2_mul_div_mod_small_mod_u8_t51_cond().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/pow2_mul_div_mod_small_div_u8_t51_cond().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_le_max64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_base().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_close_mod_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mod_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/pow2_mul_div_mod_close_mod_u8_t51_cond().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_masked_lt_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/reduce_with_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_le_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/l51_bit_mask_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_div_and_mod_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_strictly_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_telescoping().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_carry_out_equals_q().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow0().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma0_pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_biconditional().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/compute_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_biconditional().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_biconditional().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_biconditional().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_biconditional().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_biconditional().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_strictly_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_biconditional().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_biconditional().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_biconditional().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_biconditional().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Zeroize#zeroize().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/zeroize_bytes32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb0().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb0().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb0().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_basics_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb0().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb0().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb0().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_identity_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_add().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_add().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Neg#neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash_verus().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/sha512_hash_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#as_deref().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "target": "rust-analyzer cargo std https://github.com/rust-lang/rust/library/std env/var().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "target": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc string/ToString#to_string().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "target": "rust-analyzer cargo rustc_version 0.4.1 version_meta().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "target": "rust-analyzer cargo rustc_version 0.4.1 version().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#expect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 is_capable_simd().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#basepoint().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#basepoint().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#basepoint().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_ed25519_basepoint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#basepoint().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#basepoint().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#basepoint().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c3_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c3_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c3_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c2_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_niels_point_as_affine_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_projective().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#Debug#fmt().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/m().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_sqrt_m1_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_sqrt_m1_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_multiply_by_base_power_addition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_multiply_by_base_power_addition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_multiply_by_base_power_addition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_multiply_by_base_power_addition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_multiply_by_base_power_addition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_multiply_by_base_power_addition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_multiply_by_base_power_addition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_multiply_by_base_power_addition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_multiply_by_base_power_addition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_multiply_by_base_power_addition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_power_addition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_identity_edwards_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_diff_factor().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_twice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_diff_factor().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_diff_factor().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_even().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_even().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_even().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_self_0().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_even().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_even().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_spec_load8_at_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_spec_load8_at_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_fits_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_spec_load8_at_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_scalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_ed25519_basepoint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/clamp_integer().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#is_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#is_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#is_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_is_canonical_correctness().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#is_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#is_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_by_sum().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_by_sum().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_cancellation_mod_prime().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_cancellation_mod_prime().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_cancellation_mod_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_sub_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_cancellation_mod_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_cancellation_mod_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_cancellation_mod_prime().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_cancellation_mod_prime().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_cancellation_mod_prime().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_remainder_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_multiples_vanish_fancy().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_expansion().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_assign_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_select_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/get_selected_backend().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq/Seq#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/all_neg_limbs_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg_no_underflow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_le_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pre_reduce_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_lemmas/lemmas/lemma_sum_bounds().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_lemmas/lemmas/seq_sum().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_lemmas/lemmas/lemma_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_lemmas/lemmas/lemma_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strictly_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_lemmas/lemmas/lemma_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_lemmas/lemmas/lemma_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_lemmas/lemmas/lemma_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_divides_both().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_divides_both().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_divides_linear_combo().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_divides_both().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_self_0().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_divides_both().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_divides_both().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_gcd().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb2_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb4_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb0_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/bytes_match_limbs_packing_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb1_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/limb3_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_completed_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_valid_naf().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_low_limbs_encode_low_expr().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/five_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_low_limbs_encode_low_expr().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_low_limbs_encode_low_expr().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_low_limbs_encode_low_expr().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bit_or_is_plus().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_low_limbs_encode_low_expr().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_low_limbs_encode_low_expr().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_decompose().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_low_limbs_encode_low_expr().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_word_contribution_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_low_limbs_encode_low_expr().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_limb_from_adjacent_words().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat_rec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_carry_bounded_after_mask().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_carry_bounded_after_mask().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_carry_bounded_after_mask().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_carry_bounded_after_mask().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strict_inequality_converse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_div_and_mod_51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_div_and_mod_51().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/l51_bit_mask_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_div_and_mod_51().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_and_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb1_byte_contribution().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_from_limb_shift().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb4_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/bytes_match_limbs_packing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_wide_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_wide_to_nat_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c2_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c2_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c2_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c1_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/spec_mul_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/copy_from_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#finalize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash().",
      "target": "rust-analyzer cargo generic-array 0.14.7 GenericArray#as_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_difference_zero().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_difference_zero().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/u64_5_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_bridge_pow_as_nat_to_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t3_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t3().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_valid_radix_2w().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/reconstruct_radix_2w().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_valid_radix_16().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/reconstruct_radix_16().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_from_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_strong().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_strong().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_strong().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_strong().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_strong().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_strong().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_strong().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_binomial_expansion_mod_p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c4_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c4_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c4_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c3_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/valid_compressed_for_sign_bit().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_u8().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/limb2_byte_contribution().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_gcd_positive().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_gcd().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_canonical_bytes_high_bit_clear().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_canonical_bytes_high_bit_clear().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_canonical_bytes_high_bit_clear().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_canonical_bytes_high_bit_clear().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_canonical_bytes_high_bit_clear().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_canonical_bytes_high_bit_clear().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_canonical_bytes_high_bit_clear().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bytes_to_nat_lower_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_canonical_bytes_high_bit_clear().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_limb_bounds_established().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_limb_bounds_established().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_limb_bounds_established().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/edwards_lemmas/lemmas/lemma_edwards_d_limbs_bounded_54().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress_lemmas/edwards_lemmas/lemmas/lemma_step1_limb_bounds_established().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 constants_lemmas/field_lemmas/lemmas/lemma_one_limbs_bounded_54().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_0_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_term_product_bounds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_0_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_0_val_boundaries().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_boundary_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_return().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_boundary_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/term_product_bounds_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_boundary_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_val_boundaries().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_boundary_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ci_0_val_boundaries().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/pow2k_loop_boundary_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/ai_val_boundaries().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_divides_linear_combo_sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_divides_linear_combo_sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_divides_linear_combo_sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_self_0().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_left_right_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_left_right_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_left_right_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_left_right_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_left_right_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_u_from_edwards_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_u_from_edwards_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_u_from_edwards_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_u_from_edwards_y().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb4().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_basic_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb4().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb4().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb4().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb4().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_lt_pow2_8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb4().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_le_max64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_le_max64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_le_max64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_general().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_general().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_general().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_general().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_general().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_general().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_sum_factor().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_add_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_sum_factor().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_sum_factor().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_twice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/lemma_hash_is_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/spec_state_after_hash_montgomery().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/lemma_hash_is_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/lemma_hash_is_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/lemma_hash_is_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_to_array_32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/lemma_hash_is_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_to_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bytes_to_nat_lower_bound().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bytes_to_nat_lower_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bytes_to_nat_lower_bound().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bytes_to_nat_rec_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bytes_to_nat_lower_bound().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/u8_32_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_is_fourth_root().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 unused_sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_is_fourth_root().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/is_fourth_root_of_unity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/load8_at_plus_version_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strict_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_reorder_mul().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/affine_niels_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/IsIdentity#is_identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/IsIdentity#is_identity().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/IsIdentity#is_identity().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#to_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#to_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#to_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#to_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/montgomery_corresponds_to_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#to_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_smaller_than_pow256().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_smaller_than_pow256().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_smaller_than_pow256().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_smaller_than_pow256().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/a2_0_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/c2_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/from_bytes_non_canonical_example().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/group_order_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/from_bytes_non_canonical_example().",
      "target": "rust-analyzer cargo proptest 1.9.0 config/test_runner/Config#with_cases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/from_bytes_non_canonical_example().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/from_bytes_non_canonical_example().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/to_nat_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/load8_at().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/load8_at().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_rec_version_is_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/load8_at().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_versions_equivalent().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/load8_at().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo zeroize 1.8.2 Vec#Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/product_of_scalars().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_inverse_of_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#push().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/is_inverse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_not().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#Not#not().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_not().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_multiples_distinct_mod_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_euclid_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_multiples_distinct_mod_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_multiples_distinct_mod_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/is_prime().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_multiples_distinct_mod_prime().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_multiples_distinct_mod_prime().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_sub_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_multiples_distinct_mod_prime().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_word_contribution_decomposition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bit_or_is_plus().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_word_contribution_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas_extra/lemmas/lemma_word_contribution_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_mul_upper_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_0123().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_mod_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_0123().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_012().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_0123().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_0123().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_7_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_0123().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_0123().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_pow_a_pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_0123().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb3().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/math_is_edwards_identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/compressed_edwards_y_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/compressed_edwards_y_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/compressed_edwards_y_corresponds_to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/lookup_table_projective_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_point_sum_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/is_valid_lookup_table_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_affine_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#bits_le().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/bits_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#bits_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#bits_le().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field_add_16p_no_overflow().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#encode_253_bits().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#encode_253_bits().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#encode_253_bits().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_product_of_field_elems().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_product_of_field_elems().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_product_of_field_elems().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 seq/Seq#skip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_neg_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sqrt_m1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_neg_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_neg_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_square_of_complement().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_neg_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_neg_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_neg_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/axiom_sqrt_m1_squared().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_neg_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sqrt_ratio_lemmas/common_lemmas/lemmas/lemma_sqrt_m1_neq_neg_one().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p_gt_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_has_value().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#is_canonical().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_canonical_bytes_high_bit_clear().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_and().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_value().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_mixed_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core empty/sources/iter/empty().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#Zeroize#zeroize().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/zeroize_limbs5().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/math_field_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/spec_mod_inverse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_sub_eq_implies_zero().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_mod_sub_eq_implies_zero().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/edwards_double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/completed_point_as_affine_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_well_formed_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/fe51_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_projective_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/is_valid_completed_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/sum_of_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/projective_point_as_affine_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#Identity#identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/identity_projective_point_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select_u8().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select_u8().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/slice128_to_nat_exec().",
      "target": "rust-analyzer cargo num-bigint 0.4.6 biguint/BigUint#Zero#zero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/slice128_to_nat_exec().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/slice128_to_nat_exec().",
      "target": "rust-analyzer cargo num-bigint 0.4.6 convert/biguint/BigUint#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/scalar/u64/serial/backend/slice128_to_nat_exec().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_by_minus_one_is_negation().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_by_minus_one_is_negation().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_by_minus_one_is_negation().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_by_minus_one_is_negation().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_by_minus_one_is_negation().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_add_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_by_minus_one_is_negation().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_by_minus_one_is_negation().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    }
  ],
  "metadata": {
    "total_nodes": 1140,
    "total_edges": 4070,
    "project_root": "file:///home/lacra/git_repos/baif/curve25519-dalek",
    "generated_at": "2025-12-08T10:39:21.184995313+00:00"
  }
}