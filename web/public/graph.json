{
  "nodes": [
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#to_montgomery().",
      "display_name": "to_montgomery",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#to_montgomery().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn to_montgomery(&self) -> MontgomeryPoint {\n        // We have u = (1+y)/(1-y) = (Z+Y)/(Z-Y).\n        //\n        // The denominator is zero only when y=1, the identity point of\n        // the Edwards curve.  Since 0.invert() = 0, in this case we\n        // compute the 2-torsion point (0,0).\n        assume(false);\n        let U = &self.Z + &self.Y;\n        let W = &self.Z - &self.Y;\n        let u = &U * &W.invert();\n        MontgomeryPoint(u.as_bytes())\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "display_name": "lemma_limb2_contribution_correctness",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_limb2_contribution_correctness(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[1] < pow2(51),  // Need limb 1 for boundary byte 12\n        limbs[2] < pow2(51),\n        bytes_match_limbs_packing(limbs, bytes),\n    ensures\n        limb2_byte_contribution(limbs, bytes) == limbs[2] as nat * pow2(102),\n{\n    // Limb 2 stored in bytes 12-19, positioned at 2^102\n    // - Byte 12 (high 2 bits): limbs[2]'s bits 0-1\n    // - Bytes 13-18: limbs[2]'s bits 2-49 (48 bits)\n    // - Byte 19 (low 1 bit): limbs[2]'s bit 50\n    // Total: 2 + 48 + 1 = 51 bits\n    lemma2_to64();\n    lemma_pow2_adds(96, 6);  // 2^102 = 2^96 * 2^6\n    assert(pow2(102) == pow2(96) * 64);\n\n    // Stabilization placeholders\n    assert(pow2(0) == pow2(0 * 8));\n    assert(pow2(8) == pow2(1 * 8));\n    assert(pow2(16) == pow2(2 * 8));\n    assert(pow2(24) == pow2(3 * 8));\n    assert(pow2(32) == pow2(4 * 8));\n\n    // KEY INSIGHT: From bytes_match_limbs_packing:\n    // bytes[13] = (limbs[2] >> 2) as u8\n    // bytes[14] = (limbs[2] >> 10) as u8\n    // ... and so on\n    //\n    // So limb2_byte_contribution is:\n    //   (limbs[2] % 2^2) * 64 * 2^96 +             // Low 2 bits at position 2^102\n    //   (limbs[2] >> 2 ... >> 42) * positions +    // Middle 48 bits at position 2^104\n    //   (limbs[2] / 2^50) % 2 * 2^152              // High 1 bit at position 2^152\n    //\n    // This is limbs[2] * 2^102!\n\n    // Step 1: Extract arithmetic values for bytes 13-18\n    // These bytes come from limbs[2] >> 2, 10, 18, 26, 34, 42\n    lemma_byte_from_limb_shift(limbs[2], 2, bytes[13]);\n\n    lemma_byte_from_limb_shift(limbs[2], 10, bytes[14]);\n    assert(bytes[14] as nat == (limbs[2] as nat / pow2(10)) % 256);\n\n    lemma_byte_from_limb_shift(limbs[2], 18, bytes[15]);\n\n    lemma_byte_from_limb_shift(limbs[2], 26, bytes[16]);\n\n    lemma_byte_from_limb_shift(limbs[2], 34, bytes[17]);\n\n    lemma_byte_from_limb_shift(limbs[2], 42, bytes[18]);\n\n    // Step 2: Prove that bytes[13-18] reconstruct ((limbs[2] / 2^2) % 2^48) at position 2^104\n    //\n    // From lemma_byte_from_limb_shift, we have:\n    // bytes[13] as nat == (limbs[2] / pow2(2)) % 256\n    // bytes[14] as nat == (limbs[2] / pow2(10)) % 256\n    // bytes[15] as nat == (limbs[2] / pow2(18)) % 256\n    // bytes[16] as nat == (limbs[2] / pow2(26)) % 256\n    // bytes[17] as nat == (limbs[2] / pow2(34)) % 256\n    // bytes[18] as nat == (limbs[2] / pow2(42)) % 256\n    //\n    // The key insight: these bytes extract consecutive 8-bit chunks from (limbs[2] / 2^2)\n\n    // First, rewrite the byte extractions in terms of (limbs[2] / 2^2)\n    // bytes[13] == (limbs[2] / 2^2) / 2^0 % 256\n    lemma_pow2_adds(0, 2);\n    lemma_div_denominator(limbs[2] as int, pow2(2) as int, pow2(0) as int);\n\n    // bytes[14] == (limbs[2] / 2^10) % 256 == (limbs[2] / 2^2) / 2^8 % 256\n    lemma_pow2_adds(2, 8);\n    lemma_div_denominator(limbs[2] as int, pow2(2) as int, pow2(8) as int);\n\n    // bytes[15] == (limbs[2] / 2^18) % 256 == (limbs[2] / 2^2) / 2^16 % 256\n    lemma_pow2_adds(2, 16);\n    assert(pow2(2) * pow2(16) == pow2(18));\n    lemma_div_denominator(limbs[2] as int, pow2(2) as int, pow2(16) as int);\n\n    // bytes[16] == (limbs[2] / 2^26) % 256 == (limbs[2] / 2^2) / 2^24 % 256\n    lemma_pow2_adds(2, 24);\n    lemma_div_denominator(limbs[2] as int, pow2(2) as int, pow2(24) as int);\n\n    // bytes[17] == (limbs[2] / 2^34) % 256 == (limbs[2] / 2^2) / 2^32 % 256\n    lemma_pow2_adds(2, 32);\n    lemma_div_denominator(limbs[2] as int, pow2(2) as int, pow2(32) as int);\n\n    // bytes[18] == (limbs[2] / 2^42) % 256 == (limbs[2] / 2^2) / 2^40 % 256\n    lemma_pow2_adds(2, 40);\n    lemma_pow2_pos(40);\n    lemma_div_denominator(limbs[2] as int, pow2(2) as int, pow2(40) as int);\n\n    // Now handle the % 2^48 truncation\n    // Since limbs[2] < 2^51, we have limbs[2] / 2^2 < 2^49\n    lemma_div_bound(limbs[2] as nat, 2, 51);\n\n    // The bytes extract bits at positions [0..8), [8..16), [16..24), [24..32), [32..40), [40..48)\n    // from (limbs[2] / 2^2). Since all these bit positions are < 48, taking % 2^48\n    // doesn't change the extracted bytes (same argument as limb 1).\n\n    let middle_value = (limbs[2] as nat / pow2(2)) % pow2(48);\n\n    // Prove middle_value < 2^48 (trivial by definition of %)\n    lemma_pow2_pos(48);\n    lemma_mod_bound(middle_value as int, pow2(48) as int);\n\n    // Now prove that the bytes extract from middle_value\n    let v = limbs[2] as nat / pow2(2);\n    assert(bytes[13] as nat == v / pow2(0) % 256);\n\n    // Use lemma_byte_extraction_commutes_with_mod to show extraction commutes with % 2^48\n    // For byte at position k, we need k*8 + 8 <= 48\n    lemma_byte_extraction_commutes_with_mod(v, 0, 48);  // 0*8 + 8 = 8 <= 48 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 1, 48);  // 1*8 + 8 = 16 <= 48 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 2, 48);  // 2*8 + 8 = 24 <= 48 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 3, 48);  // 3*8 + 8 = 32 <= 48 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 4, 48);  // 4*8 + 8 = 40 <= 48 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 5, 48);  // 5*8 + 8 = 48 <= 48 ✓\n    assert(bytes[18] as nat == (middle_value / pow2(40)) % 256);\n\n    // Now apply lemma_6_bytes_reconstruct\n    lemma_6_bytes_reconstruct(\n        middle_value,\n        bytes[13],\n        bytes[14],\n        bytes[15],\n        bytes[16],\n        bytes[17],\n        bytes[18],\n    );\n\n    // This gives us:\n    assert(bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8) + bytes[15] as nat * pow2(16)\n        + bytes[16] as nat * pow2(24) + bytes[17] as nat * pow2(32) + bytes[18] as nat * pow2(40)\n        == middle_value);\n\n    // Now multiply both sides by 2^104 to get the bytes at their actual positions\n    lemma_mul_is_distributive_add(\n        pow2(104) as int,\n        (bytes[13] as nat * pow2(0)) as int,\n        (bytes[14] as nat * pow2(8)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(104) as int,\n        (bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8)) as int,\n        (bytes[15] as nat * pow2(16)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(104) as int,\n        (bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8) + bytes[15] as nat * pow2(\n            16,\n        )) as int,\n        (bytes[16] as nat * pow2(24)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(104) as int,\n        (bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8) + bytes[15] as nat * pow2(16)\n            + bytes[16] as nat * pow2(24)) as int,\n        (bytes[17] as nat * pow2(32)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(104) as int,\n        (bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8) + bytes[15] as nat * pow2(16)\n            + bytes[16] as nat * pow2(24) + bytes[17] as nat * pow2(32)) as int,\n        (bytes[18] as nat * pow2(40)) as int,\n    );\n\n    // Distribute the multiplication into each term\n    lemma_mul_is_associative(bytes[13] as int, pow2(0) as int, pow2(104) as int);\n    lemma_mul_is_associative(bytes[14] as int, pow2(8) as int, pow2(104) as int);\n    lemma_mul_is_associative(bytes[15] as int, pow2(16) as int, pow2(104) as int);\n    lemma_mul_is_associative(bytes[16] as int, pow2(24) as int, pow2(104) as int);\n    lemma_mul_is_associative(bytes[17] as int, pow2(32) as int, pow2(104) as int);\n    lemma_mul_is_associative(bytes[18] as int, pow2(40) as int, pow2(104) as int);\n\n    // Simplify using pow2 addition: 2^104 * 2^k = 2^(104+k)\n    lemma_pow2_adds(104, 0);\n\n    lemma_pow2_adds(104, 8);\n\n    lemma_pow2_adds(104, 16);\n\n    lemma_pow2_adds(104, 24);\n\n    lemma_pow2_adds(104, 32);\n\n    lemma_pow2_adds(104, 40);\n\n    // Now we need to show that the distributed sum equals middle_value * pow2(104)\n    // We have: bytes[13] * 2^0 + ... + bytes[18] * 2^40 = middle_value\n    // We distributed 2^104 into each term\n    // Now we need to show the result\n\n    // Build up the sum step by step\n    let sum_0 = bytes[13] as nat * pow2(13 * 8);\n    let sum_1 = sum_0 + bytes[14] as nat * pow2(14 * 8);\n    let sum_2 = sum_1 + bytes[15] as nat * pow2(15 * 8);\n    let sum_3 = sum_2 + bytes[16] as nat * pow2(16 * 8);\n    let sum_4 = sum_3 + bytes[17] as nat * pow2(17 * 8);\n    let sum_5 = sum_4 + bytes[18] as nat * pow2(18 * 8);\n\n    // This should equal middle_value * pow2(104) by the distributivity we applied\n\n    // Final result\n    assert(bytes[13] as nat * pow2(13 * 8) + bytes[14] as nat * pow2(14 * 8) + bytes[15] as nat\n        * pow2(15 * 8) + bytes[16] as nat * pow2(16 * 8) + bytes[17] as nat * pow2(17 * 8)\n        + bytes[18] as nat * pow2(18 * 8) == middle_value * pow2(104));\n\n    // Step 3: Handle boundary bytes\n    // Low 2 bits (byte 12 high part): (limbs[2] % 2^2) * 64 * 2^96 = (limbs[2] % 2^2) * 2^102\n    // High 1 bit (byte 19 low part): (limbs[2] / 2^50) % 2 * 2^152\n\n    assert(64 * pow2(96) == pow2(102)) by {\n        lemma_pow2_adds(96, 6);\n    }\n\n    // From the proof above, we have:\n    let middle_bytes_sum = bytes[13] as nat * pow2(13 * 8) + bytes[14] as nat * pow2(14 * 8)\n        + bytes[15] as nat * pow2(15 * 8) + bytes[16] as nat * pow2(16 * 8) + bytes[17] as nat\n        * pow2(17 * 8) + bytes[18] as nat * pow2(18 * 8);\n\n    let middle_value_at_position = ((limbs[2] as nat / pow2(2)) % pow2(48)) * pow2(104);\n\n    // Substitute into contribution\n    let contribution = limb2_byte_contribution(limbs, bytes);\n    assert(contribution == ((limbs[2] as nat % pow2(2)) * 64) * pow2(96) + middle_bytes_sum + ((\n    limbs[2] as nat / pow2(50)) % 2) * pow2(152));\n\n    // Step 3: Prove the reconstruction identity for limbs[2]\n    // limbs[2] = (limbs[2] % 2^2) + ((limbs[2] / 2^2) % 2^48) * 2^2 + ((limbs[2] / 2^50) % 2^1) * 2^50\n\n    // This follows the same pattern as limb 1, but with different split points:\n    // - Low 2 bits instead of 5\n    // - Middle 48 bits instead of 40\n    // - Split at 2, 50 instead of 5, 45\n\n    // First, reconstruct limbs[2] / 2^2 from its low 48 bits and high part\n    lemma_pow2_pos(48);\n    let shifted_value = limbs[2] as nat / pow2(2);\n    lemma_fundamental_div_mod(shifted_value as int, pow2(48) as int);\n    // lemma_fundamental_div_mod gives: shifted_value == pow2(48) * (shifted_value / pow2(48)) + (shifted_value % pow2(48))\n    // We need: shifted_value == (shifted_value % pow2(48)) + (shifted_value / pow2(48)) * pow2(48)\n    assert(pow2(48) * (shifted_value / pow2(48)) == (shifted_value / pow2(48)) * pow2(48)) by {\n        lemma_mul_is_commutative(pow2(48) as int, (shifted_value / pow2(48)) as int);\n    }\n\n    // Show that (limbs[2] / 2^2) / 2^48 = limbs[2] / 2^50\n    lemma_div_denominator(limbs[2] as int, pow2(2) as int, pow2(48) as int);\n    lemma_pow2_adds(2, 48);\n\n    // So: limbs[2] / 2^2 = ((limbs[2] / 2^2) % 2^48) + (limbs[2] / 2^50) * 2^48\n    assert(shifted_value == (shifted_value % pow2(48)) + (limbs[2] as nat / pow2(50)) * pow2(48));\n\n    // Next, reconstruct limbs[2] from its low 2 bits and (limbs[2] / 2^2)\n    lemma_pow2_pos(2);\n    lemma_fundamental_div_mod(limbs[2] as int, pow2(2) as int);\n    // lemma_fundamental_div_mod gives: limbs[2] == pow2(2) * (limbs[2] / pow2(2)) + (limbs[2] % pow2(2))\n    assert(pow2(2) * shifted_value == shifted_value * pow2(2)) by {\n        lemma_mul_is_commutative(pow2(2) as int, shifted_value as int);\n    }\n\n    // Substitute the reconstruction of shifted_value (limbs[2] / 2^2)\n    assert(limbs[2] as nat == (limbs[2] as nat % pow2(2)) + ((shifted_value % pow2(48)) + (\n    limbs[2] as nat / pow2(50)) * pow2(48)) * pow2(2));\n\n    // Distribute the * 2^2\n    assert(limbs[2] as nat == (limbs[2] as nat % pow2(2)) + (shifted_value % pow2(48)) * pow2(2) + (\n    limbs[2] as nat / pow2(50)) * pow2(48) * pow2(2)) by {\n        lemma_mul_is_distributive_add(\n            pow2(2) as int,\n            (shifted_value % pow2(48)) as int,\n            (limbs[2] as nat / pow2(50) * pow2(48)) as int,\n        );\n    }\n\n    // Use 2^48 * 2^2 = 2^50\n    lemma_pow2_adds(48, 2);\n    assert((limbs[2] as nat / pow2(50)) * pow2(48) * pow2(2) == (limbs[2] as nat / pow2(50)) * pow2(\n        50,\n    )) by {\n        lemma_mul_is_associative(\n            (limbs[2] as nat / pow2(50)) as int,\n            pow2(48) as int,\n            pow2(2) as int,\n        );\n    }\n\n    assert(limbs[2] as nat == (limbs[2] as nat % pow2(2)) + ((limbs[2] as nat / pow2(2)) % pow2(48))\n        * pow2(2) + (limbs[2] as nat / pow2(50)) * pow2(50));\n\n    // Handle the % 2 on the high bit\n    // Since limbs[2] < 2^51, we have limbs[2] / 2^50 < 2^1 = 2\n    lemma_div_bound(limbs[2] as nat, 50, 51);\n    assert(limbs[2] as nat / pow2(50) < pow2(1));\n    lemma_small_mod(limbs[2] as nat / pow2(50), 2);\n\n    // Therefore:\n    assert(limbs[2] as nat == (limbs[2] as nat % pow2(2)) + ((limbs[2] as nat / pow2(2)) % pow2(48))\n        * pow2(2) + ((limbs[2] as nat / pow2(50)) % 2) * pow2(50));\n\n    // Step 4: Now connect the contribution to limbs[2] * 2^102\n    // We have: contribution = ((limbs[2] % 2^2) * 64) * 2^96 + middle_bytes_sum + ((limbs[2] / 2^50) % 2) * 2^152\n    // Where: middle_bytes_sum = ((limbs[2] / 2^2) % 2^48) * 2^104\n\n    // First, simplify the low term: ((limbs[2] % 2^2) * 64) * 2^96 = (limbs[2] % 2^2) * (64 * 2^96) = (limbs[2] % 2^2) * 2^102\n    // We proved earlier that 64 * 2^96 = 2^102\n    let low_part = (limbs[2] as nat % pow2(2));\n    assert(((limbs[2] as nat % pow2(2)) * 64) * pow2(96) == low_part * (64 * pow2(96))) by {\n        lemma_mul_is_associative(low_part as int, 64, pow2(96) as int);\n    }\n\n    // So contribution = (limbs[2] % 2^2) * 2^102 + ((limbs[2] / 2^2) % 2^48) * 2^104 + ((limbs[2] / 2^50) % 2) * 2^152\n    assert(contribution == low_part * pow2(102) + ((limbs[2] as nat / pow2(2)) % pow2(48)) * pow2(\n        104,\n    ) + ((limbs[2] as nat / pow2(50)) % 2) * pow2(152));\n\n    // Rewrite using 2^104 = 2^102 * 2^2 and 2^152 = 2^102 * 2^50\n    lemma_pow2_adds(102, 2);\n    lemma_pow2_adds(102, 50);\n\n    assert(contribution == low_part * pow2(102) + ((limbs[2] as nat / pow2(2)) % pow2(48)) * (pow2(\n        102,\n    ) * pow2(2)) + ((limbs[2] as nat / pow2(50)) % 2) * (pow2(102) * pow2(50)));\n\n    // Apply associativity to move pow2(102) to the left\n    let middle_part = (limbs[2] as nat / pow2(2)) % pow2(48);\n    let high_part = (limbs[2] as nat / pow2(50)) % 2;\n\n    assert(middle_part * (pow2(102) * pow2(2)) == (middle_part * pow2(102)) * pow2(2)) by {\n        lemma_mul_is_associative(middle_part as int, pow2(102) as int, pow2(2) as int);\n    }\n    assert((middle_part * pow2(102)) * pow2(2) == pow2(102) * middle_part * pow2(2)) by {\n        lemma_mul_is_commutative((middle_part * pow2(102)) as int, pow2(2) as int);\n    }\n    assert(pow2(102) * middle_part * pow2(2) == pow2(102) * (middle_part * pow2(2))) by {\n        lemma_mul_is_associative(pow2(102) as int, middle_part as int, pow2(2) as int);\n    }\n\n    assert(high_part * (pow2(102) * pow2(50)) == (high_part * pow2(102)) * pow2(50)) by {\n        lemma_mul_is_associative(high_part as int, pow2(102) as int, pow2(50) as int);\n    }\n    assert((high_part * pow2(102)) * pow2(50) == pow2(102) * high_part * pow2(50)) by {\n        lemma_mul_is_commutative((high_part * pow2(102)) as int, pow2(50) as int);\n    }\n    assert(pow2(102) * high_part * pow2(50) == pow2(102) * (high_part * pow2(50))) by {\n        lemma_mul_is_associative(pow2(102) as int, high_part as int, pow2(50) as int);\n    }\n\n    // Now factor out pow2(102)\n    assert(contribution == low_part * pow2(102) + pow2(102) * (middle_part * pow2(2)) + pow2(102)\n        * (high_part * pow2(50)));\n\n    // Use distributivity to factor out pow2(102)\n    assert(contribution == pow2(102) * (low_part + middle_part * pow2(2) + high_part * pow2(50)))\n        by {\n        lemma_mul_is_distributive_add(\n            pow2(102) as int,\n            low_part as int,\n            (middle_part * pow2(2)) as int,\n        );\n        lemma_mul_is_distributive_add(\n            pow2(102) as int,\n            (low_part + middle_part * pow2(2)) as int,\n            (high_part * pow2(50)) as int,\n        );\n    }\n\n    // The part in parentheses equals limbs[2] by our reconstruction identity!\n    assert(contribution == limbs[2] as nat * pow2(102)) by {\n        lemma_mul_is_commutative(pow2(102) as int, limbs[2] as int);\n    }\n\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 17
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_clamped_integer().",
      "display_name": "is_clamped_integer",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_clamped_integer().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//! # fn main() {\n//! use sha2::{Digest, Sha512};\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! // Hashing a single byte slice\n//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_scalar().",
      "display_name": "is_random_scalar",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_scalar().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "#[allow(unused_imports)]\nuse crate::backend::serial::u64::scalar_specs::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::scalar_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n\n#[allow(unused_imports)]\nuse crate::core_assumes::*;\n\n#[allow(unused_imports)]\nuse crate::scalar_specs::*;\n\n#[cfg(feature = \"digest\")]\n#[allow(unused_imports)]\nuse digest::Digest;\n\nverus! {\n\n/*** <VERIFICATION NOTE> Focus on u64; removed all other backend types </VERIFICATION NOTE> ***/\ntype UnpackedScalar = backend::serial::u64::scalar::Scalar52;\n\n/// The `Scalar` struct holds an element of \\\\(\\mathbb Z / \\ell\\mathbb Z \\\\).\n#[allow(clippy::derived_hash_with_manual_eq)]\n#[derive(Copy, Clone, Hash)]\npub struct Scalar {\n    /// `bytes` is a little-endian byte encoding of an integer representing a scalar modulo the\n    /// group order.\n    ///\n    /// # Invariant #1\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255}\\\\). That is, the most\n    /// significant bit of `bytes[31]` is 0.\n    ///\n    /// This is required for `EdwardsPoint` variable- and fixed-base multiplication, because most\n    /// integers above 2^255 are unrepresentable in our radix-16 NAF (see [`Self::as_radix_16`]).\n    /// The invariant is also required because our `MontgomeryPoint` multiplication assumes the MSB\n    /// is 0 (see `MontgomeryPoint::mul`).\n    ///\n    /// # Invariant #2 (weak)\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255} - 19 \\\\), i.e., it represents\n    /// a canonical representative of an element of \\\\( \\mathbb Z / \\ell\\mathbb Z \\\\). This is\n    /// stronger than invariant #1. It also sometimes has to be broken.\n    ///\n    /// This invariant is deliberately broken in the implementation of `EdwardsPoint::{mul_clamped,\n    /// mul_base_clamped}`, `MontgomeryPoint::{mul_clamped, mul_base_clamped}`, and\n    /// `BasepointTable::mul_base_clamped`. This is not an issue though. As mentioned above,\n    /// scalar-point multiplication is defined for any choice of `bytes` that satisfies invariant\n    /// #1. Since clamping guarantees invariant #1 is satisfied, these operations are well defined.\n    ///\n    /// Note: Scalar-point mult is the _only_ thing you can do safely with an unreduced scalar.\n    /// Scalar-scalar addition and subtraction are NOT correct when using unreduced scalars.\n    /// Multiplication is correct, but this is only due to a quirk of our implementation, and not\n    /// guaranteed to hold in general in the future.\n    ///\n    /// Note: It is not possible to construct an unreduced `Scalar` from the public API unless the\n    /// `legacy_compatibility` is enabled (thus making `Scalar::from_bits` public). Thus, for all\n    /// public non-legacy uses, invariant #2\n    /// always holds.\n    ///\n    /* <VERIFICATION NOTE>\n    Changed from pub(crate) to pub\n    </VERIFICATION NOTE> */\n    pub bytes: [u8; 32],/* <ORIGINAL CODE>\n    pub(crate) bytes: [u8; 32],\n    </ORIGINAL CODE> */\n}\n\n// This is a dummy function that we call from signal\n// to test that verus functions in libsignal know\n// about verus functions in curve-dalek\npub open spec fn is_a_scalar(s: Scalar) -> bool {\n    true\n}\n\nimpl Scalar {\n    /// Construct a `Scalar` by reducing a 256-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    // VERIFICATION NOTE: VERIFIED\n    pub fn from_bytes_mod_order(bytes: [u8; 32]) -> (result: Scalar)\n        ensures\n    // Result is equivalent to input modulo the group order\n\n            bytes_to_nat(&result.bytes) % group_order() == bytes_to_nat(&bytes) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        // Temporarily allow s_unreduced.bytes > 2^255 ...\n        let s_unreduced = Scalar { bytes };\n\n        // Then reduce mod the group order and return the reduced representative.\n        let s = s_unreduced.reduce();\n        /*** <VERIFICATION NOTE> We omit debug asserts from verification  </VERIFICATION NOTE> ***/\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }\n\n    /// Construct a `Scalar` by reducing a 512-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    // VERIFICATION NOTE: VERIFIED\n    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == bytes_wide_to_nat(input) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }\n\n    /// Attempt to construct a `Scalar` from a canonical byte representation.\n    ///\n    /// # Return\n    ///\n    /// - `Some(s)`, where `s` is the `Scalar` corresponding to `bytes`,\n    ///   if `bytes` is a canonical byte representation modulo the group order \\\\( \\ell \\\\);\n    /// - `None` if `bytes` is not a canonical byte representation.\n    /*\n    <VERIFICATION NOTE>\n      - Refactored to use wrapper functions instead of trait functions for ct_eq and ct_option_new\n      - Has proof bypass\n    </VERIFICATION NOTE> */\n    pub fn from_canonical_bytes(bytes: [u8; 32]) -> (result: CtOption<Scalar>)\n        ensures\n            bytes_to_nat(&bytes) < group_order() ==> ct_option_has_value(result),\n            bytes_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result),\n            ct_option_has_value(result) ==> bytes_to_nat(&ct_option_value(result).bytes)\n                % group_order() == bytes_to_nat(&bytes) % group_order(),\n    {\n        /* <ORIGINAL CODE>\n          let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let high_byte_shifted = bytes[31] >> 7;\n        let high_bit_unset = ct_eq_u8(&high_byte_shifted, &0);\n        /* </MODIFIED CODE> */\n\n        let candidate = Scalar { bytes };\n        let is_canonical = candidate.is_canonical();\n\n        /* <ORIGINAL CODE>\n          CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n          </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let condition = choice_and(high_bit_unset, is_canonical);\n        let result = ct_option_new(candidate, condition);\n        /* </MODIFIED CODE> */\n\n        // VERIFICATION NOTE: PROOF BYPASS\n        assume(bytes_to_nat(&bytes) < group_order() ==> ct_option_has_value(result));\n        assume(bytes_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result));\n        assume(ct_option_has_value(result) ==> bytes_to_nat(&ct_option_value(result).bytes)\n            % group_order() == bytes_to_nat(&bytes) % group_order());\n\n        result\n    }\n\n    /// Construct a `Scalar` from the low 255 bits of a 256-bit integer. This breaks the invariant\n    /// that scalars are always reduced. Scalar-scalar arithmetic, i.e., addition, subtraction,\n    /// multiplication, **does not work** on scalars produced from this function. You may only use\n    /// the output of this function for `EdwardsPoint::mul`, `MontgomeryPoint::mul`, and\n    /// `EdwardsPoint::vartime_double_scalar_mul_basepoint`. **Do not use this function** unless\n    /// you absolutely have to.\n    /* <VERIFICATION NOTE>\n        -This is not in default features and not in our current target list ==> spec omitted for now\n    </VERIFICATION NOTE> */\n    #[cfg(feature = \"legacy_compatibility\")]\n    #[deprecated(\n        since = \"4.0.0\",\n        note = \"This constructor outputs scalars with undefined scalar-scalar arithmetic. See docs.\"\n    )]\n    pub const fn from_bits(bytes: [u8; 32]) -> Scalar {\n        let mut s = Scalar { bytes };\n        // Ensure invariant #1 holds. That is, make s < 2^255 by masking the high bit.\n        s.bytes[31] &= 0b0111_1111;\n\n        s\n    }\n}\n\nimpl Eq for Scalar {\n\n}\n\nimpl PartialEq for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS (problem with traits)\n    fn eq(&self, other: &Self) -> (result: bool)\n        ensures\n            result == (&self.bytes == &other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Choice::into\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let result = self.ct_eq(other).into();\n         </ORIGINAL CODE> */\n        let choice = self.ct_eq(other);\n        assert(choice_is_true(choice) == (self.bytes == other.bytes));\n        let result = choice_into(choice);\n        assert(result == choice_is_true(choice));\n        assert(result == (self.bytes == other.bytes));\n\n        // VERIFICATION NOTE: vstd's external trait specification check cannot be satisfied\n        // vstd expects obeys_eq_spec() and eq_spec() from PartialEqSpecImpl trait,\n        // but that trait is not publicly exported, so we bypass with assume(false)\n        // while maintaining our own custom ensures clause above\n        assume(false);\n\n        result\n    }\n}\n\nimpl ConstantTimeEq for Scalar {\n    fn ct_eq(&self, other: &Self) -> (result: Choice)\n        ensures\n            choice_is_true(result) == (self.bytes == other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Verus compatibility instead of direct subtle call\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.bytes.ct_eq(&other.bytes)\n         </ORIGINAL CODE> */\n        ct_eq_bytes32(&self.bytes, &other.bytes)\n    }\n}\n\nimpl Index<usize> for Scalar {\n    type Output = u8;\n\n    /// Index the bytes of the representative for this `Scalar`.  Mutation is not permitted.\n    fn index(&self, _index: usize) -> (result: &u8)\n        requires\n            _index < 32,\n        ensures\n            result == &self.bytes[_index as int],\n    {\n        &(self.bytes[_index])\n    }\n}\n\nimpl Debug for Scalar {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar{{\\n\\tbytes: {:?},\\n}}\", &self.bytes)\n    }\n}\n\nimpl<'a> MulAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    fn mul_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n            is_canonical_scalar(self),\n    {\n        /* <ORIGINAL CODE>\n         *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n        /* <VERIFICATION NOTE>\n         In the modified code, we store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&old(self).bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        *self = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&self.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n    }\n}\n\ndefine_mul_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_mul_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn mul_req(self, rhs: &Scalar) -> bool {\n        true  // No preconditions\n\n    }\n\n    open spec fn mul_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'b> Mul<&'b Scalar> for &Scalar {\n    type Output = Scalar;\n\n    // VERIFICATION NOTE: VERIFIED\n    fn mul(self, _rhs: &'b Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n    {\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n            * bytes_to_nat(&_rhs.bytes)) % group_order());\n        /* </MODIFIED CODE> */\n        /* <ORIGINAL CODE>\n         let result = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n\n        result\n    }\n}\n\ndefine_mul_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_add_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn add_req(self, rhs: &Scalar) -> bool {\n        true  // No preconditions yet\n\n    }\n\n    open spec fn add_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'a> Add<&'a Scalar> for &Scalar {\n    type Output = Scalar;\n\n    /* <VERIFICATION NOTE>\n    PROOF BYPASS; may need to add preconditions to spec\n    </VERIFICATION NOTE> */\n    #[allow(non_snake_case)]\n    fn add(self, _rhs: &'a Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(&_rhs.bytes))\n                % group_order(),\n    {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::add requires inputs < group_order()\n        // By Scalar invariant #2, scalars should be canonical\n        // However, we cannot add requires clauses to trait implementations,\n        // so we assume this property holds\n        proof {\n            assume(to_nat(&self_unpacked.limbs) < group_order());\n            assume(to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::add(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) == (to_nat(&self_unpacked.limbs) + to_nat(\n                &rhs_unpacked.limbs,\n            )) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) == to_nat(&result_unpacked.limbs));\n            assert(bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }\n}\n\ndefine_add_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> AddAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    #[allow(clippy::op_ref)]\n    fn add_assign(&mut self, _rhs: &'a Scalar)\n        ensures\n            bytes_to_nat(&self.bytes) == (bytes_to_nat(&old(self).bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order(),\n    {\n        *self = &*self + _rhs;\n    }\n}\n\ndefine_add_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_sub_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn sub_req(self, rhs: &Scalar) -> bool {\n        is_canonical_scalar(self) && is_canonical_scalar(rhs)\n    }\n\n    open spec fn sub_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'b> Sub<&'b Scalar> for &Scalar {\n    type Output = Scalar;\n\n    // VERIFICATION NOTE: PROOF BYPASS (problems with traits and preconditions)\n    // PRECONDITION is_canonical_scalar(self) && is_canonical_scalar(_rhs)\n    #[allow(non_snake_case)]\n    fn sub(self, _rhs: &'b Scalar) -> (result:\n        Scalar)/* VERIFICATION NOTE: preconditions are added to the SpecImpl above\n    requires\n      is_canonical_scalar(self),\n      is_canonical_scalar(_rhs),\n    */\n\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        /* <ORIGINAL CODE>\n         UnpackedScalar::sub(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::sub requires: -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()\n        proof {\n            assume(-group_order() <= to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs));\n            assume(to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::sub(&self_unpacked, &rhs_unpacked);\n        proof {\n            // Postconditions from sub - need to strengthen, review connections\n            assume(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                - to_nat(&rhs_unpacked.limbs)) % (group_order() as int));\n            assume(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int));\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }\n}\n\ndefine_sub_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> SubAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    #[allow(clippy::op_ref)]\n    fn sub_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        *self = &*self - _rhs;\n    }\n}\n\ndefine_sub_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &Scalar {\n    open spec fn obeys_neg_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn neg_req(self) -> bool {\n        true  // No preconditions - scalars are canonical by invariant\n\n    }\n\n    open spec fn neg_spec(self) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl Neg for &Scalar {\n    type Output = Scalar;\n\n    #[allow(non_snake_case)]\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        /* <ORIGINAL CODE>\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        proof {\n            // Preconditions for mul_internal and sub\n            assume(limbs_bounded(&constants::R));\n            assume(limbs_bounded(&UnpackedScalar::ZERO));\n        }\n\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n\n        proof {\n            assume(limbs_bounded(&self_mod_l));\n            // sub requires: -group_order() <= 0 - to_nat(&self_mod_l.limbs) < group_order()\n            assume(-group_order() <= to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(\n                &self_mod_l.limbs,\n            ));\n            assume(to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(&self_mod_l.limbs) < group_order());\n        }\n\n        let result = UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack();\n        proof {\n            // TODO: Prove that -self + self == 0 (mod group_order)\n            assume((scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0);\n        }\n\n        /* </MODIFIED CODE> */\n        result\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for Scalar {\n    open spec fn obeys_neg_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn neg_req(self) -> bool {\n        true  // No specific preconditions - scalars are canonical by invariant\n\n    }\n\n    open spec fn neg_spec(self) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl Neg for Scalar {\n    type Output = Scalar;\n\n    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        let result = (&self).neg();\n        proof {\n            assume((scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0);\n        }\n        result\n    }/* <ORIGINAL CODE>\n    fn neg(self) -> Scalar {\n        -&self\n    }\n    </ORIGINAL CODE> */\n\n}\n\nimpl ConditionallySelectable for Scalar {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> (Self) {\n        let mut bytes = [0u8;32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            /* <VERIFICATION NOTE>\n            Use wrapper function for Verus compatibility instead of direct subtle call\n            </VERIFICATION NOTE> */\n            /* <ORIGINAL CODE>\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n            </ORIGINAL CODE> */\n            /* <MODIFIED CODE> */\n            bytes[i] = select_u8(&a.bytes[i], &b.bytes[i], choice);\n            /* </MODIFIED CODE> */\n        }\n        Scalar { bytes }\n    }\n}\n\n/* <VERIFICATION NOTE>\n Trait implementations for Product and Sum declared as external_body since they use iterators which are not supported by Verus.\n</VERIFICATION NOTE> */\n\nimpl<T> Product<T> for Scalar where T: Borrow<Scalar> {\n    /* <ORIGINAL CODE>\n    fn product<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ONE, |acc, item| acc * item.borrow())\n    }\n    </ORIGINAL CODE> */\n    /* <VERIFICATION NOTE>\n     Added verifier::external_body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    /* <MODIFIED CODE> - FOR EVENTUAL VERIFICATION*/\n    fn product<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified product_of_slice function\n        Scalar::product_of_slice(&scalars)\n    }  /* </MODIFIED CODE> */\n\n}\n\nimpl<T> Sum<T> for Scalar where T: Borrow<Scalar> {\n    #[verifier::external_body]\n    fn sum<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }/* <MODIFIED CODE> - if needed in for verification in the future\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified sum_of_slice function\n        Scalar::sum_of_slice(&scalars)\n    }\n     </MODIFIED CODE> */\n\n}\n\nimpl Default for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn default() -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == 0 as nat,\n    {\n        let result = Scalar::ZERO;\n        assume(scalar_to_nat(&result) == 0 as nat);\n        result\n    }\n}\n\nimpl From<u8> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn from(x: u8) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        let mut s_bytes = [0u8;32];\n        s_bytes[0] = x;\n\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u16> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u16) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u16_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u32> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u32) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u32_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        let result = Scalar { bytes: s_bytes };\n        /* </MODIFIED CODE> */\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u64> for Scalar {\n    /// Construct a scalar from the given `u64`.\n    ///\n    /// # Inputs\n    ///\n    /// An `u64` to convert to a `Scalar`.\n    ///\n    /// # Returns\n    ///\n    /// A `Scalar` corresponding to the input `u64`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let fourtytwo = Scalar::from(42u64);\n    /// let six = Scalar::from(6u64);\n    /// let seven = Scalar::from(7u64);\n    ///\n    /// assert!(fourtytwo == six * seven);\n    /// ```\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u64) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u64_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u128> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u128) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u128_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for Scalar {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self) {\n        self.bytes.zeroize();\n    }\n}\n\nimpl Scalar {\n    /// The scalar \\\\( 0 \\\\).\n    // pub const ZERO: Self = Self { bytes: [0u8; 32] };\n    /* <VERIFICATION NOTE>\n    Changed to explicit initialization\n    </VERIFICATION NOTE> */\n    /* <ORIGINAL CODE>\n    pub const ZERO: Self = Self { bytes: [0u8; 32] };\n    </ORIGINAL CODE> */\n    pub const ZERO: Scalar = Scalar {\n        bytes: [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n        ],\n    };\n\n    /// The scalar \\\\( 1 \\\\).\n    pub const ONE: Self = Self {\n        bytes: [\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n        ],\n    };\n\n    /* <VERIFICATION NOTE>\n     Verification of random method postponed - requires rand_core feature to be enabled.\n    </VERIFICATION NOTE> */\n    #[cfg(any(test, feature = \"rand_core\"))]\n    /// Return a `Scalar` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `CryptoRngCore`\n    ///   (i.e. `CryptoRng` + `RngCore`) interface.\n    ///\n    /// # Returns\n    ///\n    /// A random scalar within \\\\(\\mathbb{Z} / \\ell\\mathbb{Z}\\\\).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # fn main() {\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// use rand_core::OsRng;\n    ///\n    /// let mut csprng = OsRng;\n    /// let a: Scalar = Scalar::random(&mut csprng);\n    /// # }\n    /* <VERIFICATION NOTE>\n     No verifier::external_body annotation but it is NOT verified\n    </VERIFICATION NOTE> */\n    pub fn random<R: CryptoRngCore + ?Sized>(rng: &mut R) -> (result: Self)\n        ensures\n            is_random_scalar(&result),\n            is_canonical_scalar(&result),\n    {\n        let mut scalar_bytes = [0u8;64];\n        rng.fill_bytes(&mut scalar_bytes);\n        Scalar::from_bytes_mod_order_wide(&scalar_bytes)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Hash a slice of bytes into a scalar using a specified hash function.\n    ///\n    /// This function hashes the input using the specified `Digest` type and then reduces\n    /// the result modulo the group order to produce a scalar.\n    ///\n    /// Convenience wrapper around `from_hash`.\n    ///\n    /// # Example\n    ///\n    #[cfg_attr(feature = \"digest\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// use sha2::Sha512;\n    /// # fn main() {\n    /// let msg = \"To really appreciate architecture, you may even need to commit a murder\";\n    /// let s = Scalar::hash_from_bytes::<Sha512>(msg.as_bytes());\n    /// # }\n    /// ```\n    /* <VERIFICATION NOTE>\n     Marked as external_body due to complexity of Digest trait.\n     For Verus verification, use hash_from_bytes_verus instead.\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    pub fn hash_from_bytes<D>(input: &[u8]) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64> + Default,\n\n        ensures\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        Scalar::from_hash(hash)\n    }\n\n    /// Verus-compatible version of hash_from_bytes that uses SHA-512.\n    ///\n    /// This function is designed for Verus verification and directly computes\n    /// a SHA-512 hash. For regular code with generic hash functions, use `hash_from_bytes` instead.\n    ///\n    /// # Inputs\n    ///\n    /// * `input`: a byte slice to hash\n    ///\n    /// # Returns\n    ///\n    /// A scalar reduced modulo the group order\n    pub fn hash_from_bytes_verus(input: &[u8]) -> (result: Scalar)\n        ensures\n            is_random_bytes(input) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        use crate::core_assumes as assumes;\n        let hash_bytes: [u8; 64] = assumes::sha512_hash_bytes(input);\n        Scalar::from_hash_verus(hash_bytes)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Construct a scalar from a 64-byte (512-bit) hash output.\n    ///\n    /// This reduces the hash output modulo the group order.\n    /// Typically used after calling `finalize()` on a SHA-512 hasher.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// use sha2::{Digest, Sha512};\n    ///\n    /// # fn main() {\n    /// let mut h = Sha512::new();\n    /// h.update(b\"To really appreciate architecture, you may even need to commit a murder.\");\n    /// h.update(b\"While the programs used for The Manhattan Transcripts are of the most extreme\");\n    /// h.update(b\"nature, they also parallel the most common formula plot: the archetype of\");\n    /// h.update(b\"murder. Other phantasms were occasionally used to underline the fact that\");\n    /// h.update(b\"perhaps all architecture, rather than being about functional standards, is\");\n    /// h.update(b\"about love and death.\");\n    ///\n    /// let hash_bytes: [u8; 64] = h.finalize().into();\n    /// let s = Scalar::from_hash(hash_bytes);\n    ///\n    /// println!(\"{:?}\", s.to_bytes());\n    /// assert_eq!(\n    ///     s.to_bytes(),\n    ///     [  21,  88, 208, 252,  63, 122, 210, 152,\n    ///       154,  38,  15,  23,  16, 167,  80, 150,\n    ///       192, 221,  77, 226,  62,  25, 224, 148,\n    ///       239,  48, 176,  10, 185,  69, 168,  11, ],\n    /// );\n    /// # }\n    /// ```\n    /* <VERIFICATION NOTE>\n     Marked as external_body due to GenericArray having private fields.\n     For Verus verification, see from_hash_verus below.\n    </VERIFICATION NOTE> */\n    #[cfg(feature = \"digest\")]\n    #[verifier::external_body]\n    pub fn from_hash<D>(hash: D) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64>,\n\n        ensures\n    //is_random_digest(&hash) ==> is_random_scalar(&result),\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut output = [0u8;64];\n        output.copy_from_slice(hash.finalize().as_slice());\n        Scalar::from_bytes_mod_order_wide(&output)\n    }\n\n    /// Verus-compatible version of from_hash that takes pre-finalized hash bytes.\n    ///\n    /// This function is designed for Verus verification and takes a byte array directly\n    /// instead of a generic Digest type. For regular code, use `from_hash` instead.\n    ///\n    /// # Inputs\n    ///\n    /// * `hash_bytes`: a 64-byte array representing the output of a hash function\n    ///\n    /// # Returns\n    ///\n    /// A scalar reduced modulo the group order\n    pub fn from_hash_verus(hash_bytes: [u8; 64]) -> (result: Scalar)\n        ensures\n            is_random_bytes(&hash_bytes) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        let result = Scalar::from_bytes_mod_order_wide(&hash_bytes);\n        assume(false);\n        result\n    }\n\n    /// Convert this `Scalar` to its underlying sequence of bytes.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.to_bytes() == [0u8; 32]);\n    /// ```\n    pub const fn to_bytes(&self) -> (result: [u8; 32])\n        ensures\n            result == self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        self.bytes\n    }\n\n    /// View the little-endian byte encoding of the integer representing this Scalar.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.as_bytes() == &[0u8; 32]);\n    /// ```\n    pub const fn as_bytes(&self) -> (result: &[u8; 32])\n        ensures\n            result == &self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        &self.bytes\n    }\n}\n\nimpl Scalar {\n    /// Given a nonzero `Scalar`, compute its multiplicative inverse.\n    ///\n    /// # Warning\n    ///\n    /// `self` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Returns\n    ///\n    /// The multiplicative inverse of the this `Scalar`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // x = 2238329342913194256032495932344128051776374960164957527413114840482143558222\n    /// let X: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x4e, 0x5a, 0xb4, 0x34, 0x5d, 0x47, 0x08, 0x84,\n    ///         0x59, 0x13, 0xb4, 0x64, 0x1b, 0xc2, 0x7d, 0x52,\n    ///         0x52, 0xa5, 0x85, 0x10, 0x1b, 0xcc, 0x42, 0x44,\n    ///         0xd4, 0x49, 0xf4, 0xa8, 0x79, 0xd9, 0xf2, 0x04,\n    ///     ]);\n    /// // 1/x = 6859937278830797291664592131120606308688036382723378951768035303146619657244\n    /// let XINV: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x1c, 0xdc, 0x17, 0xfc, 0xe0, 0xe9, 0xa5, 0xbb,\n    ///         0xd9, 0x24, 0x7e, 0x56, 0xbb, 0x01, 0x63, 0x47,\n    ///         0xbb, 0xba, 0x31, 0xed, 0xd5, 0xa9, 0xbb, 0x96,\n    ///         0xd5, 0x0b, 0xcd, 0x7a, 0x3f, 0x96, 0x2a, 0x0f,\n    ///     ]);\n    ///\n    /// let inv_X: Scalar = X.invert();\n    /// assert!(XINV == inv_X);\n    /// let should_be_one: Scalar = &inv_X * &X;\n    /// assert!(should_be_one == Scalar::ONE);\n    /// ```\n    // VERIFICATION NOTE: VERIFIED\n    pub fn invert(&self) -> (result: Scalar)\n        requires\n            is_canonical_scalar(self),\n        ensures\n    // Result is the multiplicative inverse: result * self ≡ 1 (mod group_order)\n\n            (scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1,\n            is_canonical_scalar(\n                &result,\n            ),\n    // VERIFICATION NOTE: is this true and/or necessary?\n    // Result is canonical\n    // scalar_to_nat(&result) < group_order(),\n    // result.bytes[31] <= 127,\n\n    {\n        let unpacked = self.unpack();\n        let inv_unpacked = unpacked.invert();\n        let result = inv_unpacked.pack();\n        assert((scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1);\n        assume(is_canonical_scalar(&result));\n        result\n    }\n\n    /// Given a slice of nonzero (possibly secret) `Scalar`s,\n    /// compute their inverses in a batch.\n    ///\n    /// # Return\n    ///\n    /// Each element of `inputs` is replaced by its inverse.\n    ///\n    /// The product of all inverses is returned.\n    ///\n    /// # Warning\n    ///\n    /// All input `Scalars` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// # fn main() {\n    /// let mut scalars = [\n    ///     Scalar::from(3u64),\n    ///     Scalar::from(5u64),\n    ///     Scalar::from(7u64),\n    ///     Scalar::from(11u64),\n    /// ];\n    ///\n    /// let allinv = Scalar::batch_invert(&mut scalars);\n    ///\n    /// assert_eq!(allinv, Scalar::from(3*5*7*11u64).invert());\n    /// assert_eq!(scalars[0], Scalar::from(3u64).invert());\n    /// assert_eq!(scalars[1], Scalar::from(5u64).invert());\n    /// assert_eq!(scalars[2], Scalar::from(7u64).invert());\n    /// assert_eq!(scalars[3], Scalar::from(11u64).invert());\n    /// # }\n    /// ```\n    #[cfg(feature = \"alloc\")]\n    // Theo: Verus doesn't like the zeroize in this function. I think the long-term\n    // solution is to use assume_specification to tell Verus what zeroize does.\n    // In the short-term, I've just told verus to ignore the body.\n    // (SB update: alternative is to exclude just the zeroize call, as below)\n    pub fn batch_invert(inputs: &mut [Scalar]) -> (result:\n        Scalar)/* <VERIFICATION NOTE>\n     Refactored for Verus: Index loops instead of iterators, manual Vec construction, ..\n    </VERIFICATION NOTE> */\n\n        ensures\n    // Result is the modular inverse of the product of all original inputs\n\n            is_inverse_of_nat(&result, product_of_scalars(old(inputs)@)),\n            // Each input is replaced with its inverse\n            forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ),\n    {\n        // This code is essentially identical to the FieldElement\n        // implementation, and is documented there.  Unfortunately,\n        // it's not easy to write it generically, since here we want\n        // to use `UnpackedScalar`s internally, and `Scalar`s\n        // externally, but there's no corresponding distinction for\n        // field elements.\n        let n = inputs.len();\n        let one_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(limbs_bounded(&one_unpacked));\n        }\n\n        let one: UnpackedScalar = one_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&one));\n        }\n\n        /* <VERIFICATION NOTE>\n         Build vec manually instead of vec![one; n] for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let mut scratch = vec![one; n];\n         </ORIGINAL CODE> */\n        let mut scratch = Vec::new();\n        for _ in 0..n {\n            scratch.push(one);\n        }\n\n        // Keep an accumulator of all of the previous products\n        let acc_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(scratch.len() == n);\n            assume(limbs_bounded(&acc_unpacked));\n        }\n\n        let mut acc = acc_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        /* <VERIFICATION NOTE>\n         Rewritten with index loop instead of .zip() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         for (input, scratch) in inputs.iter_mut().zip(scratch.iter_mut()) {\n             *scratch = acc;\n        //     // Avoid unnecessary Montgomery multiplication in second pass by\n        //     // keeping inputs in Montgomery form\n             let tmp = input.unpack().as_montgomery();\n             *input = tmp.pack();\n             acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n         }\n        </ORIGINAL CODE> */\n        for i in 0..n\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                limbs_bounded(&acc),\n        {\n            scratch[i] = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = input_unpacked.as_montgomery();\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n\n            proof {\n                assume(limbs_bounded(&acc));\n            }\n        }\n\n        proof {\n            // Assert that all scratch elements have bounded limbs\n            assume(forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]));\n        }\n\n        // acc is nonzero iff all inputs are nonzero\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert!(acc.pack() != Scalar::ZERO);\n\n        // Compute the inverse of all products\n        // ORIGINAL CODE: acc = acc.montgomery_invert().from_montgomery();\n        acc = acc.montgomery_invert();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        acc = acc.from_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // We need to return the product of all inverses later\n        let ret = acc.pack();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        /* <VERIFICATION NOTE>\n         Manual reverse loop instead of .rev() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.iter().rev()) {\n             let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n             *input = UnpackedScalar::montgomery_mul(&acc, scratch).pack();\n             acc = tmp;\n         }\n        </ORIGINAL CODE> */\n        let mut i: usize = n;\n        while i > 0\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                i <= n,\n                limbs_bounded(&acc),\n                forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]),\n            decreases i,\n        {\n            i -= 1;\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input_unpacked);\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = UnpackedScalar::montgomery_mul(&acc, &scratch[i]).pack();\n            acc = tmp;\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        #[cfg(not(verus_keep_ghost))]\n        Zeroize::zeroize(&mut scratch);\n\n        proof {\n            // Assume the postconditions\n            assume(is_inverse_of_nat(&ret, product_of_scalars(old(inputs)@)));\n            assume(forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ));\n        }\n\n        ret\n    }\n}\n\n#[cfg(feature = \"serde\")]\nuse serde::de::Visitor;\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[cfg(feature = \"serde\")]\n/// Visitor for deserializing a Scalar from a sequence of 32 bytes.\n///\n/* VERIFICATION NOTE:\n- We don't cover serde feature yet\n- The ScalarVisitor struct is defined at module level rather than inside the\n`Deserialize::deserialize` since Verus doesn't support nested types\n</VERIFICATION NOTE> */\nstruct ScalarVisitor;\n\n#[cfg(feature = \"serde\")]\nimpl<'de> Visitor<'de> for ScalarVisitor {\n    type Value = Scalar;\n\n    #[verifier::external_body]\n    fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        {\n            formatter.write_str(\n                \"a sequence of 32 bytes whose little-endian interpretation is less than the \\\n                        basepoint order ℓ\",\n            )\n        }\n    }\n\n    #[verifier::external_body]\n    fn visit_seq<A>(self, mut seq: A) -> Result<Scalar, A::Error> where\n        A: serde::de::SeqAccess<'de>,\n     {\n        let mut bytes = [0u8;32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            bytes[i] = seq.next_element()?.ok_or_else(\n                || serde::de::Error::invalid_length(i, &\"expected 32 bytes\"),\n            )?;\n        }\n        Option::from(Scalar::from_canonical_bytes(bytes)).ok_or_else(\n            || serde::de::Error::custom(\"scalar was not canonically encoded\"),\n        )\n    }\n}\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl Serialize for Scalar {\n    #[verifier::external_body]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl<'de> Deserialize<'de> for Scalar {\n    #[verifier::external_body]\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error> where D: Deserializer<'de> {\n        /* VERIFICATION NOTE:\n        Originally struct ScalarVisitor defined here, but moved up to the top of the file\n        </VERIFICATION NOTE> */\n        deserializer.deserialize_tuple(32, ScalarVisitor)\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "display_name": "lemma_6_bytes_reconstruct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_6_bytes_reconstruct(\n    value: nat,\n    byte0: u8,\n    byte1: u8,\n    byte2: u8,\n    byte3: u8,\n    byte4: u8,\n    byte5: u8,\n)\n    requires\n        byte0 as nat == (value / pow2(0)) % 256,\n        byte1 as nat == (value / pow2(8)) % 256,\n        byte2 as nat == (value / pow2(16)) % 256,\n        byte3 as nat == (value / pow2(24)) % 256,\n        byte4 as nat == (value / pow2(32)) % 256,\n        byte5 as nat == (value / pow2(40)) % 256,\n        value < pow2(48),  // 6 bytes = 48 bits\n\n    ensures\n        byte0 as nat * pow2(0) + byte1 as nat * pow2(8) + byte2 as nat * pow2(16) + byte3 as nat\n            * pow2(24) + byte4 as nat * pow2(32) + byte5 as nat * pow2(40) == value,\n{\n    lemma2_to64();\n\n    // Same pattern as lemma_5_bytes_reconstruct, extended to 6 bytes\n    // Use fundamental property: a = (a % d) + (a / d) * d\n\n    // Step 0: value = byte0 + (value / 256) * 256\n    lemma_fundamental_div_mod(value as int, 256);\n\n    let rest1 = value / pow2(8);\n    assert(value == byte0 as nat + rest1 * pow2(8));\n\n    // Step 1: rest1 = byte1 + (rest1 / 256) * 256\n    lemma_pow2_pos(8);\n    lemma_fundamental_div_mod(rest1 as int, 256);\n\n    let rest2 = rest1 / 256;\n    lemma_pow2_adds(8, 8);\n    lemma_div_denominator(value as int, 256, 256);\n\n    // Step 2: rest2 = byte2 + (rest2 / 256) * 256\n    lemma_fundamental_div_mod(rest2 as int, 256);\n    assert(byte2 as nat == (value / pow2(16)) % 256);\n\n    let rest3 = rest2 / 256;\n    lemma_pow2_adds(16, 8);\n    lemma_div_denominator(value as int, pow2(16) as int, 256);\n\n    // Step 3: rest3 = byte3 + (rest3 / 256) * 256\n    lemma_fundamental_div_mod(rest3 as int, 256);\n\n    let rest4 = rest3 / 256;\n    lemma_pow2_adds(24, 8);\n    lemma_div_denominator(value as int, pow2(24) as int, 256);\n    assert(value == byte0 as nat + byte1 as nat * pow2(8) + byte2 as nat * pow2(16) + byte3 as nat\n        * pow2(24) + rest4 * pow2(32));\n\n    // Step 4: rest4 = byte4 + (rest4 / 256) * 256\n    lemma_fundamental_div_mod(rest4 as int, 256);\n\n    let rest5 = rest4 / 256;\n    lemma_pow2_adds(32, 8);\n    lemma_div_denominator(value as int, pow2(32) as int, 256);\n    assert(value == byte0 as nat + byte1 as nat * pow2(8) + byte2 as nat * pow2(16) + byte3 as nat\n        * pow2(24) + byte4 as nat * pow2(32) + rest5 * pow2(40));\n\n    // Step 5: rest5 = byte5 (since value < 2^48, rest5 < 2^8 = 256)\n    lemma_div_bound(value, 40, 48);\n    assert(rest5 < pow2(8));\n\n    lemma_mod_bound(rest5 as int, 256);\n\n    // Final result\n    assert(value == byte0 as nat + byte1 as nat * pow2(8) + byte2 as nat * pow2(16) + byte3 as nat\n        * pow2(24) + byte4 as nat * pow2(32) + byte5 as nat * pow2(40));\n}",
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "display_name": "multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/mod.rs",
      "relative_path": "src/backend/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "backend",
      "body": "pub(crate) enum VartimePrecomputedStraus {\n    // #[cfg(curve25519_dalek_backend = \"simd\")]\n    // Avx2(vector::scalar_mul::precomputed_straus::spec_avx2::VartimePrecomputedStraus),\n    // #[cfg(all(curve25519_dalek_backend = \"simd\", nightly))]\n    // Avx512ifma(\n    //     vector::scalar_mul::precomputed_straus::spec_avx512ifma_avx512vl::VartimePrecomputedStraus,\n    // ),\n    Scalar(serial::scalar_mul::precomputed_straus::VartimePrecomputedStraus),\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/main().",
      "display_name": "main",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/main().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/mask_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/mask_lemmas.rs",
      "file_name": "mask_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "fn main() {\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "display_name": "lemma_limb0_contribution_correctness_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub proof fn lemma_limb0_contribution_correctness_52(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[0] < (1u64 << 52),\n        bytes_match_limbs_packing_52(limbs, bytes),\n    ensures\n        limb0_byte_contribution_52(limbs, bytes) == (limbs[0] as nat) % pow2(52),\n{\n    // Limb 0 is stored in bytes 0-6\n    // - Bytes 0-5: full bytes containing limbs[0]'s bits 0-47 (48 bits total)\n    // - Byte 6 (low 4 bits): limbs[0]'s bits 48-51 (4 bits)\n    // Total: 48 + 4 = 52 bits, which matches limbs[0] < 2^52\n    //\n    // Strategy: Apply div-mod theorem at the 48-bit boundary\n    // limbs[0] = (limbs[0] % 2^48) + (limbs[0] / 2^48) * 2^48\n    lemma2_to64();\n    shift_is_pow2(52);\n    assert(pow2(8) == 256);\n\n    // Step 1: Show bytes 0-5 contribute (limbs[0] % 2^48)\n    // From bytes_match_limbs_packing_52, we know:\n    // bytes[0] = limbs[0] as u8\n    // bytes[1] = (limbs[0] >> 8) as u8\n    // ... and so on\n\n    // These bytes, when summed with their position weights, reconstruct limbs[0] % 2^48\n    let low_48_bits = bytes[0] as nat * pow2(0 * 8) + bytes[1] as nat * pow2(1 * 8)\n        + bytes[2] as nat * pow2(2 * 8) + bytes[3] as nat * pow2(3 * 8) + bytes[4] as nat * pow2(\n        4 * 8,\n    ) + bytes[5] as nat * pow2(5 * 8);\n\n    // Use lemma_byte_from_limb_shift_52 to establish arithmetic value of each byte\n    shr_zero_is_id(limbs[0]);\n    assert(bytes[0] == (limbs[0] >> 0) as u8);\n    lemma_byte_from_limb_shift_52(limbs[0], 0, bytes[0]);\n    assert(bytes[0] as nat == (limbs[0] as nat / pow2(0)) % 256);\n\n    lemma_byte_from_limb_shift_52(limbs[0], 8, bytes[1]);\n    assert(bytes[1] as nat == (limbs[0] as nat / pow2(8)) % 256);\n\n    lemma_byte_from_limb_shift_52(limbs[0], 16, bytes[2]);\n    assert(bytes[2] as nat == (limbs[0] as nat / pow2(16)) % 256);\n\n    lemma_byte_from_limb_shift_52(limbs[0], 24, bytes[3]);\n    assert(bytes[3] as nat == (limbs[0] as nat / pow2(24)) % 256);\n\n    lemma_byte_from_limb_shift_52(limbs[0], 32, bytes[4]);\n    assert(bytes[4] as nat == (limbs[0] as nat / pow2(32)) % 256);\n\n    lemma_byte_from_limb_shift_52(limbs[0], 40, bytes[5]);\n    assert(bytes[5] as nat == (limbs[0] as nat / pow2(40)) % 256);\n\n    // For each byte i (i=0..5), extraction from limbs[0] equals extraction from limbs[0] % 2^48\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 0, 48);\n    assert(bytes[0] as nat == ((limbs[0] as nat % pow2(48)) / pow2(0)) % 256);\n\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 1, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 2, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 3, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 4, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 5, 48);\n\n    // The modulo value fits in a valid range\n    lemma_pow2_pos(48);\n    assert(pow2(48) > 0);\n    let modulo_value = limbs[0] as nat % pow2(48);\n    assert(modulo_value < pow2(48)) by {\n        lemma_mod_bound(limbs[0] as int, pow2(48) as int);\n    }\n    assert(pow2(48) < pow2(64)) by {\n        lemma_pow2_strictly_increases(48, 64);\n    }\n\n    let limb0_low48 = modulo_value as u64;\n    assert(limb0_low48 as nat == modulo_value);\n    assert(limb0_low48 < pow2(48));\n\n    // Apply the 6-byte reconstruction lemma\n    lemma_6_bytes_reconstruct(\n        limb0_low48 as nat,\n        bytes[0],\n        bytes[1],\n        bytes[2],\n        bytes[3],\n        bytes[4],\n        bytes[5],\n    );\n\n    assert(low_48_bits == (limbs[0] as nat % pow2(48)));\n\n    // Step 2: Handle the contribution from byte 6's low 4 bits\n    // Since limbs[0] < 2^52, we have limbs[0] / 2^48 < 2^4 = 16\n    lemma_div_bound(limbs[0] as nat, 48, 52);\n    assert(limbs[0] as nat / pow2(48) < pow2(4));\n    lemma2_to64();\n    assert(pow2(4) == 16);\n\n    let high_4_bits_contribution = ((limbs[0] as nat / pow2(48)) % 16) * pow2(6 * 8);\n\n    // Since limbs[0]/2^48 < 16, taking % 16 is identity\n    assert((limbs[0] as nat / pow2(48)) % 16 == limbs[0] as nat / pow2(48));\n    assert(high_4_bits_contribution == (limbs[0] as nat / pow2(48)) * pow2(48));\n\n    // Step 3: Apply div-mod theorem\n    lemma_pow2_pos(48);\n    lemma_fundamental_div_mod(limbs[0] as int, pow2(48) as int);\n    assert(limbs[0] as nat == (limbs[0] as nat % pow2(48)) + (limbs[0] as nat / pow2(48)) * pow2(\n        48,\n    ));\n\n    // Step 4: Show this equals limb0_byte_contribution_52\n    assert(limb0_byte_contribution_52(limbs, bytes) == low_48_bits + high_4_bits_contribution);\n    assert(limb0_byte_contribution_52(limbs, bytes) == limbs[0] as nat);\n\n    // Since limbs[0] < 2^52, limbs[0] % 2^52 = limbs[0]\n    assert(limbs[0] as nat % pow2(52) == limbs[0] as nat) by {\n        lemma_small_mod(limbs[0] as nat, pow2(52));\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#ConstantTimeEq#ct_eq().",
      "display_name": "ct_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#ConstantTimeEq#ct_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn ct_eq(&self, other: &CompressedEdwardsY) -> (result: Choice)\n        ensures\n            choice_is_true(result) == (self.0 == other.0),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function ct_eq_bytes32 instead of direct subtle call to ct_eq for Verus compatibility.\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.as_bytes().ct_eq(other.as_bytes())\n         </ORIGINAL CODE> */\n        ct_eq_bytes32(self.as_bytes(), other.as_bytes())\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo rustc_version 0.4.1 version_meta().",
      "display_name": "version_meta",
      "symbol": "rust-analyzer cargo rustc_version 0.4.1 version_meta().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_sign_bit().",
      "display_name": "field_element_sign_bit",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_sign_bit().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "//! see the [`curve_models` submodule][curve_models]\n//! of the internal documentation.\n//!\n//! ## Validity Checking\n//!\n//! There is no function for checking whether a point is valid.\n//! Instead, the `EdwardsPoint` struct is guaranteed to hold a valid\n//! point on the curve.\n//!\n//! We use the Rust type system to make invalid points\n//! unrepresentable: `EdwardsPoint` objects can only be created via\n//! successful decompression of a compressed point, or else by\n//! operations on other (valid) `EdwardsPoint`s.\n//!\n//! [curve_models]: https://docs.rs/curve25519-dalek/latest/curve25519-dalek/backend/serial/curve_models/index.html\n// We allow non snake_case names because coordinates in projective space are\n// traditionally denoted by the capitalisation of their respective\n// counterparts in affine space.  Yeah, you heard me, rustc, I'm gonna have my\n// affine and projective cakes and eat both of them too.\n#![allow(non_snake_case)]\n\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "display_name": "bytes_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let l_plus_two_bytes: [u8; 32] = [\n//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Option<Scalar> = Scalar::from_canonical_bytes(l_plus_two_bytes).into();\n//!\n//! assert!(a.is_none());\n//! ```\n//!\n//! Another way to create a `Scalar` is by reducing a \\\\(256\\\\)-bit integer mod\n//! \\\\( \\ell \\\\), for which one may use the\n//! [`Scalar::from_bytes_mod_order`](struct.Scalar.html#method.from_bytes_mod_order)\n//! method.  In the case of the second example above, this would reduce the\n//! resultant scalar \\\\( \\mod \\ell \\\\), producing \\\\( 2 \\\\):\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let l_plus_two_bytes: [u8; 32] = [\n//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Scalar = Scalar::from_bytes_mod_order(l_plus_two_bytes);\n//!\n//! let two: Scalar = Scalar::ONE + Scalar::ONE;\n//!\n//! assert!(a == two);\n//! ```\n//!\n//! There is also a constructor that reduces a \\\\(512\\\\)-bit integer,\n//! [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! To construct a `Scalar` as the hash of some input data, use\n//! [`Scalar::hash_from_bytes`], which takes a buffer, or\n//! [`Scalar::from_hash`], which allows an IUF API.\n//!\n#![cfg_attr(feature = \"digest\", doc = \"```\")]\n#![cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n//! # fn main() {\n//! use sha2::{Digest, Sha512};\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! // Hashing a single byte slice\n//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }",
      "is_libsignal": false,
      "caller_count": 25,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#dual().",
      "display_name": "dual",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#dual().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "            n_found += ok.unwrap_u8();\n        }\n        if n_found == 1 {\n            Some(result)\n        } else {\n            None\n        }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "display_name": "shift_is_pow2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "use vstd::arithmetic::mul::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\n#[allow(unused_imports)]\nuse vstd::bits::*;\n#[allow(unused_imports)]\nuse vstd::calc;\nuse vstd::prelude::*;\n\n#[allow(unused_imports)]\nuse super::common_verus::shift_lemmas::*;\n\nverus! {\n\n/// Verification: scalar * scalar.invert() ≡ 1 mod L\nproof fn verify_invert_correct(\n    x: Scalar52,\n)\n//     requires to_scalar(&x.limbs) != 0\n//    ensures (to_scalar(&x.limbs) * invert_spec(&x.limbs)) % group_order() == 1\n{\n    assume(false);\n\n}\n\npub proof fn lemma_52_52(x: u64, y: u64)\n    requires\n        x < (1u64 << 52),\n        y < (1u64 << 52),\n    ensures\n        (x as u128) * (y as u128) < (1u128 << 104),\n{\n    assert(1u128 << 52 == 1u64 << 52) by (bit_vector);\n    calc! {\n        (<)\n        (x as u128) * (y as u128); (<=) {\n            if x > 0 {\n                lemma_mul_strict_inequality(y as int, (1u128 << 52) as int, x as int);\n                assert(x * y < x * (1u128 << 52));\n            } else {\n                assert((0 as u128) * (y as u128) == 0);\n            }\n        }\n        (x as u128) * (1u128 << 52); (<) {\n            lemma_mul_strict_inequality(x as int, (1u128 << 52) as int, (1u128 << 52) as int);\n        }\n        (1u128 << 52) * (1u128 << 52);\n    }\n    assert((1u128 << 52) * (1u128 << 52) == (1u128 << 104)) by (compute);\n}\n\npub proof fn lemma_square_internal_no_overflow()\n    ensures\n        (1u128 << 105) + (1u128 << 105) == (1u128 << 106),\n        (1u128 << 105) + (1u128 << 104) < (1u128 << 106),\n        (1u128 << 104) * 2 == (1u128 << 105),\n        (1u128 << 106) + (1u128 << 104) < (1u128 << 107),\n{\n    assert((1u128 << 105) + (1u128 << 105) == (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 105) + (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 104) * 2 == (1u128 << 105)) by (bit_vector);\n    assert((1u128 << 106) + (1u128 << 104) < (1u128 << 107)) by (bit_vector);\n}\n\npub proof fn lemma_square_internal_correct(a: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        z[0] == (a[0] * a[0]),\n        z[1] == (a[0] * a[1]) * 2,\n        z[2] == (a[0] * a[2]) * 2 + (a[1] * a[1]),\n        z[3] == (a[0] * a[3]) * 2 + (a[1] * a[2]) * 2,\n        z[4] == (a[0] * a[4]) * 2 + (a[1] * a[3]) * 2 + (a[2] * a[2]),\n        z[5] == (a[1] * a[4]) * 2 + (a[2] * a[3]) * 2,\n        z[6] == (a[2] * a[4]) * 2 + (a[3] * a[3]),\n        z[7] == (a[3] * a[4]) * 2,\n        z[8] == (a[4] * a[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(a),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*a) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n}\n\npub proof fn lemma_mul_internal_no_overflow()\n    ensures\n        (1u128 << 104) + (1u128 << 104) == (1u128 << 105),\n        3u128 * (1u128 << 104) < (1u128 << 106),\n        4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104),\n        (1u128 << 2) * (1u128 << 104) == (1u128 << 106),\n        8u128 == (1u128 << 3),\n        (1u128 << 3) * (1u128 << 104) == (1u128 << 107),\n{\n    assert((1u128 << 104) + (1u128 << 104) == (1u128 << 105)) by (bit_vector);\n    assert(3u128 * (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert(4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104)) by (bit_vector);\n    assert((1u128 << 2) * (1u128 << 104) == (1u128 << 106)) by (bit_vector);\n    assert(8u128 == (1u128 << 3)) by (bit_vector);\n    assert((1u128 << 3) * (1u128 << 104) == (1u128 << 107)) by (bit_vector);\n}\n\npub proof fn lemma_mul_internal_correct(a: &[u64; 5], b: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        forall|i: int| 0 <= i < 5 ==> b[i] < (1u64 << 52),\n        z[0] == (a[0] * b[0]),\n        z[1] == (a[0] * b[1]) + (a[1] * b[0]),\n        z[2] == (a[0] * b[2]) + (a[1] * b[1]) + (a[2] * b[0]),\n        z[3] == (a[0] * b[3]) + (a[1] * b[2]) + (a[2] * b[1]) + (a[3] * b[0]),\n        z[4] == (a[0] * b[4]) + (a[1] * b[3]) + (a[2] * b[2]) + (a[3] * b[1]) + (a[4] * b[0]),\n        z[5] == (a[1] * b[4]) + (a[2] * b[3]) + (a[3] * b[2]) + (a[4] * b[1]),\n        z[6] == (a[2] * b[4]) + (a[3] * b[3]) + (a[4] * b[2]),\n        z[7] == (a[3] * b[4]) + (a[4] * b[3]),\n        z[8] == (a[4] * b[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(b),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*b) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n    lemma_five_limbs_equals_to_nat(&b);\n}\n\npub proof fn lemma_nine_limbs_equals_slice128_to_nat(limbs: &[u128; 9])\n    ensures\n        nine_limbs_to_nat_aux(limbs) == slice128_to_nat(limbs),\n{\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        slice128_to_nat(limbs); {}\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 10);\n        }\n        (limbs[0] as nat) + ((limbs[1] as nat) + ((limbs[2] as nat) + ((limbs[3] as nat) + ((\n        limbs[4] as nat) + ((limbs[5] as nat) + ((limbs[6] as nat) + ((limbs[7] as nat) + (\n        limbs[8] as nat) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52))\n            * pow2(52)) * pow2(52); {\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(104, 52);\n            lemma_pow2_adds(156, 52);\n            lemma_pow2_adds(208, 52);\n            lemma_pow2_adds(260, 52);\n            lemma_pow2_adds(312, 52);\n            lemma_pow2_adds(364, 52);\n            broadcast use group_mul_is_distributive;\n            broadcast use lemma_mul_is_associative;\n\n        }\n        nine_limbs_to_nat_aux(limbs);\n    }\n}\n\npub proof fn lemma_five_limbs_equals_to_nat(limbs: &[u64; 5])\n    ensures\n        five_limbs_to_nat_aux(*limbs) == to_nat(limbs),\n{\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        to_nat(limbs); {}\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 6);\n        }\n        (limbs[0] as nat) + ((limbs[1] as nat) + ((limbs[2] as nat) + ((limbs[3] as nat) + (\n        limbs[4] as nat) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52); {\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(104, 52);\n            lemma_pow2_adds(156, 52);\n            broadcast use group_mul_is_distributive;\n            broadcast use lemma_mul_is_associative;\n\n        }\n        (limbs[0] as nat) + pow2(52) * (limbs[1] as nat) + pow2(104) * (limbs[2] as nat) + pow2(156)\n            * (limbs[3] as nat) + pow2(208) * (limbs[4] as nat); {}\n        five_limbs_to_nat_aux(*limbs);\n    }\n}\n\npub proof fn lemma_bytes_to_nat_rec_equals_bytes_to_nat(bytes: &[u8; 32])\n    ensures\n        bytes_to_nat(bytes) == as_nat_32_u8(bytes),\n{\n    // Strategy: Unfold the recursive definition and show it matches the explicit sum\n    // The recursive definition bytes_to_nat_rec(bytes, 0) computes:\n    // bytes[0] * 2^0 + bytes[1] * 2^8 + ... + bytes[31] * 2^248\n    // First, reveal the recursive structure by showing a few key steps\n    reveal_with_fuel(bytes_to_nat_rec, 33);\n\n    // Now we need to show that the recursive unfolding equals the explicit sum\n    // The key is that pow2(0) == 1, so bytes[0] * pow2(0) == bytes[0]\n    assert(pow2(0) == 1) by {\n        lemma2_to64();\n    };\n\n    // Use calc block to show the transformation step by step\n    calc! {\n        (==)\n        bytes_to_nat(bytes); {}\n        bytes_to_nat_rec(bytes, 0); {\n            // Unfold recursively - Verus should be able to see this with fuel\n        }\n        (bytes[0] as nat) * pow2(0) + (bytes[1] as nat) * pow2(8) + (bytes[2] as nat) * pow2(16) + (\n        bytes[3] as nat) * pow2(24) + (bytes[4] as nat) * pow2(32) + (bytes[5] as nat) * pow2(40)\n            + (bytes[6] as nat) * pow2(48) + (bytes[7] as nat) * pow2(56) + (bytes[8] as nat)\n            * pow2(64) + (bytes[9] as nat) * pow2(72) + (bytes[10] as nat) * pow2(80) + (\n        bytes[11] as nat) * pow2(88) + (bytes[12] as nat) * pow2(96) + (bytes[13] as nat) * pow2(\n            104,\n        ) + (bytes[14] as nat) * pow2(112) + (bytes[15] as nat) * pow2(120) + (bytes[16] as nat)\n            * pow2(128) + (bytes[17] as nat) * pow2(136) + (bytes[18] as nat) * pow2(144) + (\n        bytes[19] as nat) * pow2(152) + (bytes[20] as nat) * pow2(160) + (bytes[21] as nat) * pow2(\n            168,\n        ) + (bytes[22] as nat) * pow2(176) + (bytes[23] as nat) * pow2(184) + (bytes[24] as nat)\n            * pow2(192) + (bytes[25] as nat) * pow2(200) + (bytes[26] as nat) * pow2(208) + (\n        bytes[27] as nat) * pow2(216) + (bytes[28] as nat) * pow2(224) + (bytes[29] as nat) * pow2(\n            232,\n        ) + (bytes[30] as nat) * pow2(240) + (bytes[31] as nat) * pow2(248); {\n            // Simplify bytes[0] * pow2(0) to bytes[0]\n            // Since pow2(0) == 1, we have x * 1 == x\n            assert((bytes[0] as nat) * pow2(0) == (bytes[0] as nat)) by {\n                assert(pow2(0) == 1);\n            };\n        }\n        (bytes[0] as nat) + (bytes[1] as nat) * pow2(8) + (bytes[2] as nat) * pow2(16) + (\n        bytes[3] as nat) * pow2(24) + (bytes[4] as nat) * pow2(32) + (bytes[5] as nat) * pow2(40)\n            + (bytes[6] as nat) * pow2(48) + (bytes[7] as nat) * pow2(56) + (bytes[8] as nat)\n            * pow2(64) + (bytes[9] as nat) * pow2(72) + (bytes[10] as nat) * pow2(80) + (\n        bytes[11] as nat) * pow2(88) + (bytes[12] as nat) * pow2(96) + (bytes[13] as nat) * pow2(\n            104,\n        ) + (bytes[14] as nat) * pow2(112) + (bytes[15] as nat) * pow2(120) + (bytes[16] as nat)\n            * pow2(128) + (bytes[17] as nat) * pow2(136) + (bytes[18] as nat) * pow2(144) + (\n        bytes[19] as nat) * pow2(152) + (bytes[20] as nat) * pow2(160) + (bytes[21] as nat) * pow2(\n            168,\n        ) + (bytes[22] as nat) * pow2(176) + (bytes[23] as nat) * pow2(184) + (bytes[24] as nat)\n            * pow2(192) + (bytes[25] as nat) * pow2(200) + (bytes[26] as nat) * pow2(208) + (\n        bytes[27] as nat) * pow2(216) + (bytes[28] as nat) * pow2(224) + (bytes[29] as nat) * pow2(\n            232,\n        ) + (bytes[30] as nat) * pow2(240) + (bytes[31] as nat) * pow2(248); {}\n        as_nat_32_u8(bytes);\n    }\n}\n\npub proof fn lemma_scalar_subtract_no_overflow(\n    carry: u64,\n    difference_limb: u64,\n    addend: u64,\n    i: u32,\n    l_value: &Scalar52,\n)\n    requires\n        i < 5,\n        difference_limb < (1u64 << 52),\n        addend == 0 || addend == l_value.limbs[i as int],\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n    ensures\n        (carry >> 52) + difference_limb + addend < (1u64 << 53),\n{\n    if i == 0 {\n        assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    } else if i == 1 {\n        assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n    } else if i == 2 {\n        assert(0x000000000014def9 < (1u64 << 52)) by (bit_vector);\n    } else if i == 3 {\n    } else {\n        assert(0x0000100000000000 < (1u64 << 52)) by (bit_vector);\n    }\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert(2 * (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}\n\npub proof fn lemma_borrow_and_mask_bounded(borrow: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        (borrow & mask) < (1u64 << 52),\n{\n    assert((borrow & mask) <= mask) by (bit_vector);\n}\n\npub proof fn lemma_carry_bounded_after_mask(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) <= 1,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}\n\npub proof fn lemma_add_loop_bounds(i: int, carry: u64, a_limb: u64, b_limb: u64)\n    requires\n        0 <= i < 5,\n        a_limb < (1u64 << 52),\n        b_limb < (1u64 << 52),\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n    ensures\n        (carry >> 52) + a_limb + b_limb < (1u64 << 53),\n{\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert((1u64 << 52) + (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}\n\npub proof fn lemma_add_carry_and_sum_bounds(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) < 2,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}\n\npub proof fn lemma_l_value_properties(l_value: &Scalar52, sum: &Scalar52)\n    requires\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n    ensures\n        forall|j: int| 0 <= j < 5 ==> l_value.limbs[j] < (1u64 << 52),\n{\n    assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n}\n\npub proof fn lemma_from_montgomery_limbs_conversion(limbs: &[u128; 9], self_limbs: &[u64; 5])\n    requires\n        forall|j: int| #![auto] 0 <= j < 5 ==> limbs[j] == self_limbs[j] as u128,\n        forall|j: int| 5 <= j < 9 ==> limbs[j] == 0,\n    ensures\n        slice128_to_nat(limbs) == to_nat(self_limbs),\n{\n    lemma_nine_limbs_equals_slice128_to_nat(limbs);\n    lemma_five_limbs_equals_to_nat(self_limbs);\n    assert(limbs[0] == self_limbs[0] as u128);\n    assert(nine_limbs_to_nat_aux(limbs) == (self_limbs[0] as nat) + (self_limbs[1] as nat) * pow2(\n        52,\n    ) + (self_limbs[2] as nat) * pow2(104) + (self_limbs[3] as nat) * pow2(156) + (\n    self_limbs[4] as nat) * pow2(208) + 0 * pow2(260) + 0 * pow2(312) + 0 * pow2(364) + 0 * pow2(\n        416,\n    ));\n}\n\npub proof fn lemma_rr_limbs_bounded()\n    ensures\n        0x000d63c715bea69fu64 < (1u64 << 52),\n{\n    // Verus can figure that out the other 4 limbs are bounded\n    assert(0x000d63c715bea69fu64 < (1u64 << 52)) by (bit_vector);\n}\n\n/// Need to use induction because the postcondition expands\n/// seq_u64_to_nat in the opposite way from how it's defined.\n/// The base case is straightforward, but it takes a few steps\n/// to get Verus to prove it.\n/// Induction case: Take off the first element using definition of\n/// seq_u64_to_nat, apply induction hypothesis to the remaining sequence,\n/// then put the first element back on and simplify all the powers.\npub proof fn lemma_seq_u64_to_nat_subrange_extend(seq: Seq<u64>, i: int)\n    requires\n        0 <= i < seq.len(),\n    ensures\n        seq_u64_to_nat(seq.subrange(0, i + 1)) == seq_u64_to_nat(seq.subrange(0, i)) + seq[i]\n            * pow2(52 * i as nat),\n    decreases i,\n{\n    if i == 0 {\n        reveal_with_fuel(seq_to_nat, 3);\n        assert(seq.len() > 0);\n        assert(seq.subrange(0, 1) == seq![seq[0]]);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, 0 + 1 as int)); {\n                assert(seq.subrange(0, 1) == seq![seq[0]]);\n            }\n            seq_u64_to_nat(seq![seq[0]]); {\n                let single_elem = seq![seq[0]];\n                let nat_single = single_elem.map(|idx, x| x as nat);\n                assert(nat_single == seq![seq[0] as nat]);\n                assert(seq_u64_to_nat(single_elem) == seq_to_nat(nat_single));\n                assert(nat_single.len() == 1);\n                assert(seq_to_nat(nat_single) == nat_single[0] + seq_to_nat(\n                    nat_single.subrange(1, 1),\n                ) * pow2(52));\n                assert(nat_single.subrange(1, 1).len() == 0);\n                assert(seq_to_nat(nat_single.subrange(1, 1)) == 0);\n                assert(seq_to_nat(nat_single) == nat_single[0]);\n                assert(nat_single[0] == seq[0] as nat);\n            }\n            seq[0] as nat; {\n                assert(pow2(0) == 1) by {\n                    lemma2_to64();\n                }\n                assert(52 * 0 == 0);\n                assert(pow2(52 * 0 as nat) == pow2(0));\n                assert((seq[0] * pow2(0)) as nat == (seq[0] * 1) as nat);\n                assert((seq[0] * 1) as nat == seq[0] as nat);\n            }\n            (seq[0] * pow2(52 * 0 as nat)) as nat; {\n                lemma_empty_seq_as_nat(seq);\n            }\n            (seq_u64_to_nat(seq.subrange(0, 0)) + seq[0] * pow2(52 * 0 as nat)) as nat;\n        }\n        return ;\n    } else {\n        let limbs1 = seq.subrange(0, i + 1).map(|i, x| x as nat);\n        let limbs2 = seq.subrange(0, i).map(|i, x| x as nat);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, i + 1)); {\n                assert(seq_to_nat(limbs1) == limbs1[0] + seq_to_nat(\n                    limbs1.subrange(1, limbs1.len() as int),\n                ) * pow2(52));\n            }\n            limbs1[0] + seq_to_nat(limbs1.subrange(1, limbs1.len() as int)) * pow2(52); {\n                assert(seq.subrange(1, i + 1).map(|i, x| x as nat) == limbs1.subrange(\n                    1,\n                    limbs1.len() as int,\n                ));\n            }\n            limbs1[0] + seq_u64_to_nat(seq.subrange(1, i + 1)) * pow2(52); {\n                let tail = seq.subrange(1, i + 1);\n                assert(i >= 1);\n                assert(0 <= i - 1 < tail.len());\n                lemma_seq_u64_to_nat_subrange_extend(tail, i - 1);\n                assert(seq_u64_to_nat(tail.subrange(0, i)) == seq_u64_to_nat(\n                    tail.subrange(0, i - 1),\n                ) + tail[i - 1] * pow2(52 * (i - 1) as nat));\n                assert(tail.subrange(0, i) == seq.subrange(1, i + 1));\n                assert(tail.subrange(0, i - 1) == seq.subrange(1, i));\n                assert(seq_u64_to_nat(seq.subrange(1, i + 1)) == seq_u64_to_nat(seq.subrange(1, i))\n                    + seq[i] * pow2(52 * (i - 1) as nat));\n            }\n            limbs1[0] + ((seq_u64_to_nat(seq.subrange(1, i)) + seq[i] * pow2(52 * (i - 1) as nat))\n                * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i)) * pow2(52) + seq[i] * pow2(\n                52 * (i - 1) as nat,\n            ) * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_associative;\n\n                lemma_pow2_adds(52 * (i - 1) as nat, 52);\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i)) * pow2(52) + seq[i] * pow2(\n                52 * i as nat,\n            )) as nat; {\n                assert(seq.subrange(1, i).map(|i, x| x as nat) == limbs2.subrange(\n                    1,\n                    limbs2.len() as int,\n                ));\n            }\n            (limbs2[0] + seq_to_nat(limbs2.subrange(1, limbs2.len() as int)) * pow2(52) + seq[i]\n                * pow2(52 * i as nat)) as nat; {\n                assert(seq_to_nat(limbs2) == limbs2[0] + seq_to_nat(\n                    limbs2.subrange(1, limbs2.len() as int),\n                ) * pow2(52));\n            }\n            (seq_to_nat(limbs2) + seq[i] * pow2(52 * i as nat)) as nat; {}\n            (seq_u64_to_nat(seq.subrange(0, i)) + seq[i] * pow2(52 * i as nat)) as nat;\n        }\n    }\n}\n\n/// Verus times out when this assertion is inside\n/// lemma_seq_u64_to_nat_subrange_extend\npub proof fn lemma_empty_seq_as_nat(a: Seq<u64>)\n    ensures\n        seq_u64_to_nat(a.subrange(0, 0)) == 0,\n{\n    assert(seq_u64_to_nat(a.subrange(0, 0)) == 0);\n}\n\n/// Using lemma_mod_add_multiples_vanish in a big proof made the proof hang\npub proof fn lemma_mod_cancel(a: &Scalar52, b: &Scalar52)\n    ensures\n        (group_order() + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int) == (to_nat(\n            &a.limbs,\n        ) - to_nat(&b.limbs)) % (group_order() as int),\n{\n    lemma_mod_add_multiples_vanish(\n        (to_nat(&a.limbs) - to_nat(&b.limbs)) as int,\n        group_order() as int,\n    );\n}\n\n/// The corollary of limbs_bounded(a)\npub proof fn lemma_bound_scalar(a: &Scalar52)\n    requires\n        limbs_bounded(a),\n    ensures\n        to_nat(&a.limbs) < pow2((52 * (5) as nat)),\n{\n    lemma_general_bound(a.limbs@);\n}\n\n/// The general case of lemma_bound_scalar so we\n/// can prove via straightforward induction.\npub proof fn lemma_general_bound(a: Seq<u64>)\n    requires\n        forall|i: int| 0 <= i < a.len() ==> a[i] < (1u64 << 52),\n    ensures\n        seq_u64_to_nat(a) < pow2((52 * a.len() as nat)),\n    decreases a.len(),\n{\n    if a.len() == 0 {\n        assert(seq_u64_to_nat(a) == 0);\n        lemma2_to64();  // Gives us pow2(0) == 1 among other facts\n        assert(pow2(0) == 1);\n    } else {\n        // Inductive case\n        let tail = a.subrange(1, a.len() as int);\n\n        // Apply induction hypothesis on tail\n        assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] < (1u64 << 52)) by {\n            assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] == a[i + 1]);\n        };\n\n        assert(tail.len() == a.len() - 1);\n\n        // Apply induction hypothesis\n        lemma_general_bound(tail);\n        assert(seq_u64_to_nat(tail) < pow2((52 * tail.len() as nat)));\n\n        // Now prove for the full sequence\n        assert(seq_u64_to_nat(a) == seq_to_nat(a.map(|i, x| x as nat)));\n        assert(a.map(|i, x| x as nat).len() == a.len());\n        assert(a.map(|i, x| x as nat)[0] == a[0] as nat);\n        assert(a.map(|i, x| x as nat).subrange(1, a.len() as int) == a.subrange(\n            1,\n            a.len() as int,\n        ).map(|i, x| x as nat));\n        // Therefore:\n        assert(seq_u64_to_nat(a) == a[0] as nat + seq_u64_to_nat(a.subrange(1, a.len() as int))\n            * pow2(52));\n\n        assert(a.subrange(1, a.len() as int) == tail);\n\n        // From precondition\n        assert(a[0] < (1u64 << 52));\n        lemma2_to64_rest();\n        assert(0x10000000000000 == 1u64 << 52) by (compute_only);\n        assert(0x10000000000000 == pow2(52));\n        assert((1u64 << 52) == pow2(52));\n\n        // We have seq_u64_to_nat(a) == a[0] + seq_u64_to_nat(tail) * pow2(52)\n        // We know a[0] < pow2(52) and seq_u64_to_nat(tail) < pow2(52 * (a.len() - 1))\n\n        assert(a[0] as nat <= pow2(52) - 1);\n        assert(seq_u64_to_nat(tail) <= pow2(52 * (a.len() - 1) as nat) - 1);\n\n        assert(seq_u64_to_nat(a) <= (pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(\n            52,\n        )) by {\n            lemma_mul_inequality(\n                (pow2(52 * (a.len() - 1) as nat) - 1) as int,\n                pow2(52 * (a.len() - 1) as nat) as int,\n                pow2(52) as int,\n            );\n        };\n\n        // Expand the right side\n        assert((pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(52) == pow2(52) - 1\n            + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52)) by {\n            broadcast use lemma_mul_is_distributive_sub;\n\n        };\n\n        assert(pow2(52) - 1 + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52) == pow2(\n            52 * (a.len() - 1) as nat,\n        ) * pow2(52) - 1);\n\n        lemma_pow2_adds(52 * (a.len() - 1) as nat, 52);\n        assert(pow2(52 * (a.len() - 1) as nat) * pow2(52) == pow2(52 * (a.len() - 1) as nat + 52));\n        assert(52 * (a.len() - 1) as nat + 52 == 52 * a.len() as nat);\n\n        assert(seq_u64_to_nat(a) <= pow2(52 * a.len() as nat) - 1);\n        assert(seq_u64_to_nat(a) < pow2(52 * a.len() as nat));\n    }\n}\n\n/// Claude wrote this proof. Could the proof be shorter?\n/// Moved this to a lemma to get under rlimit.\npub proof fn lemma_decompose(a: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        a == (a >> 52) * pow2(52) + (a & mask),\n{\n    // First, establish that bit shifting is division by pow2(52)\n    broadcast use lemma_u64_shr_is_div;\n\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    lemma2_to64_rest();  // Establishes pow2(52) == 0x10000000000000\n    assert((1u64 << 52) == 0x10000000000000) by (bit_vector);\n    assert(pow2(52) == 0x10000000000000);\n    assert((1u64 << 52) as nat == pow2(52));\n\n    assert(a >> 52 == a / (1u64 << 52));\n\n    // Apply fundamental division theorem: a = q * d + r\n    lemma_fundamental_div_mod(a as int, pow2(52) as int);\n    let q = a as nat / pow2(52);\n    let r = a as nat % pow2(52);\n    assert(a as nat == q * pow2(52) + r);\n    assert(0 <= r < pow2(52));\n\n    // Now prove that (a & mask) == r\n    // mask is all 1s in the lower 52 bits\n    assert(mask == (1u64 << 52) - 1);\n\n    // Key insight: a & mask gives us the lower 52 bits, which is exactly a % pow2(52)\n    lemma_u64_low_bits_mask_is_mod(a, 52);\n    assert(a & mask == a % (1u64 << 52));\n    assert((a % (1u64 << 52)) as nat == a as nat % pow2(52));\n    assert((a & mask) as nat == r);\n\n    // Now show that a >> 52 == q\n    assert((a >> 52) as nat == a as nat / pow2(52));\n    assert((a >> 52) as nat == q);\n\n    // Combine everything\n    assert(a as nat == (a >> 52) as nat * pow2(52) + (a & mask) as nat);\n}\n\n/// The loop invariant says that subtraction is correct if we only subtract\n/// the first i items of each array, plus there's a borrow term.\n/// The first parts of the calc statement expand using the previous invariant.\n/// Then we have cases depending if the wrapping_sub wrapped.\n/// If it didn't wrap, we show that borrow must be small, and borrow >> 52 == 0.\n/// If it did wrap, we show that borrow is so large that its bit-shifts are all\n/// the maximum amount.\n/// Either way, we then use the preconditions about what was mutated,\n/// and shuffle around the powers of 52.\npub proof fn lemma_sub_loop1_invariant(\n    difference: Scalar52,\n    borrow: u64,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    old_borrow: u64,\n    mask: u64,\n    difference_loop1_start: Scalar52,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> difference.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) == seq_u64_to_nat(difference_loop1_start.limbs@.subrange(0, i as int)) - (old_borrow\n            >> 63) * pow2((52 * (i) as nat)),\n        difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(\n            0,\n            i as int,\n        ),\n        difference.limbs[i as int] == borrow & mask,\n        borrow == a.limbs[i as int].wrapping_sub((b.limbs[i as int] + (old_borrow >> 63)) as u64),\n    ensures\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n            (52 * (i + 1) as nat),\n        ) == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i + 1),\n        ),\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] * pow2(52 * i as nat) - (\n        seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] * pow2(52 * i as nat)); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) + (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            assert(difference_loop1_start.limbs@.subrange(0, i as int)\n                == difference.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) - (old_borrow >> 63) * pow2(\n            52 * i as nat,\n        ) + (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n            - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n            assert(borrow == a.limbs[i as int].wrapping_sub(\n                (b.limbs[i as int] + (old_borrow >> 63)) as u64,\n            ));\n            assert(difference.limbs[i as int] == borrow & mask);\n            // Expand wrapping sub\n            if a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) < 0 {\n                assert(borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52)) by {\n                    assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    assert(b.limbs[i as int] <= (1u64 << 52) - 1);\n                    assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                        >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                    assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 <= 1u64 << 52);\n                    assert(borrow >= (a.limbs[i as int] - (1u64 << 52)\n                        + 0x1_0000_0000_0000_0000) as u64);\n                };\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n                        - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                            >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow\n                        - 0x1_0000_0000_0000_0000) * pow2(52 * i as nat); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((borrow >> 52)\n                        * pow2(52) + difference.limbs[i as int] - 0x1_0000_0000_0000_0000) * pow2(\n                        52 * i as nat,\n                    ); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                            broadcast use lemma_pow2_adds;\n\n                        };\n                        assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n                        broadcast use lemma_mul_is_distributive_sub_other_way;\n\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow\n                            >> 52) as nat * pow2(52 * (i + 1) as nat)) by {\n                            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                            lemma_mul_is_associative(\n                                (borrow >> 52) as int,\n                                pow2(52) as int,\n                                pow2(52 * i as nat) as int,\n                            );\n                        };\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) + difference.limbs[i as int] * pow2(52 * i as nat) - 0x1_0000_0000_0000_0000\n                        * pow2(52 * i as nat); {\n                        lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) - 0x1_0000_0000_0000_0000 * pow2(52 * i as nat); {\n                        assert(borrow >> 52 == (1u64 << 12) - 1) by (bit_vector)\n                            requires\n                                borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52),\n                        ;\n                        assert(0x1_0000_0000_0000_0000 * pow2(52 * i as nat) == (1u64 << 12) * pow2(\n                            52 * (i + 1) as nat,\n                        )) by {\n                            lemma2_to64();\n                            assert(0x1_0000_0000_0000_0000 == pow2(64));\n                            assert(1u64 << 12 == pow2(12)) by (compute);\n                            lemma_pow2_adds(64, 52 * i as nat);\n                            lemma_pow2_adds(12, 52 * (i + 1) as nat);\n                            assert(64 + 52 * i as nat == 12 + 52 * (i + 1) as nat);\n                        }\n                        lemma_mul_is_distributive_sub_other_way(\n                            pow2(52 * (i + 1) as nat) as int,\n                            (1u64 << 12) - 1,\n                            (1u64 << 12) as int,\n                        );\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (-1) * pow2(\n                        52 * (i + 1) as nat,\n                    ); {\n                        assert(borrow >> 63 == 1) by (bit_vector)\n                            requires\n                                borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52),\n                        ;\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n                        (52 * (i + 1) as nat),\n                    );\n                }\n            } else {\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n                        - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                            >> 63)) as u64)) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow) * pow2(\n                        52 * i as nat,\n                    ); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((borrow >> 52)\n                        * pow2(52) + difference.limbs[i as int]) * pow2(52 * i as nat); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                            broadcast use lemma_pow2_adds;\n\n                        };\n                        assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow\n                            >> 52) as nat * pow2(52 * (i + 1) as nat)) by {\n                            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                            lemma_mul_is_associative(\n                                (borrow >> 52) as int,\n                                pow2(52) as int,\n                                pow2(52 * i as nat) as int,\n                            );\n                        };\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) + difference.limbs[i as int] * pow2(52 * i as nat); {\n                        lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                        assert(borrow < 1u64 << 52) by {\n                            assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                                >> 63)) as u64)) as u64);\n                            assert(a.limbs[i as int] < (1u64 << 52));\n                            assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 >= 0);\n                        }\n                        assert(borrow >> 52 == 0) by (bit_vector)\n                            requires\n                                borrow < 1u64 << 52,\n                        ;\n                        assert(borrow >> 63 == 0) by (bit_vector)\n                            requires\n                                borrow < 1u64 << 52,\n                        ;\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n                        (52 * (i + 1) as nat),\n                    );\n                }\n            }\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n            (52 * (i + 1) as nat),\n        );\n    }\n}\n\n/// Just a proof by computation\npub(crate) proof fn lemma_l_equals_group_order()\n    ensures\n        to_nat(&constants::L.limbs) == group_order(),\n        seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order(),\n{\n    // First show that the subrange equals the full array\n    assert(constants::L.limbs@ == constants::L.limbs@.subrange(0, 5 as int));\n    assert(seq_u64_to_nat(constants::L.limbs@) == seq_u64_to_nat(\n        constants::L.limbs@.subrange(0, 5 as int),\n    ));\n    assert(to_nat(&constants::L.limbs) == seq_u64_to_nat(constants::L.limbs@));\n\n    assert(pow2(52) == 0x10000000000000) by {\n        lemma2_to64_rest();\n    };\n    lemma_pow2_adds(52, 52);\n    assert(pow2(104) == 0x100000000000000000000000000);\n    lemma_pow2_adds(104, 104);\n    assert(pow2(208) == 0x10000000000000000000000000000000000000000000000000000);\n    lemma_pow252();\n    lemma_five_limbs_equals_to_nat(&constants::L.limbs);\n    assert(five_limbs_to_nat_aux(constants::L.limbs) == group_order()) by (compute);\n}\n\npub proof fn lemma_pow252()\n    ensures\n        pow2(252) == 0x1000000000000000000000000000000000000000000000000000000000000000,\n{\n    assert(pow2(63) == 0x8000000000000000) by {\n        lemma2_to64_rest();\n    }\n    lemma_pow2_adds(63, 63);\n    assert(pow2(126) == 0x40000000000000000000000000000000);\n    lemma_pow2_adds(126, 126);\n}\n\npub proof fn lemma_pow2_260_greater_than_2_group_order()\n    ensures\n        pow2(260) > 2 * group_order(),\n{\n    // The group order is approximately 2^252, so 2 * group_order ≈ 2^253\n    // And 2^260 >> 2^253\n    assert(pow2(260) == pow2(252) * pow2(8)) by {\n        lemma_pow2_adds(252, 8);\n    };\n    assert(pow2(8) == 256) by {\n        lemma2_to64();\n    };\n    lemma_pow252();\n    // Now Verus knows what the powers of 2 mean, so it can figure out the rest\n}\n\n/// If borrow >> 63 == 0, we apply\n/// (1) `-group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()`,\n/// and that's enough to show that to_nat(&difference.limbs) is between\n/// 0 and group order.\n/// If borrow >> 63 == 1, we apply (1) to show that carry >> 52 can't be 0.\n/// This makes the excess terms in the borrow >> 63 == 1 precondition disappear\npub(crate) proof fn lemma_sub_correct_after_loops(\n    difference: Scalar52,\n    carry: u64,\n    a: &Scalar52,\n    b: &Scalar52,\n    difference_after_loop1: Scalar52,\n    borrow: u64,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        limbs_bounded(&difference),\n        limbs_bounded(&difference_after_loop1),\n        (carry >> 52) < 2,\n        -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order(),\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n            + seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ) + (carry >> 52) * pow2(52 * 5 as nat),\n        seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) - (borrow >> 63)\n            * pow2((52 * (5) as nat)),\n    ensures\n        to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int),\n{\n    assert(borrow >> 63 == 1 || borrow >> 63 == 0) by (bit_vector);\n    assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(&difference.limbs))\n        by {\n        assert(seq_u64_to_nat(difference.limbs@) == to_nat(&difference.limbs));\n        assert(difference.limbs@ == difference.limbs@.subrange(0, 5 as int));\n    }\n    assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs)) by {\n        assert(seq_u64_to_nat(b.limbs@) == to_nat(&b.limbs));\n        assert(b.limbs@ == b.limbs@.subrange(0, 5 as int));\n    }\n    assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs)) by {\n        assert(seq_u64_to_nat(a.limbs@) == to_nat(&a.limbs));\n        assert(a.limbs@ == a.limbs@.subrange(0, 5 as int));\n    }\n    if borrow >> 63 == 0 {\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) - (borrow >> 63) * pow2(\n            (52 * (5) as nat),\n        ));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)));\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) == to_nat(&difference.limbs));\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) >= 0);\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) < group_order());\n        lemma_small_mod((to_nat(&a.limbs) - to_nat(&b.limbs)) as nat, group_order());\n        assert(to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (\n        group_order() as int));\n    }\n    if borrow >> 63 == 1 {\n        assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            constants::L.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ));\n        assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n            == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ) - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) - pow2(\n            (52 * (5) as nat),\n        ));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ) - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) - pow2((52 * (5) as nat)));\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            a.limbs@.subrange(0, 5 as int),\n        ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ) + (carry >> 52) * pow2(52 * 5 as nat) - pow2((52 * (5) as nat)));\n        if carry >> 52 == 0 {\n            // Get a contradiction because the sides in the above equation have different signs\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n                a.limbs@.subrange(0, 5 as int),\n            ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) >= 0) by {\n                assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) >= group_order())\n                    by {\n                    lemma_l_equals_group_order();\n                };\n                assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs));\n                assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs));\n            };\n            assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) < pow2(\n                (52 * (5) as nat),\n            )) by {\n                assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(\n                    &difference.limbs,\n                ));\n                lemma_bound_scalar(&difference);\n            };\n            assert((carry >> 52) * pow2(52 * 5 as nat) == 0);\n            assert(false);\n        }\n        assert(carry >> 52 == 1);\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            a.limbs@.subrange(0, 5 as int),\n        ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ));\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + to_nat(&a.limbs)\n            - to_nat(&b.limbs) == to_nat(&difference.limbs));\n        assert(to_nat(&constants::L.limbs) == group_order()) by {\n            lemma_l_equals_group_order();\n        };\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order()) by {\n            lemma_l_equals_group_order();\n        };\n        assert(group_order() > 0);\n        calc! {\n            (==)\n            to_nat(&difference.limbs) as int; {}\n            group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs); {\n                assert(group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs) < group_order())\n                    by {\n                    assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n                        == to_nat(&difference_after_loop1.limbs)) by {\n                        assert(seq_u64_to_nat(difference_after_loop1.limbs@) == to_nat(\n                            &difference_after_loop1.limbs,\n                        ));\n                        assert(difference_after_loop1.limbs@\n                            == difference_after_loop1.limbs@.subrange(0, 5 as int));\n                    }\n                    assert(to_nat(&a.limbs) - to_nat(&b.limbs) == to_nat(\n                        &difference_after_loop1.limbs,\n                    ) - pow2((52 * (5) as nat)));\n                    lemma_bound_scalar(&difference_after_loop1);\n                };\n                lemma_small_mod(\n                    (group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) as nat,\n                    group_order(),\n                );\n            }\n            (group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int); {\n                lemma_mod_cancel(a, b);\n            }\n            (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int);\n        }\n    }\n}\n\n/// Moving this out to get under rlimit\npub proof fn lemma_old_carry(old_carry: u64)\n    requires\n        old_carry < 1u64 << 52,\n    ensures\n        old_carry >> 52 == 0,\n{\n    assert(old_carry >> 52 == 0) by (bit_vector)\n        requires\n            old_carry < 1u64 << 52,\n    ;\n}\n\n/// If borrow >> 63 == 0, we just prove that the loop step has no effect.\n/// If borrow >> 63 == 1, we substitute in the loop's updates\n/// like `difference.limbs[i as int] == carry & mask`.\n/// In that case we're proving that subtraction is correct if we only\n/// consider the first i items of each array, except there's also a\n/// `(carry >> 52) * pow2(52 * (i+1) as nat)` term that doesn't go away.\npub(crate) proof fn lemma_sub_loop2_invariant(\n    difference: Scalar52,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    mask: u64,\n    difference_after_loop1: Scalar52,\n    difference_loop2_start: Scalar52,\n    carry: u64,\n    old_carry: u64,\n    addend: u64,\n    borrow: u64,\n)\n    requires\n        0 <= i < 5,\n        mask == (1u64 << 52) - 1,\n        forall|j: int| 0 <= j < 5 ==> difference_loop2_start.limbs[j] < (1u64 << 52),\n        forall|j: int|\n            i <= j < 5 ==> difference_loop2_start.limbs[j] == difference_after_loop1.limbs[j],\n        forall|j: int|\n            (0 <= j < 5 && j != i) ==> difference_loop2_start.limbs[j] == difference.limbs[j],\n        mask == (1u64 << 52) - 1,\n        i == 0 ==> old_carry == 0,\n        i >= 1 ==> (old_carry >> 52) < 2,\n        (i >= 1 && borrow >> 63 == 0) ==> old_carry == difference_loop2_start.limbs[i - 1],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference_loop2_start,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int))\n            + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) == seq_u64_to_nat(\n            difference_loop2_start.limbs@.subrange(0, i as int),\n        ) + (old_carry >> 52) * pow2(52 * i as nat),\n        difference.limbs[i as int] == carry & mask,\n        difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(\n            0,\n            i as int,\n        ),\n        borrow >> 63 == 0 ==> addend == 0,\n        borrow >> 63 == 1 ==> addend == constants::L.limbs[i as int],\n        carry == (old_carry >> 52) + difference_loop2_start.limbs[i as int] + addend,\n    ensures\n        (i + 1 >= 1 && borrow >> 63 == 0) ==> carry == difference.limbs[i as int],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(\n            difference_after_loop1.limbs@.subrange(0, i + 1 as int),\n        ) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i + 1 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, i + 1 as int),\n        ) + (carry >> 52) * pow2(52 * (i + 1) as nat),\n{\n    if borrow >> 63 == 0 {\n        lemma_old_carry(old_carry);\n        assert(addend == 0);\n        assert(carry == difference_loop2_start.limbs[i as int]);\n        assert(carry & mask == carry) by (bit_vector)\n            requires\n                carry < 1u64 << 52,\n                mask == (1u64 << 52) - 1,\n        ;\n        assert(difference_after_loop1.limbs[i as int] == difference.limbs[i as int]);\n        assert(forall|j: int|\n            0 <= j < 5 ==> difference_after_loop1.limbs[j] == difference.limbs[j]);\n        assert(difference_after_loop1.limbs == difference.limbs);\n    }\n    if borrow >> 63 == 1 {\n        // When underflow, addend = L.limbs[i]\n        assert(addend == constants::L.limbs[i as int]);\n        // carry = (old_carry >> 52) + difference_after_loop1.limbs[i] + L.limbs[i]\n        // difference.limbs[i] = carry & mask\n        calc! {\n            (==)\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(\n                constants::L.limbs@.subrange(0, i + 1),\n            ); {\n                lemma_seq_u64_to_nat_subrange_extend(difference_after_loop1.limbs@, i as int);\n                lemma_seq_u64_to_nat_subrange_extend(constants::L.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int))\n                + difference_after_loop1.limbs[i as int] as nat * pow2(52 * i as nat)\n                + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int))\n                + constants::L.limbs[i as int] as nat * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n                constants::L.limbs@.subrange(0, i as int),\n            ) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                // Use invariant\n            }\n            seq_u64_to_nat(difference_loop2_start.limbs@.subrange(0, i as int)) + (old_carry\n                >> 52) as nat * pow2(52 * i as nat) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(difference_loop2_start.limbs@.subrange(0, i as int)\n                    == difference.limbs@.subrange(0, i as int));\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat\n                * pow2(52 * i as nat) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((old_carry >> 52) as nat\n                + difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(carry == (old_carry >> 52) + difference_after_loop1.limbs[i as int]\n                    + constants::L.limbs[i as int]);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + carry as nat * pow2(\n                52 * i as nat,\n            ); {\n                assert(carry == (carry >> 52) * (1u64 << 52) + (carry & mask)) by (bit_vector)\n                    requires\n                        mask == (1u64 << 52) - 1,\n                ;\n                assert(carry == (carry >> 52) * pow2(52) + difference.limbs[i as int]) by {\n                    lemma2_to64_rest();\n                    assert(0x10000000000000 == 1u64 << 52) by (compute_only);\n                };\n                assert(difference.limbs[i as int] == carry & mask);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((carry >> 52) as nat * pow2(\n                52,\n            ) + difference.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n                52,\n            ) * pow2(52 * i as nat) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                    broadcast use lemma_pow2_adds;\n\n                };\n                assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat\n                    * pow2(52 * (i + 1) as nat)) by {\n                    assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                    lemma_mul_is_associative(\n                        (carry >> 52) as int,\n                        pow2(52) as int,\n                        pow2(52 * i as nat) as int,\n                    );\n                };\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n                52 * (i + 1) as nat,\n            ) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (carry >> 52) as nat * pow2(\n                52 * (i + 1) as nat,\n            );\n        }\n    }\n}\n\n/// Proves that the addition loop maintains its invariant:\n/// a[0..i+1] + b[0..i+1] == sum[0..i+1] + (carry >> 52) * 2^(52*(i+1))\n/// See lemma_sub_loop1_invariant for more comments\npub proof fn lemma_add_loop_invariant(\n    sum: Scalar52,\n    carry: u64,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    old_carry: u64,\n    mask: u64,\n    sum_loop_start: Scalar52,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> sum.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) == seq_u64_to_nat(sum_loop_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) * pow2(\n            (52 * (i) as nat),\n        ),\n        sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int),\n        sum.limbs[i as int] == carry & mask,\n        carry == a.limbs[i as int] + b.limbs[i as int] + (old_carry >> 52),\n    ensures\n        seq_u64_to_nat(sum.limbs@.subrange(0, i + 1)) + (carry >> 52) * pow2((52 * (i + 1) as nat))\n            == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i + 1),\n        ),\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] as nat * pow2(\n            52 * i as nat,\n        ) + seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] as nat * pow2(\n            52 * i as nat,\n        ); {\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                a.limbs[i as int] as int,\n                b.limbs[i as int] as int,\n            );\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) + (a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(\n            52 * i as nat,\n        ) + (a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                (old_carry >> 52) as int,\n                (a.limbs[i as int] as nat + b.limbs[i as int] as nat) as int,\n            );\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + ((old_carry >> 52) as nat\n            + a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(carry == a.limbs[i as int] + b.limbs[i as int] + (old_carry >> 52));\n            assert(sum.limbs[i as int] == carry & mask);\n            // Decompose carry using the mask\n            lemma_decompose(carry, mask);\n            assert(carry == (carry >> 52) * pow2(52) + sum.limbs[i as int]);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + ((carry >> 52) as nat * pow2(52)\n            + sum.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                lemma_pow2_adds(52, 52 * i as nat);\n            };\n            assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                (carry >> 52) as nat * pow2(52) as int,\n                sum.limbs[i as int] as int,\n            );\n            assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat\n                * pow2(52 * (i + 1) as nat)) by {\n                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                lemma_mul_is_associative(\n                    (carry >> 52) as int,\n                    pow2(52) as int,\n                    pow2(52 * i as nat) as int,\n                );\n            };\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n            52 * (i + 1) as nat,\n        ) + sum.limbs[i as int] as nat * pow2(52 * i as nat); {\n            lemma_seq_u64_to_nat_subrange_extend(sum.limbs@, i as int);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i + 1)) + (carry >> 52) as nat * pow2(\n            (52 * (i + 1) as nat),\n        );\n    }\n}\n\n/// Get rid of the subranges from the invariant statement.\n/// Since a and b are less than group order, we can show that carry >> 52\n/// has to be 0, else the RHS is too large\npub proof fn lemma_add_sum_simplify(a: &Scalar52, b: &Scalar52, sum: &Scalar52, carry: u64)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        to_nat(&a.limbs) < group_order(),\n        to_nat(&b.limbs) < group_order(),\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n        (carry >> 52) < 2,\n        seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) + (carry >> 52) as nat * pow2(\n            (52 * (5) as nat),\n        ),\n    ensures\n        to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs),\n{\n    // First establish the relationship between the different representations\n    assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs)) by {\n        assert(a.limbs@ == a.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(a.limbs@) == to_nat(&a.limbs));\n    }\n    assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs)) by {\n        assert(b.limbs@ == b.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(b.limbs@) == to_nat(&b.limbs));\n    }\n    assert(seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) == to_nat(&sum.limbs)) by {\n        assert(sum.limbs@ == sum.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(sum.limbs@) == to_nat(&sum.limbs));\n    }\n\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs) + (carry >> 52) * pow2(\n        (52 * (5) as nat),\n    ));\n\n    // From the loop invariant, we have: a + b == sum + (carry >> 52) * 2^260\n    assert(52 * 5 == 260) by (compute);\n    assert(pow2((52 * 5) as nat) == pow2(260));\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(\n        260,\n    ));\n\n    // Since a < group_order() and b < group_order(), we have a + b < 2 * group_order()\n    // This is just basic arithmetic: if x < A and y < A, then x + y < A + A = 2*A\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) < group_order() + group_order());\n    assert(group_order() + group_order() == 2 * group_order());\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) < 2 * group_order());\n\n    // Therefore: sum + (carry >> 52) * 2^260 < 2 * group_order()\n    assert(to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260) < 2 * group_order());\n\n    // Prove a contradiction if carry is nonzero\n    assert((carry >> 52) as nat * pow2(260) < 2 * group_order());\n    if carry >> 52 == 1 {\n        lemma_pow2_260_greater_than_2_group_order();\n        assert(1 as nat * pow2(260) < 2 * group_order());\n        assert(false);\n    }\n    assert(carry >> 52 == 0);\n\n    // Since carry >> 52 >= 0 and pow2(260) > 0, we have (carry >> 52) * pow2(260) >= 0\n    // Therefore sum < sum + (carry >> 52) * pow2(260) < 2 * group_order()\n    lemma_pow2_pos(260);\n    assert(pow2(260) > 0);\n    assert((carry >> 52) as nat * pow2(260) >= 0);\n    assert(to_nat(&sum.limbs) <= to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260));\n    assert(to_nat(&sum.limbs) < 2 * group_order());\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 24,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/lemma_reorder_mul().",
      "display_name": "lemma_reorder_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/lemma_reorder_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "use core::fmt::Debug;\nuse core::ops::Neg;\nuse core::ops::{Add, AddAssign};\nuse core::ops::{Mul, MulAssign};",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_single_stage_division().",
      "display_name": "lemma_single_stage_division",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_single_stage_division().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_single_stage_division(limb: u64, carry_in: u64, stage_input: u64, carry_out: u64)\n    requires\n        limb < (1u64 << 52),\n        limb + carry_in <= u64::MAX,  // No overflow\n        stage_input == (limb + carry_in) as u64,\n        stage_input < 3 * pow2(51),\n        carry_out == (stage_input >> 51) as u64,\n    ensures\n        carry_out < 3,\n        carry_out as int == (limb as int + carry_in as int) / pow2(51) as int,\n{\n    lemma_carry_propagation_setup();\n\n    // Prove the division relationship\n    lemma_u64_shr_is_div(stage_input, 51);\n    // Since limb + carry_in <= u64::MAX, the cast doesn't change the value\n\n    // Prove the bound\n    lemma_bounded_shr_51(stage_input);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 Choice#BitAnd#bitand().",
      "display_name": "bitand",
      "symbol": "rust-analyzer cargo subtle 2.6.1 Choice#BitAnd#bitand().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_as_bytes().",
      "display_name": "spec_as_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_as_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/field_core.rs",
      "file_name": "field_core.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn spec_as_bytes(limbs: [u64; 5]) -> [u8; 32] {\n    let reduced_limbs = spec_reduce(limbs);\n    let q = compute_q_spec(reduced_limbs);\n    bit_arrange(reduce_with_q_spec(reduced_limbs, q))\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/carry_val().",
      "display_name": "carry_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/carry_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn carry_val(a: [u64; 5]) -> u64 {\n    (c4_val(a) >> 51) as u64\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "display_name": "as_montgomery",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    /* <VERIFICATION NOTE>\n     Added verifier::external_body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    /* <MODIFIED CODE> - FOR EVENTUAL VERIFICATION*/\n    fn product<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified product_of_slice function\n        Scalar::product_of_slice(&scalars)\n    }  /* </MODIFIED CODE> */",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_to_le_bytes().",
      "display_name": "u64_to_le_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_to_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//! use curve25519_dalek::scalar::Scalar;\n//!\n//! // Hashing a single byte slice\n//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }\n//! ```\n//!\n//! See also `Scalar::hash_from_bytes` and `Scalar::from_hash` that\n//! reduces a \\\\(512\\\\)-bit integer, if the optional `digest` feature\n//! has been enabled.\n\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::{Product, Sum};\nuse core::ops::Index;",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/load8_at().",
      "display_name": "load8_at",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/load8_at().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "const fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select().",
      "display_name": "select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub limbs: [u64; 5],\n}\n\n} // verus!\nimpl Debug for Scalar52 {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar52: {:?}\", self.limbs)\n    }\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    /// A random element of the Ristretto group.\n    ///\n    /// # Implementation\n    ///\n    /// Uses the Ristretto-flavoured Elligator 2 map, so that the\n    /// discrete log of the output point with respect to any other\n    /// point should be unknown.  The map is applied twice and the\n    /// results are added, to ensure a uniform distribution.\n    pub fn random<R: CryptoRngCore + ?Sized>(rng: &mut R) -> Self {\n        let mut uniform_bytes = [0u8; 64];\n        rng.fill_bytes(&mut uniform_bytes);\n\n        RistrettoPoint::from_uniform_bytes(&uniform_bytes)\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#len().",
      "display_name": "len",
      "symbol": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#len().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_scalar().",
      "display_name": "to_scalar",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_scalar().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
      "relative_path": "src/backend/serial/u64/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "u64",
      "body": "pub open spec fn to_scalar(limbs: &[u64; 5]) -> nat {\n    to_nat(limbs) % group_order()\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#MulAssign#mul_assign().",
      "display_name": "mul_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#MulAssign#mul_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn mul_assign(&mut self, scalar: &Scalar) {\n        *self = (self as &MontgomeryPoint) * scalar;\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_swap_u64().",
      "display_name": "conditional_swap_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_swap_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/limbs_bounded().",
      "display_name": "limbs_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/limbs_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "use core::ops::{Mul, MulAssign};\nuse core::ops::{Sub, SubAssign};",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "display_name": "lemma2_to64",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 53,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#as_deref().",
      "display_name": "as_deref",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#as_deref().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from16().",
      "display_name": "seq_from16",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from16().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub open spec fn seq_from16(b: &[u8; 16]) -> Seq<u8> {\n    Seq::new(16, |i: int| b[i])\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_v0_and_reorder().",
      "display_name": "mul_v0_and_reorder",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_v0_and_reorder().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs",
      "file_name": "as_nat_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "            v3 as int,\n            s4 as int,\n            v4 as int,\n        )\n    }\n\n    // we now mash them all together\n    assert(as_nat(v) * as_nat(v) == s8 * (v4 * v4) + s7 * (2 * (v3 * v4)) + s6 * (v3 * v3 + 2 * (v2\n        * v4)) + s5 * (2 * (v2 * v3) + 2 * (v1 * v4)) + s4 * (v2 * v2 + 2 * (v1 * v3) + 2 * (v0\n        * v4)) + s3 * (2 * (v1 * v2) + 2 * (v0 * v3)) + s2 * (v1 * v1 + 2 * (v0 * v2)) + s1 * (2 * (\n    v0 * v1)) + (v0 * v0)) by {\n        // These assert(a + a = 2a) statements aren't strictly necessary, but they improve the solve time\n        // s1 terms\n        assert(s1 * (v0 * v1) + s1 * (v0 * v1) == s1 * (2 * (v0 * v1))) by {\n            assert(v0 * v1 + v0 * v1 == 2 * (v0 * v1));\n            lemma_mul_is_distributive_add(s1 as int, v0 * v1, v0 * v1);\n        }\n\n        // s2 terms\n        assert(s2 * (v0 * v2) + s2 * (v1 * v1) + s2 * (v0 * v2) == s2 * (v1 * v1 + 2 * (v0 * v2)))\n            by {\n            assert(v0 * v2 + v0 * v2 == 2 * (v0 * v2));\n            lemma_mul_is_distributive_add(s2 as int, v0 * v2, v0 * v2);\n            lemma_mul_is_distributive_add(s2 as int, 2 * (v0 * v2), v1 * v1);\n        }\n\n        // s3 terms\n        assert(s3 * (v0 * v3) + s3 * (v1 * v2) + s3 * (v1 * v2) + s3 * (v0 * v3) == s3 * (2 * (v1\n            * v2) + 2 * (v0 * v3))) by {\n            assert(v1 * v2 + v1 * v2 == 2 * (v1 * v2));\n            assert(v0 * v3 + v0 * v3 == 2 * (v0 * v3));\n            lemma_mul_is_distributive_add(s3 as int, v1 * v2, v1 * v2);\n            lemma_mul_is_distributive_add(s3 as int, v0 * v3, v0 * v3);\n            lemma_mul_is_distributive_add(s3 as int, 2 * (v1 * v2), 2 * (v0 * v3));\n        }\n\n        // s4 terms\n        assert(s4 * (v0 * v4) + s4 * (v1 * v3) + s4 * (v2 * v2) + s4 * (v1 * v3) + s4 * (v0 * v4)\n            == s4 * (v2 * v2 + 2 * (v1 * v3) + 2 * (v0 * v4))) by {\n            assert(v0 * v4 + v0 * v4 == 2 * (v0 * v4));\n            assert(v1 * v3 + v1 * v3 == 2 * (v1 * v3));\n            lemma_mul_is_distributive_add(s4 as int, v0 * v4, v0 * v4);\n            lemma_mul_is_distributive_add(s4 as int, v1 * v3, v1 * v3);\n            lemma_mul_is_distributive_add(s4 as int, v2 * v2, 2 * (v1 * v3));\n            lemma_mul_is_distributive_add(s4 as int, v2 * v2 + 2 * (v1 * v3), 2 * (v0 * v4));\n        }\n\n        // s5 terms\n        assert(s5 * (v1 * v4) + s5 * (v2 * v3) + s5 * (v2 * v3) + s5 * (v1 * v4) == s5 * (2 * (v2\n            * v3) + 2 * (v1 * v4))) by {\n            assert(v1 * v4 + v1 * v4 == 2 * (v1 * v4));\n            assert(v2 * v3 + v2 * v3 == 2 * (v2 * v3));\n            lemma_mul_is_distributive_add(s5 as int, v1 * v4, v1 * v4);\n            lemma_mul_is_distributive_add(s5 as int, v2 * v3, v2 * v3);\n            lemma_mul_is_distributive_add(s5 as int, 2 * (v1 * v4), 2 * (v2 * v3));\n        }\n\n        // s6 terms\n        assert(s6 * (v2 * v4) + s6 * (v3 * v3) + s6 * (v2 * v4) == s6 * (v3 * v3 + 2 * (v2 * v4)))\n            by {\n            assert(v2 * v4 + v2 * v4 == 2 * (v2 * v4));\n            lemma_mul_is_distributive_add(s6 as int, v2 * v4, v2 * v4);\n            lemma_mul_is_distributive_add(s6 as int, 2 * (v2 * v4), v3 * v3);\n        }\n\n        // s7 terms\n        assert(s7 * (v3 * v4) + s7 * (v3 * v4) == s7 * (2 * (v3 * v4))) by {\n            assert(v3 * v4 + v3 * v4 == 2 * (v3 * v4));\n            lemma_mul_is_distributive_add(s7 as int, v3 * v4, v3 * v4);\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c4_0_val().",
      "display_name": "c4_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c4_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "pub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_is_ordered_by_denominator().",
      "display_name": "lemma_div_is_ordered_by_denominator",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_is_ordered_by_denominator().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb2_byte_contribution_52().",
      "display_name": "limb2_byte_contribution_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb2_byte_contribution_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub open spec fn limb2_byte_contribution_52(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    bytes[13] as nat * pow2(13 * 8) + bytes[14] as nat * pow2(14 * 8) + bytes[15] as nat * pow2(\n        15 * 8,\n    ) + bytes[16] as nat * pow2(16 * 8) + bytes[17] as nat * pow2(17 * 8) + bytes[18] as nat * pow2(\n        18 * 8,\n    )\n        +\n    // Byte 19 is a boundary byte - limb 2 contributes only the low 4 bits\n    ((limbs[2] as nat / pow2(48)) % 16) * pow2(19 * 8)\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/From#from().",
      "display_name": "from",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/From#from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
      "relative_path": "src/backend/serial/scalar_mul/straus.rs",
      "file_name": "straus.rs",
      "parent_folder": "scalar_mul",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_empty_seq_as_nat().",
      "display_name": "lemma_empty_seq_as_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_empty_seq_as_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_empty_seq_as_nat(a: Seq<u64>)\n    ensures\n        seq_u64_to_nat(a.subrange(0, 0)) == 0,\n{\n    assert(seq_u64_to_nat(a.subrange(0, 0)) == 0);\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb2().",
      "display_name": "load8_limb2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn load8_limb2(input: &[u8])\n    requires\n        12 + 7 < input.len(),\n    ensures\n        ((load8_at_spec(input, 12) as u64) >> 6) & mask51 == (input[12] as nat / pow2(6)) + (\n        input[13] * pow2((1 * 8 - 6) as nat)) + (input[14] * pow2((2 * 8 - 6) as nat)) + (input[15]\n            * pow2((3 * 8 - 6) as nat)) + (input[16] * pow2((4 * 8 - 6) as nat)) + (input[17]\n            * pow2((5 * 8 - 6) as nat)) + (input[18] * pow2((6 * 8 - 6) as nat)) + ((\n        input[19] as nat % pow2(1)) * pow2((7 * 8 - 6) as nat)),\n{\n    let i = 12;\n    let k = 6;\n\n    let j_div = 1;\n    let j_id = 7;\n    let j_shift = 8;\n\n    load8_limb_X(input, i, k, j_div, j_id, j_shift);\n\n    // Sanity check\n    assert((load8_at_spec(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n        / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n    pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64));\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "display_name": "load8_shift_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn load8_shift_mod(input: &[u8], i: usize, s64: u64, t: nat)\n    requires\n        i + 7 < input.len(),\n        s64 < 64,\n        t < 64,\n    ensures\n        (load8_at_spec(input, i) as u64 >> s64) & (low_bits_mask(t) as u64) == ((pow2(0 * 8)\n            * input[i + 0]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(1 * 8)\n            * input[i + 1]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(2 * 8)\n            * input[i + 2]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(3 * 8)\n            * input[i + 3]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(4 * 8)\n            * input[i + 4]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(5 * 8)\n            * input[i + 5]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(6 * 8)\n            * input[i + 6]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(7 * 8)\n            * input[i + 7]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64),\n{\n    let x = load8_at_spec(input, i) as u64;\n    let y = load8_at_plus_version_rec(input, i, 7);\n    let s = s64 as nat;\n    let ps64 = pow2(s) as u64;\n\n    assert(0 < pow2(s) <= u64::MAX) by {\n        lemma_pow2_pos(s);\n        pow2_le_max64(s);\n    }\n\n    assert(x >> s64 == x / ps64) by {\n        lemma_u64_shr_is_div(x, s64);\n    }\n\n    assert(x == y) by {\n        plus_version_is_spec(input, i);\n    }\n\n    assert forall|j: nat| j <= 7 implies #[trigger] pow2(j * 8) * input[i + j] <= u64::MAX by {\n        assert(pow2(j * 8) * input[i + j] == input[i + j] * pow2(j * 8));\n        u8_times_pow2_fits_u64(input[i + j], j * 8);\n    }\n\n    assert(y / ps64 == (pow2(0 * 8) * input[i + 0]) as u64 / ps64 + (pow2(1 * 8) * input[i\n        + 1]) as u64 / ps64 + (pow2(2 * 8) * input[i + 2]) as u64 / ps64 + (pow2(3 * 8) * input[i\n        + 3]) as u64 / ps64 + (pow2(4 * 8) * input[i + 4]) as u64 / ps64 + (pow2(5 * 8) * input[i\n        + 5]) as u64 / ps64 + (pow2(6 * 8) * input[i + 6]) as u64 / ps64 + (pow2(7 * 8) * input[i\n        + 7]) as u64 / ps64) by {\n        load8_plus_ver_div_mod(input, i, 7, s);\n        load8_plus_ver_div_mod(input, i, 6, s);\n        load8_plus_ver_div_mod(input, i, 5, s);\n        load8_plus_ver_div_mod(input, i, 4, s);\n        load8_plus_ver_div_mod(input, i, 3, s);\n        load8_plus_ver_div_mod(input, i, 2, s);\n        load8_plus_ver_div_mod(input, i, 1, s);\n\n        assert(load8_at_plus_version_rec(input, i, 0) == (pow2(0 * 8) * input[i + 0]) as u64) by {\n            assert(load8_at_plus_version_rec(input, i, 0) == (input[i as int] as u64));\n            assert(pow2(0 * 8) == 1) by {\n                lemma2_to64();\n            }\n            assert((pow2(0 * 8) * input[i + 0]) as u64 == (input[i as int] as u64)) by {\n                lemma_mul_basics_4(input[i as int] as int);  // 1 * x = x\n            }\n        }\n    }\n\n    let pt64 = pow2(t) as u64;\n    let z = y / ps64;\n\n    assert(low_bits_mask(t) <= u64::MAX) by {\n        low_bits_masks_fit_u64(t);\n    }\n\n    assert(z & (low_bits_mask(t) as u64) == z % pt64) by {\n        lemma_u64_low_bits_mask_is_mod(z, t);\n    }\n\n    assert forall|j: nat| 0 <= j <= 7 implies #[trigger] pow2(j * 8) > 0 by {\n        lemma_pow2_pos(j * 8);\n    }\n\n    assert forall|j: nat| 0 <= j <= 7 implies #[trigger] (pow2(j * 8) * input[i + j]) <= pow2(\n        (j + 1) * 8,\n    ) - pow2(j * 8) by {\n        assert(j * 8 + 8 == (j + 1) * 8) by {\n            lemma_mul_is_distributive_add_other_way(8, j as int, 1);\n        }\n        pow2_mul_u8(input[i + j], j * 8);\n    }\n\n    // pow2(_) values;\n    lemma2_to64();\n    lemma2_to64_rest();\n    assert(0 < pow2(t) <= u64::MAX) by {\n        lemma_pow2_pos(t);\n        pow2_le_max64(t);\n    }\n\n    // ---- lemmas about X * pow2\n    assert forall|j: nat| 0 <= j <= 7 implies #[trigger] pow2(j * 8) * input[i + j]\n        == #[trigger] input[i + j] * pow2(j * 8) by {\n        lemma_mul_is_commutative(pow2(j * 8) as int, input[i + j] as int);\n    }\n\n    assert forall|j: nat| 0 <= j <= 7 implies #[trigger] (pow2(j * 8) * input[i + j]) <= pow2(\n        (j + 1) * 8,\n    ) - pow2(j * 8) && pow2((j + 1) * 8) > pow2(j * 8) by {\n        assert(j * 8 + 8 == (j + 1) * 8) by {\n            lemma_mul_is_distributive_add_other_way(8, j as int, 1);\n        }\n        pow2_mul_u8(input[i + j], j * 8);\n        assert(pow2((j + 1) * 8) > pow2(j * 8)) by {\n            lemma_pow2_strictly_increases(j * 8, j * 8 + 8);\n        }\n    }\n    // ---- lemmas about X * pow2 <END>\n\n    let a0 = (pow2(0 * 8) * input[i + 0]) as u64;\n    let a1 = (pow2(1 * 8) * input[i + 1]) as u64;\n    let a2 = (pow2(2 * 8) * input[i + 2]) as u64;\n    let a3 = (pow2(3 * 8) * input[i + 3]) as u64;\n    let a4 = (pow2(4 * 8) * input[i + 4]) as u64;\n    let a5 = (pow2(5 * 8) * input[i + 5]) as u64;\n    let a6 = (pow2(6 * 8) * input[i + 6]) as u64;\n    let a7 = (pow2(7 * 8) * input[i + 7]) as u64;\n\n    // Trigger the forall-s\n    assert(a0 == input[i + 0] * pow2(0));\n    assert(a1 == input[i + 1] * pow2(8));\n    assert(a2 == input[i + 2] * pow2(16));\n    assert(a3 == input[i + 3] * pow2(24));\n    assert(a4 == input[i + 4] * pow2(32));\n    assert(a5 == input[i + 5] * pow2(40));\n    assert(a6 == input[i + 6] * pow2(48));\n    assert(a7 == input[i + 7] * pow2(56));\n\n    let s0_0 = a0;\n    let s0 = s0_0 / ps64;\n\n    assert(s0_0 < pow2(1 * 8));\n    assert(s0_0 + a1 <= u64::MAX);\n\n    let s1_0 = (s0_0 + a1) as u64;\n    let s1 = s1_0 / ps64;\n\n    assert(s1_0 < pow2(2 * 8));\n    assert(s1 == s0_0 / ps64 + a1 / ps64) by {\n        lemma_bitops_lifted(s0_0, input[i + 1] as u64, 1 * 8, s);\n    }\n    assert(s1_0 + a2 <= u64::MAX);\n\n    let s2_0 = (s1_0 + a2) as u64;\n    let s2 = s2_0 / ps64;\n\n    assert(s2_0 < pow2(3 * 8));\n    assert(s2 == s1_0 / ps64 + a2 / ps64) by {\n        lemma_bitops_lifted(s1_0, input[i + 2] as u64, 2 * 8, s);\n    }\n    assert(s2_0 + a3 <= u64::MAX);\n\n    let s3_0 = (s2_0 + a3) as u64;\n    let s3 = s3_0 / ps64;\n\n    assert(s3_0 < pow2(4 * 8));\n    assert(s3 == s2_0 / ps64 + a3 / ps64) by {\n        lemma_bitops_lifted(s2_0, input[i + 3] as u64, 3 * 8, s);\n    }\n    assert(s3_0 + a4 <= u64::MAX);\n\n    let s4_0 = (s3_0 + a4) as u64;\n    let s4 = s4_0 / ps64;\n\n    assert(s4_0 < pow2(5 * 8));\n    assert(s4 == s3_0 / ps64 + a4 / ps64) by {\n        lemma_bitops_lifted(s3_0, input[i + 4] as u64, 4 * 8, s);\n    }\n    assert(s4_0 + a5 <= u64::MAX);\n\n    let s5_0 = (s4_0 + a5) as u64;\n    let s5 = s5_0 / ps64;\n\n    assert(s5_0 < pow2(6 * 8));\n    assert(s5 == s4_0 / ps64 + a5 / ps64) by {\n        lemma_bitops_lifted(s4_0, input[i + 5] as u64, 5 * 8, s);\n    }\n    assert(s5_0 + a6 <= u64::MAX);\n\n    let s6_0 = (s5_0 + a6) as u64;\n    let s6 = s6_0 / ps64;\n\n    assert(s6_0 < pow2(7 * 8));\n    assert(s6 == s5_0 / ps64 + a6 / ps64) by {\n        lemma_bitops_lifted(s5_0, input[i + 6] as u64, 6 * 8, s);\n    }\n    assert(s6_0 + a7 <= u64::MAX);\n\n    let s7_0 = (s6_0 + a7) as u64;\n    let s7 = s7_0 / ps64;\n\n    assert(s7 == s6_0 / ps64 + a7 / ps64) by {\n        lemma_bitops_lifted(s6_0, input[i + 7] as u64, 7 * 8, s);\n    }\n\n    assert(s7 == z);\n\n    assert(s6_0 <= pow2(7 * 8) - 1);\n    assert(s5_0 <= pow2(6 * 8) - 1);\n    assert(s4_0 <= pow2(5 * 8) - 1);\n    assert(s3_0 <= pow2(4 * 8) - 1);\n    assert(s2_0 <= pow2(3 * 8) - 1);\n    assert(s1_0 <= pow2(2 * 8) - 1);\n    assert(s0_0 <= pow2(1 * 8) - 1);\n\n    assert(z % pt64 == ((pow2(0 * 8) * input[i + 0]) as u64 / ps64) % pt64 + ((pow2(1 * 8) * input[i\n        + 1]) as u64 / ps64) % pt64 + ((pow2(2 * 8) * input[i + 2]) as u64 / ps64) % pt64 + ((pow2(\n        3 * 8,\n    ) * input[i + 3]) as u64 / ps64) % pt64 + ((pow2(4 * 8) * input[i + 4]) as u64 / ps64) % pt64\n        + ((pow2(5 * 8) * input[i + 5]) as u64 / ps64) % pt64 + ((pow2(6 * 8) * input[i + 6]) as u64\n        / ps64) % pt64 + ((pow2(7 * 8) * input[i + 7]) as u64 / ps64) % pt64) by {\n        load8_shift_mod_lemma(s7_0, s6_0, a7, input[i + 7], 7, s, t);\n        load8_shift_mod_lemma(s6_0, s5_0, a6, input[i + 6], 6, s, t);\n        load8_shift_mod_lemma(s5_0, s4_0, a5, input[i + 5], 5, s, t);\n        load8_shift_mod_lemma(s4_0, s3_0, a4, input[i + 4], 4, s, t);\n        load8_shift_mod_lemma(s3_0, s2_0, a3, input[i + 3], 3, s, t);\n        load8_shift_mod_lemma(s2_0, s1_0, a2, input[i + 2], 2, s, t);\n        load8_shift_mod_lemma(s1_0, s0_0, a1, input[i + 1], 1, s, t);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 19
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base().",
      "display_name": "mul_base",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_base(scalar: &Scalar) -> Self {\n        EdwardsPoint::mul_base(scalar).to_montgomery()\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "display_name": "lemma_byte_sum_equals_limb_sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_byte_sum_equals_limb_sum(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < pow2(51),\n        bytes_match_limbs_packing(limbs, bytes),\n    ensures\n        as_nat_32_u8(&bytes) == as_nat(limbs),\n{\n    // This lemma performs the complete algebraic expansion:\n    //\n    // LHS: as_nat_32_u8(bytes)\n    //    = bytes[0] + bytes[1]*256 + bytes[2]*256^2 + ... + bytes[31]*256^31\n    //\n    // Substitute each byte[i] from bytes_match_limbs_packing:\n    //    = (limbs[0])\n    //      + (limbs[0]>>8)*256\n    //      + (limbs[0]>>16)*256^2\n    //      + ... [and so on for all 32 bytes]\n    //\n    // Group terms by limb:\n    //    = [terms involving limbs[0]]\n    //      + [terms involving limbs[1]]\n    //      + [terms involving limbs[2]]\n    //      + [terms involving limbs[3]]\n    //      + [terms involving limbs[4]]\n    //\n    // Show each group equals limbs[i] * pow2(i*51):\n    //    = limbs[0]*pow2(0) + limbs[1]*pow2(51) + limbs[2]*pow2(102) + limbs[3]*pow2(153) + limbs[4]*pow2(204)\n    //    = as_nat(limbs)\n    //\n    // The proof strategy is:\n    // 1. Define each limb's byte contribution as a spec function\n    // 2. Prove each contribution equals limbs[i] * pow2(i*51) using helper lemmas\n    // 3. Prove the sum of contributions equals as_nat_32_u8(bytes)\n    // 4. Therefore as_nat_32_u8(bytes) == as_nat(limbs)\n    //\n    // Key insight: pow2(48) * 8 = pow2(51) (the radix change point)\n    lemma2_to64();\n    lemma_pow2_adds(48, 3);  // Establishes pow2(51) = pow2(48) * 8\n\n    // Prove each limb's contribution to the byte sum\n    // Each lemma shows that the bytes from that limb contribute exactly limbs[i] * pow2(i*51)\n    let limb0_contribution = limb0_byte_contribution(limbs, bytes);\n    let limb1_contribution = limb1_byte_contribution(limbs, bytes);\n    let limb2_contribution = limb2_byte_contribution(limbs, bytes);\n    let limb3_contribution = limb3_byte_contribution(limbs, bytes);\n    let limb4_contribution = limb4_byte_contribution(limbs, bytes);\n\n    // Prove each contribution equals limbs[i] * pow2(i*51)\n    lemma_limb0_contribution_correctness(limbs, bytes);\n\n    lemma_limb1_contribution_correctness(limbs, bytes);\n\n    lemma_limb2_contribution_correctness(limbs, bytes);\n\n    lemma_limb3_contribution_correctness(limbs, bytes);\n\n    lemma_limb4_contribution_correctness(limbs, bytes);\n\n    // Prove the sum of contributions equals as_nat_32_u8(&bytes)\n    lemma_sum_equals_byte_nat(limbs, bytes);\n    assert(as_nat_32_u8(&bytes) == limb0_contribution + limb1_contribution + limb2_contribution\n        + limb3_contribution + limb4_contribution);\n\n    // Therefore, the sum equals as_nat(limbs)\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 17
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_geometric_series_radix51().",
      "display_name": "lemma_geometric_series_radix51",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_geometric_series_radix51().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_geometric_series_radix51(sum_powers: int)\n    requires\n        sum_powers == 1 + pow2(51) + pow2(102) + pow2(153) + pow2(204),\n    ensures\n        (pow2(51) - 1) * sum_powers == pow2(255) - 1,\n{\n    lemma_pow2_adds(51, 51);\n    lemma_pow2_adds(51, 102);\n    lemma_pow2_adds(51, 153);\n    lemma_pow2_adds(51, 204);\n    lemma_pow2_pos(51);\n\n    // Geometric series formula: (r - 1) * (1 + r + r^2 + ... + r^n) = r^(n+1) - 1\n    // Here: r = 2^51, n = 4, so r^5 = 2^255\n\n    // Step 1: Expand 2^51 * sum_powers using distributivity\n\n    // Expand: 2^51 * (1 + 2^51 + 2^102 + 2^153 + 2^204)\n    //       = 2^51 + 2^102 + 2^153 + 2^204 + 2^255\n    assert(pow2(51) * sum_powers == pow2(51) * 1 + pow2(51) * (pow2(51) + pow2(102) + pow2(153)\n        + pow2(204))) by {\n        lemma_mul_is_distributive_add(\n            pow2(51) as int,\n            1,\n            (pow2(51) + pow2(102) + pow2(153) + pow2(204)) as int,\n        );\n    }\n\n    assert(pow2(51) * (pow2(51) + pow2(102) + pow2(153) + pow2(204)) == pow2(51) * pow2(51) + pow2(\n        51,\n    ) * (pow2(102) + pow2(153) + pow2(204))) by {\n        lemma_mul_is_distributive_add(\n            pow2(51) as int,\n            pow2(51) as int,\n            (pow2(102) + pow2(153) + pow2(204)) as int,\n        );\n    }\n\n    assert(pow2(51) * (pow2(102) + pow2(153) + pow2(204)) == pow2(51) * pow2(102) + pow2(51) * (\n    pow2(153) + pow2(204))) by {\n        lemma_mul_is_distributive_add(\n            pow2(51) as int,\n            pow2(102) as int,\n            (pow2(153) + pow2(204)) as int,\n        );\n    }\n\n    assert(pow2(51) * (pow2(153) + pow2(204)) == pow2(51) * pow2(153) + pow2(51) * pow2(204)) by {\n        lemma_mul_is_distributive_add(pow2(51) as int, pow2(153) as int, pow2(204) as int);\n    }\n\n    // Chain them together\n\n    // Step 2: Apply the geometric series formula\n    // (2^51 - 1) * sum_powers = 2^51 * sum_powers - sum_powers\n    assert((pow2(51) - 1) * sum_powers == pow2(51) * sum_powers - sum_powers) by {\n        lemma_mul_is_distributive_sub(sum_powers, pow2(51) as int, 1);\n        lemma_mul_is_commutative(sum_powers, pow2(51) as int);\n        lemma_mul_is_commutative(sum_powers, 1);\n        lemma_mul_basics(sum_powers);\n    }\n\n    // Substitute the expansion\n    // = (2^51 + 2^102 + 2^153 + 2^204 + 2^255) - (1 + 2^51 + 2^102 + 2^153 + 2^204)\n    assert(pow2(51) * sum_powers - sum_powers == (pow2(51) + pow2(102) + pow2(153) + pow2(204)\n        + pow2(255)) - (1 + pow2(51) + pow2(102) + pow2(153) + pow2(204)));\n\n    // Step 3: Simplify by cancellation\n    // The terms 2^51, 2^102, 2^153, 2^204 cancel, leaving: 2^255 - 1\n    assert((pow2(51) + pow2(102) + pow2(153) + pow2(204) + pow2(255)) - (1 + pow2(51) + pow2(102)\n        + pow2(153) + pow2(204)) == pow2(255) - 1);\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#PartialEq#eq().",
      "display_name": "eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#PartialEq#eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn eq(&self, other: &RistrettoPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/bits_to_nat().",
      "display_name": "bits_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/bits_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "// - Brian Smith <brian@briansmith.org>\n//! Arithmetic on scalars (integers mod the group order).\n//!\n//! Both the Ristretto group and the Ed25519 basepoint have prime order\n//! \\\\( \\ell = 2\\^{252} + 27742317777372353535851937790883648493 \\\\).\n//!",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV_MOD().",
      "display_name": "pow2_mul_DIV_MOD",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV_MOD().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn pow2_mul_DIV_MOD(x: nat, px: nat, k: nat, s: nat, t: nat)\n    requires\n        x < pow2(px),\n        k <= s,\n        px <= t + s - k,\n    ensures\n        ((x * pow2(k)) / pow2(s)) % pow2(t) == x / pow2((s - k) as nat),\n{\n    let d = (s - k) as nat;\n\n    assert((x * pow2(k)) / pow2(s) == x / pow2(d)) by {\n        pow2_mul_DIV(x, k, s);\n    }\n\n    assert(pow2(d) > 0) by {\n        lemma_pow2_pos(d);\n    }\n\n    assert(x / pow2(d) < pow2(t)) by {\n        assert(x < pow2(d) * pow2(t)) by {\n            assert(pow2(d) * pow2(t) == pow2(d + t)) by {\n                lemma_pow2_adds(d, t);\n            }\n            assert(pow2(px) <= pow2(t + d)) by {\n                if (px < t + d) {\n                    lemma_pow2_strictly_increases(px, t + d);\n                }\n            }\n        }\n        assert(x / pow2(d) < pow2(t)) by {\n            lemma_multiply_divide_lt(x as int, pow2(d) as int, pow2(t) as int);\n        }\n    }\n\n    assert((x / pow2(d)) % pow2(t) == x / pow2(d)) by {\n        lemma_small_mod(x / pow2(d), pow2(t));\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/bitwise_or_r_zero_is_id().",
      "display_name": "bitwise_or_r_zero_is_id",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/bitwise_or_r_zero_is_id().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/bit_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/bit_lemmas.rs",
      "file_name": "bit_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn bitwise_or_r_zero_is_id(a: u64)\n    ensures\n        a | 0 == a,\n{\n    assert(a | 0 == a) by (bit_vector);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "display_name": "test_lizard_encode_helper",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    fn test_lizard_encode_helper(data: &[u8; 16], result: &[u8; 32]) {\n        let p = RistrettoPoint::lizard_encode::<Sha256>(data);\n        let p_bytes = p.compress().to_bytes();\n        assert!(&p_bytes == result);\n        let p = CompressedRistretto::from_slice(&p_bytes)\n            .unwrap()\n            .decompress()\n            .unwrap();\n        let data_out = p.lizard_decode::<Sha256>().unwrap();\n        assert!(&data_out == data);\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"ProjectivePoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z\n        )\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops().",
      "display_name": "lemma_bitops",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/bit_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/bit_lemmas.rs",
      "file_name": "bit_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn lemma_bitops(a: u64, b: u64, c: u64)\n    requires\n        c < 64,\n    ensures\n        (a | b) >> c == (a >> c) | (b >> c),\n        (a | b) & (low_bits_mask(c as nat) as u64) == (a & (low_bits_mask(c as nat) as u64)) | (b\n            & (low_bits_mask(c as nat) as u64)),\n{\n    assert(low_bits_mask(c as nat) <= u64::MAX) by {\n        low_bits_masks_fit_u64(c as nat);\n    }\n    assert((a | b) >> c == (a >> c) | (b >> c)) by (bit_vector);\n    let lbm = (low_bits_mask(c as nat) as u64);\n    assert((a | b) & lbm == (a & lbm) | (b & lbm)) by (bit_vector);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_strictly_bounded().",
      "display_name": "lemma_div_strictly_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_strictly_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "\n    // Now LHS equals (after substituting the expansions):\n    // = q0*2^51 + r0 - 19\n    //   + q1*2^51*2^51 + r1*2^51 - q0*2^51\n    //   + q2*2^51*2^102 + r2*2^102 - q1*2^102\n    //   + q3*2^51*2^153 + r3*2^153 - q2*2^153\n    //   + q4*2^51*2^204 + r4*2^204 - q3*2^204\n    //   + 19\n\n    // Use the power relationships to simplify products\n    assert(q1 * pow2(51) as int * pow2(51) as int == q1 * pow2(102) as int) by {\n        lemma_mul_is_associative(q1, pow2(51) as int, pow2(51) as int);\n    }",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "display_name": "optional_mixed_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        self.0\n            .optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points.into_iter().map(|P_opt| P_opt.map(|P| P.0)),\n            )\n            .map(RistrettoPoint)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#optional_mixed_multiscalar_mul().",
      "display_name": "optional_mixed_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#optional_mixed_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "//! 3. the function for decoding (so that only the canonical encoding of\n//!    a coset is accepted).\n//!\n//! Internally, each coset is represented by a curve point; two points\n//! \\\\( P, Q \\\\) may represent the same coset in the same way that two\n//! points with different \\\\(X,Y,Z\\\\) coordinates may represent the\n//! same point.  The group operations are carried out with no overhead\n//! using Edwards formulas.\n//!\n//! Notes on the details of the encoding can be found in the\n//! [Details][ristretto_notes] section of the Ristretto website.\n//!\n//! [cryptonote]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000898.html\n//! [ed25519_hkd]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000858.html\n//! [ristretto_coffee]:\n//! https://en.wikipedia.org/wiki/Ristretto\n//! [ristretto_notes]:\n//! https://ristretto.group/details/index.html\n//! [why_ristretto]:\n//! https://ristretto.group/why_ristretto.html\n//! [ristretto_main]:\n//! https://ristretto.group/\n\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\n\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#AddAssign#add_assign().",
      "display_name": "add_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#AddAssign#add_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn add_assign(&mut self, _rhs: &'a Scalar)\n        ensures\n            bytes_to_nat(&self.bytes) == (bytes_to_nat(&old(self).bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order(),\n    {\n        *self = &*self + _rhs;\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "display_name": "neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        /* <ORIGINAL CODE>\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        proof {\n            // Preconditions for mul_internal and sub\n            assume(limbs_bounded(&constants::R));\n            assume(limbs_bounded(&UnpackedScalar::ZERO));\n        }\n\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n\n        proof {\n            assume(limbs_bounded(&self_mod_l));\n            // sub requires: -group_order() <= 0 - to_nat(&self_mod_l.limbs) < group_order()\n            assume(-group_order() <= to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(\n                &self_mod_l.limbs,\n            ));\n            assume(to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(&self_mod_l.limbs) < group_order());\n        }\n\n        let result = UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack();\n        proof {\n            // TODO: Prove that -self + self == 0 (mod group_order)\n            assume((scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0);\n        }\n\n        /* </MODIFIED CODE> */\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "display_name": "mul_by_pow_2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn mul_by_pow_2(&self, k: u32) -> EdwardsPoint {\n        debug_assert!(k > 0);\n        let mut r: CompletedPoint;\n        let mut s = self.as_projective();\n        for _ in 0..(k - 1) {\n            r = s.double();\n            s = r.as_projective();\n        }\n        // Unroll last iteration so we can go directly as_extended()\n        s.double().as_extended()\n    }",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_edwards().",
      "display_name": "to_edwards",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_edwards().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "        EdwardsPoint,\n    >)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            is_valid_y_coordinate(field_element_from_bytes(&self.0))\n                ==> result.is_some()\n            // The Y coordinate matches the one from the compressed representation\n             && field_element(&result.unwrap().Y) == field_element_from_bytes(\n                &self.0,\n            )\n            // The point is valid\n             && is_valid_edwards_point(\n                result.unwrap(),\n            )\n            // The X coordinate sign bit matches the sign bit from the compressed representation\n             && field_element_sign_bit(&result.unwrap().X) == (self.0[31] >> 7),\n            !is_valid_y_coordinate(field_element_from_bytes(&self.0)) <==> result.is_none(),\n    {\n        let (is_valid_y_coord, X, Y, Z) = decompress::step_1(self);\n\n        proof {\n            assert(choice_is_true(is_valid_y_coord) ==> is_valid_y_coordinate(\n                field_element_from_bytes(&self.0),\n            ));\n            assert(choice_is_true(is_valid_y_coord) ==> on_edwards_curve(\n                field_element(&X),\n                field_element(&Y),\n            ));\n        }\n        if choice_into(is_valid_y_coord) {\n            assert(choice_is_true(is_valid_y_coord));\n            assert(field_element(&Y) == field_element_from_bytes(&self.0));\n            let point = decompress::step_2(self, X, Y, Z);\n            let result = Some(point);\n            assume(false);\n            result\n        } else {\n            assert(!choice_is_true(is_valid_y_coord));\n            assert(!is_valid_y_coordinate(field_element_from_bytes(&self.0)));\n            let result = None;\n            result\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_cast_then_mod_51().",
      "display_name": "lemma_cast_then_mod_51",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_cast_then_mod_51().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 CtOption#unwrap().",
      "display_name": "unwrap",
      "symbol": "rust-analyzer cargo subtle 2.6.1 CtOption#unwrap().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_le().",
      "display_name": "mul_le",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_le().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "use vstd::arithmetic::mul::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\n#[allow(unused_imports)]\nuse vstd::bits::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::bit_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::div_mod_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mask_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mul_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::pow_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::shift_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_nat_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::compute_q_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::field_core::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::from_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::limbs_to_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::load8_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::negate_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2_51_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 9,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#bits_le_verus().",
      "display_name": "bits_le_verus",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#bits_le_verus().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "pub(crate) fn bits_le_verus(&self) -> (result: [bool; 256])\n    ensures\n        bits_to_nat(&result) == bytes_to_nat(&self.bytes),\n{\n    let mut bits = [false;256];\n    let mut i: usize = 0;\n\n    while i < 256\n        invariant\n            i <= 256,\n            bits.len() == 256,\n            self.bytes.len() == 32,\n        decreases 256 - i,\n    {\n        // As i runs from 0..256, the bottom 3 bits index the bit, while the upper bits index\n        // the byte. Since self.bytes is little-endian at the byte level, this is\n        // little-endian on the bit level\n        let byte_idx = i >> 3;  // Divide by 8 to get byte index\n        let bit_idx = (i & 7) as u8;  // Modulo 8 to get bit position within byte\n\n        // Prove bounds using shift and mask lemmas\n        proof {\n            use crate::backend::serial::u64::common_verus::shift_lemmas::*;\n            use crate::backend::serial::u64::common_verus::mask_lemmas::*;\n            use vstd::bits::*;\n            use vstd::arithmetic::power2::*;\n\n            assert(i < 256);\n\n            // Prove i >> 3 = i / 8 using shift lemma\n            lemma_u64_shr_is_div(i as u64, 3);\n            // pow2(3) = 8\n            lemma2_to64();\n            assert(byte_idx < 32);\n\n            // Prove i & 7 = i % 8 using mask lemma\n            lemma_u64_low_bits_mask_is_mod(i as u64, 3);\n            // low_bits_mask(3) = 7 and pow2(3) = 8\n            lemma2_to64();\n            assert(bit_idx < 8);\n        }\n\n        bits[i] = ((self.bytes[byte_idx] >> bit_idx) & 1u8) == 1;\n        i += 1;\n    }\n\n    proof {\n        assume(bits_to_nat(&bits) == bytes_to_nat(&self.bytes));\n    }\n\n    bits\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#part2().",
      "display_name": "part2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#part2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn part2(sum: u128) -> (res: (u128, u64))\n        ensures\n            ({\n                let carry = res.0;\n                let w = res.1;\n                &&& w < (1u64\n                    << 52)  // VER NOTE: w is bounded by 52 bits (lower limb)\n                // VER NOTE: The sum equals w plus carry shifted left by 52 bits\n                &&& sum == (w as u128) + (carry << 52)\n            }),",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_affine_niels().",
      "display_name": "as_affine_niels",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_affine_niels().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_u8().",
      "display_name": "pow2_mul_u8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_u8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "            }\n        }\n    }\n}\n\npub proof fn plus_version_is_spec_lemma(input: &[u8], i: usize, j: nat)\n    requires\n        1 <= j <= 7,\n    ensures\n        (input[i + j] as u64) << 8 * j == pow2(j * 8) * input[i + j],\n        input[i + j] * pow2(j * 8) <= u64::MAX,\n        pow2(8 * (j + 1)) - 1 <= pow2(64) - 1,\n        pow2(8) * pow2(8 * j) == pow2(8 * (j + 1)),\n{\n    assert(pow2(64) - 1 == u64::MAX) by {\n        lemma2_to64_rest();\n    }\n\n    assert(u8::MAX + 1 == pow2(8)) by {\n        lemma2_to64();\n    }\n\n    assert(pow2(8 * (j + 1)) - 1 <= pow2(64) - 1) by {\n        if (j < 7) {\n            lemma_pow2_strictly_increases(8 * (j + 1), 64);\n        }\n    }\n\n    lemma_pow2_adds(8, j * 8);\n\n    lemma_mul_inequality(input[i + j] as int, u8::MAX as int, pow2(j * 8) as int);\n\n    assert((input[i + j] as u64) * pow2(j * 8) <= u64::MAX) by {\n        assert(u8::MAX * pow2(j * 8) <= pow2(64) - 1) by {\n            assert(u8::MAX * pow2(j * 8) == (pow2(8) - 1) * pow2(j * 8) == pow2(8 * (j + 1)) - pow2(\n                j * 8,\n            )) by {\n                assert(pow2(8) >= 1) by {\n                    lemma2_to64();\n                }\n                lemma_mul_is_distributive_sub(pow2(8) as int, 1, pow2(j * 8) as int);\n            }\n            assert(pow2(j * 8) > 1) by {\n                lemma2_to64();  // pow2(0)\n                lemma_pow2_strictly_increases(0, j * 8)\n            }\n        }\n    }\n    lemma_u64_shl_is_mul((input[i + j] as u64), (j * 8) as u64);\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "display_name": "montgomery_square",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "/* <VERIFICATION NOTE>\n Trait implementations for Product and Sum declared as external_body since they use iterators which are not supported by Verus.\n</VERIFICATION NOTE> */\n\nimpl<T> Product<T> for Scalar where T: Borrow<Scalar> {\n    /* <ORIGINAL CODE>\n    fn product<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ONE, |acc, item| acc * item.borrow())\n    }\n    </ORIGINAL CODE> */\n    /* <VERIFICATION NOTE>\n     Added verifier::external_body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    /* <MODIFIED CODE> - FOR EVENTUAL VERIFICATION*/\n    fn product<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified product_of_slice function\n        Scalar::product_of_slice(&scalars)\n    }  /* </MODIFIED CODE> */\n\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#is_torsion_free().",
      "display_name": "is_torsion_free",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#is_torsion_free().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn is_torsion_free(&self) -> bool {\n        (self * constants::BASEPOINT_ORDER_PRIVATE).is_identity()\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo std https://github.com/rust-lang/rust/library/std env/var().",
      "display_name": "var",
      "symbol": "rust-analyzer cargo std https://github.com/rust-lang/rust/library/std env/var().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "display_name": "optional_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/mod.rs",
      "relative_path": "src/backend/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "backend",
      "body": "    //     cpufeatures::new!(cpuid_avx2, \"avx2\");\n    //     let token_avx2: cpuid_avx2::InitToken = cpuid_avx2::init();\n    //     if token_avx2.get() {\n    //         return BackendKind::Avx2;\n    //     }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_seq_u64_to_nat_subrange_extend().",
      "display_name": "lemma_seq_u64_to_nat_subrange_extend",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_seq_u64_to_nat_subrange_extend().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_seq_u64_to_nat_subrange_extend(seq: Seq<u64>, i: int)\n    requires\n        0 <= i < seq.len(),\n    ensures\n        seq_u64_to_nat(seq.subrange(0, i + 1)) == seq_u64_to_nat(seq.subrange(0, i)) + seq[i]\n            * pow2(52 * i as nat),\n    decreases i,\n{\n    if i == 0 {\n        reveal_with_fuel(seq_to_nat, 3);\n        assert(seq.len() > 0);\n        assert(seq.subrange(0, 1) == seq![seq[0]]);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, 0 + 1 as int)); {\n                assert(seq.subrange(0, 1) == seq![seq[0]]);\n            }\n            seq_u64_to_nat(seq![seq[0]]); {\n                let single_elem = seq![seq[0]];\n                let nat_single = single_elem.map(|idx, x| x as nat);\n                assert(nat_single == seq![seq[0] as nat]);\n                assert(seq_u64_to_nat(single_elem) == seq_to_nat(nat_single));\n                assert(nat_single.len() == 1);\n                assert(seq_to_nat(nat_single) == nat_single[0] + seq_to_nat(\n                    nat_single.subrange(1, 1),\n                ) * pow2(52));\n                assert(nat_single.subrange(1, 1).len() == 0);\n                assert(seq_to_nat(nat_single.subrange(1, 1)) == 0);\n                assert(seq_to_nat(nat_single) == nat_single[0]);\n                assert(nat_single[0] == seq[0] as nat);\n            }\n            seq[0] as nat; {\n                assert(pow2(0) == 1) by {\n                    lemma2_to64();\n                }\n                assert(52 * 0 == 0);\n                assert(pow2(52 * 0 as nat) == pow2(0));\n                assert((seq[0] * pow2(0)) as nat == (seq[0] * 1) as nat);\n                assert((seq[0] * 1) as nat == seq[0] as nat);\n            }\n            (seq[0] * pow2(52 * 0 as nat)) as nat; {\n                lemma_empty_seq_as_nat(seq);\n            }\n            (seq_u64_to_nat(seq.subrange(0, 0)) + seq[0] * pow2(52 * 0 as nat)) as nat;\n        }\n        return ;\n    } else {\n        let limbs1 = seq.subrange(0, i + 1).map(|i, x| x as nat);\n        let limbs2 = seq.subrange(0, i).map(|i, x| x as nat);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, i + 1)); {\n                assert(seq_to_nat(limbs1) == limbs1[0] + seq_to_nat(\n                    limbs1.subrange(1, limbs1.len() as int),\n                ) * pow2(52));\n            }\n            limbs1[0] + seq_to_nat(limbs1.subrange(1, limbs1.len() as int)) * pow2(52); {\n                assert(seq.subrange(1, i + 1).map(|i, x| x as nat) == limbs1.subrange(\n                    1,\n                    limbs1.len() as int,\n                ));\n            }\n            limbs1[0] + seq_u64_to_nat(seq.subrange(1, i + 1)) * pow2(52); {\n                let tail = seq.subrange(1, i + 1);\n                assert(i >= 1);\n                assert(0 <= i - 1 < tail.len());\n                lemma_seq_u64_to_nat_subrange_extend(tail, i - 1);\n                assert(seq_u64_to_nat(tail.subrange(0, i)) == seq_u64_to_nat(\n                    tail.subrange(0, i - 1),\n                ) + tail[i - 1] * pow2(52 * (i - 1) as nat));\n                assert(tail.subrange(0, i) == seq.subrange(1, i + 1));\n                assert(tail.subrange(0, i - 1) == seq.subrange(1, i));\n                assert(seq_u64_to_nat(seq.subrange(1, i + 1)) == seq_u64_to_nat(seq.subrange(1, i))\n                    + seq[i] * pow2(52 * (i - 1) as nat));\n            }\n            limbs1[0] + ((seq_u64_to_nat(seq.subrange(1, i)) + seq[i] * pow2(52 * (i - 1) as nat))\n                * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i)) * pow2(52) + seq[i] * pow2(\n                52 * (i - 1) as nat,\n            ) * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_associative;\n\n                lemma_pow2_adds(52 * (i - 1) as nat, 52);\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i)) * pow2(52) + seq[i] * pow2(\n                52 * i as nat,\n            )) as nat; {\n                assert(seq.subrange(1, i).map(|i, x| x as nat) == limbs2.subrange(\n                    1,\n                    limbs2.len() as int,\n                ));\n            }\n            (limbs2[0] + seq_to_nat(limbs2.subrange(1, limbs2.len() as int)) * pow2(52) + seq[i]\n                * pow2(52 * i as nat)) as nat; {\n                assert(seq_to_nat(limbs2) == limbs2[0] + seq_to_nat(\n                    limbs2.subrange(1, limbs2.len() as int),\n                ) * pow2(52));\n            }\n            (seq_to_nat(limbs2) + seq[i] * pow2(52 * i as nat)) as nat; {}\n            (seq_u64_to_nat(seq.subrange(0, i)) + seq[i] * pow2(52 * i as nat)) as nat;\n        }\n    }\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "display_name": "compress",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn compress(&self) -> CompressedRistretto {\n        let mut X = self.0.X;\n        let mut Y = self.0.Y;\n        let Z = &self.0.Z;\n        let T = &self.0.T;\n\n        let u1 = &(Z + &Y) * &(Z - &Y);\n        let u2 = &X * &Y;\n        // Ignore return value since this is always square\n        let (_, invsqrt) = (&u1 * &u2.square()).invsqrt();\n        let i1 = &invsqrt * &u1;\n        let i2 = &invsqrt * &u2;\n        let z_inv = &i1 * &(&i2 * T);\n        let mut den_inv = i2;\n\n        let iX = &X * &constants::SQRT_M1;\n        let iY = &Y * &constants::SQRT_M1;\n        let ristretto_magic = &constants::INVSQRT_A_MINUS_D;\n        let enchanted_denominator = &i1 * ristretto_magic;\n\n        let rotate = (T * &z_inv).is_negative();\n\n        X.conditional_assign(&iY, rotate);\n        Y.conditional_assign(&iX, rotate);\n        den_inv.conditional_assign(&enchanted_denominator, rotate);\n\n        Y.conditional_negate((&X * &z_inv).is_negative());\n\n        let mut s = &den_inv * &(Z - &Y);\n        let s_is_negative = s.is_negative();\n        s.conditional_negate(s_is_negative);\n\n        CompressedRistretto(s.as_bytes())\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c3_0_val().",
      "display_name": "c3_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c3_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mul_mod_noop().",
      "display_name": "lemma_mul_mod_noop",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mul_mod_noop().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/pow2_MUL_div_MOD_u8_t51_cond().",
      "display_name": "pow2_MUL_div_MOD_u8_t51_cond",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/pow2_MUL_div_MOD_u8_t51_cond().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn pow2_MUL_div_MOD_u8_t51_cond(k: nat, j: nat) -> bool {\n    (k <= j * 8) && (8 + j * 8 - k <= 51)\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_inverse().",
      "display_name": "is_inverse",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_inverse().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let l_plus_two_bytes: [u8; 32] = [\n//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Option<Scalar> = Scalar::from_canonical_bytes(l_plus_two_bytes).into();\n//!\n//! assert!(a.is_none());\n//! ```\n//!\n//! Another way to create a `Scalar` is by reducing a \\\\(256\\\\)-bit integer mod\n//! \\\\( \\ell \\\\), for which one may use the\n//! [`Scalar::from_bytes_mod_order`](struct.Scalar.html#method.from_bytes_mod_order)\n//! method.  In the case of the second example above, this would reduce the\n//! resultant scalar \\\\( \\mod \\ell \\\\), producing \\\\( 2 \\\\):\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let l_plus_two_bytes: [u8; 32] = [\n//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Scalar = Scalar::from_bytes_mod_order(l_plus_two_bytes);\n//!\n//! let two: Scalar = Scalar::ONE + Scalar::ONE;\n//!\n//! assert!(a == two);\n//! ```\n//!\n//! There is also a constructor that reduces a \\\\(512\\\\)-bit integer,\n//! [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! To construct a `Scalar` as the hash of some input data, use\n//! [`Scalar::hash_from_bytes`], which takes a buffer, or\n//! [`Scalar::from_hash`], which allows an IUF API.\n//!\n#![cfg_attr(feature = \"digest\", doc = \"```\")]\n#![cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n//! # fn main() {\n//! use sha2::{Digest, Sha512};\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! // Hashing a single byte slice\n//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_MOD_u8().",
      "display_name": "pow2_MUL_div_MOD_u8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_MOD_u8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "        load8_plus_ver_div_mod(input, i, 5, s);\n        load8_plus_ver_div_mod(input, i, 4, s);\n        load8_plus_ver_div_mod(input, i, 3, s);\n        load8_plus_ver_div_mod(input, i, 2, s);\n        load8_plus_ver_div_mod(input, i, 1, s);\n\n        assert(load8_at_plus_version_rec(input, i, 0) == (pow2(0 * 8) * input[i + 0]) as u64) by {\n            assert(load8_at_plus_version_rec(input, i, 0) == (input[i as int] as u64));\n            assert(pow2(0 * 8) == 1) by {\n                lemma2_to64();\n            }\n            assert((pow2(0 * 8) * input[i + 0]) as u64 == (input[i as int] as u64)) by {\n                lemma_mul_basics_4(input[i as int] as int);  // 1 * x = x\n            }\n        }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_bytes32().",
      "display_name": "ct_eq_bytes32",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_bytes32().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//! Another way to create a `Scalar` is by reducing a \\\\(256\\\\)-bit integer mod\n//! \\\\( \\ell \\\\), for which one may use the\n//! [`Scalar::from_bytes_mod_order`](struct.Scalar.html#method.from_bytes_mod_order)\n//! method.  In the case of the second example above, this would reduce the\n//! resultant scalar \\\\( \\mod \\ell \\\\), producing \\\\( 2 \\\\):\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let l_plus_two_bytes: [u8; 32] = [\n//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Scalar = Scalar::from_bytes_mod_order(l_plus_two_bytes);\n//!\n//! let two: Scalar = Scalar::ONE + Scalar::ONE;\n//!\n//! assert!(a == two);\n//! ```\n//!\n//! There is also a constructor that reduces a \\\\(512\\\\)-bit integer,\n//! [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! To construct a `Scalar` as the hash of some input data, use\n//! [`Scalar::hash_from_bytes`], which takes a buffer, or\n//! [`Scalar::from_hash`], which allows an IUF API.\n//!\n#![cfg_attr(feature = \"digest\", doc = \"```\")]\n#![cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n//! # fn main() {\n//! use sha2::{Digest, Sha512};\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! // Hashing a single byte slice\n//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_cofactor().",
      "display_name": "mul_by_cofactor",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_cofactor().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_by_cofactor(&self) -> EdwardsPoint {\n        self.mul_by_pow_2(3)\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_compressed_identity().",
      "display_name": "is_compressed_identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_compressed_identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/curve_specs.rs",
      "relative_path": "src/curve_specs.rs",
      "file_name": "curve_specs.rs",
      "parent_folder": "src",
      "body": "pub open spec fn is_compressed_identity(compressed: crate::edwards::CompressedEdwardsY) -> bool {\n    // Extract the y-coordinate (identity has y = 1)\n    field_element_from_bytes(&compressed.0) == 1\n        &&\n    // Sign bit should be 0 (since x = 0)\n    (compressed.0[31] >> 7) == 0\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_clamped().",
      "display_name": "mul_clamped",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_clamped().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_clamped(self, bytes: [u8; 32]) -> Self {\n        // We have to construct a Scalar that is not reduced mod l, which breaks scalar invariant\n        // #2. But #2 is not necessary for correctness of variable-base multiplication. All that\n        // needs to hold is invariant #1, i.e., the scalar is less than 2^255. This is guaranteed\n        // by clamping.\n        // Further, we don't do any reduction or arithmetic with this clamped value, so there's no\n        // issues arising from the fact that the curve point is not necessarily in the prime-order\n        // subgroup.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        s * self\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#is_small_order().",
      "display_name": "is_small_order",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#is_small_order().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn is_small_order(&self) -> bool {\n        self.mul_by_cofactor().is_identity()\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "display_name": "rev",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
      "relative_path": "src/backend/serial/scalar_mul/straus.rs",
      "file_name": "straus.rs",
      "parent_folder": "scalar_mul",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/reduce_with_q_spec().",
      "display_name": "reduce_with_q_spec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/reduce_with_q_spec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb3().",
      "display_name": "load8_limb3",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb3().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn load8_limb3(input: &[u8])\n    requires\n        19 + 7 < input.len(),\n    ensures\n        ((load8_at_spec(input, 19) as u64) >> 1) & mask51 == (input[19] as nat / pow2(1)) + (\n        input[20] * pow2((1 * 8 - 1) as nat)) + (input[21] * pow2((2 * 8 - 1) as nat)) + (input[22]\n            * pow2((3 * 8 - 1) as nat)) + (input[23] * pow2((4 * 8 - 1) as nat)) + (input[24]\n            * pow2((5 * 8 - 1) as nat)) + ((input[25] as nat % pow2(4)) * pow2((6 * 8 - 1) as nat)),\n{\n    let i = 19;\n    let k = 1;\n\n    let j_div = 1;\n    let j_id = 6;\n    let j_shift = 7;\n\n    load8_limb_X(input, i, k, j_div, j_id, j_shift);\n\n    // Sanity check\n    assert((load8_at_spec(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n        / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n    pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64));\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/main().",
      "display_name": "main",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/main().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "fn main() {\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/a2_0_val().",
      "display_name": "a2_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/a2_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn a2_0_val(a: [u64; 5]) -> u64 {\n    (c2_val(a) as u64) & mask51\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_decreases().",
      "display_name": "lemma_mod_decreases",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_decreases().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/bit_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/bit_lemmas.rs",
      "file_name": "bit_lemmas.rs",
      "parent_folder": "common_verus",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_of_sum().",
      "display_name": "lemma_div_of_sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_of_sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/div_mod_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn lemma_div_of_sum(a: nat, b: nat, k: nat)\n    requires\n        (a % k) + (b % k) < k  // also implies k != 0\n        ,\n    ensures\n        (a + b) / k == a / k + b / k,\n{\n    let a0 = a / k;\n    let b0 = b / k;\n\n    assert(a == k * a0 + (a % k)) by {\n        lemma_fundamental_div_mod(a as int, k as int);\n    }\n\n    assert(b == k * b0 + (b % k)) by {\n        lemma_fundamental_div_mod(b as int, k as int);\n    }\n\n    assert(a + b == k * (a0 + b0) + (a % k) + (b % k)) by {\n        lemma_mul_is_distributive_add(k as int, a0 as int, b0 as int);\n    }\n\n    lemma_div_multiples_vanish_fancy((a0 + b0) as int, ((a % k) + (b % k)) as int, k as int);\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_1().",
      "display_name": "step_1",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_1().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub(super) fn step_1(repr: &CompressedRistretto) -> (Choice, Choice, FieldElement) {\n        // Step 1. Check s for validity:\n        // 1.a) s must be 32 bytes (we get this from the type system)\n        // 1.b) s < p\n        // 1.c) s is nonnegative\n        //\n        // Our decoding routine ignores the high bit, so the only\n        // possible failure for 1.b) is if someone encodes s in 0..18\n        // as s+p in 2^255-19..2^255-1.  We can check this by\n        // converting back to bytes, and checking that we get the\n        // original input, since our encoding routine is canonical.\n\n        let s = FieldElement::from_bytes(repr.as_bytes());\n        let s_bytes_check = s.as_bytes();\n        let s_encoding_is_canonical = s_bytes_check[..].ct_eq(repr.as_bytes());\n        let s_is_negative = s.is_negative();\n\n        (s_encoding_is_canonical, s_is_negative, s)\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_to_le_bytes().",
      "display_name": "u16_to_le_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_to_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//! let two: Scalar = Scalar::ONE + Scalar::ONE;\n//!\n//! assert!(a == two);\n//! ```\n//!\n//! There is also a constructor that reduces a \\\\(512\\\\)-bit integer,\n//! [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! To construct a `Scalar` as the hash of some input data, use\n//! [`Scalar::hash_from_bytes`], which takes a buffer, or\n//! [`Scalar::from_hash`], which allows an IUF API.\n//!\n#![cfg_attr(feature = \"digest\", doc = \"```\")]\n#![cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n//! # fn main() {\n//! use sha2::{Digest, Sha512};\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! // Hashing a single byte slice\n//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#push().",
      "display_name": "push",
      "symbol": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#push().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#non_adjacent_form().",
      "display_name": "non_adjacent_form",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#non_adjacent_form().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "pub(crate) fn non_adjacent_form(&self, w: usize) -> (result:\n    [i8; 256])\n// VERIFICATION NOTE: PROOF BYPASS\n\n    requires\n        2 <= w <= 8,\n    ensures\n// result encodes the same integer\n\n        reconstruct(result@) == scalar_to_nat(self) as int,\n        // result digits follow NAF rules\n        is_valid_naf(result@, w as nat),\n{\n    // VERIFICATION NOTE: we tell verus not to verify debug assertions\n    #[cfg(not(verus_keep_ghost))]\n    debug_assert!(w >= 2);\n    // required so that the NAF digits fit in i8\n    // VERIFICATION NOTE: we tell verus not to verify debug assertions\n    #[cfg(not(verus_keep_ghost))]\n            debug_assert!(w <= 8);\n\n    let mut naf = [0i8;256];\n\n    // VERIFICATION NOTE: Inline the read_le_u64_into logic to avoid Verus unsupported features - IN PROGRESS\n    /* <ORIGINAL CODE>\n            let mut x_u64 = [0u64; 5];\n            read_le_u64_into(&self.bytes, &mut x_u64[0..4]);\n             <ORIGINAL CODE> */\n    // Read 4 u64s from the 32-byte array (self.bytes)\n    assume(false);\n    let mut x_u64 = [0u64;5];\n    x_u64[0] = u64_from_le_bytes(\n        [\n            self.bytes[0],\n            self.bytes[1],\n            self.bytes[2],\n            self.bytes[3],\n            self.bytes[4],\n            self.bytes[5],\n            self.bytes[6],\n            self.bytes[7],\n        ],\n    );\n    x_u64[1] = u64_from_le_bytes(\n        [\n            self.bytes[8],\n            self.bytes[9],\n            self.bytes[10],\n            self.bytes[11],\n            self.bytes[12],\n            self.bytes[13],\n            self.bytes[14],\n            self.bytes[15],\n        ],\n    );\n    x_u64[2] = u64_from_le_bytes(\n        [\n            self.bytes[16],\n            self.bytes[17],\n            self.bytes[18],\n            self.bytes[19],\n            self.bytes[20],\n            self.bytes[21],\n            self.bytes[22],\n            self.bytes[23],\n        ],\n    );\n    x_u64[3] = u64_from_le_bytes(\n        [\n            self.bytes[24],\n            self.bytes[25],\n            self.bytes[26],\n            self.bytes[27],\n            self.bytes[28],\n            self.bytes[29],\n            self.bytes[30],\n            self.bytes[31],\n        ],\n    );\n    // x_u64[4] remains 0\n\n    let width = 1 << w;\n    let window_mask = width - 1;\n\n    let mut pos = 0;\n    let mut carry = 0;\n    while pos < 256\n        decreases 256 - pos,\n    {\n        assume(false);\n\n        // Construct a buffer of bits of the scalar, starting at bit `pos`\n        let u64_idx = pos / 64;\n        let bit_idx = pos % 64;\n        let bit_buf: u64 = if bit_idx < 64 - w {\n            // This window's bits are contained in a single u64\n            x_u64[u64_idx] >> bit_idx\n        } else {\n            // Combine the current u64's bits with the bits from the next u64\n            (x_u64[u64_idx] >> bit_idx) | (x_u64[1 + u64_idx] << (64 - bit_idx))\n        };\n\n        // Add the carry into the current window\n        assume(false);\n        let window = carry + (bit_buf & window_mask);\n\n        if window & 1 == 0 {\n            // If the window value is even, preserve the carry and continue.\n            // Why is the carry preserved?\n            // If carry == 0 and window & 1 == 0, then the next carry should be 0\n            // If carry == 1 and window & 1 == 0, then bit_buf & 1 == 1 so the next carry should be 1\n            pos += 1;\n            continue ;\n        }\n        if window < width / 2 {\n            carry = 0;\n            naf[pos] = window as i8;\n        } else {\n            carry = 1;\n            naf[pos] = (window as i8).wrapping_sub(width as i8);\n        }\n        assume(false);\n        pos += w;\n    }\n\n    naf\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimeMultiscalarMul#optional_multiscalar_mul().",
      "display_name": "optional_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimeMultiscalarMul#optional_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<Self::Point>>;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// public points, compute\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// using variable-time operations.\n    ///\n    /// It is an error to call this function with two iterators of different lengths.\n    ///\n    /// # Examples\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    ///\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    ///\n    /// // A1 = a*P + b*Q + c*R\n    /// let abc = [a,b,c];\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &[P,Q,R]);\n    /// // Note: (&abc).into_iter(): Iterator<Item=&Scalar>\n    ///\n    /// // A2 = (-a)*P + (-b)*Q + (-c)*R\n    /// let minus_abc = abc.iter().map(|x| -x);\n    /// let A2 = RistrettoPoint::vartime_multiscalar_mul(minus_abc, &[P,Q,R]);\n    /// // Note: minus_abc.into_iter(): Iterator<Item=Scalar>\n    ///\n    /// assert_eq!(A1.compress(), (-A2).compress());\n    /// # }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "display_name": "step_2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub(super) fn step_2(s: FieldElement) -> (Choice, Choice, Choice, RistrettoPoint) {\n        // Step 2.  Compute (X:Y:Z:T).\n        let one = FieldElement::ONE;\n        let ss = s.square();\n        let u1 = &one - &ss; //  1 + as²\n        let u2 = &one + &ss; //  1 - as²    where a=-1\n        let u2_sqr = u2.square(); // (1 - as²)²\n\n        // v == ad(1+as²)² - (1-as²)²            where d=-121665/121666\n        let v = &(&(-&constants::EDWARDS_D) * &u1.square()) - &u2_sqr;\n\n        let (ok, I) = (&v * &u2_sqr).invsqrt(); // 1/sqrt(v*u_2²)\n\n        let Dx = &I * &u2; // 1/sqrt(v)\n        let Dy = &I * &(&Dx * &v); // 1/u2\n\n        // x == | 2s/sqrt(v) | == + sqrt(4s²/(ad(1+as²)² - (1-as²)²))\n        let mut x = &(&s + &s) * &Dx;\n        let x_neg = x.is_negative();\n        x.conditional_negate(x_neg);\n\n        // y == (1-as²)/(1+as²)\n        let y = &u1 * &Dy;\n\n        // t == ((1+as²) sqrt(4s²/(ad(1+as²)² - (1-as²)²)))/(1-as²)\n        let t = &x * &y;\n\n        (\n            ok,\n            t.is_negative(),\n            y.is_zero(),\n            RistrettoPoint(EdwardsPoint {\n                X: x,\n                Y: y,\n                Z: one,\n                T: t,\n            }),\n        )\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "display_name": "mask_div2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 3, 48);\n    assert(bytes[3] as nat == ((limbs[0] as nat % pow2(48)) / pow2(24)) % 256);\n\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 4, 48);\n    assert(bytes[4] as nat == ((limbs[0] as nat % pow2(48)) / pow2(32)) % 256);\n\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 5, 48);\n\n    // Now the bytes satisfy the preconditions of our reconstruction lemma!\n    // We also need to show that (limbs[0] % 2^48) < 2^48\n    lemma_pow2_pos(48);\n    assert(pow2(48) > 0);\n    assert(limbs[0] as nat % pow2(48) < pow2(48)) by {\n        lemma_mod_bound(limbs[0] as int, pow2(48) as int);\n    }",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "display_name": "reduce",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "fn reduce(&self) -> (result: Scalar)\n// VERIFICATION NOTE: PROOF BYPASS\n\n    ensures\n// Result is equivalent to input modulo the group order\n\n        bytes_to_nat(&result.bytes) % group_order() == bytes_to_nat(&self.bytes) % group_order(),\n        // Result satisfies Scalar invariants #1 and #2\n        is_canonical_scalar(&result),\n{\n    let x = self.unpack();\n    //    assume(limbs_bounded(&x));\n    assume(limbs_bounded(&constants::R));\n    let xR = UnpackedScalar::mul_internal(&x, &constants::R);\n    let x_mod_l = UnpackedScalar::montgomery_reduce(&xR);\n    let result = x_mod_l.pack();\n    // Assume postconditions (to be proven later)\n    assume(bytes_to_nat(&result.bytes) % group_order() == bytes_to_nat(&self.bytes)\n        % group_order());\n    assume(is_canonical_scalar(&result));\n    result\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_all_carries_bounded_by_3().",
      "display_name": "lemma_all_carries_bounded_by_3",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_all_carries_bounded_by_3().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_all_carries_bounded_by_3(limbs: [u64; 5])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 52),\n    ensures\n        ({\n            let q0 = ((limbs[0] + 19) as u64 >> 51) as u64;\n            let q1 = ((limbs[1] + q0) as u64 >> 51) as u64;\n            let q2 = ((limbs[2] + q1) as u64 >> 51) as u64;\n            let q3 = ((limbs[3] + q2) as u64 >> 51) as u64;\n            let q4 = ((limbs[4] + q3) as u64 >> 51) as u64;\n            q0 < 3 && q1 < 3 && q2 < 3 && q3 < 3 && q4 < 3\n        }),",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01().",
      "display_name": "from_bytes_as_nat_01",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn from_bytes_as_nat_01(bytes: &[u8; 32])\n    ensures\n        (load8_at_spec(bytes, 0) as u64 & mask51) + pow2(51) * ((load8_at_spec(bytes, 6) as u64\n            >> 3) & mask51) == (bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (bytes[2]\n            * pow2(2 * 8)) + (bytes[3] * pow2(3 * 8)) + (bytes[4] * pow2(4 * 8)) + (bytes[5] * pow2(\n            5 * 8,\n        )) + (bytes[6] * pow2(6 * 8)) + (bytes[7] * pow2(7 * 8)) + (bytes[8] * pow2(8 * 8)) + (\n        bytes[9] * pow2(9 * 8)) + (bytes[10] * pow2(10 * 8)) + (bytes[11] * pow2(11 * 8)) + ((\n        bytes[12] as nat % pow2(6)) * pow2((12 * 8) as nat)),\n{\n    assert((load8_at_spec(bytes, 0) as u64) & mask51 == (bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(\n        1 * 8,\n    )) + (bytes[2] * pow2(2 * 8)) + (bytes[3] * pow2(3 * 8)) + (bytes[4] * pow2(4 * 8)) + (bytes[5]\n        * pow2(5 * 8)) + ((bytes[6] as nat % pow2(3)) * pow2(6 * 8))) by {\n        load8_limb0(bytes);\n    }\n\n    assert(((load8_at_spec(bytes, 6) as u64) >> 3) & mask51 == (bytes[6] as nat / pow2(3)) + (\n    bytes[7] * pow2((1 * 8 - 3) as nat)) + (bytes[8] * pow2((2 * 8 - 3) as nat)) + (bytes[9] * pow2(\n        (3 * 8 - 3) as nat,\n    )) + (bytes[10] * pow2((4 * 8 - 3) as nat)) + (bytes[11] * pow2((5 * 8 - 3) as nat)) + ((\n    bytes[12] as nat % pow2(6)) * pow2((6 * 8 - 3) as nat))) by {\n        load8_limb1(bytes);\n    }\n\n    assert(pow2(51) * ((load8_at_spec(bytes, 6) as u64 >> 3) & mask51) == pow2(51) * (\n    bytes[6] as nat / pow2(3)) + pow2(51) * (bytes[7] * pow2((1 * 8 - 3) as nat)) + pow2(51) * (\n    bytes[8] * pow2((2 * 8 - 3) as nat)) + pow2(51) * (bytes[9] * pow2((3 * 8 - 3) as nat)) + pow2(\n        51,\n    ) * (bytes[10] * pow2((4 * 8 - 3) as nat)) + pow2(51) * (bytes[11] * pow2((5 * 8 - 3) as nat))\n        + pow2(51) * ((bytes[12] as nat % pow2(6)) * pow2((6 * 8 - 3) as nat))) by {\n        mul_7_terms(\n            pow2(51) as int,\n            (bytes[6] as nat / pow2(3)) as int,\n            (bytes[7] * pow2((1 * 8 - 3) as nat)) as int,\n            (bytes[8] * pow2((2 * 8 - 3) as nat)) as int,\n            (bytes[9] * pow2((3 * 8 - 3) as nat)) as int,\n            (bytes[10] * pow2((4 * 8 - 3) as nat)) as int,\n            (bytes[11] * pow2((5 * 8 - 3) as nat)) as int,\n            ((bytes[12] as nat % pow2(6)) * pow2((6 * 8 - 3) as nat)) as int,\n        );\n    }\n\n    assert(((bytes[6] as nat % pow2(3)) * pow2(6 * 8)) + pow2(51) * (bytes[6] as nat / pow2(3))\n        == bytes[6] * pow2(6 * 8)) by {\n        assemble_mod_div(bytes[6] as nat, 3, 6 * 8);\n    }\n\n    assert(pow2(51) * (bytes[7] * pow2((1 * 8 - 3) as nat)) + pow2(51) * (bytes[8] * pow2(\n        (2 * 8 - 3) as nat,\n    )) + pow2(51) * (bytes[9] * pow2((3 * 8 - 3) as nat)) + pow2(51) * (bytes[10] * pow2(\n        (4 * 8 - 3) as nat,\n    )) + pow2(51) * (bytes[11] * pow2((5 * 8 - 3) as nat)) + pow2(51) * ((bytes[12] as nat % pow2(\n        6,\n    )) * pow2((6 * 8 - 3) as nat)) == (bytes[7] * pow2(7 * 8)) + (bytes[8] * pow2(8 * 8)) + (\n    bytes[9] * pow2(9 * 8)) + (bytes[10] * pow2(10 * 8)) + (bytes[11] * pow2(11 * 8)) + ((\n    bytes[12] as nat % pow2(6)) * pow2((12 * 8) as nat))) by {\n        assemble_pow_a_pow(bytes[7] as nat, 6, 1, 3);\n        assemble_pow_a_pow(bytes[8] as nat, 6, 2, 3);\n        assemble_pow_a_pow(bytes[9] as nat, 6, 3, 3);\n        assemble_pow_a_pow(bytes[10] as nat, 6, 4, 3);\n        assemble_pow_a_pow(bytes[11] as nat, 6, 5, 3);\n        assemble_pow_a_pow(bytes[12] as nat % pow2(6), 6, 6, 3);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_l_value_properties().",
      "display_name": "lemma_l_value_properties",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_l_value_properties().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_l_value_properties(l_value: &Scalar52, sum: &Scalar52)\n    requires\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n    ensures\n        forall|j: int| 0 <= j < 5 ==> l_value.limbs[j] < (1u64 << 52),\n{\n    assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness().",
      "display_name": "lemma_limb0_contribution_correctness",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_limb0_contribution_correctness(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[0] < pow2(51),\n        bytes_match_limbs_packing(limbs, bytes),\n    ensures\n        limb0_byte_contribution(limbs, bytes) == limbs[0] as nat,\n{\n    // Limb 0 is stored in bytes 0-6\n    // - Bytes 0-5: full bytes containing limbs[0]'s bits 0-47 (48 bits total)\n    // - Byte 6 (low 3 bits): limbs[0]'s bits 48-50 (3 bits)\n    // Total: 51 bits, which matches limbs[0] < 2^51\n    //\n    // Strategy: Apply div-mod theorem at the 48-bit boundary\n    // limbs[0] = (limbs[0] % 2^48) + (limbs[0] / 2^48) * 2^48\n    lemma2_to64();\n    assert(pow2(8) == 256);\n\n    // Stabilization placeholders\n    assert(pow2(0) == pow2(0 * 8));\n    assert(pow2(8) == pow2(1 * 8));\n    assert(pow2(16) == pow2(2 * 8));\n    assert(pow2(24) == pow2(3 * 8));\n    assert(pow2(32) == pow2(4 * 8));\n\n    // Step 1: Show bytes 0-5 contribute (limbs[0] % 2^48)\n    // From bytes_match_limbs_packing, we know:\n    // bytes[0] = limbs[0] as u8\n    // bytes[1] = (limbs[0] >> 8) as u8\n    // ... and so on\n\n    // These bytes, when summed with their position weights, reconstruct limbs[0] % 2^48\n    let low_48_bits = bytes[0] as nat * pow2(0 * 8) + bytes[1] as nat * pow2(1 * 8)\n        + bytes[2] as nat * pow2(2 * 8) + bytes[3] as nat * pow2(3 * 8) + bytes[4] as nat * pow2(\n        4 * 8,\n    ) + bytes[5] as nat * pow2(5 * 8);\n\n    // Prove this equals limbs[0] % 2^48\n    // From bytes_match_limbs_packing, we know each byte is exactly (limbs[0] >> (i*8)) as u8\n\n    // Use lemma_byte_from_limb_shift to establish arithmetic value of each byte\n    shr_zero_is_id(limbs[0]);  // Explicit call instead of broadcast for better Z3 performance\n    assert(bytes[0] == (limbs[0] >> 0) as u8);\n    lemma_byte_from_limb_shift(limbs[0], 0, bytes[0]);\n    assert(bytes[0] as nat == (limbs[0] as nat / pow2(0)) % 256);\n\n    lemma_byte_from_limb_shift(limbs[0], 8, bytes[1]);\n    assert(bytes[1] as nat == (limbs[0] as nat / pow2(8)) % 256);\n\n    lemma_byte_from_limb_shift(limbs[0], 16, bytes[2]);\n    assert(bytes[2] as nat == (limbs[0] as nat / pow2(16)) % 256);\n\n    lemma_byte_from_limb_shift(limbs[0], 24, bytes[3]);\n\n    lemma_byte_from_limb_shift(limbs[0], 32, bytes[4]);\n    assert(bytes[4] as nat == (limbs[0] as nat / pow2(32)) % 256);\n\n    lemma_byte_from_limb_shift(limbs[0], 40, bytes[5]);\n    assert(bytes[5] as nat == (limbs[0] as nat / pow2(40)) % 256);\n\n    // Now we know the arithmetic value of each byte!\n    // We need to show that summing them reconstructs limbs[0] % 2^48\n\n    // Key insight: We have bytes extracted from limbs[0], but our reconstruction lemma\n    // expects bytes extracted from (limbs[0] % 2^48). We need to show these are the same.\n\n    // For each byte i (i=0..5), show that extraction from limbs[0] equals extraction from limbs[0] % 2^48\n    // This holds because byte i is at position i*8, and i*8+7 < 48, so it's below the modulo boundary\n\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 0, 48);\n    assert(bytes[0] as nat == ((limbs[0] as nat % pow2(48)) / pow2(0)) % 256);\n\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 1, 48);\n\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 2, 48);\n    assert(bytes[2] as nat == ((limbs[0] as nat % pow2(48)) / pow2(16)) % 256);\n\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 3, 48);\n    assert(bytes[3] as nat == ((limbs[0] as nat % pow2(48)) / pow2(24)) % 256);\n\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 4, 48);\n    assert(bytes[4] as nat == ((limbs[0] as nat % pow2(48)) / pow2(32)) % 256);\n\n    lemma_byte_extraction_commutes_with_mod(limbs[0] as nat, 5, 48);\n\n    // Now the bytes satisfy the preconditions of our reconstruction lemma!\n    // We also need to show that (limbs[0] % 2^48) < 2^48\n    lemma_pow2_pos(48);\n    assert(pow2(48) > 0);\n    assert(limbs[0] as nat % pow2(48) < pow2(48)) by {\n        lemma_mod_bound(limbs[0] as int, pow2(48) as int);\n    }\n\n    // The modulo value fits in u64 since 2^48 < 2^64\n    let modulo_value = limbs[0] as nat % pow2(48);\n    assert(pow2(48) < pow2(64)) by {\n        lemma_pow2_strictly_increases(48, 64);\n    }\n    assert(modulo_value < pow2(64));\n\n    let limb0_low48 = modulo_value as u64;\n\n    // Show that limb0_low48 satisfies the preconditions\n    // The cast to u64 and back to nat preserves the value since modulo_value < 2^64\n    // For x < 2^64, (x as u64) as nat == x - this is a fundamental property of u64 casting\n    // Verus should be able to verify this directly\n    assert(limb0_low48 as nat == modulo_value);\n    assert(limb0_low48 as nat == limbs[0] as nat % pow2(48));\n\n    // The bytes we extracted from limbs[0] % pow2(48) satisfy the preconditions\n    // We already proved: bytes[i] == ((limbs[0] % pow2(48)) / pow2(i*8)) % 256\n    assert(bytes[0] as nat == (limb0_low48 as nat / pow2(0)) % 256);\n    assert(bytes[1] as nat == (limb0_low48 as nat / pow2(8)) % 256);\n    assert(bytes[2] as nat == (limb0_low48 as nat / pow2(16)) % 256);\n    assert(bytes[3] as nat == (limb0_low48 as nat / pow2(24)) % 256);\n    assert(bytes[4] as nat == (limb0_low48 as nat / pow2(32)) % 256);\n    assert(bytes[5] as nat == (limb0_low48 as nat / pow2(40)) % 256);\n\n    // Now apply our reconstruction lemma\n    lemma_6_bytes_reconstruct(\n        limb0_low48 as nat,\n        bytes[0],\n        bytes[1],\n        bytes[2],\n        bytes[3],\n        bytes[4],\n        bytes[5],\n    );\n\n    // The reconstruction lemma tells us: low_48_bits == limbs[0] % 2^48\n    assert(low_48_bits == (limbs[0] as nat % pow2(48)));\n\n    // Step 2: Show the contribution from byte 6\n    // From bytes_match_limbs_packing: bytes[6] == ((limbs[0] >> 48) | (limbs[1] << 3)) as u8\n    // The low 3 bits of bytes[6] come from limbs[0] >> 48\n    // which is limbs[0] / 2^48\n\n    // Since limbs[0] < 2^51, we have limbs[0] / 2^48 < 2^3 = 8\n    assert(limbs[0] < pow2(51));\n    lemma_div_bound(limbs[0] as nat, 48, 51);\n    assert(limbs[0] as nat / pow2(48) < pow2((51 - 48) as nat));\n    assert(limbs[0] as nat / pow2(48) < pow2(3));\n    lemma2_to64();\n    assert(pow2(3) == 8);\n    assert(limbs[0] as nat / pow2(48) < 8);\n\n    // The high 5 bits of byte 6 come from limbs[1], so the low 3 bits are:\n    let high_3_bits_contribution = ((limbs[0] as nat / pow2(48)) % 8) * pow2(6 * 8);\n\n    // Since limbs[0]/2^48 < 8, taking % 8 is identity\n    assert((limbs[0] as nat / pow2(48)) % 8 == limbs[0] as nat / pow2(48));\n    assert(high_3_bits_contribution == (limbs[0] as nat / pow2(48)) * pow2(48));\n\n    // Step 3: Apply div-mod theorem\n    // limbs[0] = (limbs[0] % 2^48) + (limbs[0] / 2^48) * 2^48\n    lemma_pow2_pos(48);  // Establishes pow2(48) > 0\n    assert(pow2(48) > 0);\n    lemma_fundamental_div_mod(limbs[0] as int, pow2(48) as int);\n    assert(limbs[0] as nat == (limbs[0] as nat % pow2(48)) + (limbs[0] as nat / pow2(48)) * pow2(\n        48,\n    ));\n\n    // Step 4: Show this equals limb0_byte_contribution\n    assert(limb0_byte_contribution(limbs, bytes) == low_48_bits + high_3_bits_contribution);\n    assert(limb0_byte_contribution(limbs, bytes) == (limbs[0] as nat % pow2(48)) + (limbs[0] as nat\n        / pow2(48)) * pow2(48));\n    assert(limb0_byte_contribution(limbs, bytes) == limbs[0] as nat);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 13
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/lemma0_pow().",
      "display_name": "lemma0_pow",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/lemma0_pow().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_verus",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "display_name": "mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/mod.rs",
      "relative_path": "src/backend/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "backend",
      "body": "//! implementation strategy derived from parallel formulas of Hisil,\n//! Wong, Carter, and Dawson.\n//!\n//! Because the two strategies give rise to different curve models,\n//! it's not possible to reuse exactly the same scalar multiplication\n//! code (or to write it generically), so both serial and vector\n//! backends contain matching implementations of scalar multiplication\n//! algorithms.  These are intended to be selected by a `#[cfg]`-based\n//! type alias.\n//!\n//! The [`vector`] backend is selected by the `simd_backend` cargo\n//! feature; it uses the [`serial`] backend for non-vectorized operations.\nuse crate::EdwardsPoint;\nuse crate::Scalar;\n\npub mod serial;\n\n// #[cfg(curve25519_dalek_backend = \"simd\")]\n// pub mod vector;\n\n#[derive(Copy, Clone)]\nenum BackendKind {\n    // #[cfg(curve25519_dalek_backend = \"simd\")]\n    // Avx2,\n    // #[cfg(all(curve25519_dalek_backend = \"simd\", nightly))]\n    // Avx512,\n    Serial,\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConditionallySelectable#conditional_select().",
      "display_name": "conditional_select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConditionallySelectable#conditional_select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> (Self) {\n        let mut bytes = [0u8;32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            /* <VERIFICATION NOTE>\n            Use wrapper function for Verus compatibility instead of direct subtle call\n            </VERIFICATION NOTE> */\n            /* <ORIGINAL CODE>\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n            </ORIGINAL CODE> */\n            /* <MODIFIED CODE> */\n            bytes[i] = select_u8(&a.bytes[i], &b.bytes[i], choice);\n            /* </MODIFIED CODE> */\n        }\n        Scalar { bytes }\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo rustc_version 0.4.1 version().",
      "display_name": "version",
      "symbol": "rust-analyzer cargo rustc_version 0.4.1 version().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/TryInto#try_into().",
      "display_name": "try_into",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/TryInto#try_into().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#From#from().",
      "display_name": "from",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#From#from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
      "relative_path": "src/backend/serial/scalar_mul/variable_base.rs",
      "file_name": "variable_base.rs",
      "parent_folder": "scalar_mul",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Sum#sum().",
      "display_name": "sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Sum#sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(RistrettoPoint::identity(), |acc, item| acc + item.borrow())\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/lemma_pow1().",
      "display_name": "lemma_pow1",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/lemma_pow1().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_chunk_extraction_commutes_with_mod().",
      "display_name": "lemma_chunk_extraction_commutes_with_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_chunk_extraction_commutes_with_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "    // For byte extraction at position k where k*8 < 40:\n    //   (v / 2^(k*8)) % 256 == ((v % 2^40) / 2^(k*8)) % 256\n    //\n    // This is because v % 2^40 only affects bits >= 40, and byte extraction at k*8\n    // only looks at bits [k*8, k*8+8), which are all < 40.\n\n    let v = limbs[1] as nat / pow2(5);\n\n    // Use lemma_byte_extraction_commutes_with_mod to show extraction commutes with % 2^40\n    // For byte at position k, we need k*8 + 8 <= 40\n    lemma_byte_extraction_commutes_with_mod(v, 0, 40);  // 0*8 + 8 = 8 <= 40 ✓\n    assert(bytes[7] as nat == (middle_value / pow2(0)) % 256);\n\n    lemma_byte_extraction_commutes_with_mod(v, 1, 40);  // 1*8 + 8 = 16 <= 40 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 2, 40);  // 2*8 + 8 = 24 <= 40 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 3, 40);  // 3*8 + 8 = 32 <= 40 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 4, 40);  // 4*8 + 8 = 40 <= 40 ✓\n\n    // Now apply lemma_5_bytes_reconstruct\n    lemma_5_bytes_reconstruct(middle_value, bytes[7], bytes[8], bytes[9], bytes[10], bytes[11]);\n\n    // This gives us:\n    assert(bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8) + bytes[9] as nat * pow2(16)\n        + bytes[10] as nat * pow2(24) + bytes[11] as nat * pow2(32) == middle_value);\n\n    // Now multiply both sides by 2^56 to get the bytes at their actual positions\n    lemma_mul_is_distributive_add(\n        pow2(56) as int,\n        (bytes[7] as nat * pow2(0)) as int,\n        (bytes[8] as nat * pow2(8)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(56) as int,\n        (bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8)) as int,\n        (bytes[9] as nat * pow2(16)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(56) as int,\n        (bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8) + bytes[9] as nat * pow2(16)) as int,\n        (bytes[10] as nat * pow2(24)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(56) as int,\n        (bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8) + bytes[9] as nat * pow2(16)\n            + bytes[10] as nat * pow2(24)) as int,\n        (bytes[11] as nat * pow2(32)) as int,\n    );\n\n    // Distribute the multiplication into each term\n    lemma_mul_is_associative(bytes[7] as int, pow2(0) as int, pow2(56) as int);\n    lemma_mul_is_associative(bytes[8] as int, pow2(8) as int, pow2(56) as int);\n    lemma_mul_is_associative(bytes[9] as int, pow2(16) as int, pow2(56) as int);\n    lemma_mul_is_associative(bytes[10] as int, pow2(24) as int, pow2(56) as int);\n    lemma_mul_is_associative(bytes[11] as int, pow2(32) as int, pow2(56) as int);\n\n    // Simplify using pow2 addition: 2^56 * 2^k = 2^(56+k)\n    lemma_pow2_adds(56, 0);\n\n    lemma_pow2_adds(56, 8);\n\n    lemma_pow2_adds(56, 16);\n\n    lemma_pow2_adds(56, 24);\n\n    lemma_pow2_adds(56, 32);\n    assert(pow2(88) == pow2(11 * 8));\n\n    // Final result§\n    assert(bytes[7] as nat * pow2(7 * 8) + bytes[8] as nat * pow2(8 * 8) + bytes[9] as nat * pow2(\n        9 * 8,\n    ) + bytes[10] as nat * pow2(10 * 8) + bytes[11] as nat * pow2(11 * 8) == middle_value * pow2(\n        56,\n    ));\n\n    // Step 3: Handle boundary bytes\n    // Low 5 bits (byte 6 high part): (limbs[1] % 2^5) * 8 * 2^48 = (limbs[1] % 2^5) * 2^51\n    // High 6 bits (byte 12 low part): (limbs[1] / 2^45) % 2^6 * 2^96\n\n    assert(8 * pow2(48) == pow2(51)) by {\n        lemma_pow2_adds(48, 3);\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_verus/u64/serial/backend/seq_sum().",
      "display_name": "seq_sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_verus/u64/serial/backend/seq_sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/sum_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/sum_lemmas.rs",
      "file_name": "sum_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub open spec fn seq_sum(coefs: Seq<nat>, k: nat) -> nat\n    decreases k,\n{\n    if (k == 0) {\n        coefs[0]\n    } else {\n        seq_sum(coefs, (k - 1) as nat) + coefs[k as int]\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from4().",
      "display_name": "seq_from4",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from4().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub open spec fn seq_from4(b: &[u8; 4]) -> Seq<u8> {\n    Seq::new(4, |i: int| b[i])\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_MOD().",
      "display_name": "pow2_MUL_div_MOD",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_MOD().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn pow2_MUL_div_MOD(x: nat, px: nat, k: nat, s: nat, t: nat)\n    requires\n        x < pow2(px),\n        s <= k,\n        px + k - s <= t,\n    ensures\n        ((x * pow2(k)) / pow2(s)) % pow2(t) == x * pow2((k - s) as nat),\n{\n    let d = (k - s) as nat;\n\n    assert((x * pow2(k)) / pow2(s) == x * pow2(d)) by {\n        pow2_MUL_div(x, k, s);\n    }\n\n    let dd = (t - d) as nat;\n\n    assert((x * pow2(d)) % pow2(t) == (x % pow2(dd)) * pow2(d)) by {\n        mask_pow2(x, d, t);\n    }\n\n    assert(x % pow2(dd) == x) by {\n        assert(x < pow2(px) <= pow2(dd)) by {\n            if (px < dd) {\n                lemma_pow2_strictly_increases(px, dd);\n            }\n        }\n        assert(x % pow2(dd) == x) by {\n            lemma_small_mod(x, pow2(dd));\n        }\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#select().",
      "display_name": "select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    pub fn select(&self, x: usize) -> T {\n        debug_assert_eq!(x & 1, 1);\n        debug_assert!(x < 128);\n\n        self.0[x / 2]\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb0_byte_contribution_52().",
      "display_name": "limb0_byte_contribution_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb0_byte_contribution_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub open spec fn limb0_byte_contribution_52(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    bytes[0] as nat * pow2(0 * 8) + bytes[1] as nat * pow2(1 * 8) + bytes[2] as nat * pow2(2 * 8)\n        + bytes[3] as nat * pow2(3 * 8) + bytes[4] as nat * pow2(4 * 8) + bytes[5] as nat * pow2(\n        5 * 8,\n    )\n        +\n    // Byte 6 is a boundary byte - limb 0 contributes only the low 4 bits\n    // These 4 bits represent limbs[0]'s bits 48-51\n    ((limbs[0] as nat / pow2(48)) % 16) * pow2(6 * 8)\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_nonincreasing().",
      "display_name": "shr_nonincreasing",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_nonincreasing().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "\n    assert(u8::MAX + 1 == pow2(8)) by {\n        lemma2_to64();\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#ConditionallySelectable#conditional_assign().",
      "display_name": "conditional_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#ConditionallySelectable#conditional_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.Y_plus_X.conditional_assign(&other.Y_plus_X, choice);\n        self.Y_minus_X.conditional_assign(&other.Y_minus_X, choice);\n        self.Z.conditional_assign(&other.Z, choice);\n        self.T2d.conditional_assign(&other.T2d, choice);\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "display_name": "mul_bits_be",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_bits_be(&self, bits: impl Iterator<Item = bool>) -> MontgomeryPoint {\n        // Algorithm 8 of Costello-Smith 2017\n        let affine_u = FieldElement::from_bytes(&self.0);\n        let mut x0 = ProjectivePoint::identity();\n        let mut x1 = ProjectivePoint {\n            U: affine_u,\n            W: FieldElement::ONE,\n        };\n\n        // Go through the bits from most to least significant, using a sliding window of 2\n        let mut prev_bit = false;\n        for cur_bit in bits {\n            let choice: u8 = (prev_bit ^ cur_bit) as u8;\n\n            debug_assert!(choice == 0 || choice == 1);\n\n            ProjectivePoint::conditional_swap(&mut x0, &mut x1, choice.into());\n            differential_add_and_double(&mut x0, &mut x1, &affine_u);\n\n            prev_bit = cur_bit;\n        }\n        // The final value of prev_bit above is scalar.bits()[0], i.e., the LSB of scalar\n        ProjectivePoint::conditional_swap(&mut x0, &mut x1, Choice::from(prev_bit as u8));\n        // Don't leave the bit in the stack\n        #[cfg(feature = \"zeroize\")]\n        prev_bit.zeroize();\n\n        x0.as_affine()\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "display_name": "as_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::bit_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::div_mod_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mask_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mul_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::pow_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::shift_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_nat_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::compute_q_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::field_core::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::from_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::limbs_to_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::load8_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::negate_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2_51_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 27,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Hash#hash().",
      "display_name": "hash",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Hash#hash().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn hash<H: Hasher>(&self, state: &mut H) {\n        // Do a round trip through a `FieldElement`. `as_bytes` is guaranteed to give a canonical\n        // 32-byte encoding\n        let canonical_bytes = FieldElement::from_bytes(&self.0).as_bytes();\n        canonical_bytes.hash(state);\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_inv_axiom().",
      "display_name": "field_inv_axiom",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_inv_axiom().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field_specs.rs",
      "relative_path": "src/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "src",
      "body": "pub proof fn field_inv_axiom(a: nat)\n    requires\n        a % p() != 0,\n    ensures\n        field_inv(a) < p(),\n        ((a % p()) * field_inv(a)) % p() == 1,\n{\n    admit();  // This would be proven from field theory or assumed as axiom\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ValidityCheck#is_valid().",
      "display_name": "is_valid",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ValidityCheck#is_valid().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn is_valid(&self) -> bool {\n        let point_on_curve = self.as_projective().is_valid();\n        let on_segre_image = (&self.X * &self.Y) == (&self.Z * &self.T);\n\n        point_on_curve && on_segre_image\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_squared().",
      "display_name": "as_nat_squared",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_squared().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "use crate::backend::serial::u64::common_verus::pow_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::shift_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_nat_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::compute_q_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::field_core::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::from_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::limbs_to_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::load8_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::negate_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2_51_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#TryFrom#try_from().",
      "display_name": "try_from",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#TryFrom#try_from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn try_from(slice: &[u8]) -> (result: Result<CompressedEdwardsY, TryFromSliceError>)\n        ensures\n            match result {\n                Ok(point) => point.0@ == slice@,\n                Err(_) => true,\n            },",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/lemma_pow_adds().",
      "display_name": "lemma_pow_adds",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/lemma_pow_adds().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_verus",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c1_val().",
      "display_name": "c1_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c1_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    {\n        self.limbs.zeroize();\n    }",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn identity() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::ONE,\n            Y_minus_X: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T2d: FieldElement::ZERO,\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_multiples_vanish_fancy().",
      "display_name": "lemma_div_multiples_vanish_fancy",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_multiples_vanish_fancy().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_carry_bounded_after_mask().",
      "display_name": "lemma_carry_bounded_after_mask",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_carry_bounded_after_mask().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_carry_bounded_after_mask(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) <= 1,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/l51_bit_mask_lt().",
      "display_name": "l51_bit_mask_lt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/l51_bit_mask_lt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "#[allow(unused_imports)]\nuse vstd::arithmetic::mul::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\n#[allow(unused_imports)]\nuse vstd::bits::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::bit_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::div_mod_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mask_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mul_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::pow_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::shift_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_nat_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::compute_q_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::field_core::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::from_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::limbs_to_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::load8_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::negate_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2_51_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_versions_equivalent().",
      "display_name": "load8_at_versions_equivalent",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_versions_equivalent().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_zero_is_id().",
      "display_name": "shr_zero_is_id",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_zero_is_id().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "}\n\npub proof fn plus_version_is_spec_lemma(input: &[u8], i: usize, j: nat)\n    requires\n        1 <= j <= 7,\n    ensures\n        (input[i + j] as u64) << 8 * j == pow2(j * 8) * input[i + j],\n        input[i + j] * pow2(j * 8) <= u64::MAX,\n        pow2(8 * (j + 1)) - 1 <= pow2(64) - 1,\n        pow2(8) * pow2(8 * j) == pow2(8 * (j + 1)),\n{\n    assert(pow2(64) - 1 == u64::MAX) by {\n        lemma2_to64_rest();\n    }\n\n    assert(u8::MAX + 1 == pow2(8)) by {\n        lemma2_to64();\n    }\n\n    assert(pow2(8 * (j + 1)) - 1 <= pow2(64) - 1) by {\n        if (j < 7) {\n            lemma_pow2_strictly_increases(8 * (j + 1), 64);\n        }\n    }\n\n    lemma_pow2_adds(8, j * 8);\n\n    lemma_mul_inequality(input[i + j] as int, u8::MAX as int, pow2(j * 8) as int);\n\n    assert((input[i + j] as u64) * pow2(j * 8) <= u64::MAX) by {\n        assert(u8::MAX * pow2(j * 8) <= pow2(64) - 1) by {\n            assert(u8::MAX * pow2(j * 8) == (pow2(8) - 1) * pow2(j * 8) == pow2(8 * (j + 1)) - pow2(\n                j * 8,\n            )) by {\n                assert(pow2(8) >= 1) by {\n                    lemma2_to64();\n                }\n                lemma_mul_is_distributive_sub(pow2(8) as int, 1, pow2(j * 8) as int);\n            }\n            assert(pow2(j * 8) > 1) by {\n                lemma2_to64();  // pow2(0)\n                lemma_pow2_strictly_increases(0, j * 8)\n            }\n        }\n    }\n    lemma_u64_shl_is_mul((input[i + j] as u64), (j * 8) as u64);\n}",
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/main().",
      "display_name": "main",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/main().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "fn main() {\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_bytes().",
      "display_name": "field_element_as_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "        let result = ct_eq_bytes32(&self.as_bytes(), &other.as_bytes());\n        assume(choice_is_true(result) == (field_element_as_bytes(self) == field_element_as_bytes(\n            other,\n        )));\n        result\n    }\n}\n\nimpl FieldElement {\n    /// Determine if this `FieldElement` is negative, in the sense\n    /// used in the ed25519 paper: `x` is negative if the low bit is\n    /// set.\n    ///\n    /// # Return\n    ///\n    /// If negative, return `Choice(1)`.  Otherwise, return `Choice(0)`.\n    pub(crate) fn is_negative(&self) -> (result:\n        Choice)/* VERIFICATION NOTE:\n    - PROOF BYPASS AND SPEC BYPASS\n    - we cannot write this directly; need to find a spec function for FieldElement51::as_bytes\n    ensures choice_is_true(result) == (self.as_bytes()[0] & 1 == 1)\n    - (note after slack call: maybe the first bit of as_bytes() is sufficient as a spec)\n    </VERIFICATION NOTE> */\n\n        ensures\n            choice_is_true(result) == (field_element_as_bytes(self)[0] & 1\n                == 1),\n    // SPEC BYPASS through placeholder field_element_as_bytes\n\n    {\n        let bytes = self.as_bytes();\n        let result = Choice::from(bytes[0] & 1);\n        assume(choice_is_true(result) == (field_element_as_bytes(self)[0] & 1 == 1));\n        result\n    }\n\n    /// Determine if this `FieldElement` is zero.\n    ///\n    /// # Return\n    ///\n    /// If zero, return `Choice(1)`.  Otherwise, return `Choice(0)`.\n    pub(crate) fn is_zero(&self) -> (result:\n        Choice)/* VERIFICATION NOTE:\n    - PROOF BYPASS AND SPEC BYPASS\n    - we cannot write this directly; need to find a spec function for FieldElement51::as_bytes\n    ensures choice_is_true(result) == (self.as_bytes() == [0u8; 32])\n    - (note: maybe an all_zeroes(as_bytes(...)) is sufficient as a spec)\n    </VERIFICATION NOTE> */\n\n        ensures\n            choice_is_true(result) == (field_element_as_bytes(self)\n                == seq![0u8; 32]),\n    // SPEC BYPASS through placeholder field_element_as_bytes\n\n    {\n        let zero = [0u8;32];\n        let bytes = self.as_bytes();\n\n        let result = ct_eq_bytes32(&bytes, &zero);\n        assume(choice_is_true(result) == (field_element_as_bytes(self) == seq![0u8; 32]));\n        result\n    }\n\n    /// Compute (self^(2^250-1), self^11), used as a helper function\n    /// within invert() and pow22523().\n    #[rustfmt::skip]  // keep alignment of explanatory comments\n    fn pow22501(&self) -> (result: (FieldElement, FieldElement))\n        ensures\n            field_element_as_nat(&result.0) == pow(\n                field_element_as_nat(self) as int,\n                (pow2(250) - 1) as nat,\n            ) % (p() as int),\n            field_element_as_nat(&result.1) == pow(field_element_as_nat(self) as int, 11) % (\n            p() as int),\n    {\n        // Instead of managing which temporary variables are used\n        // for what, we define as many as we need and leave stack\n        // allocation to the compiler\n        //\n        // Each temporary variable t_i is of the form (self)^e_i.\n        // Squaring t_i corresponds to multiplying e_i by 2,\n        // so the pow2k function shifts e_i left by k places.\n        // Multiplying t_i and t_j corresponds to adding e_i + e_j.\n        //\n        // Temporary t_i                      Nonzero bits of e_i\n        //\n        assume(false);\n        let t0 = self.square();  // 1         e_0 = 2^1\n        let t1 = t0.square().square();  // 3         e_1 = 2^3\n        let t2 = self * &t1;  // 3,0       e_2 = 2^3 + 2^0\n        let t3 = &t0 * &t2;  // 3,1,0\n        let t4 = t3.square();  // 4,2,1\n        let t5 = &t2 * &t4;  // 4,3,2,1,0\n        let t6 = t5.pow2k(5);  // 9,8,7,6,5\n        let t7 = &t6 * &t5;  // 9,8,7,6,5,4,3,2,1,0\n        let t8 = t7.pow2k(10);  // 19..10\n        let t9 = &t8 * &t7;  // 19..0\n        let t10 = t9.pow2k(20);  // 39..20\n        let t11 = &t10 * &t9;  // 39..0\n        let t12 = t11.pow2k(10);  // 49..10\n        let t13 = &t12 * &t7;  // 49..0\n        let t14 = t13.pow2k(50);  // 99..50\n        let t15 = &t14 * &t13;  // 99..0\n        let t16 = t15.pow2k(100);  // 199..100\n        let t17 = &t16 * &t15;  // 199..0\n        let t18 = t17.pow2k(50);  // 249..50\n        let t19 = &t18 * &t13;  // 249..0\n\n        (t19, t3)\n    }\n\n    /// Given a slice of pub(crate)lic `FieldElements`, replace each with its inverse.\n    ///\n    /// When an input `FieldElement` is zero, its value is unchanged.\n    #[cfg(feature = \"alloc\")]\n    pub(crate) fn batch_invert(\n        inputs: &mut [FieldElement],\n    )/* <VERIFICATION NOTE>\n     - Refactored for Verus: Index loops instead of iterators, manual Vec construction\n     - Choice type operations handled by wrappers in subtle_assumes.rs\n     - PROOF BYPASSES because of trait issues and proof obligations.\n    </VERIFICATION NOTE> */\n\n        ensures\n    // Each element is replaced appropriately:\n\n            forall|i: int|\n                #![auto]\n                0 <= i < inputs.len() ==> {\n                    // If input was non-zero, it's replaced with its inverse\n                    (field_element_as_nat(&old(inputs)[i]) != 0) ==> is_inverse_field(\n                        &old(inputs)[i],\n                        &inputs[i],\n                    ) &&\n                    // If input was zero, it remains zero\n                    (field_element_as_nat(&old(inputs)[i]) == 0) ==> field_element_as_nat(\n                        &inputs[i],\n                    ) == 0\n                },\n    {\n        // Montgomery's Trick and Fast Implementation of Masked AES\n        // Genelle, Prouff and Quisquater\n        // Section 3.2\n        let n = inputs.len();\n\n        // Extract ONE constant before loops (similar to scalar.rs pattern)\n        let one = FieldElement::ONE;\n\n        /* <VERIFICATION NOTE>\n         Build vec manually instead of vec![one; n] for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let mut scratch = vec![FieldElement::ONE; n];\n        </ORIGINAL CODE> */\n        let mut scratch = Vec::new();\n        for _ in 0..n {\n            scratch.push(one);\n        }\n\n        // Keep an accumulator of all of the previous products\n        let mut acc = one;\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        /* <VERIFICATION NOTE>\n         Rewritten with index loop instead of .zip() for Verus compatibility\n         Using choice_not() wrapper instead of ! operator\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         for (input, scratch) in inputs.iter().zip(scratch.iter_mut()) {\n            *scratch = acc;\n            // acc <- acc * input, but skipping zeros (constant-time)\n            acc.conditional_assign(&(&acc * input), !input.is_zero());\n        }\n        </ORIGINAL CODE> */\n        for i in 0..n {\n            assume(false);\n            scratch[i] = acc;\n            assume(false);\n            // acc <- acc * input, but skipping zeros (constant-time)\n            acc.conditional_assign(&(&acc * &inputs[i]), choice_not(inputs[i].is_zero()));\n        }\n\n        // acc is nonzero because we skipped zeros in inputs\n        // ORIGINAL: assert!(bool::from(!acc.is_zero()));\n        #[cfg(not(verus_keep_ghost))]\n        assert!(bool::from(choice_not(acc.is_zero())));\n\n        // Compute the inverse of all products\n        acc = acc.invert();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        /* <VERIFICATION NOTE>\n         Manual reverse loop instead of .rev().zip() for Verus compatibility\n         Using choice_not() wrapper instead of ! operator\n         Extract-modify-reassign pattern for mutable indexing\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         for (input, scratch) in inputs.iter_mut().rev().zip(scratch.into_iter().rev()) {\n            let tmp = &acc * input;\n            // input <- acc * scratch, then acc <- tmp\n            // Again, we skip zeros in a constant-time way\n            let nz = !input.is_zero();\n            input.conditional_assign(&(&acc * &scratch), nz);\n            acc.conditional_assign(&tmp, nz);\n        }\n        </ORIGINAL CODE> */\n\n        proof {\n            assume(scratch.len() == n);\n        }\n\n        let mut i: usize = n;\n        while i > 0\n            invariant\n                n == inputs.len(),\n                n == scratch.len(),\n            decreases i,\n        {\n            i -= 1;\n            proof {\n                assume(i < inputs.len());\n                assume(i < scratch.len());\n                assume(0 <= i);\n                assume(false);\n            }\n            let tmp = &acc * &inputs[i];\n            // input <- acc * scratch, then acc <- tmp\n            // Again, we skip zeros in a constant-time way\n            let nz = choice_not(inputs[i].is_zero());\n            // Verus doesn't support index for &mut, so we extract-modify-reassign\n            let mut input_i = inputs[i];\n            input_i.conditional_assign(&(&acc * &scratch[i]), nz);\n            inputs[i] = input_i;\n            acc.conditional_assign(&tmp, nz);\n        }\n\n        proof {\n            // Assume the postconditions hold\n            assume(forall|i: int|\n                #![auto]\n                0 <= i < inputs.len() ==> {\n                    (field_element_as_nat(&old(inputs)[i]) != 0) ==> is_inverse_field(\n                        &old(inputs)[i],\n                        &inputs[i],\n                    ) && (field_element_as_nat(&old(inputs)[i]) == 0) ==> field_element_as_nat(\n                        &inputs[i],\n                    ) == 0\n                });\n        }\n    }\n\n    /// Given a nonzero field element, compute its inverse.\n    ///\n    /// The inverse is computed as self^(p-2), since\n    /// x^(p-2)x = x^(p-1) = 1 (mod p).\n    ///\n    /// This function returns zero on input zero.\n    #[rustfmt::skip]  // keep alignment of explanatory comments\n    #[allow(clippy::let_and_return)]\n    pub(crate) fn invert(&self) -> (result:\n        FieldElement)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n    // If self is non-zero, result is the multiplicative inverse: result * self ≡ 1 (mod p)\n\n            field_element_as_nat(self) != 0 ==> (field_element_as_nat(&result)\n                * field_element_as_nat(self)) % p() == 1,\n            // If self is zero, result is zero\n            field_element_as_nat(self) == 0 ==> field_element_as_nat(&result) == 0,\n            field_element(&result) == field_inv(field_element(self)),\n    {\n        // The bits of p-2 = 2^255 -19 -2 are 11010111111...11.\n        //\n        //                                 nonzero bits of exponent\n        assume(false);\n        let (t19, t3) = self.pow22501();  // t19: 249..0 ; t3: 3,1,0\n        let t20 = t19.pow2k(5);  // 254..5\n        let t21 = &t20 * &t3;  // 254..5,3,1,0\n\n        t21\n    }\n\n    /// Raise this field element to the power (p-5)/8 = 2^252 -3.\n    #[rustfmt::skip]  // keep alignment of explanatory comments\n    #[allow(clippy::let_and_return)]\n    fn pow_p58(&self) -> (result: FieldElement)\n        ensures\n            field_element_as_nat(&result) == pow(\n                field_element_as_nat(self) as int,\n                (pow2(252) - 3) as nat,\n            ) % (p() as int),\n    {\n        // The bits of (p-5)/8 are 101111.....11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, _) = self.pow22501();  // 249..0\n        assume(false);\n        let t20 = t19.pow2k(2);  // 251..2\n        assume(false);\n        let t21 = self * &t20;  // 251..2,0\n\n        t21\n    }\n\n    /// Given `FieldElements` `u` and `v`, compute either `sqrt(u/v)`\n    /// or `sqrt(i*u/v)` in constant time.\n    ///\n    /// This function always returns the nonnegative square root.\n    ///\n    /// # Return\n    ///\n    /// - `(Choice(1), +sqrt(u/v))  ` if `v` is nonzero and `u/v` is square;\n    /// - `(Choice(1), zero)        ` if `u` is zero;\n    /// - `(Choice(0), zero)        ` if `v` is zero and `u` is nonzero;\n    /// - `(Choice(0), +sqrt(i*u/v))` if `u/v` is nonsquare (so `i*u/v` is square).\n    ///\n    pub(crate) fn sqrt_ratio_i(u: &FieldElement, v: &FieldElement) -> (result: (\n        Choice,\n        FieldElement,\n    ))\n        ensures\n    // When u = 0: always return (true, 0)\n\n            (field_element_as_nat(u) == 0) ==> (choice_is_true(result.0) && field_element_as_nat(\n                &result.1,\n            ) == 0),\n            // When v = 0 but u ≠ 0: return (false, 0) [division by zero case]\n            (field_element_as_nat(v) == 0 && field_element_as_nat(u) != 0) ==> (!choice_is_true(\n                result.0,\n            ) && field_element_as_nat(&result.1) == 0),\n            // When successful and v ≠ 0: r² * v ≡ u (mod p)\n            (choice_is_true(result.0) && field_element_as_nat(v) != 0) ==> is_sqrt_ratio(\n                u,\n                v,\n                &result.1,\n            ),\n            // When unsuccessful and v ≠ 0: r² * v ≡ i*u (mod p) [nonsquare case]\n            (!choice_is_true(result.0) && field_element_as_nat(v) != 0 && field_element_as_nat(u)\n                != 0) ==> is_sqrt_ratio_times_i(\n                u,\n                v,\n                &result.1,\n            ),\n    // VERIFICATION NOTE: PROOF BYPASS\n\n    {\n        // Using the same trick as in ed25519 decoding, we merge the\n        // inversion, the square root, and the square test as follows.\n        //\n        // To compute sqrt(α), we can compute β = α^((p+3)/8).\n        // Then β^2 = ±α, so multiplying β by sqrt(-1) if necessary\n        // gives sqrt(α).\n        //\n        // To compute 1/sqrt(α), we observe that\n        //    1/β = α^(p-1 - (p+3)/8) = α^((7p-11)/8)\n        //                            = α^3 * (α^7)^((p-5)/8).\n        //\n        // We can therefore compute sqrt(u/v) = sqrt(u)/sqrt(v)\n        // by first computing\n        //    r = u^((p+3)/8) v^(p-1-(p+3)/8)\n        //      = u u^((p-5)/8) v^3 (v^7)^((p-5)/8)\n        //      = (uv^3) (uv^7)^((p-5)/8).\n        //\n        // If v is nonzero and u/v is square, then r^2 = ±u/v,\n        //                                     so vr^2 = ±u.\n        // If vr^2 =  u, then sqrt(u/v) = r.\n        // If vr^2 = -u, then sqrt(u/v) = r*sqrt(-1).\n        //\n        // If v is zero, r is also zero.\n        proof {\n            assume(false);  // PROOF BYPASS\n        }\n        let v3 = &v.square() * v;\n        let v7 = &v3.square() * v;\n        let mut r = &(u * &v3) * &(u * &v7).pow_p58();\n        let check = v * &r.square();\n\n        let i = &constants::SQRT_M1;\n\n        let correct_sign_sqrt = check.ct_eq(u);\n\n        // ORIGINAL CODE:\n        // let flipped_sign_sqrt = check.ct_eq(&(-u));\n        // let flipped_sign_sqrt_i = check.ct_eq(&(&(-u) * i));\n        // REFACTORED: Use wrapper to avoid Verus internal error with negation\n        let u_neg = negate_field(u);\n        let flipped_sign_sqrt = check.ct_eq(&u_neg);\n        let flipped_sign_sqrt_i = check.ct_eq(&(&u_neg * i));\n\n        let r_prime = &constants::SQRT_M1 * &r;\n        // ORIGINAL CODE:\n        // r.conditional_assign(&r_prime, flipped_sign_sqrt | flipped_sign_sqrt_i);\n        // REFACTORED: Use wrapper for Choice bitwise OR\n        r.conditional_assign(&r_prime, choice_or(flipped_sign_sqrt, flipped_sign_sqrt_i));\n\n        // Choose the nonnegative square root.\n        let r_is_negative = r.is_negative();\n        // ORIGINAL CODE:\n        // r.conditional_negate(r_is_negative);\n        // REFACTORED: Use wrapper for conditional_negate\n        conditional_negate_field(&mut r, r_is_negative);\n\n        // ORIGINAL CODE:\n        // let was_nonzero_square = correct_sign_sqrt | flipped_sign_sqrt;\n        // REFACTORED: Use wrapper for Choice bitwise OR\n        let was_nonzero_square = choice_or(correct_sign_sqrt, flipped_sign_sqrt);\n\n        (was_nonzero_square, r)\n    }\n\n    /// Attempt to compute `sqrt(1/self)` in constant time.\n    ///\n    /// Convenience wrapper around `sqrt_ratio_i`.\n    ///\n    /// This function always returns the nonnegative square root.\n    ///\n    /// # Return\n    ///\n    /// - `(Choice(1), +sqrt(1/self))  ` if `self` is a nonzero square;\n    /// - `(Choice(0), zero)           ` if `self` is zero;\n    /// - `(Choice(0), +sqrt(i/self))  ` if `self` is a nonzero nonsquare;\n    ///\n    pub(crate) fn invsqrt(&self) -> (result: (\n        Choice,\n        FieldElement,\n    ))\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n    // When self = 0: return (false, 0)\n\n            (field_element_as_nat(self) == 0) ==> (!choice_is_true(result.0)\n                && field_element_as_nat(&result.1) == 0),\n            // When successful and self ≠ 0: r² * self ≡ 1 (mod p)\n            (choice_is_true(result.0)) ==> is_sqrt_ratio(&FieldElement::ONE, self, &result.1),\n            // When unsuccessful and self ≠ 0: r² * self ≡ i (mod p) [nonsquare case]\n            (!choice_is_true(result.0) && field_element_as_nat(self) != 0)\n                ==> is_sqrt_ratio_times_i(&FieldElement::ONE, self, &result.1),\n    {\n        assume(false);\n        FieldElement::sqrt_ratio_i(&FieldElement::ONE, self)\n    }\n}",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_52_52().",
      "display_name": "lemma_52_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_52_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_52_52(x: u64, y: u64)\n    requires\n        x < (1u64 << 52),\n        y < (1u64 << 52),\n    ensures\n        (x as u128) * (y as u128) < (1u128 << 104),\n{\n    assert(1u128 << 52 == 1u64 << 52) by (bit_vector);\n    calc! {\n        (<)\n        (x as u128) * (y as u128); (<=) {\n            if x > 0 {\n                lemma_mul_strict_inequality(y as int, (1u128 << 52) as int, x as int);\n                assert(x * y < x * (1u128 << 52));\n            } else {\n                assert((0 as u128) * (y as u128) == 0);\n            }\n        }\n        (x as u128) * (1u128 << 52); (<) {\n            lemma_mul_strict_inequality(x as int, (1u128 << 52) as int, (1u128 << 52) as int);\n        }\n        (1u128 << 52) * (1u128 << 52);\n    }\n    assert((1u128 << 52) * (1u128 << 52) == (1u128 << 104)) by (compute);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash().",
      "display_name": "from_hash",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn from_hash<D>(hash: D) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64>,\n\n        ensures\n    //is_random_digest(&hash) ==> is_random_scalar(&result),\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut output = [0u8;64];\n        output.copy_from_slice(hash.finalize().as_slice());\n        Scalar::from_bytes_mod_order_wide(&output)\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#Index#index().",
      "display_name": "index",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#Index#index().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn index(&self, _index: usize) -> (result: &u64)\n        requires\n            _index < 5,\n        ensures\n            result == &(self.limbs[_index as int]),\n    {\n        &(self.limbs[_index])\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/bit_arrange().",
      "display_name": "bit_arrange",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/bit_arrange().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "display_name": "lemma_mul_is_distributive_add",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 23,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_modular_bit_partitioning().",
      "display_name": "lemma_modular_bit_partitioning",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_modular_bit_partitioning().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/bit_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/bit_lemmas.rs",
      "file_name": "bit_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn lemma_modular_bit_partitioning(a: nat, b: nat, k: nat, n: nat)\n    requires\n        k <= n,\n        a < pow2(k),\n    ensures\n        (a + b * pow2(k)) % pow2(n) == (a % pow2(k)) + ((b % pow2((n - k) as nat)) * pow2(k)),\n{\n    assert((a + b * pow2(k)) % pow2(n) == a % pow2(n) + (b * pow2(k)) % pow2(n)) by {\n        sum_mod_decomposition(a, b, k, n);\n    }\n\n    assert((b * pow2(k)) % pow2(n) == (b % pow2((n - k) as nat)) * pow2(k)) by {\n        mask_pow2(b, k, n);\n    }\n\n    assert(a % pow2(k) == a == a % pow2(n)) by {\n        assert(pow2(k) <= pow2(n)) by {\n            if (k < n) {\n                lemma_pow2_strictly_increases(k, n);\n            }\n        }\n        lemma_small_mod(a, pow2(k));\n        lemma_small_mod(a, pow2(n));\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "display_name": "lemma_mul_is_associative",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 34,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c0_0_val().",
      "display_name": "c0_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c0_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_pow2().",
      "display_name": "mask_pow2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_pow2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "    )) * pow2((6 * 8 - 1) as nat)) == (bytes[20] * pow2(20 * 8)) + (bytes[21] * pow2(21 * 8)) + (\n    bytes[22] * pow2(22 * 8)) + (bytes[23] * pow2(23 * 8)) + (bytes[24] * pow2(24 * 8)) + ((\n    bytes[25] as nat % pow2(4)) * pow2((25 * 8) as nat))) by {\n        assemble_pow_a_pow(bytes[20] as nat, 19, 1, 1);\n        assemble_pow_a_pow(bytes[21] as nat, 19, 2, 1);\n        assemble_pow_a_pow(bytes[22] as nat, 19, 3, 1);\n        assemble_pow_a_pow(bytes[23] as nat, 19, 4, 1);\n        assemble_pow_a_pow(bytes[24] as nat, 19, 5, 1);\n        assemble_pow_a_pow(bytes[25] as nat % pow2(4), 19, 6, 1);\n    }",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "display_name": "lemma_mul_is_commutative",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 26,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_strictly_positive().",
      "display_name": "lemma_mul_strictly_positive",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_strictly_positive().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/sum_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/sum_lemmas.rs",
      "file_name": "sum_lemmas.rs",
      "parent_folder": "common_verus",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#to_radix_2w_size_hint().",
      "display_name": "to_radix_2w_size_hint",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#to_radix_2w_size_hint().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "pub(crate) fn to_radix_2w_size_hint(w: usize) -> usize\n    requires\n        4 <= w <= 8,\n    returns\n        if w < 8 {\n            (256 + w - 1) / (w as int)\n        } else {\n            (256 + w - 1) / (w as int) + 1\n        } as usize,",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MulAssign#mul_assign().",
      "display_name": "mul_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MulAssign#mul_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn mul_assign(&mut self, scalar: &'b Scalar) {\n        let result = (self as &EdwardsPoint) * scalar;\n        *self = result;\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_div_bound().",
      "display_name": "lemma_div_bound",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_div_bound().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "{\n    // Connect the bit shift in the requires clause to pow2\n    shift_is_pow2(51);\n    lemma_byte_sum_equals_limb_sum(limbs, bytes);\n}",
      "is_libsignal": false,
      "caller_count": 10,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01234().",
      "display_name": "from_bytes_as_nat_01234",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01234().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn from_bytes_as_nat_01234(bytes: &[u8; 32])\n    ensures\n        (load8_at_spec(bytes, 0) as u64 & mask51) + pow2(51) * ((load8_at_spec(bytes, 6) as u64\n            >> 3) & mask51) + pow2(102) * ((load8_at_spec(bytes, 12) as u64 >> 6) & mask51) + pow2(\n            153,\n        ) * ((load8_at_spec(bytes, 19) as u64 >> 1) & mask51) + pow2(204) * ((load8_at_spec(\n            bytes,\n            24,\n        ) as u64 >> 12) & mask51) == (bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (bytes[2]\n            * pow2(2 * 8)) + (bytes[3] * pow2(3 * 8)) + (bytes[4] * pow2(4 * 8)) + (bytes[5] * pow2(\n            5 * 8,\n        )) + (bytes[6] * pow2(6 * 8)) + (bytes[7] * pow2(7 * 8)) + (bytes[8] * pow2(8 * 8)) + (\n        bytes[9] * pow2(9 * 8)) + (bytes[10] * pow2(10 * 8)) + (bytes[11] * pow2(11 * 8)) + (\n        bytes[12] * pow2(12 * 8)) + (bytes[13] * pow2(13 * 8)) + (bytes[14] * pow2(14 * 8)) + (\n        bytes[15] * pow2(15 * 8)) + (bytes[16] * pow2(16 * 8)) + (bytes[17] * pow2(17 * 8)) + (\n        bytes[18] * pow2(18 * 8)) + (bytes[19] * pow2(19 * 8)) + (bytes[20] * pow2(20 * 8)) + (\n        bytes[21] * pow2(21 * 8)) + (bytes[22] * pow2(22 * 8)) + (bytes[23] * pow2(23 * 8)) + (\n        bytes[24] * pow2(24 * 8)) + (bytes[25] * pow2(25 * 8)) + (bytes[26] * pow2(26 * 8)) + (\n        bytes[27] * pow2(27 * 8)) + (bytes[28] * pow2(28 * 8)) + (bytes[29] * pow2(29 * 8)) + (\n        bytes[30] * pow2(30 * 8)) + ((bytes[31] as nat % pow2(7)) * pow2((31 * 8) as nat)),\n{\n    assert((load8_at_spec(bytes, 0) as u64 & mask51) + pow2(51) * ((load8_at_spec(bytes, 6) as u64\n        >> 3) & mask51) + pow2(102) * ((load8_at_spec(bytes, 12) as u64 >> 6) & mask51) + pow2(153)\n        * ((load8_at_spec(bytes, 19) as u64 >> 1) & mask51) == (bytes[0] * pow2(0 * 8)) + (bytes[1]\n        * pow2(1 * 8)) + (bytes[2] * pow2(2 * 8)) + (bytes[3] * pow2(3 * 8)) + (bytes[4] * pow2(\n        4 * 8,\n    )) + (bytes[5] * pow2(5 * 8)) + (bytes[6] * pow2(6 * 8)) + (bytes[7] * pow2(7 * 8)) + (bytes[8]\n        * pow2(8 * 8)) + (bytes[9] * pow2(9 * 8)) + (bytes[10] * pow2(10 * 8)) + (bytes[11] * pow2(\n        11 * 8,\n    )) + (bytes[12] * pow2(12 * 8)) + (bytes[13] * pow2(13 * 8)) + (bytes[14] * pow2(14 * 8)) + (\n    bytes[15] * pow2(15 * 8)) + (bytes[16] * pow2(16 * 8)) + (bytes[17] * pow2(17 * 8)) + (bytes[18]\n        * pow2(18 * 8)) + (bytes[19] * pow2(19 * 8)) + (bytes[20] * pow2(20 * 8)) + (bytes[21]\n        * pow2(21 * 8)) + (bytes[22] * pow2(22 * 8)) + (bytes[23] * pow2(23 * 8)) + (bytes[24]\n        * pow2(24 * 8)) + ((bytes[25] as nat % pow2(4)) * pow2((25 * 8) as nat))) by {\n        from_bytes_as_nat_0123(bytes);\n    }\n\n    assert(((load8_at_spec(bytes, 24) as u64) >> 12) & mask51 == (bytes[25] as nat / pow2(4)) + (\n    bytes[26] * pow2((2 * 8 - 12) as nat)) + (bytes[27] * pow2((3 * 8 - 12) as nat)) + (bytes[28]\n        * pow2((4 * 8 - 12) as nat)) + (bytes[29] * pow2((5 * 8 - 12) as nat)) + (bytes[30] * pow2(\n        (6 * 8 - 12) as nat,\n    )) + ((bytes[31] as nat % pow2(7)) * pow2((7 * 8 - 12) as nat))) by {\n        load8_limb4(bytes);\n    }\n\n    assert(pow2(204) * (((load8_at_spec(bytes, 24) as u64) >> 12) & mask51) == pow2(204) * (\n    bytes[25] as nat / pow2(4)) + pow2(204) * (bytes[26] * pow2((2 * 8 - 12) as nat)) + pow2(204)\n        * (bytes[27] * pow2((3 * 8 - 12) as nat)) + pow2(204) * (bytes[28] * pow2(\n        (4 * 8 - 12) as nat,\n    )) + pow2(204) * (bytes[29] * pow2((5 * 8 - 12) as nat)) + pow2(204) * (bytes[30] * pow2(\n        (6 * 8 - 12) as nat,\n    )) + pow2(204) * ((bytes[31] as nat % pow2(7)) * pow2((7 * 8 - 12) as nat))) by {\n        mul_7_terms(\n            pow2(204) as int,\n            (bytes[25] as nat / pow2(4)) as int,\n            (bytes[26] * pow2((2 * 8 - 12) as nat)) as int,\n            (bytes[27] * pow2((3 * 8 - 12) as nat)) as int,\n            (bytes[28] * pow2((4 * 8 - 12) as nat)) as int,\n            (bytes[29] * pow2((5 * 8 - 12) as nat)) as int,\n            (bytes[30] * pow2((6 * 8 - 12) as nat)) as int,\n            ((bytes[31] as nat % pow2(7)) * pow2((7 * 8 - 12) as nat)) as int,\n        );\n    }\n\n    assert(((bytes[25] as nat % pow2(4)) * pow2((25 * 8) as nat)) + pow2(204) * (bytes[25] as nat\n        / pow2(4)) == bytes[25] * pow2(25 * 8)) by { assemble_mod_div(bytes[25] as nat, 4, 25 * 8) }\n\n    assert(pow2(204) * (bytes[26] * pow2((2 * 8 - 12) as nat)) + pow2(204) * (bytes[27] * pow2(\n        (3 * 8 - 12) as nat,\n    )) + pow2(204) * (bytes[28] * pow2((4 * 8 - 12) as nat)) + pow2(204) * (bytes[29] * pow2(\n        (5 * 8 - 12) as nat,\n    )) + pow2(204) * (bytes[30] * pow2((6 * 8 - 12) as nat)) + pow2(204) * ((bytes[31] as nat\n        % pow2(7)) * pow2((7 * 8 - 12) as nat)) == (bytes[26] * pow2(26 * 8)) + (bytes[27] * pow2(\n        27 * 8,\n    )) + (bytes[28] * pow2(28 * 8)) + (bytes[29] * pow2(29 * 8)) + (bytes[30] * pow2(30 * 8)) + ((\n    bytes[31] as nat % pow2(7)) * pow2((31 * 8) as nat))) by {\n        assemble_pow_a_pow(bytes[26] as nat, 24, 2, 12);\n        assemble_pow_a_pow(bytes[27] as nat, 24, 3, 12);\n        assemble_pow_a_pow(bytes[28] as nat, 24, 4, 12);\n        assemble_pow_a_pow(bytes[29] as nat, 24, 5, 12);\n        assemble_pow_a_pow(bytes[30] as nat, 24, 6, 12);\n        assemble_pow_a_pow(bytes[31] as nat % pow2(7), 24, 7, 12);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "display_name": "nonspec_map_to_curve",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn nonspec_map_to_curve<D>(bytes: &[u8]) -> EdwardsPoint where\n        D: Digest<OutputSize = U64> + Default,\n     {\n        let mut hash = D::new();\n        hash.update(bytes);\n        let h = hash.finalize();\n        let mut res = [0u8;32];\n        res.copy_from_slice(&h[0..32]);\n\n        let sign_bit = (res[31] & 0x80) >> 7;\n\n        let fe = FieldElement::from_bytes(&res);\n\n        let M1 = crate::montgomery::elligator_encode(&fe);\n        let E1_opt = M1.to_edwards(sign_bit);\n\n        E1_opt.expect(\n            \"Montgomery conversion to Edwards point in Elligator failed\",\n        ).mul_by_cofactor()\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_bytes().",
      "display_name": "as_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub const fn as_bytes(&self) -> (result: &[u8; 32])\n        ensures\n            result == &self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        &self.bytes\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "display_name": "square_multiply",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "fn square_multiply(\n    y: &mut UnpackedScalar,\n    squarings: usize,\n    x: &UnpackedScalar,\n)/*  VERIFICATION NOTE:\n- PROOF BYPASS\n- This function was initially inside the body of montgomery_invert, but was moved outside for Verus\n*/\n\n    requires\n        limbs_bounded(old(y)),  // Use old() for &mut parameters in requires\n        limbs_bounded(x),  // No old() needed for & parameters\n\n    ensures\n        limbs_bounded(y),\n        limbs_bounded(x),\n        (to_nat(&y.limbs) * montgomery_radix()) % group_order() == (pow(\n            to_nat(&old(y).limbs) as int,\n            pow2(squarings as nat),\n        ) * to_nat(&x.limbs)) % (group_order() as int),\n{\n    assume(false);\n    let ghost mut i: int = 0;  // Ghost variable: tracks iterations for proof\n    for _ in 0..squarings\n        invariant\n            limbs_bounded(y),\n            limbs_bounded(x),\n            i <= squarings,\n            pow(to_nat(&old(y).limbs) as int, pow2(i as nat)) < group_order() as int,\n    {\n        proof {\n            i = i + 1;\n            assume(i <= squarings);\n            assume(pow(to_nat(&old(y).limbs) as int, pow2(i as nat)) < group_order() as int);\n        }\n        *y = y.montgomery_square();\n    }\n    *y = UnpackedScalar::montgomery_mul(y, x);\n    proof {\n        assume(limbs_bounded(y));\n        assume(limbs_bounded(x));\n        assume((to_nat(&y.limbs) * montgomery_radix()) % group_order() == (pow(\n            to_nat(&old(y).limbs) as int,\n            pow2(squarings as nat),\n        ) * to_nat(&x.limbs)) % (group_order() as int));\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_sub_limbs().",
      "display_name": "spec_sub_limbs",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_sub_limbs().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::div_mod_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mask_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mul_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::pow_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::shift_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_nat_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::compute_q_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::field_core::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::from_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::limbs_to_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::load8_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::negate_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2_51_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/bit_or_is_plus().",
      "display_name": "bit_or_is_plus",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/bit_or_is_plus().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "    }\n}\n\npub proof fn rec_version_is_exec(input: &[u8], i: usize)\n    ensures\n        load8_at_or_version_rec(input, i, 7) == (input[i as int] as u64) | ((input[i + 1] as u64)\n            << 8) | ((input[i + 2] as u64) << 16) | ((input[i + 3] as u64) << 24) | ((input[i\n            + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((input[i + 6] as u64) << 48) | ((\n        input[i + 7] as u64) << 56),\n{\n    assert(load8_at_or_version_rec(input, i, 0) == (input[i as int] as u64));\n\n    assert forall|j: nat| 1 <= j <= 7 implies #[trigger] load8_at_or_version_rec(input, i, j)\n        == load8_at_or_version_rec(input, i, (j - 1) as nat) | ((input[i + j] as u64) << 8 * j) by {\n        reveal_with_fuel(load8_at_or_version_rec, 1);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "display_name": "sum_mod_decomposition",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "\n    assert(pow2(102) * ((load8_at_spec(bytes, 12) as u64 >> 6) & mask51) == pow2(102) * (\n    bytes[12] as nat / pow2(6)) + pow2(102) * (bytes[13] * pow2((1 * 8 - 6) as nat)) + pow2(102) * (\n    bytes[14] * pow2((2 * 8 - 6) as nat)) + pow2(102) * (bytes[15] * pow2((3 * 8 - 6) as nat))\n        + pow2(102) * (bytes[16] * pow2((4 * 8 - 6) as nat)) + pow2(102) * (bytes[17] * pow2(\n        (5 * 8 - 6) as nat,\n    )) + pow2(102) * (bytes[18] * pow2((6 * 8 - 6) as nat)) + pow2(102) * ((bytes[19] as nat % pow2(\n        1,\n    )) * pow2((7 * 8 - 6) as nat))) by {\n        mul_8_terms(\n            pow2(102) as int,\n            (bytes[12] as nat / pow2(6)) as int,\n            (bytes[13] * pow2((1 * 8 - 6) as nat)) as int,\n            (bytes[14] * pow2((2 * 8 - 6) as nat)) as int,\n            (bytes[15] * pow2((3 * 8 - 6) as nat)) as int,\n            (bytes[16] * pow2((4 * 8 - 6) as nat)) as int,\n            (bytes[17] * pow2((5 * 8 - 6) as nat)) as int,\n            (bytes[18] * pow2((6 * 8 - 6) as nat)) as int,\n            ((bytes[19] as nat % pow2(1)) * pow2((7 * 8 - 6) as nat)) as int,\n        );\n    }",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo rand 0.8.5 thread/rngs/ThreadRng#RngCore#fill_bytes().",
      "display_name": "fill_bytes",
      "symbol": "rust-analyzer cargo rand 0.8.5 thread/rngs/ThreadRng#RngCore#fill_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_wide_to_nat_rec().",
      "display_name": "bytes_wide_to_nat_rec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_wide_to_nat_rec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
      "relative_path": "src/backend/serial/u64/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "u64",
      "body": "pub open spec fn bytes_wide_to_nat_rec(bytes: &[u8; 64], index: int) -> nat\n    decreases 64 - index,\n{\n    if index >= 64 {\n        0\n    } else {\n        (bytes[index] as nat) * pow2((index * 8) as nat) + bytes_wide_to_nat_rec(bytes, index + 1)\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/main().",
      "display_name": "main",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/main().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/div_mod_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "fn main() {\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random().",
      "display_name": "is_random",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub uninterp spec fn is_random(x: u8) -> bool;\n\npub uninterp spec fn is_random_bytes(bytes: &[u8]) -> bool;\n\npub uninterp spec fn is_random_scalar(scalar: &Scalar) -> bool;\n\n#[cfg(feature = \"rand_core\")]\n#[verifier::external_body]\npub fn fill_bytes<R: RngCore>(rng: &mut R, bytes: &mut [u8; 64])\n    ensures\n        is_random_bytes(bytes),\n{\n    rng.fill_bytes(bytes)\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/vartime_double_base_mul().",
      "display_name": "vartime_double_base_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/vartime_double_base_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "                field_element(&X),\n                field_element(&Y),\n            ));\n        }\n        if choice_into(is_valid_y_coord) {\n            assert(choice_is_true(is_valid_y_coord));\n            assert(field_element(&Y) == field_element_from_bytes(&self.0));\n            let point = decompress::step_2(self, X, Y, Z);\n            let result = Some(point);\n            assume(false);\n            result\n        } else {\n            assert(!choice_is_true(is_valid_y_coord));\n            assert(!is_valid_y_coordinate(field_element_from_bytes(&self.0)));\n            let result = None;\n            result\n        }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_reduce().",
      "display_name": "spec_reduce",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_reduce().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///",
      "is_libsignal": false,
      "caller_count": 10,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/a1_0_val().",
      "display_name": "a1_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/a1_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn a1_0_val(a: [u64; 5]) -> u64 {\n    (c1_val(a) as u64) & mask51\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#negate().",
      "display_name": "negate",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#negate().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    pub fn negate(&mut self)\n        requires\n            forall|i: int| 0 <= i < 5 ==> old(self).limbs[i] < (1u64 << 51),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52),\n            // Assume we start with l = (l0, l1, l2, l3, l4).\n            // Using c0 = 2^51 - 19 and c = 2^51 - 1, we can see that\n            // ( 36028797018963664u64 - l0,\n            //   36028797018963952u64 - l1,\n            //   36028797018963952u64 - l2,\n            //   36028797018963952u64 - l3,\n            //   36028797018963952u64 - l4 )\n            // is just 16 * (c0, c, c, c, c) - l (in vector notation)\n            // Further, as_nat((c0, c, c, c, c)) = p, so\n            // as_nat(16 * (c0, c, c, c, c) - l) is 16p - as_nat(l)\n            // We know as_nat(reduce(v)) = as_nat(v) - p * (v4 >> 51) for any v.\n            // This gives us the identity\n            // as_nat(negate(l)) = as_nat(reduce(16 * (c0, c, c, c, c) - l))\n            //                   = 16p - as_nat(l) - p * ((16c - l4) >> 51)\n            // Note that (16c - l4) >> 51 is either 14 or 15, in either case < 16.\n            as_nat(self.limbs) == 16 * p() - as_nat(old(self).limbs) - p() * ((36028797018963952u64\n                - old(self).limbs[4]) as u64 >> 51),\n            (as_nat(self.limbs) + as_nat(old(self).limbs)) % p() == 0,\n    {\n        proof {\n            lemma_neg_no_underflow(self.limbs);\n            negate_proof(self.limbs);\n        }\n        // See commentary in the Sub impl: (copied below)\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        let neg = FieldElement51::reduce(\n            [\n                36028797018963664u64 - self.limbs[0],\n                36028797018963952u64 - self.limbs[1],\n                36028797018963952u64 - self.limbs[2],\n                36028797018963952u64 - self.limbs[3],\n                36028797018963952u64 - self.limbs[4],\n            ],\n        );\n        self.limbs = neg.limbs;\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_si_vi_and_reorder().",
      "display_name": "mul_si_vi_and_reorder",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_si_vi_and_reorder().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs",
      "file_name": "as_nat_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "        // s4 terms\n        assert(s4 * (v0 * v4) + s4 * (v1 * v3) + s4 * (v2 * v2) + s4 * (v1 * v3) + s4 * (v0 * v4)\n            == s4 * (v2 * v2 + 2 * (v1 * v3) + 2 * (v0 * v4))) by {\n            assert(v0 * v4 + v0 * v4 == 2 * (v0 * v4));\n            assert(v1 * v3 + v1 * v3 == 2 * (v1 * v3));\n            lemma_mul_is_distributive_add(s4 as int, v0 * v4, v0 * v4);\n            lemma_mul_is_distributive_add(s4 as int, v1 * v3, v1 * v3);\n            lemma_mul_is_distributive_add(s4 as int, v2 * v2, 2 * (v1 * v3));\n            lemma_mul_is_distributive_add(s4 as int, v2 * v2 + 2 * (v1 * v3), 2 * (v0 * v4));\n        }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#from_uniform_bytes_single_elligator().",
      "display_name": "from_uniform_bytes_single_elligator",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#from_uniform_bytes_single_elligator().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    pub fn from_uniform_bytes_single_elligator(bytes: &[u8; 32]) -> RistrettoPoint {\n        RistrettoPoint::elligator_ristretto_flavor(&FieldElement::from_bytes(bytes))\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "display_name": "decompress",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn decompress(&self) -> (result: Option<\n        EdwardsPoint,\n    >)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            is_valid_y_coordinate(field_element_from_bytes(&self.0))\n                ==> result.is_some()\n            // The Y coordinate matches the one from the compressed representation\n             && field_element(&result.unwrap().Y) == field_element_from_bytes(\n                &self.0,\n            )\n            // The point is valid\n             && is_valid_edwards_point(\n                result.unwrap(),\n            )\n            // The X coordinate sign bit matches the sign bit from the compressed representation\n             && field_element_sign_bit(&result.unwrap().X) == (self.0[31] >> 7),\n            !is_valid_y_coordinate(field_element_from_bytes(&self.0)) <==> result.is_none(),\n    {\n        let (is_valid_y_coord, X, Y, Z) = decompress::step_1(self);\n\n        proof {\n            assert(choice_is_true(is_valid_y_coord) ==> is_valid_y_coordinate(\n                field_element_from_bytes(&self.0),\n            ));\n            assert(choice_is_true(is_valid_y_coord) ==> on_edwards_curve(\n                field_element(&X),\n                field_element(&Y),\n            ));\n        }\n        if choice_into(is_valid_y_coord) {\n            assert(choice_is_true(is_valid_y_coord));\n            assert(field_element(&Y) == field_element_from_bytes(&self.0));\n            let point = decompress::step_2(self, X, Y, Z);\n            let result = Some(point);\n            assume(false);\n            result\n        } else {\n            assert(!choice_is_true(is_valid_y_coord));\n            assert(!is_valid_y_coordinate(field_element_from_bytes(&self.0)));\n            let result = None;\n            result\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#AddAssign#add_assign().",
      "display_name": "add_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#AddAssign#add_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_add_limbs().",
      "display_name": "spec_add_limbs",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_add_limbs().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "use vstd::arithmetic::div_mod::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::mul::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\n#[allow(unused_imports)]\nuse vstd::bits::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::bit_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::div_mod_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mask_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mul_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::pow_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::shift_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_nat_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::compute_q_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::field_core::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::from_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::limbs_to_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::load8_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::negate_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2_51_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries2().",
      "display_name": "as_bytes_boundaries2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo digest 0.10.7 digest/Digest#finalize().",
      "display_name": "finalize",
      "symbol": "rust-analyzer cargo digest 0.10.7 digest/Digest#finalize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/sum_of_scalars().",
      "display_name": "sum_of_scalars",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/sum_of_scalars().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar_helpers.rs",
      "relative_path": "src/scalar_helpers.rs",
      "file_name": "scalar_helpers.rs",
      "parent_folder": "src",
      "body": "                // Assume the result maintains the invariant\n                assume(scalar_to_nat(&acc) < group_order());\n                assume(scalar_congruent_nat(\n                    &acc,\n                    product_of_scalars(scalars@.subrange(0, (i + 1) as int)),\n                ));\n            }\n        }\n\n        proof {\n            // At this point, acc is the product of all scalars\n            assert(scalars@.subrange(0, n as int) =~= scalars@);\n        }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo digest 0.10.7 digest/Digest#update().",
      "display_name": "update",
      "symbol": "rust-analyzer cargo digest 0.10.7 digest/Digest#update().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "display_name": "pow22501",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "    fn pow22501(&self) -> (result: (FieldElement, FieldElement))\n        ensures\n            field_element_as_nat(&result.0) == pow(\n                field_element_as_nat(self) as int,\n                (pow2(250) - 1) as nat,\n            ) % (p() as int),\n            field_element_as_nat(&result.1) == pow(field_element_as_nat(self) as int, 11) % (\n            p() as int),\n    {\n        // Instead of managing which temporary variables are used\n        // for what, we define as many as we need and leave stack\n        // allocation to the compiler\n        //\n        // Each temporary variable t_i is of the form (self)^e_i.\n        // Squaring t_i corresponds to multiplying e_i by 2,\n        // so the pow2k function shifts e_i left by k places.\n        // Multiplying t_i and t_j corresponds to adding e_i + e_j.\n        //\n        // Temporary t_i                      Nonzero bits of e_i\n        //\n        assume(false);\n        let t0 = self.square();  // 1         e_0 = 2^1\n        let t1 = t0.square().square();  // 3         e_1 = 2^3\n        let t2 = self * &t1;  // 3,0       e_2 = 2^3 + 2^0\n        let t3 = &t0 * &t2;  // 3,1,0\n        let t4 = t3.square();  // 4,2,1\n        let t5 = &t2 * &t4;  // 4,3,2,1,0\n        let t6 = t5.pow2k(5);  // 9,8,7,6,5\n        let t7 = &t6 * &t5;  // 9,8,7,6,5,4,3,2,1,0\n        let t8 = t7.pow2k(10);  // 19..10\n        let t9 = &t8 * &t7;  // 19..0\n        let t10 = t9.pow2k(20);  // 39..20\n        let t11 = &t10 * &t9;  // 39..0\n        let t12 = t11.pow2k(10);  // 49..10\n        let t13 = &t12 * &t7;  // 49..0\n        let t14 = t13.pow2k(50);  // 99..50\n        let t15 = &t14 * &t13;  // 99..0\n        let t16 = t15.pow2k(100);  // 199..100\n        let t17 = &t16 * &t15;  // 199..0\n        let t18 = t17.pow2k(50);  // 249..50\n        let t19 = &t18 * &t13;  // 249..0\n\n        (t19, t3)\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective().",
      "display_name": "as_projective",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub(crate) const fn as_projective(&self) -> ProjectivePoint {\n        ProjectivePoint { X: self.X, Y: self.Y, Z: self.Z }\n    }",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_loop2_invariant().",
      "display_name": "lemma_sub_loop2_invariant",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_loop2_invariant().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub(crate) proof fn lemma_sub_loop2_invariant(\n    difference: Scalar52,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    mask: u64,\n    difference_after_loop1: Scalar52,\n    difference_loop2_start: Scalar52,\n    carry: u64,\n    old_carry: u64,\n    addend: u64,\n    borrow: u64,\n)\n    requires\n        0 <= i < 5,\n        mask == (1u64 << 52) - 1,\n        forall|j: int| 0 <= j < 5 ==> difference_loop2_start.limbs[j] < (1u64 << 52),\n        forall|j: int|\n            i <= j < 5 ==> difference_loop2_start.limbs[j] == difference_after_loop1.limbs[j],\n        forall|j: int|\n            (0 <= j < 5 && j != i) ==> difference_loop2_start.limbs[j] == difference.limbs[j],\n        mask == (1u64 << 52) - 1,\n        i == 0 ==> old_carry == 0,\n        i >= 1 ==> (old_carry >> 52) < 2,\n        (i >= 1 && borrow >> 63 == 0) ==> old_carry == difference_loop2_start.limbs[i - 1],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference_loop2_start,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int))\n            + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) == seq_u64_to_nat(\n            difference_loop2_start.limbs@.subrange(0, i as int),\n        ) + (old_carry >> 52) * pow2(52 * i as nat),\n        difference.limbs[i as int] == carry & mask,\n        difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(\n            0,\n            i as int,\n        ),\n        borrow >> 63 == 0 ==> addend == 0,\n        borrow >> 63 == 1 ==> addend == constants::L.limbs[i as int],\n        carry == (old_carry >> 52) + difference_loop2_start.limbs[i as int] + addend,\n    ensures\n        (i + 1 >= 1 && borrow >> 63 == 0) ==> carry == difference.limbs[i as int],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(\n            difference_after_loop1.limbs@.subrange(0, i + 1 as int),\n        ) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i + 1 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, i + 1 as int),\n        ) + (carry >> 52) * pow2(52 * (i + 1) as nat),\n{\n    if borrow >> 63 == 0 {\n        lemma_old_carry(old_carry);\n        assert(addend == 0);\n        assert(carry == difference_loop2_start.limbs[i as int]);\n        assert(carry & mask == carry) by (bit_vector)\n            requires\n                carry < 1u64 << 52,\n                mask == (1u64 << 52) - 1,\n        ;\n        assert(difference_after_loop1.limbs[i as int] == difference.limbs[i as int]);\n        assert(forall|j: int|\n            0 <= j < 5 ==> difference_after_loop1.limbs[j] == difference.limbs[j]);\n        assert(difference_after_loop1.limbs == difference.limbs);\n    }\n    if borrow >> 63 == 1 {\n        // When underflow, addend = L.limbs[i]\n        assert(addend == constants::L.limbs[i as int]);\n        // carry = (old_carry >> 52) + difference_after_loop1.limbs[i] + L.limbs[i]\n        // difference.limbs[i] = carry & mask\n        calc! {\n            (==)\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(\n                constants::L.limbs@.subrange(0, i + 1),\n            ); {\n                lemma_seq_u64_to_nat_subrange_extend(difference_after_loop1.limbs@, i as int);\n                lemma_seq_u64_to_nat_subrange_extend(constants::L.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int))\n                + difference_after_loop1.limbs[i as int] as nat * pow2(52 * i as nat)\n                + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int))\n                + constants::L.limbs[i as int] as nat * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n                constants::L.limbs@.subrange(0, i as int),\n            ) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                // Use invariant\n            }\n            seq_u64_to_nat(difference_loop2_start.limbs@.subrange(0, i as int)) + (old_carry\n                >> 52) as nat * pow2(52 * i as nat) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(difference_loop2_start.limbs@.subrange(0, i as int)\n                    == difference.limbs@.subrange(0, i as int));\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat\n                * pow2(52 * i as nat) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((old_carry >> 52) as nat\n                + difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(carry == (old_carry >> 52) + difference_after_loop1.limbs[i as int]\n                    + constants::L.limbs[i as int]);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + carry as nat * pow2(\n                52 * i as nat,\n            ); {\n                assert(carry == (carry >> 52) * (1u64 << 52) + (carry & mask)) by (bit_vector)\n                    requires\n                        mask == (1u64 << 52) - 1,\n                ;\n                assert(carry == (carry >> 52) * pow2(52) + difference.limbs[i as int]) by {\n                    lemma2_to64_rest();\n                    assert(0x10000000000000 == 1u64 << 52) by (compute_only);\n                };\n                assert(difference.limbs[i as int] == carry & mask);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((carry >> 52) as nat * pow2(\n                52,\n            ) + difference.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n                52,\n            ) * pow2(52 * i as nat) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                    broadcast use lemma_pow2_adds;\n\n                };\n                assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat\n                    * pow2(52 * (i + 1) as nat)) by {\n                    assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                    lemma_mul_is_associative(\n                        (carry >> 52) as int,\n                        pow2(52) as int,\n                        pow2(52 * i as nat) as int,\n                    );\n                };\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n                52 * (i + 1) as nat,\n            ) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (carry >> 52) as nat * pow2(\n                52 * (i + 1) as nat,\n            );\n        }\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#From#from().",
      "display_name": "from",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#From#from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_affine_niels(); 64];\n        let A2 = A.double();\n        for i in 0..63 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n        NafLookupTable8(Ai)\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "display_name": "lemma_pow2_strictly_increases",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 28,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "display_name": "conditional_select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n            ],\n        );\n\n        proof {\n            // The bytes [1, 0, 0, ..., 0] represent the value 1 in little-endian\n            // byte 31 is 0, so the sign bit (bit 7 of byte 31) is 0\n            assert(result.0[31] == 0);\n            let x = result.0[31];\n            assume(x >> 7 == 0);\n            // field_element_from_bytes([1, 0, ...]) should equal 1\n            // This requires the byte-to-nat conversion to recognize [1,0,0,...] = 1\n            assume(field_element_from_bytes(&result.0) == 1);\n        }",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_mul().",
      "display_name": "field_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/curve_specs.rs",
      "relative_path": "src/curve_specs.rs",
      "file_name": "curve_specs.rs",
      "parent_folder": "src",
      "body": "    let y = field_element(&point.Y);\n    let z = field_element(&point.Z);\n    let t = field_element(&point.T);\n\n    // Z must be non-zero\n    z != 0 &&\n    // The affine coordinates (X/Z, Y/Z) must be on the curve\n    on_edwards_curve(field_mul(x, field_inv(z)), field_mul(y, field_inv(z)))\n        &&\n    // Extended coordinate must satisfy T = X*Y/Z\n    t == field_mul(field_mul(x, y), field_inv(z))\n}\n\n/// Returns the abstract affine coordinates (x, y) of this point.\npub open spec fn affine_coords(point: crate::edwards::EdwardsPoint) -> (nat, nat) {\n    let x_abs = field_element(&point.X);\n    let y_abs = field_element(&point.Y);\n    let z_abs = field_element(&point.Z);\n    let z_inv = field_inv(z_abs);\n    (field_mul(x_abs, z_inv), field_mul(y_abs, z_inv))\n}",
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 CtOption#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo subtle 2.6.1 CtOption#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/all_neg_limbs_positive().",
      "display_name": "all_neg_limbs_positive",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/all_neg_limbs_positive().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/negate_lemmas.rs",
      "file_name": "negate_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn all_neg_limbs_positive(limbs: [u64; 5]) -> bool {\n    &&& 36028797018963664u64 >= limbs[0]\n    &&& 36028797018963952u64 >= limbs[1]\n    &&& 36028797018963952u64 >= limbs[2]\n    &&& 36028797018963952u64 >= limbs[3]\n    &&& 36028797018963952u64 >= limbs[4]\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/lemma_neg_no_underflow().",
      "display_name": "lemma_neg_no_underflow",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/lemma_neg_no_underflow().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "\n#[allow(unused_imports)]\nuse vstd::arithmetic::div_mod::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::mul::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\n#[allow(unused_imports)]\nuse vstd::bits::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::bit_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::div_mod_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mask_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mul_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::pow_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::shift_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_nat_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::compute_q_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::field_core::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::from_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::limbs_to_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::load8_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::negate_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2_51_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConstantTimeEq#ct_eq().",
      "display_name": "ct_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConstantTimeEq#ct_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn ct_eq(&self, other: &EdwardsPoint) -> Choice {\n        // We would like to check that the point (X/Z, Y/Z) is equal to\n        // the point (X'/Z', Y'/Z') without converting into affine\n        // coordinates (x, y) and (x', y'), which requires two inversions.\n        // We have that X = xZ and X' = x'Z'. Thus, x = x' is equivalent to\n        // (xZ)Z' = (x'Z')Z, and similarly for the y-coordinate.\n\n        (&self.X * &other.Z).ct_eq(&(&other.X * &self.Z))\n            & (&self.Y * &other.Z).ct_eq(&(&other.Y * &self.Z))\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "display_name": "conditional_add_l",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub(crate) fn conditional_add_l(&mut self, condition: Choice) -> (carry: u64)\n        requires\n            limbs_bounded(&old(self)),\n            to_nat(&old(self).limbs) + group_order() < pow2(260),\n        ensures\n    // The mathematical value modulo group_order doesn't change (since L = group_order)\n\n            to_nat(&self.limbs) % group_order() == to_nat(&old(self).limbs) % group_order(),\n            // VERIFICATION NOTE: expression below unsupported by Verus\n            //limbs_bounded(&self),\n            // Meaning of conditional addition\n            super::subtle_assumes::choice_is_true(condition) ==> to_nat(&self.limbs) == to_nat(\n                &old(self).limbs,\n            ) + group_order(),\n            !super::subtle_assumes::choice_is_true(condition) ==> to_nat(&self.limbs) == to_nat(\n                &old(self).limbs,\n            ),\n    {\n        let mut carry: u64 = 0;\n\n        proof {\n            assert(1u64 << 52 > 0) by (bit_vector);\n        }\n        let mask = (1u64 << 52) - 1;\n\n        for i in 0..5\n            invariant\n                mask == (1u64 << 52) - 1,\n                forall|j: int| 0 <= j < i ==> self.limbs[j] < (1u64 << 52),\n                forall|j: int| i <= j < 5 ==> self.limbs[j] == old(self).limbs[j],\n                forall|j: int| i <= j < 5 ==> self.limbs[j] < (1u64 << 52),\n                i == 0 ==> carry == 0,\n                i >= 1 ==> (carry >> 52) < 2,\n        {\n            /* <VERIFICATION NOTE> Using wrapper function for Verus compatibility instead of direct call to conditional_select */\n            let addend = select(&0, &constants::L.limbs[i], condition);\n            /* <ORIGINAL CODE>\n             let addend = u64::conditional_select(&0, &constants::L[i], condition);\n             <ORIGINAL CODE>*/\n\n            // Prove no overflow using the same lemma as in sub()\n            proof {\n                lemma_scalar_subtract_no_overflow(\n                    carry,\n                    self.limbs[i as int],\n                    addend,\n                    i as u32,\n                    &constants::L,\n                );\n            }\n\n            carry = (carry >> 52) + self.limbs[i] + addend;\n            self.limbs[i] = carry & mask;\n\n            proof {\n                lemma_carry_bounded_after_mask(carry, mask);\n            }\n        }\n\n        proof {\n            // TODO: Prove the postconditions\n            assume(to_nat(&self.limbs) % group_order() == to_nat(&old(self).limbs) % group_order());\n            //   assume(limbs_bounded(&self));\n            assume(super::subtle_assumes::choice_is_true(condition) ==> to_nat(&self.limbs)\n                == to_nat(&old(self).limbs) + group_order());\n            assume(!super::subtle_assumes::choice_is_true(condition) ==> to_nat(&self.limbs)\n                == to_nat(&old(self).limbs));\n        }\n\n        carry\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "display_name": "ct_eq",
      "symbol": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix_51_partial_geometric_sum().",
      "display_name": "lemma_radix_51_partial_geometric_sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix_51_partial_geometric_sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_radix_51_partial_geometric_sum()\n    ensures\n        pow2(51) + pow2(102) + pow2(153) + pow2(204) < pow2(255),\n{\n    // Each of the first three terms is < pow2(204)\n    lemma_pow2_strictly_increases(51, 204);\n    lemma_pow2_strictly_increases(102, 204);\n    lemma_pow2_strictly_increases(153, 204);\n\n    // Therefore the sum < 4 * pow2(204) = pow2(206) < pow2(255)\n    assert(4 * pow2(204) < pow2(255)) by {\n        assert(4 == pow2(2)) by {\n            lemma2_to64();\n        }\n        lemma_pow2_adds(2, 204);\n        lemma_pow2_strictly_increases(206, 255);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_fits_u64().",
      "display_name": "load8_plus_fits_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_fits_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn load8_plus_fits_u64(input: &[u8], i: usize, k: nat)\n    requires\n        i + k < input.len(),\n        0 < k <= 7,\n    ensures\n        load8_at_plus_version_rec(input, i, (k - 1) as nat) + pow2(k * 8) * input[i + k]\n            <= u64::MAX,\n{\n    let xk_1 = load8_at_plus_version_rec(input, i, (k - 1) as nat);\n    let v = input[i + k];\n\n    assert((xk_1 + pow2(k * 8) * v) <= u64::MAX) by {\n        assert(v <= u8::MAX);  // known\n        assert(pow2(8 * k) <= 0x100000000000000) by {\n            if (k < 7) {\n                lemma_pow2_strictly_increases(k * 8, 56);\n            }\n            lemma2_to64_rest();\n        }\n        assert(xk_1 < pow2(8 * k)) by {\n            load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n        }\n        assert(xk_1 <= 0x100000000000000 - 1);\n        assert(pow2(k * 8) * v <= 0x100000000000000 * u8::MAX) by {\n            mul_le(pow2(k * 8), 0x100000000000000, v as nat, u8::MAX as nat);\n        }\n        assert((0x100000000000000 - 1) + (0x100000000000000) * u8::MAX <= u64::MAX) by (compute);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_uniform_bytes().",
      "display_name": "from_uniform_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_uniform_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn from_uniform_bytes(bytes: &[u8; 64]) -> RistrettoPoint {\n        // This follows the one-way map construction from the Ristretto RFC:\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#section-4.3.4\n        let mut r_1_bytes = [0u8; 32];\n        r_1_bytes.copy_from_slice(&bytes[0..32]);\n        let r_1 = FieldElement::from_bytes(&r_1_bytes);\n        let R_1 = RistrettoPoint::elligator_ristretto_flavor(&r_1);\n\n        let mut r_2_bytes = [0u8; 32];\n        r_2_bytes.copy_from_slice(&bytes[32..64]);\n        let r_2 = FieldElement::from_bytes(&r_2_bytes);\n        let R_2 = RistrettoPoint::elligator_ristretto_flavor(&r_2);\n\n        // Applying Elligator twice and adding the results ensures a\n        // uniform distribution.\n        R_1 + R_2\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#enumerate().",
      "display_name": "enumerate",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#enumerate().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c3_val().",
      "display_name": "c3_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c3_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_multiples_vanish().",
      "display_name": "lemma_mod_multiples_vanish",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_multiples_vanish().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/reduce_lemmas.rs",
      "file_name": "reduce_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/a3_0_val().",
      "display_name": "a3_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/a3_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn a3_0_val(a: [u64; 5]) -> u64 {\n    (c3_val(a) as u64) & mask51\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_correct_after_loops().",
      "display_name": "lemma_sub_correct_after_loops",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_correct_after_loops().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub(crate) proof fn lemma_sub_correct_after_loops(\n    difference: Scalar52,\n    carry: u64,\n    a: &Scalar52,\n    b: &Scalar52,\n    difference_after_loop1: Scalar52,\n    borrow: u64,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        limbs_bounded(&difference),\n        limbs_bounded(&difference_after_loop1),\n        (carry >> 52) < 2,\n        -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order(),\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n            + seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ) + (carry >> 52) * pow2(52 * 5 as nat),\n        seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) - (borrow >> 63)\n            * pow2((52 * (5) as nat)),\n    ensures\n        to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int),\n{\n    assert(borrow >> 63 == 1 || borrow >> 63 == 0) by (bit_vector);\n    assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(&difference.limbs))\n        by {\n        assert(seq_u64_to_nat(difference.limbs@) == to_nat(&difference.limbs));\n        assert(difference.limbs@ == difference.limbs@.subrange(0, 5 as int));\n    }\n    assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs)) by {\n        assert(seq_u64_to_nat(b.limbs@) == to_nat(&b.limbs));\n        assert(b.limbs@ == b.limbs@.subrange(0, 5 as int));\n    }\n    assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs)) by {\n        assert(seq_u64_to_nat(a.limbs@) == to_nat(&a.limbs));\n        assert(a.limbs@ == a.limbs@.subrange(0, 5 as int));\n    }\n    if borrow >> 63 == 0 {\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) - (borrow >> 63) * pow2(\n            (52 * (5) as nat),\n        ));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)));\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) == to_nat(&difference.limbs));\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) >= 0);\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) < group_order());\n        lemma_small_mod((to_nat(&a.limbs) - to_nat(&b.limbs)) as nat, group_order());\n        assert(to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (\n        group_order() as int));\n    }\n    if borrow >> 63 == 1 {\n        assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            constants::L.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ));\n        assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n            == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ) - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) - pow2(\n            (52 * (5) as nat),\n        ));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ) - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) - pow2((52 * (5) as nat)));\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            a.limbs@.subrange(0, 5 as int),\n        ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ) + (carry >> 52) * pow2(52 * 5 as nat) - pow2((52 * (5) as nat)));\n        if carry >> 52 == 0 {\n            // Get a contradiction because the sides in the above equation have different signs\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n                a.limbs@.subrange(0, 5 as int),\n            ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) >= 0) by {\n                assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) >= group_order())\n                    by {\n                    lemma_l_equals_group_order();\n                };\n                assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs));\n                assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs));\n            };\n            assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) < pow2(\n                (52 * (5) as nat),\n            )) by {\n                assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(\n                    &difference.limbs,\n                ));\n                lemma_bound_scalar(&difference);\n            };\n            assert((carry >> 52) * pow2(52 * 5 as nat) == 0);\n            assert(false);\n        }\n        assert(carry >> 52 == 1);\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            a.limbs@.subrange(0, 5 as int),\n        ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ));\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + to_nat(&a.limbs)\n            - to_nat(&b.limbs) == to_nat(&difference.limbs));\n        assert(to_nat(&constants::L.limbs) == group_order()) by {\n            lemma_l_equals_group_order();\n        };\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order()) by {\n            lemma_l_equals_group_order();\n        };\n        assert(group_order() > 0);\n        calc! {\n            (==)\n            to_nat(&difference.limbs) as int; {}\n            group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs); {\n                assert(group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs) < group_order())\n                    by {\n                    assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n                        == to_nat(&difference_after_loop1.limbs)) by {\n                        assert(seq_u64_to_nat(difference_after_loop1.limbs@) == to_nat(\n                            &difference_after_loop1.limbs,\n                        ));\n                        assert(difference_after_loop1.limbs@\n                            == difference_after_loop1.limbs@.subrange(0, 5 as int));\n                    }\n                    assert(to_nat(&a.limbs) - to_nat(&b.limbs) == to_nat(\n                        &difference_after_loop1.limbs,\n                    ) - pow2((52 * (5) as nat)));\n                    lemma_bound_scalar(&difference_after_loop1);\n                };\n                lemma_small_mod(\n                    (group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) as nat,\n                    group_order(),\n                );\n            }\n            (group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int); {\n                lemma_mod_cancel(a, b);\n            }\n            (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int);\n        }\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "display_name": "invert",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "\n        let result = EdwardsPoint { X, Y, Z, T: &X * &Y };\n",
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_field_add().",
      "display_name": "spec_field_add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_field_add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "//! Field arithmetic modulo \\\\(p = 2\\^{255} - 19\\\\), using \\\\(64\\\\)-bit\n//! limbs with \\\\(128\\\\)-bit products.",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/main().",
      "display_name": "main",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/main().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs",
      "file_name": "as_nat_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "fn main() {\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "display_name": "mul_internal",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "        result\n    }\n}\n\ndefine_add_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> AddAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    #[allow(clippy::op_ref)]\n    fn add_assign(&mut self, _rhs: &'a Scalar)\n        ensures\n            bytes_to_nat(&self.bytes) == (bytes_to_nat(&old(self).bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order(),\n    {\n        *self = &*self + _rhs;\n    }\n}",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_012().",
      "display_name": "from_bytes_as_nat_012",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_012().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn from_bytes_as_nat_012(bytes: &[u8; 32])\n    ensures\n        (load8_at_spec(bytes, 0) as u64 & mask51) + pow2(51) * ((load8_at_spec(bytes, 6) as u64\n            >> 3) & mask51) + pow2(102) * ((load8_at_spec(bytes, 12) as u64 >> 6) & mask51) == (\n        bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (bytes[2] * pow2(2 * 8)) + (bytes[3]\n            * pow2(3 * 8)) + (bytes[4] * pow2(4 * 8)) + (bytes[5] * pow2(5 * 8)) + (bytes[6] * pow2(\n            6 * 8,\n        )) + (bytes[7] * pow2(7 * 8)) + (bytes[8] * pow2(8 * 8)) + (bytes[9] * pow2(9 * 8)) + (\n        bytes[10] * pow2(10 * 8)) + (bytes[11] * pow2(11 * 8)) + (bytes[12] * pow2(12 * 8)) + (\n        bytes[13] * pow2(13 * 8)) + (bytes[14] * pow2(14 * 8)) + (bytes[15] * pow2(15 * 8)) + (\n        bytes[16] * pow2(16 * 8)) + (bytes[17] * pow2(17 * 8)) + (bytes[18] * pow2(18 * 8)) + ((\n        bytes[19] as nat % pow2(1)) * pow2((19 * 8) as nat)),\n{\n    assert((load8_at_spec(bytes, 0) as u64 & mask51) + pow2(51) * ((load8_at_spec(bytes, 6) as u64\n        >> 3) & mask51) == (bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (bytes[2] * pow2(\n        2 * 8,\n    )) + (bytes[3] * pow2(3 * 8)) + (bytes[4] * pow2(4 * 8)) + (bytes[5] * pow2(5 * 8)) + (bytes[6]\n        * pow2(6 * 8)) + (bytes[7] * pow2(7 * 8)) + (bytes[8] * pow2(8 * 8)) + (bytes[9] * pow2(\n        9 * 8,\n    )) + (bytes[10] * pow2(10 * 8)) + (bytes[11] * pow2(11 * 8)) + ((bytes[12] as nat % pow2(6))\n        * pow2((12 * 8) as nat))) by {\n        from_bytes_as_nat_01(bytes);\n    }\n\n    assert(((load8_at_spec(bytes, 12) as u64) >> 6) & mask51 == (bytes[12] as nat / pow2(6)) + (\n    bytes[13] * pow2((1 * 8 - 6) as nat)) + (bytes[14] * pow2((2 * 8 - 6) as nat)) + (bytes[15]\n        * pow2((3 * 8 - 6) as nat)) + (bytes[16] * pow2((4 * 8 - 6) as nat)) + (bytes[17] * pow2(\n        (5 * 8 - 6) as nat,\n    )) + (bytes[18] * pow2((6 * 8 - 6) as nat)) + ((bytes[19] as nat % pow2(1)) * pow2(\n        (7 * 8 - 6) as nat,\n    ))) by {\n        load8_limb2(bytes);\n    }\n\n    assert(pow2(102) * ((load8_at_spec(bytes, 12) as u64 >> 6) & mask51) == pow2(102) * (\n    bytes[12] as nat / pow2(6)) + pow2(102) * (bytes[13] * pow2((1 * 8 - 6) as nat)) + pow2(102) * (\n    bytes[14] * pow2((2 * 8 - 6) as nat)) + pow2(102) * (bytes[15] * pow2((3 * 8 - 6) as nat))\n        + pow2(102) * (bytes[16] * pow2((4 * 8 - 6) as nat)) + pow2(102) * (bytes[17] * pow2(\n        (5 * 8 - 6) as nat,\n    )) + pow2(102) * (bytes[18] * pow2((6 * 8 - 6) as nat)) + pow2(102) * ((bytes[19] as nat % pow2(\n        1,\n    )) * pow2((7 * 8 - 6) as nat))) by {\n        mul_8_terms(\n            pow2(102) as int,\n            (bytes[12] as nat / pow2(6)) as int,\n            (bytes[13] * pow2((1 * 8 - 6) as nat)) as int,\n            (bytes[14] * pow2((2 * 8 - 6) as nat)) as int,\n            (bytes[15] * pow2((3 * 8 - 6) as nat)) as int,\n            (bytes[16] * pow2((4 * 8 - 6) as nat)) as int,\n            (bytes[17] * pow2((5 * 8 - 6) as nat)) as int,\n            (bytes[18] * pow2((6 * 8 - 6) as nat)) as int,\n            ((bytes[19] as nat % pow2(1)) * pow2((7 * 8 - 6) as nat)) as int,\n        );\n    }\n\n    assert(((bytes[12] as nat % pow2(6)) * pow2((12 * 8) as nat)) + pow2(102) * (bytes[12] as nat\n        / pow2(6)) == bytes[12] * pow2(12 * 8)) by {\n        assemble_mod_div(bytes[12] as nat, 6, 12 * 8);\n    }\n\n    assert(pow2(102) * (bytes[13] * pow2((1 * 8 - 6) as nat)) + pow2(102) * (bytes[14] * pow2(\n        (2 * 8 - 6) as nat,\n    )) + pow2(102) * (bytes[15] * pow2((3 * 8 - 6) as nat)) + pow2(102) * (bytes[16] * pow2(\n        (4 * 8 - 6) as nat,\n    )) + pow2(102) * (bytes[17] * pow2((5 * 8 - 6) as nat)) + pow2(102) * (bytes[18] * pow2(\n        (6 * 8 - 6) as nat,\n    )) + pow2(102) * ((bytes[19] as nat % pow2(1)) * pow2((7 * 8 - 6) as nat)) == (bytes[13] * pow2(\n        13 * 8,\n    )) + (bytes[14] * pow2(14 * 8)) + (bytes[15] * pow2(15 * 8)) + (bytes[16] * pow2(16 * 8)) + (\n    bytes[17] * pow2(17 * 8)) + (bytes[18] * pow2(18 * 8)) + ((bytes[19] as nat % pow2(1)) * pow2(\n        (19 * 8) as nat,\n    ))) by {\n        assemble_pow_a_pow(bytes[13] as nat, 12, 1, 6);\n        assemble_pow_a_pow(bytes[14] as nat, 12, 2, 6);\n        assemble_pow_a_pow(bytes[15] as nat, 12, 3, 6);\n        assemble_pow_a_pow(bytes[16] as nat, 12, 4, 6);\n        assemble_pow_a_pow(bytes[17] as nat, 12, 5, 6);\n        assemble_pow_a_pow(bytes[18] as nat, 12, 6, 6);\n        assemble_pow_a_pow(bytes[19] as nat % pow2(1), 12, 7, 6);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "display_name": "lemma_boundary_byte_combines",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_boundary_byte_combines(\n    low_limb: u64,\n    high_limb: u64,\n    byte: u8,\n    low_shift: nat,\n    low_bits: nat,\n)\n    requires\n        low_limb < pow2(51),\n        high_limb < pow2(51),\n        low_bits < 8,\n        low_shift + low_bits == 51,  // Strengthened from <= to == (all call sites use equality)\n        byte == ((low_limb >> low_shift) | (high_limb << low_bits)) as u8,\n    ensures\n        byte as nat == (low_limb as nat / pow2(low_shift)) % pow2(low_bits) + (high_limb as nat\n            % pow2((8 - low_bits) as nat)) * pow2(low_bits),\n{\n    lemma2_to64();\n\n    assert(low_limb >> low_shift == low_limb as nat / pow2(low_shift)) by {\n        lemma_u64_shr_is_div(low_limb, low_shift as u64);\n    }\n\n    assert(pow2(51) == pow2(low_shift) * pow2(low_bits) == pow2(low_bits) * pow2(low_shift)) by {\n        lemma_pow2_adds(low_shift, low_bits);\n        lemma_mul_is_commutative(pow2(low_bits) as int, pow2(low_shift) as int);\n    }\n\n    assert(low_limb as nat / pow2(low_shift) < pow2(low_bits)) by {\n        assert(pow2(51) / pow2(low_shift) == pow2(low_bits)) by {\n            lemma_div_by_multiple(pow2(low_bits) as int, pow2(low_shift) as int);\n        }\n        assert(pow2(low_shift) > 0) by {\n            lemma_pow2_pos(low_shift);\n        }\n        lemma_div_by_multiple_is_strongly_ordered(\n            low_limb as int,\n            pow2(51) as int,\n            pow2(low_bits) as int,\n            pow2(low_shift) as int,\n        );\n    }\n\n    let a = low_limb >> low_shift;\n    let b = high_limb;\n\n    assert(b << low_bits == high_limb * pow2(low_bits)) by {\n        assert(b * pow2(low_bits) < u64::MAX) by {\n            assert(b * pow2(low_bits) < pow2(51 + 8)) by {\n                lemma_pow2_strictly_increases(low_bits, 8);\n                mul_lt(b as nat, pow2(51), pow2(low_bits), pow2(8));\n                lemma_pow2_adds(51, 8);\n            }\n            assert(pow2(59) <= u64::MAX) by {\n                pow2_le_max64(59);\n            }\n        }\n        lemma_u64_shl_is_mul(high_limb, low_bits as u64);\n    }\n\n    assert((a | b << low_bits) == a + (b << low_bits)) by {\n        assert(b <= (u64::MAX >> low_bits)) by {\n            assert(u64::MAX >> low_bits == u64::MAX as nat / pow2(low_bits)) by {\n                lemma_u64_shr_is_div(u64::MAX, low_bits as u64);\n            }\n            assert(u64::MAX as nat / pow2(low_bits) >= u64::MAX as nat / pow2(8)) by {\n                lemma_pow2_pos(low_bits);\n                lemma_pow2_strictly_increases(low_bits, 8);\n                lemma_div_is_ordered_by_denominator(\n                    u64::MAX as int,\n                    pow2(low_bits) as int,\n                    pow2(8) as int,\n                );\n            }\n            assert(u64::MAX / 256 >= pow2(51)) by {\n                lemma2_to64_rest();\n            }\n        }\n\n        assert(pow2(low_bits) == 1u64 << low_bits) by {\n            shift_is_pow2(low_bits);\n        }\n\n        assert((a | b << low_bits) == a + (b << low_bits)) by {\n            bit_or_is_plus(a, b, low_bits as u64);\n        }\n    }\n\n    assert((a | (b << low_bits)) as u8 == (a + (b * pow2(low_bits))) as nat % pow2(8)) by {\n        lemma_u8_cast_is_mod_256(a | (b << low_bits));\n    }\n\n    assert((a + (b * pow2(low_bits))) as nat % pow2(8) == a as nat % pow2(8) + (b as nat * pow2(\n        low_bits,\n    )) % pow2(8)) by {\n        sum_mod_decomposition(a as nat, b as nat, low_bits, 8);\n    }\n\n    assert((low_limb as nat / pow2(low_shift)) % pow2(8) == ((low_limb as nat) % pow2(\n        low_shift + 8,\n    )) / pow2(low_shift)) by {\n        mask_div2(low_limb as nat, low_shift, 8);\n    }\n\n    assert(((low_limb as nat) % pow2(low_shift + 8)) == low_limb as nat) by {\n        lemma_pow2_strictly_increases(\n            low_shift + low_bits  /* = 51 */\n            ,\n            low_shift + 8,\n        );\n        lemma_small_mod(low_limb as nat, pow2(low_shift + 8));\n    }\n\n    assert(low_limb as nat / pow2(low_shift) == (low_limb as nat / pow2(low_shift)) % pow2(\n        low_bits,\n    )) by {\n        lemma_small_mod(low_limb as nat / pow2(low_shift), pow2(low_bits));\n    }\n\n    assert((b as nat * pow2(low_bits)) % pow2(8) == (b as nat % pow2((8 - low_bits) as nat)) * pow2(\n        low_bits,\n    )) by {\n        mask_pow2(b as nat, low_bits, 8);\n    }\n\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 19
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#as_bytes().",
      "display_name": "as_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#as_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 CtOption#is_some().",
      "display_name": "is_some",
      "symbol": "rust-analyzer cargo subtle 2.6.1 CtOption#is_some().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_into().",
      "display_name": "choice_into",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_into().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//! [`Scalar::from_hash`], which allows an IUF API.\n//!\n#![cfg_attr(feature = \"digest\", doc = \"```\")]\n#![cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n//! # fn main() {\n//! use sha2::{Digest, Sha512};\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! // Hashing a single byte slice\n//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "display_name": "to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//! To create a [`Scalar`](struct.Scalar.html) from a supposedly canonical encoding, use\n//! [`Scalar::from_canonical_bytes`](struct.Scalar.html#method.from_canonical_bytes).\n//!\n//! This function does input validation, ensuring that the input bytes\n//! are the canonical encoding of a `Scalar`.\n//! If they are, we'll get\n//! `Some(Scalar)` in return:\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let one_as_bytes: [u8; 32] = Scalar::ONE.to_bytes();\n//! let a: Option<Scalar> = Scalar::from_canonical_bytes(one_as_bytes).into();\n//!\n//! assert!(a.is_some());\n//! ```\n//!\n//! However, if we give it bytes representing a scalar larger than \\\\( \\ell \\\\)\n//! (in this case, \\\\( \\ell + 2 \\\\)), we'll get `None` back:\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let l_plus_two_bytes: [u8; 32] = [\n//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Option<Scalar> = Scalar::from_canonical_bytes(l_plus_two_bytes).into();\n//!\n//! assert!(a.is_none());\n//! ```\n//!\n//! Another way to create a `Scalar` is by reducing a \\\\(256\\\\)-bit integer mod\n//! \\\\( \\ell \\\\), for which one may use the\n//! [`Scalar::from_bytes_mod_order`](struct.Scalar.html#method.from_bytes_mod_order)\n//! method.  In the case of the second example above, this would reduce the\n//! resultant scalar \\\\( \\mod \\ell \\\\), producing \\\\( 2 \\\\):\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let l_plus_two_bytes: [u8; 32] = [\n//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Scalar = Scalar::from_bytes_mod_order(l_plus_two_bytes);\n//!\n//! let two: Scalar = Scalar::ONE + Scalar::ONE;\n//!\n//! assert!(a == two);\n//! ```\n//!\n//! There is also a constructor that reduces a \\\\(512\\\\)-bit integer,\n//! [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! To construct a `Scalar` as the hash of some input data, use\n//! [`Scalar::hash_from_bytes`], which takes a buffer, or\n//! [`Scalar::from_hash`], which allows an IUF API.\n//!\n#![cfg_attr(feature = \"digest\", doc = \"```\")]\n#![cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n//! # fn main() {\n//! use sha2::{Digest, Sha512};\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! // Hashing a single byte slice\n//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }",
      "is_libsignal": false,
      "caller_count": 36,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#by_ref().",
      "display_name": "by_ref",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#by_ref().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "display_name": "choice_is_true",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//! All arithmetic on `Scalars` is done modulo \\\\( \\ell \\\\).\n//!\n//! # Constructing a scalar\n//!\n//! To create a [`Scalar`](struct.Scalar.html) from a supposedly canonical encoding, use\n//! [`Scalar::from_canonical_bytes`](struct.Scalar.html#method.from_canonical_bytes).\n//!\n//! This function does input validation, ensuring that the input bytes\n//! are the canonical encoding of a `Scalar`.\n//! If they are, we'll get\n//! `Some(Scalar)` in return:\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let one_as_bytes: [u8; 32] = Scalar::ONE.to_bytes();\n//! let a: Option<Scalar> = Scalar::from_canonical_bytes(one_as_bytes).into();\n//!\n//! assert!(a.is_some());\n//! ```\n//!\n//! However, if we give it bytes representing a scalar larger than \\\\( \\ell \\\\)\n//! (in this case, \\\\( \\ell + 2 \\\\)), we'll get `None` back:\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let l_plus_two_bytes: [u8; 32] = [\n//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Option<Scalar> = Scalar::from_canonical_bytes(l_plus_two_bytes).into();\n//!\n//! assert!(a.is_none());\n//! ```\n//!\n//! Another way to create a `Scalar` is by reducing a \\\\(256\\\\)-bit integer mod\n//! \\\\( \\ell \\\\), for which one may use the\n//! [`Scalar::from_bytes_mod_order`](struct.Scalar.html#method.from_bytes_mod_order)\n//! method.  In the case of the second example above, this would reduce the\n//! resultant scalar \\\\( \\mod \\ell \\\\), producing \\\\( 2 \\\\):\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let l_plus_two_bytes: [u8; 32] = [\n//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Scalar = Scalar::from_bytes_mod_order(l_plus_two_bytes);\n//!\n//! let two: Scalar = Scalar::ONE + Scalar::ONE;\n//!\n//! assert!(a == two);\n//! ```\n//!\n//! There is also a constructor that reduces a \\\\(512\\\\)-bit integer,\n//! [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! To construct a `Scalar` as the hash of some input data, use\n//! [`Scalar::hash_from_bytes`], which takes a buffer, or\n//! [`Scalar::from_hash`], which allows an IUF API.\n//!\n#![cfg_attr(feature = \"digest\", doc = \"```\")]\n#![cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n//! # fn main() {\n//! use sha2::{Digest, Sha512};\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! // Hashing a single byte slice\n//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }",
      "is_libsignal": false,
      "caller_count": 31,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 From#from().",
      "display_name": "from",
      "symbol": "rust-analyzer cargo subtle 2.6.1 From#from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb3_byte_contribution().",
      "display_name": "limb3_byte_contribution",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb3_byte_contribution().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "spec fn limb3_byte_contribution(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    // Byte 19 high 7 bits (limbs[3]'s bits 0-6)\n    ((limbs[3] as nat % pow2(7)) * 2) * pow2(19 * 8) + bytes[20] as nat * pow2(20 * 8)\n        + bytes[21] as nat * pow2(21 * 8) + bytes[22] as nat * pow2(22 * 8) + bytes[23] as nat\n        * pow2(23 * 8) + bytes[24] as nat * pow2(24 * 8)\n        +\n    // Byte 25 low 4 bits (limbs[3]'s bits 47-50)\n    ((limbs[3] as nat / pow2(47)) % pow2(4)) * pow2(25 * 8)\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#ConditionallySelectable#conditional_select().",
      "display_name": "conditional_select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#ConditionallySelectable#conditional_select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::conditional_select(&a.y_plus_x, &b.y_plus_x, choice),\n            y_minus_x: FieldElement::conditional_select(&a.y_minus_x, &b.y_minus_x, choice),\n            xy2d: FieldElement::conditional_select(&a.xy2d, &b.xy2d, choice),\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Neg#neg().",
      "display_name": "neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Neg#neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        let result = (&self).neg();\n        proof {\n            assume((scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0);\n        }\n        result\n    }/* <ORIGINAL CODE>",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat().",
      "display_name": "lemma_sum_equals_byte_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_sum_equals_byte_nat(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < pow2(51),\n        bytes_match_limbs_packing(limbs, bytes),\n    ensures\n        as_nat_32_u8(&bytes) == limb0_byte_contribution(limbs, bytes) + limb1_byte_contribution(\n            limbs,\n            bytes,\n        ) + limb2_byte_contribution(limbs, bytes) + limb3_byte_contribution(limbs, bytes)\n            + limb4_byte_contribution(limbs, bytes),\n{\n    lemma2_to64();\n\n    // Strategy: Show that the sum of contributions equals as_nat_32_u8(bytes)\n    // by proving that for boundary bytes, the split parts reconstruct the full byte.\n    //\n    // Boundary bytes:\n    // - Byte 6  = low 3 bits (limb0) + high 5 bits (limb1)\n    // - Byte 12 = low 6 bits (limb1) + high 2 bits (limb2)\n    // - Byte 19 = low 1 bit (limb2) + high 7 bits (limb3)\n    // - Byte 25 = low 4 bits (limb3) + high 4 bits (limb4)\n\n    // From bytes_match_limbs_packing, we know how bytes relate to limbs\n    // For each boundary byte, we need to prove it reconstructs correctly\n\n    // Define the boundary byte splits (bytes that span two limbs)\n    // Each boundary byte is split into a low part (from lower limb) and high part (from higher limb)\n    let byte6_low = ((limbs[0] as nat / pow2(48)) % 8) * pow2(6 * 8);\n    let byte6_high = ((limbs[1] as nat % pow2(5)) * 8) * pow2(6 * 8);\n\n    let byte12_low = ((limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(12 * 8);\n    let byte12_high = ((limbs[2] as nat % pow2(2)) * pow2(6)) * pow2(12 * 8);\n\n    let byte19_low = ((limbs[2] as nat / pow2(50)) % 2) * pow2(19 * 8);\n    let byte19_high = ((limbs[3] as nat % pow2(7)) * 2) * pow2(19 * 8);\n\n    let byte25_low = ((limbs[3] as nat / pow2(47)) % pow2(4)) * pow2(25 * 8);\n    let byte25_high = ((limbs[4] as nat % pow2(4)) * pow2(4)) * pow2(25 * 8);\n\n    // Prove each boundary byte reconstruction using lemma_boundary_byte_combines\n    // Then multiply both sides by pow2(byte_position * 8) and apply distributivity\n    // Byte 6: lemma_boundary_byte_combines proves bytes[6] == (limbs[0]/2^48)%8 + (limbs[1]%2^5)*8\n    // Multiply both sides by pow2(6*8): (a+b)*c = a*c + b*c by distributivity\n    //lemma_boundary_byte_combines(limbs[0], limbs[1], bytes[6], 48, 3);\n    assert(bytes[6] as nat == (limbs[0] as nat / pow2(48)) % 8 + (limbs[1] as nat % pow2(5)) * 8)\n        by {\n        lemma_boundary_byte_combines(limbs[0], limbs[1], bytes[6], 48, 3);\n    }\n    // Distributivity gives us: (a+b)*c == a*c + b*c\n    assert(bytes[6] as nat * pow2(6 * 8) == ((limbs[0] as nat / pow2(48)) % 8) * pow2(6 * 8) + ((\n    limbs[1] as nat % pow2(5)) * 8) * pow2(6 * 8)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(6 * 8) as int,\n            ((limbs[0] as nat / pow2(48)) % 8) as int,\n            ((limbs[1] as nat % pow2(5)) * 8) as int,\n        );\n    }\n    // Which exactly matches byte6_low + byte6_high by definition\n    assert(bytes[6] as nat * pow2(6 * 8) == byte6_low + byte6_high);\n\n    // Byte 12: lemma_boundary_byte_combines proves bytes[12] == (limbs[1]/2^45)%2^6 + (limbs[2]%2^2)*2^6\n    // Multiply both sides by pow2(12*8): (a+b)*c = a*c + b*c by distributivity\n    assert(bytes[12] as nat == (limbs[1] as nat / pow2(45)) % pow2(6) + (limbs[2] as nat % pow2(2))\n        * pow2(6)) by {\n        lemma_boundary_byte_combines(limbs[1], limbs[2], bytes[12], 45, 6);\n    }\n    // Distributivity gives us: (a+b)*c == a*c + b*c\n    assert(bytes[12] as nat * pow2(12 * 8) == ((limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(\n        12 * 8,\n    ) + ((limbs[2] as nat % pow2(2)) * pow2(6)) * pow2(12 * 8)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(12 * 8) as int,\n            ((limbs[1] as nat / pow2(45)) % pow2(6)) as int,\n            ((limbs[2] as nat % pow2(2)) * pow2(6)) as int,\n        );\n    }\n    // Which exactly matches byte12_low + byte12_high by definition\n    assert(bytes[12] as nat * pow2(12 * 8) == byte12_low + byte12_high);\n\n    // Byte 19: lemma_boundary_byte_combines proves bytes[19] == (limbs[2]/2^50)%2 + (limbs[3]%2^7)*2\n    // Multiply both sides by pow2(19*8): (a+b)*c = a*c + b*c by distributivity\n    assert(bytes[19] as nat == (limbs[2] as nat / pow2(50)) % 2 + (limbs[3] as nat % pow2(7)) * 2)\n        by {\n        lemma_boundary_byte_combines(limbs[2], limbs[3], bytes[19], 50, 1);\n    }\n    // Distributivity gives us: (a+b)*c == a*c + b*c\n    assert(bytes[19] as nat * pow2(19 * 8) == ((limbs[2] as nat / pow2(50)) % 2) * pow2(19 * 8) + ((\n    limbs[3] as nat % pow2(7)) * 2) * pow2(19 * 8)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(19 * 8) as int,\n            ((limbs[2] as nat / pow2(50)) % 2) as int,\n            ((limbs[3] as nat % pow2(7)) * 2) as int,\n        );\n    }\n    // Which exactly matches byte19_low + byte19_high by definition\n    assert(bytes[19] as nat * pow2(19 * 8) == byte19_low + byte19_high);\n\n    // Byte 25: lemma_boundary_byte_combines proves bytes[25] == (limbs[3]/2^47)%2^4 + (limbs[4]%2^4)*2^4\n    // Multiply both sides by pow2(25*8): (a+b)*c = a*c + b*c by distributivity\n    assert(bytes[25] as nat == (limbs[3] as nat / pow2(47)) % pow2(4) + (limbs[4] as nat % pow2(4))\n        * pow2(4)) by {\n        lemma_boundary_byte_combines(limbs[3], limbs[4], bytes[25], 47, 4);\n    }\n    // Distributivity gives us: (a+b)*c == a*c + b*c\n    assert(bytes[25] as nat * pow2(25 * 8) == ((limbs[3] as nat / pow2(47)) % pow2(4)) * pow2(\n        25 * 8,\n    ) + ((limbs[4] as nat % pow2(4)) * pow2(4)) * pow2(25 * 8)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(25 * 8) as int,\n            ((limbs[3] as nat / pow2(47)) % pow2(4)) as int,\n            ((limbs[4] as nat % pow2(4)) * pow2(4)) as int,\n        );\n    }\n    // Which exactly matches byte25_low + byte25_high by definition\n    assert(bytes[25] as nat * pow2(25 * 8) == byte25_low + byte25_high);\n\n    let after_split_25_pow2_first = (bytes[0] as nat) + (bytes[1] as nat) * pow2(1 * 8) + (\n    bytes[2] as nat) * pow2(2 * 8) + (bytes[3] as nat) * pow2(3 * 8) + (bytes[4] as nat) * pow2(\n        4 * 8,\n    ) + (bytes[5] as nat) * pow2(5 * 8) + byte6_low + byte6_high + (bytes[7] as nat) * pow2(7 * 8)\n        + (bytes[8] as nat) * pow2(8 * 8) + (bytes[9] as nat) * pow2(9 * 8) + (bytes[10] as nat)\n        * pow2(10 * 8) + (bytes[11] as nat) * pow2(11 * 8) + byte12_low + byte12_high + (\n    bytes[13] as nat) * pow2(13 * 8) + (bytes[14] as nat) * pow2(14 * 8) + (bytes[15] as nat)\n        * pow2(15 * 8) + (bytes[16] as nat) * pow2(16 * 8) + (bytes[17] as nat) * pow2(17 * 8) + (\n    bytes[18] as nat) * pow2(18 * 8) + byte19_low + byte19_high + (bytes[20] as nat) * pow2(20 * 8)\n        + (bytes[21] as nat) * pow2(21 * 8) + (bytes[22] as nat) * pow2(22 * 8) + (bytes[23] as nat)\n        * pow2(23 * 8) + (bytes[24] as nat) * pow2(24 * 8) + byte25_low + byte25_high + (\n    bytes[26] as nat) * pow2(26 * 8) + (bytes[27] as nat) * pow2(27 * 8) + (bytes[28] as nat)\n        * pow2(28 * 8) + (bytes[29] as nat) * pow2(29 * 8) + (bytes[30] as nat) * pow2(30 * 8) + (\n    bytes[31] as nat) * pow2(31 * 8);\n\n    assert(after_split_25_pow2_first == as_nat_32_u8(&bytes));\n\n    assert(bytes[0] as nat * pow2(0 * 8) == bytes[0] as nat * 1);\n    // The mathematical fact: after splitting boundary bytes, this equals the sum of limb contributions\n    assert(after_split_25_pow2_first == limb0_byte_contribution(limbs, bytes)\n        + limb1_byte_contribution(limbs, bytes) + limb2_byte_contribution(limbs, bytes)\n        + limb3_byte_contribution(limbs, bytes) + limb4_byte_contribution(limbs, bytes));\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n        self.0[0] = 1;\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/main().",
      "display_name": "main",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/main().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "fn main() {\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_from_le_bytes().",
      "display_name": "u128_from_le_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_from_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub fn u128_from_le_bytes(bytes: [u8; 16]) -> (x: u128)\n    ensures\n        x as nat == bytes_seq_to_nat(seq_from16(&bytes)),\n{\n    u128::from_le_bytes(bytes)\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb4_byte_contribution().",
      "display_name": "limb4_byte_contribution",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb4_byte_contribution().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "spec fn limb4_byte_contribution(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    // Byte 25 high 4 bits (limbs[4]'s bits 0-3)\n    ((limbs[4] as nat % pow2(4)) * pow2(4)) * pow2(25 * 8) + bytes[26] as nat * pow2(26 * 8)\n        + bytes[27] as nat * pow2(27 * 8) + bytes[28] as nat * pow2(28 * 8) + bytes[29] as nat\n        * pow2(29 * 8) + bytes[30] as nat * pow2(30 * 8) + bytes[31] as nat * pow2(31 * 8)\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        let coset = self.coset4();\n        write!(\n            f,\n            \"RistrettoPoint: coset \\n{:?}\\n{:?}\\n{:?}\\n{:?}\",\n            coset[0], coset[1], coset[2], coset[3]\n        )\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_l_equals_group_order().",
      "display_name": "lemma_l_equals_group_order",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_l_equals_group_order().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub(crate) proof fn lemma_l_equals_group_order()\n    ensures\n        to_nat(&constants::L.limbs) == group_order(),\n        seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order(),\n{\n    // First show that the subrange equals the full array\n    assert(constants::L.limbs@ == constants::L.limbs@.subrange(0, 5 as int));\n    assert(seq_u64_to_nat(constants::L.limbs@) == seq_u64_to_nat(\n        constants::L.limbs@.subrange(0, 5 as int),\n    ));\n    assert(to_nat(&constants::L.limbs) == seq_u64_to_nat(constants::L.limbs@));\n\n    assert(pow2(52) == 0x10000000000000) by {\n        lemma2_to64_rest();\n    };\n    lemma_pow2_adds(52, 52);\n    assert(pow2(104) == 0x100000000000000000000000000);\n    lemma_pow2_adds(104, 104);\n    assert(pow2(208) == 0x10000000000000000000000000000000000000000000000000000);\n    lemma_pow252();\n    lemma_five_limbs_equals_to_nat(&constants::L.limbs);\n    assert(five_limbs_to_nat_aux(constants::L.limbs) == group_order()) by (compute);\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn default() -> (result: EdwardsPoint)\n        ensures\n            is_identity(result),\n    {\n        EdwardsPoint::identity()\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/VartimeEdwardsPrecomputation#VartimePrecomputedMultiscalarMul#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/VartimeEdwardsPrecomputation#VartimePrecomputedMultiscalarMul#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self(crate::backend::VartimePrecomputedStraus::new(static_points))\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_two_factoring_51().",
      "display_name": "lemma_two_factoring_51",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_two_factoring_51().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/reduce_lemmas.rs",
      "file_name": "reduce_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "// Each component of spec_reduce is bounded.\n// The reason we _don't_ write\n// ensures forall |i: int| 0 <= i < 5 ==> spec_reduce(limbs)[i] < (1u64 << 52)\n// is that the solver treats `spec_reduce`` above as symbolic and does _not_ instantiate e.g.\n// ((limbs[4] & mask51) + (limbs[3] >> 51)) as u64 < (1u64 << 52)\npub proof fn lemma_boundaries(limbs: [u64; 5])\n    ensures\n        ((limbs[0] & mask51) + (limbs[4] >> 51) * 19) < (1u64 << 52),\n        ((limbs[1] & mask51) + (limbs[0] >> 51)) < (1u64 << 52),\n        ((limbs[2] & mask51) + (limbs[1] >> 51)) < (1u64 << 52),\n        ((limbs[3] & mask51) + (limbs[2] >> 51)) < (1u64 << 52),\n        ((limbs[4] & mask51) + (limbs[3] >> 51)) < (1u64 << 52),\n{\n    // \\A i. limbs[i] < 2^13\n    shifted_lt(limbs[0], 51);\n    shifted_lt(limbs[1], 51);\n    shifted_lt(limbs[2], 51);\n    shifted_lt(limbs[3], 51);\n    shifted_lt(limbs[4], 51);\n\n    // \\A i. limbs[i] & mask51 < 2^51\n    masked_lt_51(limbs[0]);\n    masked_lt_51(limbs[1]);\n    masked_lt_51(limbs[2]);\n    masked_lt_51(limbs[3]);\n    masked_lt_51(limbs[4]);\n\n    // Since 19 < 2^5 and (limbs[4] >> 51) < 2^13, their product is less than 2^18\n    assert((limbs[4] >> 51) * 19 < (1u64 << 18) as nat) by {\n        assert(19 < (1u64 << 5)) by (bit_vector);\n        shift_is_pow2(5);\n        shift_is_pow2(13);\n        shift_is_pow2(18);\n        lemma_pow2_adds(13, 5);\n        // If (limbs[4] >> 51) < 2^13 and 19 < 2^5 then their product is less than 2^18\n        mul_lt((limbs[4] >> 51) as nat, (1u64 << 13) as nat, 19nat, (1u64 << 5) as nat);\n    }\n\n    // The final values (limbs[i] += cX) are all bounded by 2^51 + eps, for eps \\in {2^18, 2^13}.\n    assert(((1u64 << 18)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n    assert(((1u64 << 13)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n\n    // In summary, they're all bounded by 2^52\n    // The solver can prove this automatically\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"CompletedPoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?},\\n\\tT: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z, &self.T\n        )\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat().",
      "display_name": "from_bytes_as_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "display_name": "lemma_as_bytes_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "        let mut words = [0u64;4];\n        for i in 0..4\n            invariant\n                0 <= i <= 4  // proof\n                ,\n        {\n            for j in 0..8\n                invariant\n                    0 <= j <= 8 && i < 4,\n            {\n                proof {\n                    assert(i < 4 && j < 8);\n                    assert((i as u64) * 8u64 < 32u64);\n                    let idx = (i as u64) * 8 + (j as u64);\n                    assert(idx < 32);\n                }\n                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);\n            }\n        }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 17
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_boundary_byte_combines_52().",
      "display_name": "lemma_boundary_byte_combines_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_boundary_byte_combines_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "proof fn lemma_boundary_byte_combines_52(\n    low_limb: u64,\n    high_limb: u64,\n    byte: u8,\n    low_shift: nat,\n    low_bits: nat,\n)\n    requires\n        low_limb < pow2(52),\n        high_limb < pow2(52),\n        low_bits < 8,\n        low_shift + low_bits == 52,\n        byte == ((low_limb >> low_shift) | (high_limb << low_bits)) as u8,\n    ensures\n        byte as nat == (low_limb as nat / pow2(low_shift)) % pow2(low_bits) + (high_limb as nat\n            % pow2((8 - low_bits) as nat)) * pow2(low_bits),\n{\n    // Proof following docs_22_oct/lemma_boundary_byte_combines_52_proof.md\n    lemma2_to64();\n\n    // Establish that pow2 values fit in u64\n    assert(pow2(low_shift) <= u64::MAX as nat) by {\n        lemma_pow2_strictly_increases(low_shift, 64);\n    }\n\n    assert(pow2(low_bits) <= u64::MAX as nat) by {\n        lemma_pow2_strictly_increases(low_bits, 64);\n    }\n\n    // === STEP 1: Convert bit operations to arithmetic ===\n    let low_part = low_limb >> low_shift;\n    let high_part = high_limb << low_bits;\n\n    // Prove high_part doesn't overflow: high_limb * 2^low_bits <= u64::MAX\n    assert(high_limb as nat * pow2(low_bits) <= u64::MAX as nat) by {\n        // Worst case: high_limb = 2^52 - 1, low_bits = 7\n        // Need: 2^52 * 2^7 = 2^59 <= 2^64 - 1 ✓\n        assert(pow2(52) * pow2(7) <= pow2(64) - 1) by {\n            lemma_pow2_adds(52, 7);\n            lemma_pow2_strictly_increases(59, 64);\n        }\n        if low_bits < 7 {\n            lemma_pow2_strictly_increases(low_bits, 7);\n        }\n        mul_le(high_limb as nat, (pow2(52) - 1) as nat, pow2(low_bits), pow2(7));\n    }\n\n    assert(high_part == high_limb * (pow2(low_bits) as u64)) by {\n        lemma_u64_shl_is_mul(high_limb, low_bits as u64);\n    }\n\n    // === STEP 2: Prove OR equals addition ===\n    // Need preconditions for bit_or_is_plus:\n    // 1) low_part < 1u64 << low_bits\n    // 2) high_limb <= u64::MAX >> low_bits\n\n    // Subproof 2.1: Bound low_part\n    assert((low_part as nat) < pow2(low_bits)) by {\n        // low_part = low_limb / 2^low_shift (by shr)\n        lemma_u64_shr_is_div(low_limb, low_shift as u64);\n\n        // low_limb / 2^low_shift < 2^52 / 2^low_shift = 2^(52 - low_shift)\n        // Since low_shift + low_bits = 52, we have 52 - low_shift = low_bits\n        lemma_pow2_adds(low_shift, (52 - low_shift) as nat);\n\n        // Apply: low_limb < 2^52 = 2^low_shift * 2^(52-low_shift)\n        // Therefore: low_limb / 2^low_shift < 2^(52-low_shift) = 2^low_bits\n        lemma_pow2_pos(low_shift);\n        lemma_div_strictly_bounded(\n            low_limb as int,\n            pow2(low_shift) as int,\n            pow2((52 - low_shift) as nat) as int,\n        );\n    }\n\n    assert(low_part < 1u64 << low_bits) by {\n        assert(1u64 << low_bits == (pow2(low_bits) as u64)) by {\n            shift_is_pow2(low_bits);\n        }\n    }\n\n    // Subproof 2.2: Bound high_limb for shift\n    assert(high_limb <= (u64::MAX >> low_bits)) by {\n        // We proved: high_limb * 2^low_bits <= u64::MAX\n        // Conclude: high_limb <= u64::MAX / 2^low_bits\n        lemma_pow2_pos(low_bits);\n        lemma_mul_le_implies_div_le(high_limb as nat, pow2(low_bits), u64::MAX as nat);\n\n        // u64::MAX / 2^low_bits = u64::MAX >> low_bits\n        lemma_u64_shr_is_div(u64::MAX, low_bits as u64);\n    }\n\n    // Apply bit_or_is_plus\n    assert(low_part | high_part == low_part + high_part) by {\n        bit_or_is_plus(low_part, high_limb, low_bits as u64);\n    }\n\n    // === STEP 3: Express combined value ===\n    let combined = low_part + high_part;\n\n    let a = (low_limb as nat) / pow2(low_shift);\n    let b = high_limb as nat;\n    let k = low_bits;\n\n    // Prove combined as nat == a + b * pow2(k)\n    assert(combined as nat == a + b * pow2(k)) by {\n        lemma_u64_shr_is_div(low_limb, low_shift as u64);\n        lemma_u64_shl_is_mul(high_limb, low_bits as u64);\n    }\n\n    // === STEP 4: Apply modular bit partitioning ===\n\n    // Verify precondition: (a % 2^k) + ((b % 2^(8-k)) * 2^k) < 256\n    assert((a % pow2(k)) + ((b % pow2((8 - k) as nat)) * pow2(k)) < 256) by {\n        // Since a < pow2(k): a % pow2(k) = a\n        assert(a % pow2(k) == a) by {\n            lemma_small_mod(a, pow2(k));\n        }\n\n        // Key fact: pow2(k) * pow2(8 - k) = 256\n        assert(pow2(k) * pow2((8 - k) as nat) == 256) by {\n            lemma_pow2_adds(k, (8 - k) as nat);\n        }\n\n        // Get upper bound on b % pow2(8-k)\n        assert((b % pow2((8 - k) as nat)) < pow2((8 - k) as nat)) by {\n            lemma_mod_bound(b as int, pow2((8 - k) as nat) as int);\n        }\n\n        // Arithmetic: a + (b % pow2(8-k)) * pow2(k) <= (pow2(k) - 1) + (pow2(8-k) - 1) * pow2(k)\n        //           = pow2(k) * pow2(8-k) - 1 = 256 - 1 = 255 < 256\n        assert((pow2(k) - 1) + (pow2((8 - k) as nat) - 1) * pow2(k) == pow2((8 - k) as nat) * pow2(\n            k,\n        ) - 1) by (nonlinear_arith);\n\n        assert(a + (b % pow2((8 - k) as nat)) * pow2(k) < 256) by (nonlinear_arith)\n            requires\n                a <= pow2(k) - 1,\n                (b % pow2((8 - k) as nat)) <= pow2((8 - k) as nat) - 1,\n                (pow2(k) - 1) + (pow2((8 - k) as nat) - 1) * pow2(k) == 255,\n        ;\n    }\n\n    lemma_modular_bit_partitioning(a, b, k, 8);\n\n    assert(a % pow2(k) == a) by {\n        lemma_small_mod(a, pow2(k));\n    }\n\n    // === STEP 5: Connect to byte value ===\n    // byte = combined as u8 means byte as nat = combined % 256\n    assert((combined as nat) % pow2(8) == (combined as u8)) by {\n        lemma_u8_cast_is_mod_256(combined as u64);\n    }\n\n    // We know: combined as nat = a + b * pow2(k)\n    // Apply modular bit partitioning: (a + b * 2^k) % 256 = a + (b % 2^(8-k)) * 2^k\n    // This gives us the desired result\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"AffineNielsPoint{{\\n\\ty_plus_x: {:?},\\n\\ty_minus_x: {:?},\\n\\txy2d: {:?}\\n}}\",\n            &self.y_plus_x, &self.y_minus_x, &self.xy2d\n        )\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#SubAssign#sub_assign().",
      "display_name": "sub_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#SubAssign#sub_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn sub_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) - _rhs;\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_seq_to_nat().",
      "display_name": "bytes_seq_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_seq_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//! assert!(a == two);\n//! ```\n//!\n//! There is also a constructor that reduces a \\\\(512\\\\)-bit integer,\n//! [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! To construct a `Scalar` as the hash of some input data, use\n//! [`Scalar::hash_from_bytes`], which takes a buffer, or\n//! [`Scalar::from_hash`], which allows an IUF API.\n//!\n#![cfg_attr(feature = \"digest\", doc = \"```\")]\n#![cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n//! # fn main() {\n//! use sha2::{Digest, Sha512};\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! // Hashing a single byte slice\n//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }",
      "is_libsignal": false,
      "caller_count": 9,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn default() -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == 0 as nat,\n    {\n        let result = Scalar::ZERO;\n        assume(scalar_to_nat(&result) == 0 as nat);\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "display_name": "pow_p58",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "    fn pow_p58(&self) -> (result: FieldElement)\n        ensures\n            field_element_as_nat(&result) == pow(\n                field_element_as_nat(self) as int,\n                (pow2(252) - 3) as nat,\n            ) % (p() as int),\n    {\n        // The bits of (p-5)/8 are 101111.....11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, _) = self.pow22501();  // 249..0\n        assume(false);\n        let t20 = t19.pow2k(2);  // 251..2\n        assume(false);\n        let t21 = self * &t20;  // 251..2,0\n\n        t21\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec_lemma().",
      "display_name": "plus_version_is_spec_lemma",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec_lemma().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn plus_version_is_spec_lemma(input: &[u8], i: usize, j: nat)\n    requires\n        1 <= j <= 7,\n    ensures\n        (input[i + j] as u64) << 8 * j == pow2(j * 8) * input[i + j],\n        input[i + j] * pow2(j * 8) <= u64::MAX,\n        pow2(8 * (j + 1)) - 1 <= pow2(64) - 1,\n        pow2(8) * pow2(8 * j) == pow2(8 * (j + 1)),\n{\n    assert(pow2(64) - 1 == u64::MAX) by {\n        lemma2_to64_rest();\n    }\n\n    assert(u8::MAX + 1 == pow2(8)) by {\n        lemma2_to64();\n    }\n\n    assert(pow2(8 * (j + 1)) - 1 <= pow2(64) - 1) by {\n        if (j < 7) {\n            lemma_pow2_strictly_increases(8 * (j + 1), 64);\n        }\n    }\n\n    lemma_pow2_adds(8, j * 8);\n\n    lemma_mul_inequality(input[i + j] as int, u8::MAX as int, pow2(j * 8) as int);\n\n    assert((input[i + j] as u64) * pow2(j * 8) <= u64::MAX) by {\n        assert(u8::MAX * pow2(j * 8) <= pow2(64) - 1) by {\n            assert(u8::MAX * pow2(j * 8) == (pow2(8) - 1) * pow2(j * 8) == pow2(8 * (j + 1)) - pow2(\n                j * 8,\n            )) by {\n                assert(pow2(8) >= 1) by {\n                    lemma2_to64();\n                }\n                lemma_mul_is_distributive_sub(pow2(8) as int, 1, pow2(j * 8) as int);\n            }\n            assert(pow2(j * 8) > 1) by {\n                lemma2_to64();  // pow2(0)\n                lemma_pow2_strictly_increases(0, j * 8)\n            }\n        }\n    }\n    lemma_u64_shl_is_mul((input[i + j] as u64), (j * 8) as u64);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_valid_radix_16().",
      "display_name": "is_valid_radix_16",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_valid_radix_16().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "#[cfg(feature = \"digest\")]\n#[allow(unused_imports)]\nuse digest::Digest;\n\nverus! {\n\n/*** <VERIFICATION NOTE> Focus on u64; removed all other backend types </VERIFICATION NOTE> ***/\ntype UnpackedScalar = backend::serial::u64::scalar::Scalar52;\n\n/// The `Scalar` struct holds an element of \\\\(\\mathbb Z / \\ell\\mathbb Z \\\\).\n#[allow(clippy::derived_hash_with_manual_eq)]\n#[derive(Copy, Clone, Hash)]\npub struct Scalar {\n    /// `bytes` is a little-endian byte encoding of an integer representing a scalar modulo the\n    /// group order.\n    ///\n    /// # Invariant #1\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255}\\\\). That is, the most\n    /// significant bit of `bytes[31]` is 0.\n    ///\n    /// This is required for `EdwardsPoint` variable- and fixed-base multiplication, because most\n    /// integers above 2^255 are unrepresentable in our radix-16 NAF (see [`Self::as_radix_16`]).\n    /// The invariant is also required because our `MontgomeryPoint` multiplication assumes the MSB\n    /// is 0 (see `MontgomeryPoint::mul`).\n    ///\n    /// # Invariant #2 (weak)\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255} - 19 \\\\), i.e., it represents\n    /// a canonical representative of an element of \\\\( \\mathbb Z / \\ell\\mathbb Z \\\\). This is\n    /// stronger than invariant #1. It also sometimes has to be broken.\n    ///\n    /// This invariant is deliberately broken in the implementation of `EdwardsPoint::{mul_clamped,\n    /// mul_base_clamped}`, `MontgomeryPoint::{mul_clamped, mul_base_clamped}`, and\n    /// `BasepointTable::mul_base_clamped`. This is not an issue though. As mentioned above,\n    /// scalar-point multiplication is defined for any choice of `bytes` that satisfies invariant\n    /// #1. Since clamping guarantees invariant #1 is satisfied, these operations are well defined.\n    ///\n    /// Note: Scalar-point mult is the _only_ thing you can do safely with an unreduced scalar.\n    /// Scalar-scalar addition and subtraction are NOT correct when using unreduced scalars.\n    /// Multiplication is correct, but this is only due to a quirk of our implementation, and not\n    /// guaranteed to hold in general in the future.\n    ///\n    /// Note: It is not possible to construct an unreduced `Scalar` from the public API unless the\n    /// `legacy_compatibility` is enabled (thus making `Scalar::from_bits` public). Thus, for all\n    /// public non-legacy uses, invariant #2\n    /// always holds.\n    ///\n    /* <VERIFICATION NOTE>\n    Changed from pub(crate) to pub\n    </VERIFICATION NOTE> */\n    pub bytes: [u8; 32],/* <ORIGINAL CODE>\n    pub(crate) bytes: [u8; 32],\n    </ORIGINAL CODE> */\n}\n\n// This is a dummy function that we call from signal\n// to test that verus functions in libsignal know\n// about verus functions in curve-dalek\npub open spec fn is_a_scalar(s: Scalar) -> bool {\n    true\n}\n\nimpl Scalar {\n    /// Construct a `Scalar` by reducing a 256-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    // VERIFICATION NOTE: VERIFIED\n    pub fn from_bytes_mod_order(bytes: [u8; 32]) -> (result: Scalar)\n        ensures\n    // Result is equivalent to input modulo the group order\n\n            bytes_to_nat(&result.bytes) % group_order() == bytes_to_nat(&bytes) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        // Temporarily allow s_unreduced.bytes > 2^255 ...\n        let s_unreduced = Scalar { bytes };\n\n        // Then reduce mod the group order and return the reduced representative.\n        let s = s_unreduced.reduce();\n        /*** <VERIFICATION NOTE> We omit debug asserts from verification  </VERIFICATION NOTE> ***/\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }\n\n    /// Construct a `Scalar` by reducing a 512-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    // VERIFICATION NOTE: VERIFIED\n    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == bytes_wide_to_nat(input) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }\n\n    /// Attempt to construct a `Scalar` from a canonical byte representation.\n    ///\n    /// # Return\n    ///\n    /// - `Some(s)`, where `s` is the `Scalar` corresponding to `bytes`,\n    ///   if `bytes` is a canonical byte representation modulo the group order \\\\( \\ell \\\\);\n    /// - `None` if `bytes` is not a canonical byte representation.\n    /*\n    <VERIFICATION NOTE>\n      - Refactored to use wrapper functions instead of trait functions for ct_eq and ct_option_new\n      - Has proof bypass\n    </VERIFICATION NOTE> */\n    pub fn from_canonical_bytes(bytes: [u8; 32]) -> (result: CtOption<Scalar>)\n        ensures\n            bytes_to_nat(&bytes) < group_order() ==> ct_option_has_value(result),\n            bytes_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result),\n            ct_option_has_value(result) ==> bytes_to_nat(&ct_option_value(result).bytes)\n                % group_order() == bytes_to_nat(&bytes) % group_order(),\n    {\n        /* <ORIGINAL CODE>\n          let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let high_byte_shifted = bytes[31] >> 7;\n        let high_bit_unset = ct_eq_u8(&high_byte_shifted, &0);\n        /* </MODIFIED CODE> */\n\n        let candidate = Scalar { bytes };\n        let is_canonical = candidate.is_canonical();\n\n        /* <ORIGINAL CODE>\n          CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n          </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let condition = choice_and(high_bit_unset, is_canonical);\n        let result = ct_option_new(candidate, condition);\n        /* </MODIFIED CODE> */\n\n        // VERIFICATION NOTE: PROOF BYPASS\n        assume(bytes_to_nat(&bytes) < group_order() ==> ct_option_has_value(result));\n        assume(bytes_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result));\n        assume(ct_option_has_value(result) ==> bytes_to_nat(&ct_option_value(result).bytes)\n            % group_order() == bytes_to_nat(&bytes) % group_order());\n\n        result\n    }\n\n    /// Construct a `Scalar` from the low 255 bits of a 256-bit integer. This breaks the invariant\n    /// that scalars are always reduced. Scalar-scalar arithmetic, i.e., addition, subtraction,\n    /// multiplication, **does not work** on scalars produced from this function. You may only use\n    /// the output of this function for `EdwardsPoint::mul`, `MontgomeryPoint::mul`, and\n    /// `EdwardsPoint::vartime_double_scalar_mul_basepoint`. **Do not use this function** unless\n    /// you absolutely have to.\n    /* <VERIFICATION NOTE>\n        -This is not in default features and not in our current target list ==> spec omitted for now\n    </VERIFICATION NOTE> */\n    #[cfg(feature = \"legacy_compatibility\")]\n    #[deprecated(\n        since = \"4.0.0\",\n        note = \"This constructor outputs scalars with undefined scalar-scalar arithmetic. See docs.\"\n    )]\n    pub const fn from_bits(bytes: [u8; 32]) -> Scalar {\n        let mut s = Scalar { bytes };\n        // Ensure invariant #1 holds. That is, make s < 2^255 by masking the high bit.\n        s.bytes[31] &= 0b0111_1111;\n\n        s\n    }\n}\n\nimpl Eq for Scalar {\n\n}\n\nimpl PartialEq for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS (problem with traits)\n    fn eq(&self, other: &Self) -> (result: bool)\n        ensures\n            result == (&self.bytes == &other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Choice::into\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let result = self.ct_eq(other).into();\n         </ORIGINAL CODE> */\n        let choice = self.ct_eq(other);\n        assert(choice_is_true(choice) == (self.bytes == other.bytes));\n        let result = choice_into(choice);\n        assert(result == choice_is_true(choice));\n        assert(result == (self.bytes == other.bytes));\n\n        // VERIFICATION NOTE: vstd's external trait specification check cannot be satisfied\n        // vstd expects obeys_eq_spec() and eq_spec() from PartialEqSpecImpl trait,\n        // but that trait is not publicly exported, so we bypass with assume(false)\n        // while maintaining our own custom ensures clause above\n        assume(false);\n\n        result\n    }\n}\n\nimpl ConstantTimeEq for Scalar {\n    fn ct_eq(&self, other: &Self) -> (result: Choice)\n        ensures\n            choice_is_true(result) == (self.bytes == other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Verus compatibility instead of direct subtle call\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.bytes.ct_eq(&other.bytes)\n         </ORIGINAL CODE> */\n        ct_eq_bytes32(&self.bytes, &other.bytes)\n    }\n}\n\nimpl Index<usize> for Scalar {\n    type Output = u8;\n\n    /// Index the bytes of the representative for this `Scalar`.  Mutation is not permitted.\n    fn index(&self, _index: usize) -> (result: &u8)\n        requires\n            _index < 32,\n        ensures\n            result == &self.bytes[_index as int],\n    {\n        &(self.bytes[_index])\n    }\n}\n\nimpl Debug for Scalar {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar{{\\n\\tbytes: {:?},\\n}}\", &self.bytes)\n    }\n}\n\nimpl<'a> MulAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    fn mul_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n            is_canonical_scalar(self),\n    {\n        /* <ORIGINAL CODE>\n         *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n        /* <VERIFICATION NOTE>\n         In the modified code, we store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&old(self).bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        *self = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&self.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n    }\n}\n\ndefine_mul_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_mul_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn mul_req(self, rhs: &Scalar) -> bool {\n        true  // No preconditions\n\n    }\n\n    open spec fn mul_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'b> Mul<&'b Scalar> for &Scalar {\n    type Output = Scalar;\n\n    // VERIFICATION NOTE: VERIFIED\n    fn mul(self, _rhs: &'b Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n    {\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n            * bytes_to_nat(&_rhs.bytes)) % group_order());\n        /* </MODIFIED CODE> */\n        /* <ORIGINAL CODE>\n         let result = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n\n        result\n    }\n}\n\ndefine_mul_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_add_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn add_req(self, rhs: &Scalar) -> bool {\n        true  // No preconditions yet\n\n    }\n\n    open spec fn add_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'a> Add<&'a Scalar> for &Scalar {\n    type Output = Scalar;\n\n    /* <VERIFICATION NOTE>\n    PROOF BYPASS; may need to add preconditions to spec\n    </VERIFICATION NOTE> */\n    #[allow(non_snake_case)]\n    fn add(self, _rhs: &'a Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(&_rhs.bytes))\n                % group_order(),\n    {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::add requires inputs < group_order()\n        // By Scalar invariant #2, scalars should be canonical\n        // However, we cannot add requires clauses to trait implementations,\n        // so we assume this property holds\n        proof {\n            assume(to_nat(&self_unpacked.limbs) < group_order());\n            assume(to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::add(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) == (to_nat(&self_unpacked.limbs) + to_nat(\n                &rhs_unpacked.limbs,\n            )) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) == to_nat(&result_unpacked.limbs));\n            assert(bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }\n}\n\ndefine_add_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> AddAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    #[allow(clippy::op_ref)]\n    fn add_assign(&mut self, _rhs: &'a Scalar)\n        ensures\n            bytes_to_nat(&self.bytes) == (bytes_to_nat(&old(self).bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order(),\n    {\n        *self = &*self + _rhs;\n    }\n}\n\ndefine_add_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_sub_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn sub_req(self, rhs: &Scalar) -> bool {\n        is_canonical_scalar(self) && is_canonical_scalar(rhs)\n    }\n\n    open spec fn sub_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'b> Sub<&'b Scalar> for &Scalar {\n    type Output = Scalar;\n\n    // VERIFICATION NOTE: PROOF BYPASS (problems with traits and preconditions)\n    // PRECONDITION is_canonical_scalar(self) && is_canonical_scalar(_rhs)\n    #[allow(non_snake_case)]\n    fn sub(self, _rhs: &'b Scalar) -> (result:\n        Scalar)/* VERIFICATION NOTE: preconditions are added to the SpecImpl above\n    requires\n      is_canonical_scalar(self),\n      is_canonical_scalar(_rhs),\n    */\n\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        /* <ORIGINAL CODE>\n         UnpackedScalar::sub(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::sub requires: -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()\n        proof {\n            assume(-group_order() <= to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs));\n            assume(to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::sub(&self_unpacked, &rhs_unpacked);\n        proof {\n            // Postconditions from sub - need to strengthen, review connections\n            assume(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                - to_nat(&rhs_unpacked.limbs)) % (group_order() as int));\n            assume(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int));\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }\n}\n\ndefine_sub_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> SubAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    #[allow(clippy::op_ref)]\n    fn sub_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        *self = &*self - _rhs;\n    }\n}\n\ndefine_sub_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &Scalar {\n    open spec fn obeys_neg_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn neg_req(self) -> bool {\n        true  // No preconditions - scalars are canonical by invariant\n\n    }\n\n    open spec fn neg_spec(self) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl Neg for &Scalar {\n    type Output = Scalar;\n\n    #[allow(non_snake_case)]\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        /* <ORIGINAL CODE>\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        proof {\n            // Preconditions for mul_internal and sub\n            assume(limbs_bounded(&constants::R));\n            assume(limbs_bounded(&UnpackedScalar::ZERO));\n        }\n\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n\n        proof {\n            assume(limbs_bounded(&self_mod_l));\n            // sub requires: -group_order() <= 0 - to_nat(&self_mod_l.limbs) < group_order()\n            assume(-group_order() <= to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(\n                &self_mod_l.limbs,\n            ));\n            assume(to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(&self_mod_l.limbs) < group_order());\n        }\n\n        let result = UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack();\n        proof {\n            // TODO: Prove that -self + self == 0 (mod group_order)\n            assume((scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0);\n        }\n\n        /* </MODIFIED CODE> */\n        result\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for Scalar {\n    open spec fn obeys_neg_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn neg_req(self) -> bool {\n        true  // No specific preconditions - scalars are canonical by invariant\n\n    }\n\n    open spec fn neg_spec(self) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl Neg for Scalar {\n    type Output = Scalar;\n\n    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        let result = (&self).neg();\n        proof {\n            assume((scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0);\n        }\n        result\n    }/* <ORIGINAL CODE>\n    fn neg(self) -> Scalar {\n        -&self\n    }\n    </ORIGINAL CODE> */\n\n}\n\nimpl ConditionallySelectable for Scalar {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> (Self) {\n        let mut bytes = [0u8;32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            /* <VERIFICATION NOTE>\n            Use wrapper function for Verus compatibility instead of direct subtle call\n            </VERIFICATION NOTE> */\n            /* <ORIGINAL CODE>\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n            </ORIGINAL CODE> */\n            /* <MODIFIED CODE> */\n            bytes[i] = select_u8(&a.bytes[i], &b.bytes[i], choice);\n            /* </MODIFIED CODE> */\n        }\n        Scalar { bytes }\n    }\n}\n\n/* <VERIFICATION NOTE>\n Trait implementations for Product and Sum declared as external_body since they use iterators which are not supported by Verus.\n</VERIFICATION NOTE> */\n\nimpl<T> Product<T> for Scalar where T: Borrow<Scalar> {\n    /* <ORIGINAL CODE>\n    fn product<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ONE, |acc, item| acc * item.borrow())\n    }\n    </ORIGINAL CODE> */\n    /* <VERIFICATION NOTE>\n     Added verifier::external_body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    /* <MODIFIED CODE> - FOR EVENTUAL VERIFICATION*/\n    fn product<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified product_of_slice function\n        Scalar::product_of_slice(&scalars)\n    }  /* </MODIFIED CODE> */\n\n}\n\nimpl<T> Sum<T> for Scalar where T: Borrow<Scalar> {\n    #[verifier::external_body]\n    fn sum<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }/* <MODIFIED CODE> - if needed in for verification in the future\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified sum_of_slice function\n        Scalar::sum_of_slice(&scalars)\n    }\n     </MODIFIED CODE> */\n\n}\n\nimpl Default for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn default() -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == 0 as nat,\n    {\n        let result = Scalar::ZERO;\n        assume(scalar_to_nat(&result) == 0 as nat);\n        result\n    }\n}\n\nimpl From<u8> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn from(x: u8) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        let mut s_bytes = [0u8;32];\n        s_bytes[0] = x;\n\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u16> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u16) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u16_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u32> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u32) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u32_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        let result = Scalar { bytes: s_bytes };\n        /* </MODIFIED CODE> */\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u64> for Scalar {\n    /// Construct a scalar from the given `u64`.\n    ///\n    /// # Inputs\n    ///\n    /// An `u64` to convert to a `Scalar`.\n    ///\n    /// # Returns\n    ///\n    /// A `Scalar` corresponding to the input `u64`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let fourtytwo = Scalar::from(42u64);\n    /// let six = Scalar::from(6u64);\n    /// let seven = Scalar::from(7u64);\n    ///\n    /// assert!(fourtytwo == six * seven);\n    /// ```\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u64) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u64_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u128> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u128) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u128_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for Scalar {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self) {\n        self.bytes.zeroize();\n    }\n}\n\nimpl Scalar {\n    /// The scalar \\\\( 0 \\\\).\n    // pub const ZERO: Self = Self { bytes: [0u8; 32] };\n    /* <VERIFICATION NOTE>\n    Changed to explicit initialization\n    </VERIFICATION NOTE> */\n    /* <ORIGINAL CODE>\n    pub const ZERO: Self = Self { bytes: [0u8; 32] };\n    </ORIGINAL CODE> */\n    pub const ZERO: Scalar = Scalar {\n        bytes: [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n        ],\n    };\n\n    /// The scalar \\\\( 1 \\\\).\n    pub const ONE: Self = Self {\n        bytes: [\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n        ],\n    };\n\n    /* <VERIFICATION NOTE>\n     Verification of random method postponed - requires rand_core feature to be enabled.\n    </VERIFICATION NOTE> */\n    #[cfg(any(test, feature = \"rand_core\"))]\n    /// Return a `Scalar` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `CryptoRngCore`\n    ///   (i.e. `CryptoRng` + `RngCore`) interface.\n    ///\n    /// # Returns\n    ///\n    /// A random scalar within \\\\(\\mathbb{Z} / \\ell\\mathbb{Z}\\\\).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # fn main() {\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// use rand_core::OsRng;\n    ///\n    /// let mut csprng = OsRng;\n    /// let a: Scalar = Scalar::random(&mut csprng);\n    /// # }\n    /* <VERIFICATION NOTE>\n     No verifier::external_body annotation but it is NOT verified\n    </VERIFICATION NOTE> */\n    pub fn random<R: CryptoRngCore + ?Sized>(rng: &mut R) -> (result: Self)\n        ensures\n            is_random_scalar(&result),\n            is_canonical_scalar(&result),\n    {\n        let mut scalar_bytes = [0u8;64];\n        rng.fill_bytes(&mut scalar_bytes);\n        Scalar::from_bytes_mod_order_wide(&scalar_bytes)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Hash a slice of bytes into a scalar using a specified hash function.\n    ///\n    /// This function hashes the input using the specified `Digest` type and then reduces\n    /// the result modulo the group order to produce a scalar.\n    ///\n    /// Convenience wrapper around `from_hash`.\n    ///\n    /// # Example\n    ///\n    #[cfg_attr(feature = \"digest\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// use sha2::Sha512;\n    /// # fn main() {\n    /// let msg = \"To really appreciate architecture, you may even need to commit a murder\";\n    /// let s = Scalar::hash_from_bytes::<Sha512>(msg.as_bytes());\n    /// # }\n    /// ```\n    /* <VERIFICATION NOTE>\n     Marked as external_body due to complexity of Digest trait.\n     For Verus verification, use hash_from_bytes_verus instead.\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    pub fn hash_from_bytes<D>(input: &[u8]) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64> + Default,\n\n        ensures\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        Scalar::from_hash(hash)\n    }\n\n    /// Verus-compatible version of hash_from_bytes that uses SHA-512.\n    ///\n    /// This function is designed for Verus verification and directly computes\n    /// a SHA-512 hash. For regular code with generic hash functions, use `hash_from_bytes` instead.\n    ///\n    /// # Inputs\n    ///\n    /// * `input`: a byte slice to hash\n    ///\n    /// # Returns\n    ///\n    /// A scalar reduced modulo the group order\n    pub fn hash_from_bytes_verus(input: &[u8]) -> (result: Scalar)\n        ensures\n            is_random_bytes(input) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        use crate::core_assumes as assumes;\n        let hash_bytes: [u8; 64] = assumes::sha512_hash_bytes(input);\n        Scalar::from_hash_verus(hash_bytes)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Construct a scalar from a 64-byte (512-bit) hash output.\n    ///\n    /// This reduces the hash output modulo the group order.\n    /// Typically used after calling `finalize()` on a SHA-512 hasher.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// use sha2::{Digest, Sha512};\n    ///\n    /// # fn main() {\n    /// let mut h = Sha512::new();\n    /// h.update(b\"To really appreciate architecture, you may even need to commit a murder.\");\n    /// h.update(b\"While the programs used for The Manhattan Transcripts are of the most extreme\");\n    /// h.update(b\"nature, they also parallel the most common formula plot: the archetype of\");\n    /// h.update(b\"murder. Other phantasms were occasionally used to underline the fact that\");\n    /// h.update(b\"perhaps all architecture, rather than being about functional standards, is\");\n    /// h.update(b\"about love and death.\");\n    ///\n    /// let hash_bytes: [u8; 64] = h.finalize().into();\n    /// let s = Scalar::from_hash(hash_bytes);\n    ///\n    /// println!(\"{:?}\", s.to_bytes());\n    /// assert_eq!(\n    ///     s.to_bytes(),\n    ///     [  21,  88, 208, 252,  63, 122, 210, 152,\n    ///       154,  38,  15,  23,  16, 167,  80, 150,\n    ///       192, 221,  77, 226,  62,  25, 224, 148,\n    ///       239,  48, 176,  10, 185,  69, 168,  11, ],\n    /// );\n    /// # }\n    /// ```\n    /* <VERIFICATION NOTE>\n     Marked as external_body due to GenericArray having private fields.\n     For Verus verification, see from_hash_verus below.\n    </VERIFICATION NOTE> */\n    #[cfg(feature = \"digest\")]\n    #[verifier::external_body]\n    pub fn from_hash<D>(hash: D) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64>,\n\n        ensures\n    //is_random_digest(&hash) ==> is_random_scalar(&result),\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut output = [0u8;64];\n        output.copy_from_slice(hash.finalize().as_slice());\n        Scalar::from_bytes_mod_order_wide(&output)\n    }\n\n    /// Verus-compatible version of from_hash that takes pre-finalized hash bytes.\n    ///\n    /// This function is designed for Verus verification and takes a byte array directly\n    /// instead of a generic Digest type. For regular code, use `from_hash` instead.\n    ///\n    /// # Inputs\n    ///\n    /// * `hash_bytes`: a 64-byte array representing the output of a hash function\n    ///\n    /// # Returns\n    ///\n    /// A scalar reduced modulo the group order\n    pub fn from_hash_verus(hash_bytes: [u8; 64]) -> (result: Scalar)\n        ensures\n            is_random_bytes(&hash_bytes) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        let result = Scalar::from_bytes_mod_order_wide(&hash_bytes);\n        assume(false);\n        result\n    }\n\n    /// Convert this `Scalar` to its underlying sequence of bytes.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.to_bytes() == [0u8; 32]);\n    /// ```\n    pub const fn to_bytes(&self) -> (result: [u8; 32])\n        ensures\n            result == self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        self.bytes\n    }\n\n    /// View the little-endian byte encoding of the integer representing this Scalar.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.as_bytes() == &[0u8; 32]);\n    /// ```\n    pub const fn as_bytes(&self) -> (result: &[u8; 32])\n        ensures\n            result == &self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        &self.bytes\n    }\n}\n\nimpl Scalar {\n    /// Given a nonzero `Scalar`, compute its multiplicative inverse.\n    ///\n    /// # Warning\n    ///\n    /// `self` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Returns\n    ///\n    /// The multiplicative inverse of the this `Scalar`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // x = 2238329342913194256032495932344128051776374960164957527413114840482143558222\n    /// let X: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x4e, 0x5a, 0xb4, 0x34, 0x5d, 0x47, 0x08, 0x84,\n    ///         0x59, 0x13, 0xb4, 0x64, 0x1b, 0xc2, 0x7d, 0x52,\n    ///         0x52, 0xa5, 0x85, 0x10, 0x1b, 0xcc, 0x42, 0x44,\n    ///         0xd4, 0x49, 0xf4, 0xa8, 0x79, 0xd9, 0xf2, 0x04,\n    ///     ]);\n    /// // 1/x = 6859937278830797291664592131120606308688036382723378951768035303146619657244\n    /// let XINV: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x1c, 0xdc, 0x17, 0xfc, 0xe0, 0xe9, 0xa5, 0xbb,\n    ///         0xd9, 0x24, 0x7e, 0x56, 0xbb, 0x01, 0x63, 0x47,\n    ///         0xbb, 0xba, 0x31, 0xed, 0xd5, 0xa9, 0xbb, 0x96,\n    ///         0xd5, 0x0b, 0xcd, 0x7a, 0x3f, 0x96, 0x2a, 0x0f,\n    ///     ]);\n    ///\n    /// let inv_X: Scalar = X.invert();\n    /// assert!(XINV == inv_X);\n    /// let should_be_one: Scalar = &inv_X * &X;\n    /// assert!(should_be_one == Scalar::ONE);\n    /// ```\n    // VERIFICATION NOTE: VERIFIED\n    pub fn invert(&self) -> (result: Scalar)\n        requires\n            is_canonical_scalar(self),\n        ensures\n    // Result is the multiplicative inverse: result * self ≡ 1 (mod group_order)\n\n            (scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1,\n            is_canonical_scalar(\n                &result,\n            ),\n    // VERIFICATION NOTE: is this true and/or necessary?\n    // Result is canonical\n    // scalar_to_nat(&result) < group_order(),\n    // result.bytes[31] <= 127,\n\n    {\n        let unpacked = self.unpack();\n        let inv_unpacked = unpacked.invert();\n        let result = inv_unpacked.pack();\n        assert((scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1);\n        assume(is_canonical_scalar(&result));\n        result\n    }\n\n    /// Given a slice of nonzero (possibly secret) `Scalar`s,\n    /// compute their inverses in a batch.\n    ///\n    /// # Return\n    ///\n    /// Each element of `inputs` is replaced by its inverse.\n    ///\n    /// The product of all inverses is returned.\n    ///\n    /// # Warning\n    ///\n    /// All input `Scalars` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// # fn main() {\n    /// let mut scalars = [\n    ///     Scalar::from(3u64),\n    ///     Scalar::from(5u64),\n    ///     Scalar::from(7u64),\n    ///     Scalar::from(11u64),\n    /// ];\n    ///\n    /// let allinv = Scalar::batch_invert(&mut scalars);\n    ///\n    /// assert_eq!(allinv, Scalar::from(3*5*7*11u64).invert());\n    /// assert_eq!(scalars[0], Scalar::from(3u64).invert());\n    /// assert_eq!(scalars[1], Scalar::from(5u64).invert());\n    /// assert_eq!(scalars[2], Scalar::from(7u64).invert());\n    /// assert_eq!(scalars[3], Scalar::from(11u64).invert());\n    /// # }\n    /// ```\n    #[cfg(feature = \"alloc\")]\n    // Theo: Verus doesn't like the zeroize in this function. I think the long-term\n    // solution is to use assume_specification to tell Verus what zeroize does.\n    // In the short-term, I've just told verus to ignore the body.\n    // (SB update: alternative is to exclude just the zeroize call, as below)\n    pub fn batch_invert(inputs: &mut [Scalar]) -> (result:\n        Scalar)/* <VERIFICATION NOTE>\n     Refactored for Verus: Index loops instead of iterators, manual Vec construction, ..\n    </VERIFICATION NOTE> */\n\n        ensures\n    // Result is the modular inverse of the product of all original inputs\n\n            is_inverse_of_nat(&result, product_of_scalars(old(inputs)@)),\n            // Each input is replaced with its inverse\n            forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ),\n    {\n        // This code is essentially identical to the FieldElement\n        // implementation, and is documented there.  Unfortunately,\n        // it's not easy to write it generically, since here we want\n        // to use `UnpackedScalar`s internally, and `Scalar`s\n        // externally, but there's no corresponding distinction for\n        // field elements.\n        let n = inputs.len();\n        let one_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(limbs_bounded(&one_unpacked));\n        }\n\n        let one: UnpackedScalar = one_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&one));\n        }\n\n        /* <VERIFICATION NOTE>\n         Build vec manually instead of vec![one; n] for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let mut scratch = vec![one; n];\n         </ORIGINAL CODE> */\n        let mut scratch = Vec::new();\n        for _ in 0..n {\n            scratch.push(one);\n        }\n\n        // Keep an accumulator of all of the previous products\n        let acc_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(scratch.len() == n);\n            assume(limbs_bounded(&acc_unpacked));\n        }\n\n        let mut acc = acc_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        /* <VERIFICATION NOTE>\n         Rewritten with index loop instead of .zip() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         for (input, scratch) in inputs.iter_mut().zip(scratch.iter_mut()) {\n             *scratch = acc;\n        //     // Avoid unnecessary Montgomery multiplication in second pass by\n        //     // keeping inputs in Montgomery form\n             let tmp = input.unpack().as_montgomery();\n             *input = tmp.pack();\n             acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n         }\n        </ORIGINAL CODE> */\n        for i in 0..n\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                limbs_bounded(&acc),\n        {\n            scratch[i] = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = input_unpacked.as_montgomery();\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n\n            proof {\n                assume(limbs_bounded(&acc));\n            }\n        }\n\n        proof {\n            // Assert that all scratch elements have bounded limbs\n            assume(forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]));\n        }\n\n        // acc is nonzero iff all inputs are nonzero\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert!(acc.pack() != Scalar::ZERO);\n\n        // Compute the inverse of all products\n        // ORIGINAL CODE: acc = acc.montgomery_invert().from_montgomery();\n        acc = acc.montgomery_invert();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        acc = acc.from_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // We need to return the product of all inverses later\n        let ret = acc.pack();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        /* <VERIFICATION NOTE>\n         Manual reverse loop instead of .rev() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.iter().rev()) {\n             let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n             *input = UnpackedScalar::montgomery_mul(&acc, scratch).pack();\n             acc = tmp;\n         }\n        </ORIGINAL CODE> */\n        let mut i: usize = n;\n        while i > 0\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                i <= n,\n                limbs_bounded(&acc),\n                forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]),\n            decreases i,\n        {\n            i -= 1;\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input_unpacked);\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = UnpackedScalar::montgomery_mul(&acc, &scratch[i]).pack();\n            acc = tmp;\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        #[cfg(not(verus_keep_ghost))]\n        Zeroize::zeroize(&mut scratch);\n\n        proof {\n            // Assume the postconditions\n            assume(is_inverse_of_nat(&ret, product_of_scalars(old(inputs)@)));\n            assume(forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ));\n        }\n\n        ret\n    }\n}\n\n#[cfg(feature = \"serde\")]\nuse serde::de::Visitor;\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[cfg(feature = \"serde\")]\n/// Visitor for deserializing a Scalar from a sequence of 32 bytes.\n///\n/* VERIFICATION NOTE:\n- We don't cover serde feature yet\n- The ScalarVisitor struct is defined at module level rather than inside the\n`Deserialize::deserialize` since Verus doesn't support nested types\n</VERIFICATION NOTE> */\nstruct ScalarVisitor;\n\n#[cfg(feature = \"serde\")]\nimpl<'de> Visitor<'de> for ScalarVisitor {\n    type Value = Scalar;\n\n    #[verifier::external_body]\n    fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        {\n            formatter.write_str(\n                \"a sequence of 32 bytes whose little-endian interpretation is less than the \\\n                        basepoint order ℓ\",\n            )\n        }\n    }\n\n    #[verifier::external_body]\n    fn visit_seq<A>(self, mut seq: A) -> Result<Scalar, A::Error> where\n        A: serde::de::SeqAccess<'de>,\n     {\n        let mut bytes = [0u8;32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            bytes[i] = seq.next_element()?.ok_or_else(\n                || serde::de::Error::invalid_length(i, &\"expected 32 bytes\"),\n            )?;\n        }\n        Option::from(Scalar::from_canonical_bytes(bytes)).ok_or_else(\n            || serde::de::Error::custom(\"scalar was not canonically encoded\"),\n        )\n    }\n}\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl Serialize for Scalar {\n    #[verifier::external_body]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl<'de> Deserialize<'de> for Scalar {\n    #[verifier::external_body]\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error> where D: Deserializer<'de> {\n        /* VERIFICATION NOTE:\n        Originally struct ScalarVisitor defined here, but moved up to the top of the file\n        </VERIFICATION NOTE> */\n        deserializer.deserialize_tuple(32, ScalarVisitor)\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_base().",
      "display_name": "load8_limb_base",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_base().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn load8_limb_base(input: &[u8], i: usize, k: u64)\n    requires\n        i + 7 < input.len(),\n        k < 64,\n    ensures\n        0 < pow2(51) <= u64::MAX,\n        load8_at_spec(input, i) <= u64::MAX,\n        ((load8_at_spec(input, i) as u64) >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64),\n{\n    assert(0 < pow2(51) <= u64::MAX) by {\n        lemma_pow2_pos(51);\n        pow2_le_max64(51);\n    }\n\n    assert(0 < pow2(k as nat) <= u64::MAX) by {\n        lemma_pow2_pos(k as nat);\n        pow2_le_max64(k as nat);\n    }\n\n    let p51 = pow2(51) as u64;\n    let pk = pow2(k as nat) as u64;\n\n    assert(mask51 == low_bits_mask(51)) by {\n        l51_bit_mask_lt();\n    }\n\n    assert(load8_at_spec(input, i) <= u64::MAX) by {\n        load8_at_spec_fits_u64(input, i);\n    }\n\n    assert((load8_at_spec(input, i) as u64 >> k) & (low_bits_mask(51) as u64) == (((input[i + 0]\n        * pow2(0 * 8)) as u64) / pk) % p51 + (((input[i + 1] * pow2(1 * 8)) as u64) / pk) % p51 + ((\n    (input[i + 2] * pow2(2 * 8)) as u64) / pk) % p51 + (((input[i + 3] * pow2(3 * 8)) as u64) / pk)\n        % p51 + (((input[i + 4] * pow2(4 * 8)) as u64) / pk) % p51 + (((input[i + 5] * pow2(\n        5 * 8,\n    )) as u64) / pk) % p51 + (((input[i + 6] * pow2(6 * 8)) as u64) / pk) % p51 + (((input[i + 7]\n        * pow2(7 * 8)) as u64) / pk) % p51) by {\n        load8_shift_mod(input, i, k, 51);\n    }\n\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#ConditionallySelectable#conditional_select().",
      "display_name": "conditional_select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#ConditionallySelectable#conditional_select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::conditional_select(&a.Y_plus_X, &b.Y_plus_X, choice),\n            Y_minus_X: FieldElement::conditional_select(&a.Y_minus_X, &b.Y_minus_X, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T2d: FieldElement::conditional_select(&a.T2d, &b.T2d, choice),\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/to_le_bytes().",
      "display_name": "to_le_bytes",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/to_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#skip().",
      "display_name": "skip",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#skip().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core map/adapters/iter/Map#Iterator#next().",
      "display_name": "next",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core map/adapters/iter/Map#Iterator#next().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
      "relative_path": "src/backend/serial/scalar_mul/pippenger.rs",
      "file_name": "pippenger.rs",
      "parent_folder": "scalar_mul",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_mul_sub().",
      "display_name": "lemma_mul_sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_mul_sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_square_internal_correct().",
      "display_name": "lemma_square_internal_correct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_square_internal_correct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_square_internal_correct(a: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        z[0] == (a[0] * a[0]),\n        z[1] == (a[0] * a[1]) * 2,\n        z[2] == (a[0] * a[2]) * 2 + (a[1] * a[1]),\n        z[3] == (a[0] * a[3]) * 2 + (a[1] * a[2]) * 2,\n        z[4] == (a[0] * a[4]) * 2 + (a[1] * a[3]) * 2 + (a[2] * a[2]),\n        z[5] == (a[1] * a[4]) * 2 + (a[2] * a[3]) * 2,\n        z[6] == (a[2] * a[4]) * 2 + (a[3] * a[3]),\n        z[7] == (a[3] * a[4]) * 2,\n        z[8] == (a[4] * a[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(a),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*a) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/lemma_as_nat_sub().",
      "display_name": "lemma_as_nat_sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/lemma_as_nat_sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs",
      "file_name": "as_nat_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_as_nat_sub(a: [u64; 5], b: [u64; 5])\n    requires\n        forall|i: int| 0 <= i < 5 ==> b[i] <= a[i],\n    ensures\n        as_nat(\n            [\n                (a[0] - b[0]) as u64,\n                (a[1] - b[1]) as u64,\n                (a[2] - b[2]) as u64,\n                (a[3] - b[3]) as u64,\n                (a[4] - b[4]) as u64,\n            ],\n        ) == as_nat(a) - as_nat(b),\n{\n    let c: [u64; 5] = [\n        (a[0] - b[0]) as u64,\n        (a[1] - b[1]) as u64,\n        (a[2] - b[2]) as u64,\n        (a[3] - b[3]) as u64,\n        (a[4] - b[4]) as u64,\n    ];\n    // distribute pow2\n    assert(as_nat(c) == (a[0] - b[0]) + pow2(51) * a[1] - pow2(51) * b[1] + pow2(102) * a[2] - pow2(\n        102,\n    ) * b[2] + pow2(153) * a[3] - pow2(153) * b[3] + pow2(204) * a[4] - pow2(204) * b[4]) by {\n        lemma_mul_is_distributive_sub(pow2(1 * 51) as int, a[1] as int, b[1] as int);\n        lemma_mul_is_distributive_sub(pow2(2 * 51) as int, a[2] as int, b[2] as int);\n        lemma_mul_is_distributive_sub(pow2(3 * 51) as int, a[3] as int, b[3] as int);\n        lemma_mul_is_distributive_sub(pow2(4 * 51) as int, a[4] as int, b[4] as int);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#to_bytes().",
      "display_name": "to_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#to_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub const fn to_bytes(&self) -> (result: [u8; 32])\n        ensures\n            result == self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        self.bytes\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod_lemma().",
      "display_name": "load8_shift_mod_lemma",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod_lemma().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn load8_shift_mod_lemma(\n    s_jplus1: u64,\n    s_j: u64,\n    a_jplus1: u64,\n    x: u8,\n    j: nat,\n    s: nat,\n    t: nat,\n)\n    requires\n        s_j < pow2(j * 8),\n        s_j + x * pow2(j * 8) <= u64::MAX,\n        a_jplus1 == (x * pow2(j * 8)) as u64,\n        s_jplus1 == s_j + a_jplus1,\n        s_jplus1 / (pow2(s) as u64) == s_j / (pow2(s) as u64) + a_jplus1 / (pow2(s) as u64),\n        0 <= j <= 7,\n        s < 64,\n        t < 64,\n        0 < pow2(s) <= u64::MAX,\n        0 < pow2(t) <= u64::MAX,\n    ensures\n        (s_jplus1 / (pow2(s) as u64)) % (pow2(t) as u64) == (s_j / (pow2(s) as u64)) % (pow2(\n            t,\n        ) as u64) + (a_jplus1 / (pow2(s) as u64)) % (pow2(t) as u64),\n{\n    let ps64 = (pow2(s) as u64);\n    let pt64 = (pow2(t) as u64);\n\n    assert((s_jplus1 / ps64) % pt64 == (s_j / ps64) % pt64 + (a_jplus1 / ps64) % pt64) by {\n        if (s <= j * 8) {\n            assert(pow2(s) <= pow2(j * 8)) by {\n                if (s < j * 8) {\n                    lemma_pow2_strictly_increases(s, j * 8);\n                }\n            }\n            assert(x * pow2(s) <= a_jplus1) by {\n                lemma_mul_inequality(pow2(s) as int, pow2(j * 8) as int, x as int);\n            }\n            assert(s_j + x * pow2(s) <= s_j + a_jplus1 <= u64::MAX);\n\n            let d = (8 * j - s) as nat;\n\n            assert(s_j / ps64 < pow2(d) && a_jplus1 / ps64 == x * pow2(d) && s_j / ps64 + x * pow2(\n                d,\n            ) <= u64::MAX) by {\n                div_pow2_preserves_decomposition(s_j, x as u64, j * 8, s);\n            }\n\n            assert((s_j / ps64 + x * pow2(d)) as u64 % pt64 == (s_j / ps64) % pt64 + (x * pow2(\n                d,\n            )) as u64 % pt64 == (s_j / ps64) % pt64 + (a_jplus1 / ps64) % pt64) by {\n                lemma_bitops_lifted(s_j / ps64, x as u64, d, t);\n            }\n        } else {\n            // s > j * 8\n            assert(pow2(j * 8) < pow2(s)) by {\n                lemma_pow2_strictly_increases(j * 8, s);\n            }\n            assert(s_j / ps64 == 0) by {\n                lemma_basic_div(s_j as int, ps64 as int);\n            }\n\n            assert(0u64 % pt64 == 0) by {\n                lemma_small_mod(0, pow2(t));\n            }\n        }\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_sub_multiples_vanish().",
      "display_name": "lemma_mod_sub_multiples_vanish",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_sub_multiples_vanish().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shifted_lt().",
      "display_name": "shifted_lt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shifted_lt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/reduce_lemmas.rs",
      "file_name": "reduce_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "        assert(pow2(254) < pow2(255) - 38) by {\n            assert(38 < pow2(6));  // known\n            assert(pow2(255) - 38 > pow2(255) - pow2(6) == pow2(254) + pow2(254) - pow2(6)) by {\n                lemma_pow2_plus_one(254);\n            }\n            assert(pow2(254) - pow2(6) > 0) by {\n                lemma_pow2_strictly_increases(6, 254);\n            }\n        }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn zeroize(&mut self) {\n        self.Y_plus_X.zeroize();\n        self.Y_minus_X.zeroize();\n        self.Z.zeroize();\n        self.T2d.zeroize();\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_0123().",
      "display_name": "from_bytes_as_nat_0123",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_0123().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn from_bytes_as_nat_0123(bytes: &[u8; 32])\n    ensures\n        (load8_at_spec(bytes, 0) as u64 & mask51) + pow2(51) * ((load8_at_spec(bytes, 6) as u64\n            >> 3) & mask51) + pow2(102) * ((load8_at_spec(bytes, 12) as u64 >> 6) & mask51) + pow2(\n            153,\n        ) * ((load8_at_spec(bytes, 19) as u64 >> 1) & mask51) == (bytes[0] * pow2(0 * 8)) + (\n        bytes[1] * pow2(1 * 8)) + (bytes[2] * pow2(2 * 8)) + (bytes[3] * pow2(3 * 8)) + (bytes[4]\n            * pow2(4 * 8)) + (bytes[5] * pow2(5 * 8)) + (bytes[6] * pow2(6 * 8)) + (bytes[7] * pow2(\n            7 * 8,\n        )) + (bytes[8] * pow2(8 * 8)) + (bytes[9] * pow2(9 * 8)) + (bytes[10] * pow2(10 * 8)) + (\n        bytes[11] * pow2(11 * 8)) + (bytes[12] * pow2(12 * 8)) + (bytes[13] * pow2(13 * 8)) + (\n        bytes[14] * pow2(14 * 8)) + (bytes[15] * pow2(15 * 8)) + (bytes[16] * pow2(16 * 8)) + (\n        bytes[17] * pow2(17 * 8)) + (bytes[18] * pow2(18 * 8)) + (bytes[19] * pow2(19 * 8)) + (\n        bytes[20] * pow2(20 * 8)) + (bytes[21] * pow2(21 * 8)) + (bytes[22] * pow2(22 * 8)) + (\n        bytes[23] * pow2(23 * 8)) + (bytes[24] * pow2(24 * 8)) + ((bytes[25] as nat % pow2(4))\n            * pow2((25 * 8) as nat)),\n{\n    assert((load8_at_spec(bytes, 0) as u64 & mask51) + pow2(51) * ((load8_at_spec(bytes, 6) as u64\n        >> 3) & mask51) + pow2(102) * ((load8_at_spec(bytes, 12) as u64 >> 6) & mask51) == (bytes[0]\n        * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (bytes[2] * pow2(2 * 8)) + (bytes[3] * pow2(\n        3 * 8,\n    )) + (bytes[4] * pow2(4 * 8)) + (bytes[5] * pow2(5 * 8)) + (bytes[6] * pow2(6 * 8)) + (bytes[7]\n        * pow2(7 * 8)) + (bytes[8] * pow2(8 * 8)) + (bytes[9] * pow2(9 * 8)) + (bytes[10] * pow2(\n        10 * 8,\n    )) + (bytes[11] * pow2(11 * 8)) + (bytes[12] * pow2(12 * 8)) + (bytes[13] * pow2(13 * 8)) + (\n    bytes[14] * pow2(14 * 8)) + (bytes[15] * pow2(15 * 8)) + (bytes[16] * pow2(16 * 8)) + (bytes[17]\n        * pow2(17 * 8)) + (bytes[18] * pow2(18 * 8)) + ((bytes[19] as nat % pow2(1)) * pow2(\n        (19 * 8) as nat,\n    ))) by {\n        from_bytes_as_nat_012(bytes);\n    }\n\n    assert(((load8_at_spec(bytes, 19) as u64) >> 1) & mask51 == (bytes[19] as nat / pow2(1)) + (\n    bytes[20] * pow2((1 * 8 - 1) as nat)) + (bytes[21] * pow2((2 * 8 - 1) as nat)) + (bytes[22]\n        * pow2((3 * 8 - 1) as nat)) + (bytes[23] * pow2((4 * 8 - 1) as nat)) + (bytes[24] * pow2(\n        (5 * 8 - 1) as nat,\n    )) + ((bytes[25] as nat % pow2(4)) * pow2((6 * 8 - 1) as nat))) by {\n        load8_limb3(bytes);\n    }\n\n    assert(pow2(153) * (((load8_at_spec(bytes, 19) as u64) >> 1) & mask51) == pow2(153) * (\n    bytes[19] as nat / pow2(1)) + pow2(153) * (bytes[20] * pow2((1 * 8 - 1) as nat)) + pow2(153) * (\n    bytes[21] * pow2((2 * 8 - 1) as nat)) + pow2(153) * (bytes[22] * pow2((3 * 8 - 1) as nat))\n        + pow2(153) * (bytes[23] * pow2((4 * 8 - 1) as nat)) + pow2(153) * (bytes[24] * pow2(\n        (5 * 8 - 1) as nat,\n    )) + pow2(153) * ((bytes[25] as nat % pow2(4)) * pow2((6 * 8 - 1) as nat))) by {\n        mul_7_terms(\n            pow2(153) as int,\n            (bytes[19] as nat / pow2(1)) as int,\n            (bytes[20] * pow2((1 * 8 - 1) as nat)) as int,\n            (bytes[21] * pow2((2 * 8 - 1) as nat)) as int,\n            (bytes[22] * pow2((3 * 8 - 1) as nat)) as int,\n            (bytes[23] * pow2((4 * 8 - 1) as nat)) as int,\n            (bytes[24] * pow2((5 * 8 - 1) as nat)) as int,\n            ((bytes[25] as nat % pow2(4)) * pow2((6 * 8 - 1) as nat)) as int,\n        );\n    }\n\n    assert(((bytes[19] as nat % pow2(1)) * pow2((19 * 8) as nat)) + pow2(153) * (bytes[19] as nat\n        / pow2(1)) == bytes[19] * pow2(19 * 8)) by { assemble_mod_div(bytes[19] as nat, 1, 19 * 8) }\n\n    assert(pow2(153) * (bytes[20] * pow2((1 * 8 - 1) as nat)) + pow2(153) * (bytes[21] * pow2(\n        (2 * 8 - 1) as nat,\n    )) + pow2(153) * (bytes[22] * pow2((3 * 8 - 1) as nat)) + pow2(153) * (bytes[23] * pow2(\n        (4 * 8 - 1) as nat,\n    )) + pow2(153) * (bytes[24] * pow2((5 * 8 - 1) as nat)) + pow2(153) * ((bytes[25] as nat % pow2(\n        4,\n    )) * pow2((6 * 8 - 1) as nat)) == (bytes[20] * pow2(20 * 8)) + (bytes[21] * pow2(21 * 8)) + (\n    bytes[22] * pow2(22 * 8)) + (bytes[23] * pow2(23 * 8)) + (bytes[24] * pow2(24 * 8)) + ((\n    bytes[25] as nat % pow2(4)) * pow2((25 * 8) as nat))) by {\n        assemble_pow_a_pow(bytes[20] as nat, 19, 1, 1);\n        assemble_pow_a_pow(bytes[21] as nat, 19, 2, 1);\n        assemble_pow_a_pow(bytes[22] as nat, 19, 3, 1);\n        assemble_pow_a_pow(bytes[23] as nat, 19, 4, 1);\n        assemble_pow_a_pow(bytes[24] as nat, 19, 5, 1);\n        assemble_pow_a_pow(bytes[25] as nat % pow2(4), 19, 6, 1);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn identity() -> MontgomeryPoint {\n        MontgomeryPoint([0u8; 32])\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#MultiscalarMul#multiscalar_mul().",
      "display_name": "multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#MultiscalarMul#multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> RistrettoPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<RistrettoPoint>,\n    {\n        let extended_points = points.into_iter().map(|P| P.borrow().0);\n        RistrettoPoint(EdwardsPoint::multiscalar_mul(scalars, extended_points))\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConstantTimeEq#ct_eq().",
      "display_name": "ct_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConstantTimeEq#ct_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn ct_eq(&self, other: &Self) -> (result: Choice)\n        ensures\n            choice_is_true(result) == (self.bytes == other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Verus compatibility instead of direct subtle call\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.bytes.ct_eq(&other.bytes)\n         </ORIGINAL CODE> */\n        ct_eq_bytes32(&self.bytes, &other.bytes)\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/lemma_m().",
      "display_name": "lemma_m",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/lemma_m().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "        (a[4] as u128) * ((19 * a[3]) as u128) < 19 * (bound * bound),\n        // c3\n        (a[4] as u128) * ((19 * a[4]) as u128) < 19 * (bound * bound),\n        (a[0] as u128) * (a[3] as u128) < (bound * bound),\n        (a[1] as u128) * (a[2] as u128) < (bound * bound),\n        // c4\n        (a[2] as u128) * (a[2] as u128) < (bound * bound),\n        (a[0] as u128) * (a[4] as u128) < (bound * bound),\n        (a[1] as u128) * (a[3] as u128) < (bound * bound),\n{\n    let bound19 = (19 * bound) as u64;\n\n    let a3_19 = (19 * a[3]) as u64;\n    let a4_19 = (19 * a[4]) as u64;\n\n    assert(bound * (19 * bound) == 19 * (bound * bound)) by {\n        lemma_mul_is_associative(19, bound as int, bound as int);\n    }\n\n    // c0\n    lemma_m(a[0], a[0], bound, bound);\n    lemma_m(a[1], a4_19, bound, bound19);\n    lemma_m(a[2], a3_19, bound, bound19);\n\n    // c1\n    lemma_m(a[3], a3_19, bound, bound19);\n    lemma_m(a[0], a[1], bound, bound);\n    lemma_m(a[2], a4_19, bound, bound19);\n\n    // c2\n    lemma_m(a[1], a[1], bound, bound);\n    lemma_m(a[0], a[2], bound, bound);\n    lemma_m(a[4], a3_19, bound, bound19);\n\n    // c3\n    lemma_m(a[4], a4_19, bound, bound19);\n    lemma_m(a[0], a[3], bound, bound);\n    lemma_m(a[1], a[2], bound, bound);\n\n    // c4\n    lemma_m(a[2], a[2], bound, bound);\n    lemma_m(a[0], a[4], bound, bound);\n    lemma_m(a[1], a[3], bound, bound);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_direct().",
      "display_name": "lemma_radix51_telescoping_direct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_direct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_radix51_telescoping_direct(\n    limbs: [u64; 5],\n    q0: int,\n    q1: int,\n    q2: int,\n    q3: int,\n    q4: int,\n    r0: int,\n    r1: int,\n    r2: int,\n    r3: int,\n    r4: int,\n)\n    requires\n        limbs[0] as int + 19 == q0 * pow2(51) as int + r0,\n        limbs[1] as int + q0 == q1 * pow2(51) as int + r1,\n        limbs[2] as int + q1 == q2 * pow2(51) as int + r2,\n        limbs[3] as int + q2 == q3 * pow2(51) as int + r3,\n        limbs[4] as int + q3 == q4 * pow2(51) as int + r4,\n        0 <= r0 < pow2(51) as int,\n        0 <= r1 < pow2(51) as int,\n        0 <= r2 < pow2(51) as int,\n        0 <= r3 < pow2(51) as int,\n        0 <= r4 < pow2(51) as int,\n    ensures\n        q4 == (as_nat(limbs) as int + 19) / pow2(255) as int,\n{\n    // Establish power-of-2 relationships: 2^51 * 2^k = 2^(51+k)\n    lemma_pow2_pos(51);\n    lemma_pow2_adds(51, 51);\n    lemma_pow2_adds(51, 102);\n    lemma_pow2_adds(51, 153);\n    lemma_pow2_adds(51, 204);\n\n    // Step 1: Express value = as_nat(limbs) + 19 in radix-51 form\n    let value = limbs[0] as int + limbs[1] as int * pow2(51) as int + limbs[2] as int * pow2(\n        102,\n    ) as int + limbs[3] as int * pow2(153) as int + limbs[4] as int * pow2(204) as int + 19;\n\n    assert(as_nat(limbs) == (limbs[0] as nat) + pow2(51) * (limbs[1] as nat) + pow2(102) * (\n    limbs[2] as nat) + pow2(153) * (limbs[3] as nat) + pow2(204) * (limbs[4] as nat));\n\n    assert((limbs[0] as nat) + pow2(51) * (limbs[1] as nat) + pow2(102) * (limbs[2] as nat) + pow2(\n        153,\n    ) * (limbs[3] as nat) + pow2(204) * (limbs[4] as nat) == limbs[0] as nat + (limbs[1] as nat)\n        * pow2(51) + (limbs[2] as nat) * pow2(102) + (limbs[3] as nat) * pow2(153) + (\n    limbs[4] as nat) * pow2(204)) by {\n        lemma_mul_is_commutative(pow2(51) as int, limbs[1] as int);\n        lemma_mul_is_commutative(pow2(102) as int, limbs[2] as int);\n        lemma_mul_is_commutative(pow2(153) as int, limbs[3] as int);\n        lemma_mul_is_commutative(pow2(204) as int, limbs[4] as int);\n    }\n\n    // Step 2: Solve for each limb using the division theorem equations\n\n    // Step 3: Expand limbs[i] * 2^(51*i) using distributivity\n    assert((q1 * pow2(51) as int + r1 - q0) * pow2(51) as int == q1 * pow2(51) as int * pow2(\n        51,\n    ) as int + r1 * pow2(51) as int - q0 * pow2(51) as int) by {\n        lemma_mul_is_distributive_sub_other_way(pow2(51) as int, q1 * pow2(51) as int + r1, q0);\n        lemma_mul_is_distributive_add_other_way(pow2(51) as int, q1 * pow2(51) as int, r1);\n    }\n\n    assert((q2 * pow2(51) as int + r2 - q1) * pow2(102) as int == q2 * pow2(51) as int * pow2(\n        102,\n    ) as int + r2 * pow2(102) as int - q1 * pow2(102) as int) by {\n        lemma_mul_is_distributive_sub_other_way(pow2(102) as int, q2 * pow2(51) as int + r2, q1);\n        lemma_mul_is_distributive_add_other_way(pow2(102) as int, q2 * pow2(51) as int, r2);\n    }\n\n    assert((q3 * pow2(51) as int + r3 - q2) * pow2(153) as int == q3 * pow2(51) as int * pow2(\n        153,\n    ) as int + r3 * pow2(153) as int - q2 * pow2(153) as int) by {\n        lemma_mul_is_distributive_sub_other_way(pow2(153) as int, q3 * pow2(51) as int + r3, q2);\n        lemma_mul_is_distributive_add_other_way(pow2(153) as int, q3 * pow2(51) as int, r3);\n    }\n\n    assert((q4 * pow2(51) as int + r4 - q3) * pow2(204) as int == q4 * pow2(51) as int * pow2(\n        204,\n    ) as int + r4 * pow2(204) as int - q3 * pow2(204) as int) by {\n        lemma_mul_is_distributive_sub_other_way(pow2(204) as int, q4 * pow2(51) as int + r4, q3);\n        lemma_mul_is_distributive_add_other_way(pow2(204) as int, q4 * pow2(51) as int, r4);\n    }\n\n    // Step 4: Define remainder and observe telescoping\n    // When we substitute and expand, intermediate q_i terms cancel, leaving only q4 and remainders\n    let remainder = r0 + r1 * pow2(51) as int + r2 * pow2(102) as int + r3 * pow2(153) as int + r4\n        * pow2(204) as int;\n\n    assert(limbs[0] as int + limbs[1] as int * pow2(51) as int + limbs[2] as int * pow2(102) as int\n        + limbs[3] as int * pow2(153) as int + limbs[4] as int * pow2(204) as int + 19 == (q0\n        * pow2(51) as int + r0 - 19) + (q1 * pow2(51) as int + r1 - q0) * pow2(51) as int + (q2\n        * pow2(51) as int + r2 - q1) * pow2(102) as int + (q3 * pow2(51) as int + r3 - q2) * pow2(\n        153,\n    ) as int + (q4 * pow2(51) as int + r4 - q3) * pow2(204) as int + 19);\n\n    // After algebraic simplification (intermediate terms cancel), we get: value = q4 * 2^255 + remainder\n    lemma_radix51_telescoping_expansion(q0, q1, q2, q3, q4, r0, r1, r2, r3, r4);\n\n    assert(q4 * pow2(51) as int * pow2(204) as int == q4 * pow2(255) as int) by {\n        lemma_mul_is_associative(q4, pow2(51) as int, pow2(204) as int);\n    }\n\n    // Step 5: Apply uniqueness of division to conclude q4 = value / 2^255\n    lemma_radix51_remainder_bound(r0, r1, r2, r3, r4);\n    lemma_pow2_pos(255);\n    lemma_fundamental_div_mod(value, pow2(255) as int);\n    lemma_div_multiples_vanish_fancy(q4, remainder, pow2(255) as int);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 12
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "display_name": "reduce",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn reduce(mut limbs: [u64; 5]) -> (r: FieldElement51)\n        ensures\n            r.limbs == spec_reduce(limbs),\n            forall|i: int| 0 <= i < 5 ==> r.limbs[i] < (1u64 << 52),\n            (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (r.limbs =~= limbs),\n            as_nat(r.limbs) == as_nat(limbs) - p() * (limbs[4] >> 51),\n            as_nat(r.limbs) % p() == as_nat(limbs) % p(),\n            as_nat(r.limbs) < 2 * p(),\n    {\n        proof {\n            lemma_boundaries(limbs);\n            lemma_reduce(limbs);\n            lemma_reduce_bound_2p(limbs);\n        }\n\n        // Since the input limbs are bounded by 2^64, the biggest\n        // carry-out is bounded by 2^13.\n        //\n        // The biggest carry-in is c4 * 19, resulting in\n        //\n        // 2^51 + 19*2^13 < 2^51.0000000001\n        //\n        // Because we don't need to canonicalize, only to reduce the\n        // limb sizes, it's OK to do a \"weak reduction\", where we\n        // compute the carry-outs in parallel.\n\n        let c0 = limbs[0] >> 51;\n        let c1 = limbs[1] >> 51;\n        let c2 = limbs[2] >> 51;\n        let c3 = limbs[3] >> 51;\n        let c4 = limbs[4] >> 51;\n\n        limbs[0] &= LOW_51_BIT_MASK;\n        limbs[1] &= LOW_51_BIT_MASK;\n        limbs[2] &= LOW_51_BIT_MASK;\n        limbs[3] &= LOW_51_BIT_MASK;\n        limbs[4] &= LOW_51_BIT_MASK;\n\n        limbs[0] += c4 * 19;\n        limbs[1] += c0;\n        limbs[2] += c1;\n        limbs[3] += c2;\n        limbs[4] += c3;\n\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51 { limbs }\n    }",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_decomposition().",
      "display_name": "shl_decomposition",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_decomposition().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn shl_decomposition(v: u64, a: nat, b: nat)\n    requires\n        (a + b) < 64,\n        v * pow2(a + b) <= u64::MAX,\n    ensures\n        (v << (a + b)) == ((v << a) << b),\n{\n    if (a == 0 || b == 0) {\n        broadcast use shl_zero_is_id;\n\n    } else {\n        // 2^(a + b) == 2^a * 2^b\n        lemma_pow2_adds(a, b);\n        // 2^a < 2^(a + b) ...\n        lemma_pow2_strictly_increases(a, a + b);\n        // ..., which implies v * 2^a < v * 2^(a + b) <= u64::MAX\n        mul_le(v as nat, v as nat, pow2(a), pow2(a + b));\n        // v << a + b = v * 2^(a+b)\n        lemma_u64_shl_is_mul(v, (a + b) as u64);\n        // v << a = v * 2^a\n        lemma_u64_shl_is_mul(v, a as u64);\n        // (v * 2^a) * 2^b = v * (2^a * 2^b)\n        lemma_mul_is_associative(v as int, pow2(a) as int, pow2(b) as int);\n        // (v * 2^a) << b = (v * 2^a) * 2^b\n        lemma_u64_shl_is_mul((v * pow2(a)) as u64, b as u64);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_mod().",
      "display_name": "lemma_mod_mod",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_loop_bounds().",
      "display_name": "lemma_add_loop_bounds",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_loop_bounds().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_add_loop_bounds(i: int, carry: u64, a_limb: u64, b_limb: u64)\n    requires\n        0 <= i < 5,\n        a_limb < (1u64 << 52),\n        b_limb < (1u64 << 52),\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n    ensures\n        (carry >> 52) + a_limb + b_limb < (1u64 << 53),\n{\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert((1u64 << 52) + (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_bytes_to_nat_rec_equals_bytes_to_nat().",
      "display_name": "lemma_bytes_to_nat_rec_equals_bytes_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_bytes_to_nat_rec_equals_bytes_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "// This is a dummy function that we call from signal\n// to test that verus functions in libsignal know\n// about verus functions in curve-dalek\npub open spec fn is_a_scalar(s: Scalar) -> bool {\n    true\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 is_capable_simd().",
      "display_name": "is_capable_simd",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 is_capable_simd().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "body": "fn is_capable_simd(arch: &str, bits: DalekBits) -> bool {\n    arch == \"x86_64\" && bits == DalekBits::Dalek64\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "display_name": "select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
      "relative_path": "src/backend/serial/scalar_mul/variable_base.rs",
      "file_name": "variable_base.rs",
      "parent_folder": "scalar_mul",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_bound_scalar().",
      "display_name": "lemma_bound_scalar",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_bound_scalar().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_bound_scalar(a: &Scalar52)\n    requires\n        limbs_bounded(a),\n    ensures\n        to_nat(&a.limbs) < pow2((52 * (5) as nat)),\n{\n    lemma_general_bound(a.limbs@);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "display_name": "collect",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/IsIdentity#is_identity().",
      "display_name": "is_identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/IsIdentity#is_identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn is_identity(&self) -> bool {\n        self.ct_eq(&T::identity()).into()\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "display_name": "lemma_small_mod",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 20,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar{{\\n\\tbytes: {:?},\\n}}\", &self.bytes)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Mul#mul().",
      "display_name": "mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Mul#mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn mul(self, point: &'b EdwardsPoint) -> EdwardsPoint {\n        point * self\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_limbs().",
      "display_name": "from_limbs",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_limbs().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    pub(crate) const fn from_limbs(limbs: [u64; 5]) -> FieldElement51 {\n        FieldElement51 { limbs }\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order().",
      "display_name": "from_bytes_mod_order",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn from_bytes_mod_order(bytes: [u8; 32]) -> (result: Scalar)\n        ensures\n    // Result is equivalent to input modulo the group order\n\n            bytes_to_nat(&result.bytes) % group_order() == bytes_to_nat(&bytes) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        // Temporarily allow s_unreduced.bytes > 2^255 ...\n        let s_unreduced = Scalar { bytes };\n\n        // Then reduce mod the group order and return the reduced representative.\n        let s = s_unreduced.reduce();\n        /*** <VERIFICATION NOTE> We omit debug asserts from verification  </VERIFICATION NOTE> ***/\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/masked_lt_51().",
      "display_name": "masked_lt_51",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/masked_lt_51().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_and().",
      "display_name": "choice_and",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_and().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }\n//! ```\n//!\n//! See also `Scalar::hash_from_bytes` and `Scalar::from_hash` that\n//! reduces a \\\\(512\\\\)-bit integer, if the optional `digest` feature\n//! has been enabled.\n\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::{Product, Sum};\nuse core::ops::Index;",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb1().",
      "display_name": "load8_limb1",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb1().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn load8_limb1(input: &[u8])\n    requires\n        6 + 7 < input.len(),\n    ensures\n        ((load8_at_spec(input, 6) as u64) >> 3) & mask51 == (input[6] as nat / pow2(3)) + (input[7]\n            * pow2((1 * 8 - 3) as nat)) + (input[8] * pow2((2 * 8 - 3) as nat)) + (input[9] * pow2(\n            (3 * 8 - 3) as nat,\n        )) + (input[10] * pow2((4 * 8 - 3) as nat)) + (input[11] * pow2((5 * 8 - 3) as nat)) + ((\n        input[12] as nat % pow2(6)) * pow2((6 * 8 - 3) as nat)),\n{\n    let i = 6;\n    let k = 3;\n\n    let j_div = 1;\n    let j_id = 6;\n    let j_shift = 7;\n\n    load8_limb_X(input, i, k, j_div, j_id, j_shift);\n\n    // Sanity check\n    assert((load8_at_spec(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n        / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n    pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64));\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_shr_51_fits_u64().",
      "display_name": "lemma_shr_51_fits_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_shr_51_fits_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_shr_51_fits_u64(a: u128)\n    requires\n        a <= (u64::MAX as u128) << 51,\n    ensures\n        (a >> 51) <= (u64::MAX as u128),\n{\n    assert(((u64::MAX as u128) << 51) >> 51 == (u64::MAX as u128)) by (compute);\n    lemma_shr_51_le(a, (u64::MAX as u128) << 51);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_negate().",
      "display_name": "spec_negate",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_negate().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/field_core.rs",
      "file_name": "field_core.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn spec_negate(limbs: [u64; 5]) -> [u64; 5] {\n    let r = spec_reduce(pre_reduce_limbs(limbs));\n    r\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#map().",
      "display_name": "map",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#map().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_strict_inequality_converse().",
      "display_name": "lemma_mul_strict_inequality_converse",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_strict_inequality_converse().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_strict_inequality().",
      "display_name": "lemma_mul_strict_inequality",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_strict_inequality().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "display_name": "lemma_reduce_bound_2p",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 19
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_by_multiple().",
      "display_name": "lemma_div_by_multiple",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_by_multiple().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_by_multiple_is_strongly_ordered().",
      "display_name": "lemma_div_by_multiple_is_strongly_ordered",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_by_multiple_is_strongly_ordered().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/bitwise_or_l_zero_is_id().",
      "display_name": "bitwise_or_l_zero_is_id",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/bitwise_or_l_zero_is_id().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/bit_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/bit_lemmas.rs",
      "file_name": "bit_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn bitwise_or_l_zero_is_id(a: u64)\n    ensures\n        0 | a == a,\n{\n    assert(0 | a == a) by (bit_vector);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "display_name": "lemma_limb1_contribution_correctness_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub proof fn lemma_limb1_contribution_correctness_52(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[0] < (1u64 << 52),  // Need limb 0 for boundary byte 6\n        limbs[1] < (1u64 << 52),\n        bytes_match_limbs_packing_52(limbs, bytes),\n    ensures\n        limb1_byte_contribution_52(limbs, bytes) == (limbs[1] as nat) * pow2(52),\n{\n    // Proof following docs_22_oct/lemma_limb1_contribution_52_proof.md\n    lemma2_to64();\n    shift_is_pow2(52);\n\n    // === STEP 1: Define the Split ===\n    let l1_low = limbs[1] as nat % pow2(4);  // Low 4 bits in byte 6\n    let l1_high = limbs[1] as nat / pow2(4);  // High 48 bits in bytes 7-12\n\n    // === STEP 2: Bound the High Part ===\n    lemma_div_bound(limbs[1] as nat, 4, 52);\n    assert(l1_high < pow2(48));\n\n    // === STEP 3: Reconstruction Identity ===\n    lemma_pow2_pos(4);\n    lemma_fundamental_div_mod(limbs[1] as int, pow2(4) as int);\n    assert(pow2(4) * l1_high == l1_high * pow2(4)) by {\n        lemma_mul_is_commutative(pow2(4) as int, l1_high as int);\n    }\n    assert(limbs[1] as nat == l1_low + l1_high * pow2(4));\n\n    // === STEP 4: Byte Reconstruction for High 48 Bits ===\n    lemma_byte_from_limb_shift_52(limbs[1], 4, bytes[7]);\n    lemma_byte_from_limb_shift_52(limbs[1], 12, bytes[8]);\n    lemma_byte_from_limb_shift_52(limbs[1], 20, bytes[9]);\n    lemma_byte_from_limb_shift_52(limbs[1], 28, bytes[10]);\n    lemma_byte_from_limb_shift_52(limbs[1], 36, bytes[11]);\n    lemma_byte_from_limb_shift_52(limbs[1], 44, bytes[12]);\n\n    // Rewrite byte extractions in terms of l1_high = limbs[1] / 2^4\n    lemma_pow2_adds(4, 0);\n    lemma_pow2_pos(0);\n    lemma_div_denominator(limbs[1] as int, pow2(4) as int, pow2(0) as int);\n    assert(bytes[7] as nat == l1_high / pow2(0) % 256);\n\n    lemma_pow2_adds(4, 8);\n    lemma_pow2_pos(8);\n    lemma_div_denominator(limbs[1] as int, pow2(4) as int, pow2(8) as int);\n    assert(bytes[8] as nat == l1_high / pow2(8) % 256);\n\n    lemma_pow2_adds(4, 16);\n    lemma_pow2_pos(16);\n    lemma_div_denominator(limbs[1] as int, pow2(4) as int, pow2(16) as int);\n    assert(bytes[9] as nat == l1_high / pow2(16) % 256);\n\n    lemma_pow2_adds(4, 24);\n    lemma_pow2_pos(24);\n    lemma_div_denominator(limbs[1] as int, pow2(4) as int, pow2(24) as int);\n    assert(bytes[10] as nat == l1_high / pow2(24) % 256);\n\n    lemma_pow2_adds(4, 32);\n    lemma_pow2_pos(32);\n    lemma_div_denominator(limbs[1] as int, pow2(4) as int, pow2(32) as int);\n    assert(bytes[11] as nat == l1_high / pow2(32) % 256);\n\n    lemma_pow2_adds(4, 40);\n    lemma_pow2_pos(40);\n    lemma_div_denominator(limbs[1] as int, pow2(4) as int, pow2(40) as int);\n    assert(bytes[12] as nat == l1_high / pow2(40) % 256);\n\n    // 6-byte reconstruction lemma\n    lemma_6_bytes_reconstruct(\n        l1_high,\n        bytes[7],\n        bytes[8],\n        bytes[9],\n        bytes[10],\n        bytes[11],\n        bytes[12],\n    );\n\n    let bytes_at_offset_0 = bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8) + bytes[9] as nat\n        * pow2(16) + bytes[10] as nat * pow2(24) + bytes[11] as nat * pow2(32) + bytes[12] as nat\n        * pow2(40);\n\n    assert(bytes_at_offset_0 == l1_high);\n\n    // === STEP 5: Position Adjustment ===\n\n    // Multiply reconstruction identity by pow2(52)\n    assert((l1_low + l1_high * pow2(4)) * pow2(52) == limbs[1] as nat * pow2(52));\n\n    // Distribute\n    assert((l1_low + l1_high * pow2(4)) * pow2(52) == l1_low * pow2(52) + (l1_high * pow2(4))\n        * pow2(52)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(52) as int,\n            l1_low as int,\n            (l1_high * pow2(4)) as int,\n        );\n    }\n\n    // Simplify high term\n    lemma_pow2_adds(4, 52);\n    assert((l1_high * pow2(4)) * pow2(52) == l1_high * pow2(56)) by {\n        lemma_mul_is_associative(l1_high as int, pow2(4) as int, pow2(52) as int);\n    }\n\n    // Now we have: limbs[1] * 2^52 = l1_low * 2^52 + l1_high * 2^56\n\n    // === STEP 6: Express Low Part in Contribution Form ===\n    // l1_low * 2^52 = l1_low * 2^48 * 2^4 = (l1_low * 16) * 2^48\n    lemma_pow2_adds(48, 4);\n    assert(pow2(52) == pow2(48) * pow2(4));\n    assert(pow2(4) == 16) by {\n        assert(pow2(2) == 4);\n        assert(pow2(4) == pow2(2) * pow2(2)) by {\n            lemma_pow2_adds(2, 2);\n        }\n    }\n\n    assert(l1_low * pow2(52) == l1_low * (pow2(48) * pow2(4))) by {\n        // pow2(52) = pow2(48) * pow2(4) proven above\n    }\n    assert(l1_low * (pow2(48) * pow2(4)) == (l1_low * pow2(48)) * pow2(4)) by {\n        lemma_mul_is_associative(l1_low as int, pow2(48) as int, pow2(4) as int);\n    }\n    assert((l1_low * pow2(48)) * pow2(4) == pow2(48) * l1_low * pow2(4)) by {\n        lemma_mul_is_commutative((l1_low * pow2(48)) as int, pow2(4) as int);\n    }\n    assert(pow2(48) * l1_low * pow2(4) == pow2(48) * (l1_low * pow2(4))) by {\n        lemma_mul_is_associative(pow2(48) as int, l1_low as int, pow2(4) as int);\n    }\n    assert(l1_low * pow2(52) == (l1_low * 16) * pow2(48));\n\n    // === STEP 7: Expand the High Part ===\n    // Multiply bytes_at_offset_0 by pow2(56)\n    assert(bytes_at_offset_0 * pow2(56) == l1_high * pow2(56));\n\n    // Distribute pow2(56) into each byte term\n    assert(bytes_at_offset_0 * pow2(56) == bytes[7] as nat * pow2(0) * pow2(56) + bytes[8] as nat\n        * pow2(8) * pow2(56) + bytes[9] as nat * pow2(16) * pow2(56) + bytes[10] as nat * pow2(24)\n        * pow2(56) + bytes[11] as nat * pow2(32) * pow2(56) + bytes[12] as nat * pow2(40) * pow2(\n        56,\n    )) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(56) as int,\n            (bytes[7] as nat * pow2(0)) as int,\n            (bytes[8] as nat * pow2(8)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(56) as int,\n            (bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8)) as int,\n            (bytes[9] as nat * pow2(16)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(56) as int,\n            (bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8) + bytes[9] as nat * pow2(\n                16,\n            )) as int,\n            (bytes[10] as nat * pow2(24)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(56) as int,\n            (bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8) + bytes[9] as nat * pow2(16)\n                + bytes[10] as nat * pow2(24)) as int,\n            (bytes[11] as nat * pow2(32)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(56) as int,\n            (bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8) + bytes[9] as nat * pow2(16)\n                + bytes[10] as nat * pow2(24) + bytes[11] as nat * pow2(32)) as int,\n            (bytes[12] as nat * pow2(40)) as int,\n        );\n\n        // Apply associativity: (byte * pow2(k)) * pow2(56) = byte * (pow2(k) * pow2(56))\n        lemma_mul_is_associative(bytes[7] as int, pow2(0) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[8] as int, pow2(8) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[9] as int, pow2(16) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[10] as int, pow2(24) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[11] as int, pow2(32) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[12] as int, pow2(40) as int, pow2(56) as int);\n    }\n\n    // Apply power addition and connect to final positions\n    assert(bytes_at_offset_0 * pow2(56) == bytes[7] as nat * pow2(56) + bytes[8] as nat * pow2(64)\n        + bytes[9] as nat * pow2(72) + bytes[10] as nat * pow2(80) + bytes[11] as nat * pow2(88)\n        + bytes[12] as nat * pow2(96)) by {\n        lemma_mul_is_associative(bytes[7] as int, pow2(0) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[8] as int, pow2(8) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[9] as int, pow2(16) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[10] as int, pow2(24) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[11] as int, pow2(32) as int, pow2(56) as int);\n        lemma_mul_is_associative(bytes[12] as int, pow2(40) as int, pow2(56) as int);\n        lemma_pow2_adds(0, 56);\n        lemma_pow2_adds(8, 56);\n        lemma_pow2_adds(16, 56);\n        lemma_pow2_adds(24, 56);\n        lemma_pow2_adds(32, 56);\n        lemma_pow2_adds(40, 56);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn zeroize(&mut self) {\n        self.y_plus_x.zeroize();\n        self.y_minus_x.zeroize();\n        self.xy2d.zeroize();\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_mod().",
      "display_name": "pow2_MUL_div_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn pow2_MUL_div_mod(x: nat, px: nat, k: nat, s: nat, t: nat)\n    requires\n        x < pow2(px),\n        s <= k,\n        t <= k - s,\n    ensures\n        ((x * pow2(k)) / pow2(s)) % pow2(t) == 0,\n{\n    let d = (k - s) as nat;\n\n    assert((x * pow2(k)) / pow2(s) == x * pow2(d)) by {\n        pow2_MUL_div(x, k, s);\n    }\n\n    let dd = (d - t) as nat;\n\n    assert(x * pow2(d) == (x * pow2(dd)) * pow2(t)) by {\n        lemma_pow2_adds(dd, t);\n        lemma_mul_is_associative(x as int, pow2(dd) as int, pow2(t) as int);\n    }\n\n    assert(pow2(t) > 0) by {\n        lemma_pow2_pos(t);\n    }\n\n    assert(((x * pow2(dd)) * pow2(t)) % pow2(t) == 0) by {\n        lemma_mod_multiples_basic((x * pow2(dd)) as int, pow2(t) as int);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#double_and_compress_batch().",
      "display_name": "double_and_compress_batch",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#double_and_compress_batch().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn double_and_compress_batch<'a, I>(points: I) -> Vec<CompressedRistretto>\n    where\n        I: IntoIterator<Item = &'a RistrettoPoint>,\n    {\n        #[derive(Copy, Clone, Debug)]\n        struct BatchCompressState {\n            e: FieldElement,\n            f: FieldElement,\n            g: FieldElement,\n            h: FieldElement,\n            eg: FieldElement,\n            fh: FieldElement,\n        }\n\n        impl BatchCompressState {\n            fn efgh(&self) -> FieldElement {\n                &self.eg * &self.fh\n            }\n        }\n\n        impl<'a> From<&'a RistrettoPoint> for BatchCompressState {\n            #[rustfmt::skip] // keep alignment of explanatory comments\n            fn from(P: &'a RistrettoPoint) -> BatchCompressState {\n                let XX = P.0.X.square();\n                let YY = P.0.Y.square();\n                let ZZ = P.0.Z.square();\n                let dTT = &P.0.T.square() * &constants::EDWARDS_D;\n\n                let e = &P.0.X * &(&P.0.Y + &P.0.Y); // = 2*X*Y\n                let f = &ZZ + &dTT;                  // = Z^2 + d*T^2\n                let g = &YY + &XX;                   // = Y^2 - a*X^2\n                let h = &ZZ - &dTT;                  // = Z^2 - d*T^2\n\n                let eg = &e * &g;\n                let fh = &f * &h;\n\n                BatchCompressState{ e, f, g, h, eg, fh }\n            }\n        }\n\n        let states: Vec<BatchCompressState> =\n            points.into_iter().map(BatchCompressState::from).collect();\n\n        let mut invs: Vec<FieldElement> = states.iter().map(|state| state.efgh()).collect();\n\n        FieldElement::batch_invert(&mut invs[..]);\n\n        states\n            .iter()\n            .zip(invs.iter())\n            .map(|(state, inv): (&BatchCompressState, &FieldElement)| {\n                let Zinv = &state.eg * inv;\n                let Tinv = &state.fh * inv;\n\n                let mut magic = constants::INVSQRT_A_MINUS_D;\n\n                let negcheck1 = (&state.eg * &Zinv).is_negative();\n\n                let mut e = state.e;\n                let mut g = state.g;\n                let mut h = state.h;\n\n                let minus_e = -&e;\n                let f_times_sqrta = &state.f * &constants::SQRT_M1;\n\n                e.conditional_assign(&state.g, negcheck1);\n                g.conditional_assign(&minus_e, negcheck1);\n                h.conditional_assign(&f_times_sqrta, negcheck1);\n\n                magic.conditional_assign(&constants::SQRT_M1, negcheck1);\n\n                let negcheck2 = (&(&h * &e) * &Zinv).is_negative();\n\n                g.conditional_negate(negcheck2);\n\n                let mut s = &(&h - &g) * &(&magic * &(&g * &Tinv));\n\n                let s_is_negative = s.is_negative();\n                s.conditional_negate(s_is_negative);\n\n                CompressedRistretto(s.as_bytes())\n            })\n            .collect()\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_swap().",
      "display_name": "conditional_swap",
      "symbol": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_swap().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "display_name": "elligator_ristretto_flavor",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn elligator_ristretto_flavor(r_0: &FieldElement) -> RistrettoPoint {\n        let i = &constants::SQRT_M1;\n        let d = &constants::EDWARDS_D;\n        let one_minus_d_sq = &constants::ONE_MINUS_EDWARDS_D_SQUARED;\n        let d_minus_one_sq = &constants::EDWARDS_D_MINUS_ONE_SQUARED;\n        let mut c = constants::MINUS_ONE;\n\n        let one = FieldElement::ONE;\n\n        let r = i * &r_0.square();\n        let N_s = &(&r + &one) * one_minus_d_sq;\n        let D = &(&c - &(d * &r)) * &(&r + d);\n\n        let (Ns_D_is_sq, mut s) = FieldElement::sqrt_ratio_i(&N_s, &D);\n        let mut s_prime = &s * r_0;\n        let s_prime_is_pos = !s_prime.is_negative();\n        s_prime.conditional_negate(s_prime_is_pos);\n\n        s.conditional_assign(&s_prime, !Ns_D_is_sq);\n        c.conditional_assign(&r, !Ns_D_is_sq);\n\n        let N_t = &(&(&c * &(&r - &one)) * d_minus_one_sq) - &D;\n        let s_sq = s.square();\n\n        use crate::backend::serial::curve_models::CompletedPoint;\n\n        // The conversion from W_i is exactly the conversion from P1xP1.\n        RistrettoPoint(\n            CompletedPoint {\n                X: &(&s + &s) * &D,\n                Z: &N_t * &constants::SQRT_AD_MINUS_ONE,\n                Y: &FieldElement::ONE - &s_sq,\n                T: &FieldElement::ONE + &s_sq,\n            }\n            .as_extended(),\n        )\n    }",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_assign().",
      "display_name": "conditional_assign",
      "symbol": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_or().",
      "display_name": "choice_or",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_or().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "        /* <VERIFICATION NOTE>\n         Use wrapper function for Verus compatibility instead of direct subtle call\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.as_bytes().ct_eq(&other.as_bytes())\n         </ORIGINAL CODE> */\n        let result = ct_eq_bytes32(&self.as_bytes(), &other.as_bytes());\n        assume(choice_is_true(result) == (field_element_as_bytes(self) == field_element_as_bytes(\n            other,\n        )));\n        result\n    }\n}\n\nimpl FieldElement {\n    /// Determine if this `FieldElement` is negative, in the sense\n    /// used in the ed25519 paper: `x` is negative if the low bit is\n    /// set.\n    ///\n    /// # Return\n    ///\n    /// If negative, return `Choice(1)`.  Otherwise, return `Choice(0)`.\n    pub(crate) fn is_negative(&self) -> (result:\n        Choice)/* VERIFICATION NOTE:\n    - PROOF BYPASS AND SPEC BYPASS\n    - we cannot write this directly; need to find a spec function for FieldElement51::as_bytes\n    ensures choice_is_true(result) == (self.as_bytes()[0] & 1 == 1)\n    - (note after slack call: maybe the first bit of as_bytes() is sufficient as a spec)\n    </VERIFICATION NOTE> */\n\n        ensures\n            choice_is_true(result) == (field_element_as_bytes(self)[0] & 1\n                == 1),\n    // SPEC BYPASS through placeholder field_element_as_bytes\n\n    {\n        let bytes = self.as_bytes();\n        let result = Choice::from(bytes[0] & 1);\n        assume(choice_is_true(result) == (field_element_as_bytes(self)[0] & 1 == 1));\n        result\n    }\n\n    /// Determine if this `FieldElement` is zero.\n    ///\n    /// # Return\n    ///\n    /// If zero, return `Choice(1)`.  Otherwise, return `Choice(0)`.\n    pub(crate) fn is_zero(&self) -> (result:\n        Choice)/* VERIFICATION NOTE:\n    - PROOF BYPASS AND SPEC BYPASS\n    - we cannot write this directly; need to find a spec function for FieldElement51::as_bytes\n    ensures choice_is_true(result) == (self.as_bytes() == [0u8; 32])\n    - (note: maybe an all_zeroes(as_bytes(...)) is sufficient as a spec)\n    </VERIFICATION NOTE> */\n\n        ensures\n            choice_is_true(result) == (field_element_as_bytes(self)\n                == seq![0u8; 32]),\n    // SPEC BYPASS through placeholder field_element_as_bytes\n\n    {\n        let zero = [0u8;32];\n        let bytes = self.as_bytes();\n\n        let result = ct_eq_bytes32(&bytes, &zero);\n        assume(choice_is_true(result) == (field_element_as_bytes(self) == seq![0u8; 32]));\n        result\n    }\n\n    /// Compute (self^(2^250-1), self^11), used as a helper function\n    /// within invert() and pow22523().\n    #[rustfmt::skip]  // keep alignment of explanatory comments\n    fn pow22501(&self) -> (result: (FieldElement, FieldElement))\n        ensures\n            field_element_as_nat(&result.0) == pow(\n                field_element_as_nat(self) as int,\n                (pow2(250) - 1) as nat,\n            ) % (p() as int),\n            field_element_as_nat(&result.1) == pow(field_element_as_nat(self) as int, 11) % (\n            p() as int),\n    {\n        // Instead of managing which temporary variables are used\n        // for what, we define as many as we need and leave stack\n        // allocation to the compiler\n        //\n        // Each temporary variable t_i is of the form (self)^e_i.\n        // Squaring t_i corresponds to multiplying e_i by 2,\n        // so the pow2k function shifts e_i left by k places.\n        // Multiplying t_i and t_j corresponds to adding e_i + e_j.\n        //\n        // Temporary t_i                      Nonzero bits of e_i\n        //\n        assume(false);\n        let t0 = self.square();  // 1         e_0 = 2^1\n        let t1 = t0.square().square();  // 3         e_1 = 2^3\n        let t2 = self * &t1;  // 3,0       e_2 = 2^3 + 2^0\n        let t3 = &t0 * &t2;  // 3,1,0\n        let t4 = t3.square();  // 4,2,1\n        let t5 = &t2 * &t4;  // 4,3,2,1,0\n        let t6 = t5.pow2k(5);  // 9,8,7,6,5\n        let t7 = &t6 * &t5;  // 9,8,7,6,5,4,3,2,1,0\n        let t8 = t7.pow2k(10);  // 19..10\n        let t9 = &t8 * &t7;  // 19..0\n        let t10 = t9.pow2k(20);  // 39..20\n        let t11 = &t10 * &t9;  // 39..0\n        let t12 = t11.pow2k(10);  // 49..10\n        let t13 = &t12 * &t7;  // 49..0\n        let t14 = t13.pow2k(50);  // 99..50\n        let t15 = &t14 * &t13;  // 99..0\n        let t16 = t15.pow2k(100);  // 199..100\n        let t17 = &t16 * &t15;  // 199..0\n        let t18 = t17.pow2k(50);  // 249..50\n        let t19 = &t18 * &t13;  // 249..0\n\n        (t19, t3)\n    }\n\n    /// Given a slice of pub(crate)lic `FieldElements`, replace each with its inverse.\n    ///\n    /// When an input `FieldElement` is zero, its value is unchanged.\n    #[cfg(feature = \"alloc\")]\n    pub(crate) fn batch_invert(\n        inputs: &mut [FieldElement],\n    )/* <VERIFICATION NOTE>\n     - Refactored for Verus: Index loops instead of iterators, manual Vec construction\n     - Choice type operations handled by wrappers in subtle_assumes.rs\n     - PROOF BYPASSES because of trait issues and proof obligations.\n    </VERIFICATION NOTE> */\n\n        ensures\n    // Each element is replaced appropriately:\n\n            forall|i: int|\n                #![auto]\n                0 <= i < inputs.len() ==> {\n                    // If input was non-zero, it's replaced with its inverse\n                    (field_element_as_nat(&old(inputs)[i]) != 0) ==> is_inverse_field(\n                        &old(inputs)[i],\n                        &inputs[i],\n                    ) &&\n                    // If input was zero, it remains zero\n                    (field_element_as_nat(&old(inputs)[i]) == 0) ==> field_element_as_nat(\n                        &inputs[i],\n                    ) == 0\n                },\n    {\n        // Montgomery's Trick and Fast Implementation of Masked AES\n        // Genelle, Prouff and Quisquater\n        // Section 3.2\n        let n = inputs.len();\n\n        // Extract ONE constant before loops (similar to scalar.rs pattern)\n        let one = FieldElement::ONE;\n\n        /* <VERIFICATION NOTE>\n         Build vec manually instead of vec![one; n] for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let mut scratch = vec![FieldElement::ONE; n];\n        </ORIGINAL CODE> */\n        let mut scratch = Vec::new();\n        for _ in 0..n {\n            scratch.push(one);\n        }\n\n        // Keep an accumulator of all of the previous products\n        let mut acc = one;\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        /* <VERIFICATION NOTE>\n         Rewritten with index loop instead of .zip() for Verus compatibility\n         Using choice_not() wrapper instead of ! operator\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         for (input, scratch) in inputs.iter().zip(scratch.iter_mut()) {\n            *scratch = acc;\n            // acc <- acc * input, but skipping zeros (constant-time)\n            acc.conditional_assign(&(&acc * input), !input.is_zero());\n        }\n        </ORIGINAL CODE> */\n        for i in 0..n {\n            assume(false);\n            scratch[i] = acc;\n            assume(false);\n            // acc <- acc * input, but skipping zeros (constant-time)\n            acc.conditional_assign(&(&acc * &inputs[i]), choice_not(inputs[i].is_zero()));\n        }\n\n        // acc is nonzero because we skipped zeros in inputs\n        // ORIGINAL: assert!(bool::from(!acc.is_zero()));\n        #[cfg(not(verus_keep_ghost))]\n        assert!(bool::from(choice_not(acc.is_zero())));\n\n        // Compute the inverse of all products\n        acc = acc.invert();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        /* <VERIFICATION NOTE>\n         Manual reverse loop instead of .rev().zip() for Verus compatibility\n         Using choice_not() wrapper instead of ! operator\n         Extract-modify-reassign pattern for mutable indexing\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         for (input, scratch) in inputs.iter_mut().rev().zip(scratch.into_iter().rev()) {\n            let tmp = &acc * input;\n            // input <- acc * scratch, then acc <- tmp\n            // Again, we skip zeros in a constant-time way\n            let nz = !input.is_zero();\n            input.conditional_assign(&(&acc * &scratch), nz);\n            acc.conditional_assign(&tmp, nz);\n        }\n        </ORIGINAL CODE> */\n\n        proof {\n            assume(scratch.len() == n);\n        }\n\n        let mut i: usize = n;\n        while i > 0\n            invariant\n                n == inputs.len(),\n                n == scratch.len(),\n            decreases i,\n        {\n            i -= 1;\n            proof {\n                assume(i < inputs.len());\n                assume(i < scratch.len());\n                assume(0 <= i);\n                assume(false);\n            }\n            let tmp = &acc * &inputs[i];\n            // input <- acc * scratch, then acc <- tmp\n            // Again, we skip zeros in a constant-time way\n            let nz = choice_not(inputs[i].is_zero());\n            // Verus doesn't support index for &mut, so we extract-modify-reassign\n            let mut input_i = inputs[i];\n            input_i.conditional_assign(&(&acc * &scratch[i]), nz);\n            inputs[i] = input_i;\n            acc.conditional_assign(&tmp, nz);\n        }\n\n        proof {\n            // Assume the postconditions hold\n            assume(forall|i: int|\n                #![auto]\n                0 <= i < inputs.len() ==> {\n                    (field_element_as_nat(&old(inputs)[i]) != 0) ==> is_inverse_field(\n                        &old(inputs)[i],\n                        &inputs[i],\n                    ) && (field_element_as_nat(&old(inputs)[i]) == 0) ==> field_element_as_nat(\n                        &inputs[i],\n                    ) == 0\n                });\n        }\n    }\n\n    /// Given a nonzero field element, compute its inverse.\n    ///\n    /// The inverse is computed as self^(p-2), since\n    /// x^(p-2)x = x^(p-1) = 1 (mod p).\n    ///\n    /// This function returns zero on input zero.\n    #[rustfmt::skip]  // keep alignment of explanatory comments\n    #[allow(clippy::let_and_return)]\n    pub(crate) fn invert(&self) -> (result:\n        FieldElement)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n    // If self is non-zero, result is the multiplicative inverse: result * self ≡ 1 (mod p)\n\n            field_element_as_nat(self) != 0 ==> (field_element_as_nat(&result)\n                * field_element_as_nat(self)) % p() == 1,\n            // If self is zero, result is zero\n            field_element_as_nat(self) == 0 ==> field_element_as_nat(&result) == 0,\n            field_element(&result) == field_inv(field_element(self)),\n    {\n        // The bits of p-2 = 2^255 -19 -2 are 11010111111...11.\n        //\n        //                                 nonzero bits of exponent\n        assume(false);\n        let (t19, t3) = self.pow22501();  // t19: 249..0 ; t3: 3,1,0\n        let t20 = t19.pow2k(5);  // 254..5\n        let t21 = &t20 * &t3;  // 254..5,3,1,0\n\n        t21\n    }\n\n    /// Raise this field element to the power (p-5)/8 = 2^252 -3.\n    #[rustfmt::skip]  // keep alignment of explanatory comments\n    #[allow(clippy::let_and_return)]\n    fn pow_p58(&self) -> (result: FieldElement)\n        ensures\n            field_element_as_nat(&result) == pow(\n                field_element_as_nat(self) as int,\n                (pow2(252) - 3) as nat,\n            ) % (p() as int),\n    {\n        // The bits of (p-5)/8 are 101111.....11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, _) = self.pow22501();  // 249..0\n        assume(false);\n        let t20 = t19.pow2k(2);  // 251..2\n        assume(false);\n        let t21 = self * &t20;  // 251..2,0\n\n        t21\n    }\n\n    /// Given `FieldElements` `u` and `v`, compute either `sqrt(u/v)`\n    /// or `sqrt(i*u/v)` in constant time.\n    ///\n    /// This function always returns the nonnegative square root.\n    ///\n    /// # Return\n    ///\n    /// - `(Choice(1), +sqrt(u/v))  ` if `v` is nonzero and `u/v` is square;\n    /// - `(Choice(1), zero)        ` if `u` is zero;\n    /// - `(Choice(0), zero)        ` if `v` is zero and `u` is nonzero;\n    /// - `(Choice(0), +sqrt(i*u/v))` if `u/v` is nonsquare (so `i*u/v` is square).\n    ///\n    pub(crate) fn sqrt_ratio_i(u: &FieldElement, v: &FieldElement) -> (result: (\n        Choice,\n        FieldElement,\n    ))\n        ensures\n    // When u = 0: always return (true, 0)\n\n            (field_element_as_nat(u) == 0) ==> (choice_is_true(result.0) && field_element_as_nat(\n                &result.1,\n            ) == 0),\n            // When v = 0 but u ≠ 0: return (false, 0) [division by zero case]\n            (field_element_as_nat(v) == 0 && field_element_as_nat(u) != 0) ==> (!choice_is_true(\n                result.0,\n            ) && field_element_as_nat(&result.1) == 0),\n            // When successful and v ≠ 0: r² * v ≡ u (mod p)\n            (choice_is_true(result.0) && field_element_as_nat(v) != 0) ==> is_sqrt_ratio(\n                u,\n                v,\n                &result.1,\n            ),\n            // When unsuccessful and v ≠ 0: r² * v ≡ i*u (mod p) [nonsquare case]\n            (!choice_is_true(result.0) && field_element_as_nat(v) != 0 && field_element_as_nat(u)\n                != 0) ==> is_sqrt_ratio_times_i(\n                u,\n                v,\n                &result.1,\n            ),\n    // VERIFICATION NOTE: PROOF BYPASS\n\n    {\n        // Using the same trick as in ed25519 decoding, we merge the\n        // inversion, the square root, and the square test as follows.\n        //\n        // To compute sqrt(α), we can compute β = α^((p+3)/8).\n        // Then β^2 = ±α, so multiplying β by sqrt(-1) if necessary\n        // gives sqrt(α).\n        //\n        // To compute 1/sqrt(α), we observe that\n        //    1/β = α^(p-1 - (p+3)/8) = α^((7p-11)/8)\n        //                            = α^3 * (α^7)^((p-5)/8).\n        //\n        // We can therefore compute sqrt(u/v) = sqrt(u)/sqrt(v)\n        // by first computing\n        //    r = u^((p+3)/8) v^(p-1-(p+3)/8)\n        //      = u u^((p-5)/8) v^3 (v^7)^((p-5)/8)\n        //      = (uv^3) (uv^7)^((p-5)/8).\n        //\n        // If v is nonzero and u/v is square, then r^2 = ±u/v,\n        //                                     so vr^2 = ±u.\n        // If vr^2 =  u, then sqrt(u/v) = r.\n        // If vr^2 = -u, then sqrt(u/v) = r*sqrt(-1).\n        //\n        // If v is zero, r is also zero.\n        proof {\n            assume(false);  // PROOF BYPASS\n        }\n        let v3 = &v.square() * v;\n        let v7 = &v3.square() * v;\n        let mut r = &(u * &v3) * &(u * &v7).pow_p58();\n        let check = v * &r.square();\n\n        let i = &constants::SQRT_M1;\n\n        let correct_sign_sqrt = check.ct_eq(u);\n\n        // ORIGINAL CODE:\n        // let flipped_sign_sqrt = check.ct_eq(&(-u));\n        // let flipped_sign_sqrt_i = check.ct_eq(&(&(-u) * i));\n        // REFACTORED: Use wrapper to avoid Verus internal error with negation\n        let u_neg = negate_field(u);\n        let flipped_sign_sqrt = check.ct_eq(&u_neg);\n        let flipped_sign_sqrt_i = check.ct_eq(&(&u_neg * i));\n\n        let r_prime = &constants::SQRT_M1 * &r;\n        // ORIGINAL CODE:\n        // r.conditional_assign(&r_prime, flipped_sign_sqrt | flipped_sign_sqrt_i);\n        // REFACTORED: Use wrapper for Choice bitwise OR\n        r.conditional_assign(&r_prime, choice_or(flipped_sign_sqrt, flipped_sign_sqrt_i));\n\n        // Choose the nonnegative square root.\n        let r_is_negative = r.is_negative();\n        // ORIGINAL CODE:\n        // r.conditional_negate(r_is_negative);\n        // REFACTORED: Use wrapper for conditional_negate\n        conditional_negate_field(&mut r, r_is_negative);\n\n        // ORIGINAL CODE:\n        // let was_nonzero_square = correct_sign_sqrt | flipped_sign_sqrt;\n        // REFACTORED: Use wrapper for Choice bitwise OR\n        let was_nonzero_square = choice_or(correct_sign_sqrt, flipped_sign_sqrt);\n\n        (was_nonzero_square, r)\n    }\n\n    /// Attempt to compute `sqrt(1/self)` in constant time.\n    ///\n    /// Convenience wrapper around `sqrt_ratio_i`.\n    ///\n    /// This function always returns the nonnegative square root.\n    ///\n    /// # Return\n    ///\n    /// - `(Choice(1), +sqrt(1/self))  ` if `self` is a nonzero square;\n    /// - `(Choice(0), zero)           ` if `self` is zero;\n    /// - `(Choice(0), +sqrt(i/self))  ` if `self` is a nonzero nonsquare;\n    ///\n    pub(crate) fn invsqrt(&self) -> (result: (\n        Choice,\n        FieldElement,\n    ))\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n    // When self = 0: return (false, 0)\n\n            (field_element_as_nat(self) == 0) ==> (!choice_is_true(result.0)\n                && field_element_as_nat(&result.1) == 0),\n            // When successful and self ≠ 0: r² * self ≡ 1 (mod p)\n            (choice_is_true(result.0)) ==> is_sqrt_ratio(&FieldElement::ONE, self, &result.1),\n            // When unsuccessful and self ≠ 0: r² * self ≡ i (mod p) [nonsquare case]\n            (!choice_is_true(result.0) && field_element_as_nat(self) != 0)\n                ==> is_sqrt_ratio_times_i(&FieldElement::ONE, self, &result.1),\n    {\n        assume(false);\n        FieldElement::sqrt_ratio_i(&FieldElement::ONE, self)\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_boundaries().",
      "display_name": "lemma_boundaries",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_boundaries().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "use zeroize::Zeroize;\n\n#[allow(unused_imports)]\nuse vstd::arithmetic::div_mod::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::mul::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\n#[allow(unused_imports)]\nuse vstd::bits::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::bit_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::div_mod_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mask_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mul_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::pow_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::shift_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_nat_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::compute_q_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::field_core::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::from_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::limbs_to_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::load8_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::negate_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2_51_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_edwards_point().",
      "display_name": "is_valid_edwards_point",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_edwards_point().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/curve_specs.rs",
      "relative_path": "src/curve_specs.rs",
      "file_name": "curve_specs.rs",
      "parent_folder": "src",
      "body": "pub open spec fn is_valid_edwards_point(point: crate::edwards::EdwardsPoint) -> bool {\n    let x = field_element(&point.X);\n    let y = field_element(&point.Y);\n    let z = field_element(&point.Z);\n    let t = field_element(&point.T);\n\n    // Z must be non-zero\n    z != 0 &&\n    // The affine coordinates (X/Z, Y/Z) must be on the curve\n    on_edwards_curve(field_mul(x, field_inv(z)), field_mul(y, field_inv(z)))\n        &&\n    // Extended coordinate must satisfy T = X*Y/Z\n    t == field_mul(field_mul(x, y), field_inv(z))\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "display_name": "mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    }\n\n    open spec fn neg_spec(self) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "display_name": "invert",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn invert(&self) -> (result: UnpackedScalar)\n        ensures\n            limbs_bounded(&result),\n            // Postcondition: result * self ≡ 1 (mod group_order)\n            to_nat(&result.limbs) * to_nat(&self.limbs) % group_order() == 1,\n    {\n        /* <ORIGINAL CODE>\n                self.as_montgomery().montgomery_invert().from_montgomery()\n        </ORIGINAL CODE> */\n        assume(limbs_bounded(self));\n        let mont = self.as_montgomery();\n        assume(limbs_bounded(&mont));\n        let inv = mont.montgomery_invert();\n        assume(limbs_bounded(&inv));\n        let result = inv.from_montgomery();\n\n        proof {\n            assume(limbs_bounded(&result));\n            assume(to_nat(&result.limbs) * to_nat(&self.limbs) % group_order() == 1);\n        }\n\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#SubAssign#sub_assign().",
      "display_name": "sub_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#SubAssign#sub_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn sub_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        *self = &*self - _rhs;\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn default() -> (result: CompressedEdwardsY)\n        ensures\n            is_compressed_identity(result),\n    {\n        let result = CompressedEdwardsY::identity();\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/product_of_fields().",
      "display_name": "product_of_fields",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/product_of_fields().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field_specs.rs",
      "relative_path": "src/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "src",
      "body": "pub open spec fn product_of_fields(fields: Seq<FieldElement51>) -> nat\n    decreases fields.len(),\n{\n    if fields.len() == 0 {\n        1\n    } else {\n        (product_of_fields(fields.skip(1)) * field_element_as_nat(&fields[0])) % p()\n    }\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/on_edwards_curve().",
      "display_name": "on_edwards_curve",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/on_edwards_curve().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/curve_specs.rs",
      "relative_path": "src/curve_specs.rs",
      "file_name": "curve_specs.rs",
      "parent_folder": "src",
      "body": "pub open spec fn on_edwards_curve(x: nat, y: nat) -> bool {\n    let p = p();\n    let d = field_element(&crate::backend::serial::u64::constants::EDWARDS_D);\n    let x2 = field_square(x);\n    let y2 = field_square(y);\n    let x2y2 = field_mul(x2, y2);\n\n    // -x² + y² = 1 + d·x²·y²\n    let lhs = field_sub(y2, x2);  // y² - x²\n    let rhs = field_add(1, field_mul(d, x2y2));  // 1 + d·x²·y²\n\n    lhs == rhs\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn default() -> ProjectivePoint {\n        ProjectivePoint::identity()\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c0_val().",
      "display_name": "c0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn c0_val(a: [u64; 5]) -> u128 {\n    c0_0_val(a)\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_pow252().",
      "display_name": "lemma_pow252",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_pow252().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_pow252()\n    ensures\n        pow2(252) == 0x1000000000000000000000000000000000000000000000000000000000000000,\n{\n    assert(pow2(63) == 0x8000000000000000) by {\n        lemma2_to64_rest();\n    }\n    lemma_pow2_adds(63, 63);\n    assert(pow2(126) == 0x40000000000000000000000000000000);\n    lemma_pow2_adds(126, 126);\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/is_a_scalar().",
      "display_name": "is_a_scalar",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/is_a_scalar().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "pub open spec fn is_a_scalar(s: Scalar) -> bool {\n    true\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_negate_field().",
      "display_name": "conditional_negate_field",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_negate_field().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "            is_valid_y_coordinate(field_element_from_bytes(&self.0))\n                ==> result.is_some()\n            // The Y coordinate matches the one from the compressed representation\n             && field_element(&result.unwrap().Y) == field_element_from_bytes(\n                &self.0,\n            )\n            // The point is valid\n             && is_valid_edwards_point(\n                result.unwrap(),\n            )\n            // The X coordinate sign bit matches the sign bit from the compressed representation\n             && field_element_sign_bit(&result.unwrap().X) == (self.0[31] >> 7),\n            !is_valid_y_coordinate(field_element_from_bytes(&self.0)) <==> result.is_none(),\n    {\n        let (is_valid_y_coord, X, Y, Z) = decompress::step_1(self);\n\n        proof {\n            assert(choice_is_true(is_valid_y_coord) ==> is_valid_y_coordinate(\n                field_element_from_bytes(&self.0),\n            ));\n            assert(choice_is_true(is_valid_y_coord) ==> on_edwards_curve(\n                field_element(&X),\n                field_element(&Y),\n            ));\n        }\n        if choice_into(is_valid_y_coord) {\n            assert(choice_is_true(is_valid_y_coord));\n            assert(field_element(&Y) == field_element_from_bytes(&self.0));\n            let point = decompress::step_2(self, X, Y, Z);\n            let result = Some(point);\n            assume(false);\n            result\n        } else {\n            assert(!choice_is_true(is_valid_y_coord));\n            assert(!is_valid_y_coordinate(field_element_from_bytes(&self.0)));\n            let result = None;\n            result\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/VartimeEdwardsPrecomputation#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "display_name": "optional_mixed_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/VartimeEdwardsPrecomputation#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        self.0\n            .optional_mixed_multiscalar_mul(static_scalars, dynamic_scalars, dynamic_points)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "display_name": "pow2k",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 39
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/mod.rs",
      "relative_path": "src/backend/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "backend",
      "body": "//! feature; it uses the [`serial`] backend for non-vectorized operations.\nuse crate::EdwardsPoint;\nuse crate::Scalar;\n\npub mod serial;\n\n// #[cfg(curve25519_dalek_backend = \"simd\")]\n// pub mod vector;\n\n#[derive(Copy, Clone)]\nenum BackendKind {\n    // #[cfg(curve25519_dalek_backend = \"simd\")]\n    // Avx2,\n    // #[cfg(all(curve25519_dalek_backend = \"simd\", nightly))]\n    // Avx512,\n    Serial,\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "display_name": "invsqrt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    /// }\n    /// # }\n    /// ```\n    #[cfg(feature = \"alloc\")]\n    pub fn double_and_compress_batch<'a, I>(points: I) -> Vec<CompressedRistretto>\n    where\n        I: IntoIterator<Item = &'a RistrettoPoint>,\n    {\n        #[derive(Copy, Clone, Debug)]\n        struct BatchCompressState {\n            e: FieldElement,\n            f: FieldElement,\n            g: FieldElement,\n            h: FieldElement,\n            eg: FieldElement,\n            fh: FieldElement,\n        }\n\n        impl BatchCompressState {\n            fn efgh(&self) -> FieldElement {\n                &self.eg * &self.fh\n            }\n        }\n\n        impl<'a> From<&'a RistrettoPoint> for BatchCompressState {\n            #[rustfmt::skip] // keep alignment of explanatory comments\n            fn from(P: &'a RistrettoPoint) -> BatchCompressState {\n                let XX = P.0.X.square();\n                let YY = P.0.Y.square();\n                let ZZ = P.0.Z.square();\n                let dTT = &P.0.T.square() * &constants::EDWARDS_D;\n\n                let e = &P.0.X * &(&P.0.Y + &P.0.Y); // = 2*X*Y\n                let f = &ZZ + &dTT;                  // = Z^2 + d*T^2\n                let g = &YY + &XX;                   // = Y^2 - a*X^2\n                let h = &ZZ - &dTT;                  // = Z^2 - d*T^2\n\n                let eg = &e * &g;\n                let fh = &f * &h;\n\n                BatchCompressState{ e, f, g, h, eg, fh }\n            }\n        }\n\n        let states: Vec<BatchCompressState> =\n            points.into_iter().map(BatchCompressState::from).collect();\n\n        let mut invs: Vec<FieldElement> = states.iter().map(|state| state.efgh()).collect();\n\n        FieldElement::batch_invert(&mut invs[..]);\n\n        states\n            .iter()\n            .zip(invs.iter())\n            .map(|(state, inv): (&BatchCompressState, &FieldElement)| {\n                let Zinv = &state.eg * inv;\n                let Tinv = &state.fh * inv;\n\n                let mut magic = constants::INVSQRT_A_MINUS_D;\n\n                let negcheck1 = (&state.eg * &Zinv).is_negative();\n\n                let mut e = state.e;\n                let mut g = state.g;\n                let mut h = state.h;\n\n                let minus_e = -&e;\n                let f_times_sqrta = &state.f * &constants::SQRT_M1;\n\n                e.conditional_assign(&state.g, negcheck1);\n                g.conditional_assign(&minus_e, negcheck1);\n                h.conditional_assign(&f_times_sqrta, negcheck1);\n\n                magic.conditional_assign(&constants::SQRT_M1, negcheck1);\n\n                let negcheck2 = (&(&h * &e) * &Zinv).is_negative();\n\n                g.conditional_negate(negcheck2);\n\n                let mut s = &(&h - &g) * &(&magic * &(&g * &Tinv));\n\n                let s_is_negative = s.is_negative();\n                s.conditional_negate(s_is_negative);\n\n                CompressedRistretto(s.as_bytes())\n            })\n            .collect()\n    }",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective_niels().",
      "display_name": "as_projective_niels",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective_niels().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Neg#neg().",
      "display_name": "neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Neg#neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#expect().",
      "display_name": "expect",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#expect().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "display_name": "mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn mul(self, _rhs: &'b Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n    {\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n            * bytes_to_nat(&_rhs.bytes)) % group_order());\n        /* </MODIFIED CODE> */\n        /* <ORIGINAL CODE>\n         let result = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#to_jacobi_quartic_ristretto().",
      "display_name": "to_jacobi_quartic_ristretto",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#to_jacobi_quartic_ristretto().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    fn to_jacobi_quartic_ristretto(self) -> [JacobiPoint; 4] {\n        let x2 = self.0.X.square(); // X^2\n        let y2 = self.0.Y.square(); // Y^2\n        let y4 = y2.square(); // Y^4\n        let z2 = self.0.Z.square(); // Z^2\n        let z_min_y = &self.0.Z - &self.0.Y; // Z - Y\n        let z_pl_y = &self.0.Z + &self.0.Y; // Z + Y\n        let z2_min_y2 = &z2 - &y2; // Z^2 - Y^2\n\n        // gamma := 1/sqrt( Y^4 X^2 (Z^2 - Y^2) )\n        let (_, gamma) = (&(&y4 * &x2) * &z2_min_y2).invsqrt();\n\n        let den = &gamma * &y2;\n\n        let s_over_x = &den * &z_min_y;\n        let sp_over_xp = &den * &z_pl_y;\n\n        let s0 = &s_over_x * &self.0.X;\n        let s1 = &(-(&sp_over_xp)) * &self.0.X;\n\n        // t_0 := -2/sqrt(-d-1) * Z * sOverX\n        // t_1 := -2/sqrt(-d-1) * Z * spOverXp\n        let tmp = &lizard_constants::MDOUBLE_INVSQRT_A_MINUS_D * &self.0.Z;\n        let mut t0 = &tmp * &s_over_x;\n        let mut t1 = &tmp * &sp_over_xp;\n\n        // den := -1/sqrt(1+d) (Y^2 - Z^2) gamma\n        let den = &(&(-(&z2_min_y2)) * &lizard_constants::MINVSQRT_ONE_PLUS_D) * &gamma;\n\n        // Same as before but with the substitution (X, Y, Z) = (Y, X, i*Z)\n        let iz = &constants::SQRT_M1 * &self.0.Z; // iZ\n        let iz_min_x = &iz - &self.0.X; // iZ - X\n        let iz_pl_x = &iz + &self.0.X; // iZ + X\n\n        let s_over_y = &den * &iz_min_x;\n        let sp_over_yp = &den * &iz_pl_x;\n\n        let mut s2 = &s_over_y * &self.0.Y;\n        let mut s3 = &(-(&sp_over_yp)) * &self.0.Y;\n\n        // t_2 := -2/sqrt(-d-1) * i*Z * sOverY\n        // t_3 := -2/sqrt(-d-1) * i*Z * spOverYp\n        let tmp = &lizard_constants::MDOUBLE_INVSQRT_A_MINUS_D * &iz;\n        let mut t2 = &tmp * &s_over_y;\n        let mut t3 = &tmp * &sp_over_yp;\n\n        // Special case: X=0 or Y=0.  Then return\n        //\n        //  (0,1)   (1,-2i/sqrt(-d-1)   (-1,-2i/sqrt(-d-1))\n        //\n        // Note that if X=0 or Y=0, then s_i = t_i = 0.\n        let x_or_y_is_zero = self.0.X.is_zero() | self.0.Y.is_zero();\n        t0.conditional_assign(&FieldElement::ONE, x_or_y_is_zero);\n        t1.conditional_assign(&FieldElement::ONE, x_or_y_is_zero);\n        t2.conditional_assign(\n            &lizard_constants::MIDOUBLE_INVSQRT_A_MINUS_D,\n            x_or_y_is_zero,\n        );\n        t3.conditional_assign(\n            &lizard_constants::MIDOUBLE_INVSQRT_A_MINUS_D,\n            x_or_y_is_zero,\n        );\n        s2.conditional_assign(&FieldElement::ONE, x_or_y_is_zero);\n        s3.conditional_assign(&(-(&FieldElement::ONE)), x_or_y_is_zero);\n\n        [\n            JacobiPoint { S: s0, T: t0 },\n            JacobiPoint { S: s1, T: t1 },\n            JacobiPoint { S: s2, T: t2 },\n            JacobiPoint { S: s3, T: t3 },\n        ]\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "display_name": "lemma_mul_is_distributive_sub",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 9,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#IndexMut#index_mut().",
      "display_name": "index_mut",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#IndexMut#index_mut().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn index_mut(&mut self, _index: usize) -> &mut u64 {\n        &mut (self.limbs[_index])\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "display_name": "optional_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/mod.rs",
      "relative_path": "src/backend/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "backend",
      "body": "            // #[cfg(all(curve25519_dalek_backend = \"simd\", nightly))]\n            // VartimePrecomputedStraus::Avx512ifma(inner) => inner.optional_mixed_multiscalar_mul(\n            //     static_scalars,\n            //     dynamic_scalars,\n            //     dynamic_points,\n            // ),\n            VartimePrecomputedStraus::Scalar(inner) => inner.optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points,\n            ),\n        }\n    }\n}\n\n#[allow(missing_docs)]\n#[cfg(feature = \"alloc\")]\npub fn straus_multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator,\n    J::Item: core::borrow::Borrow<EdwardsPoint>,\n{\n    use crate::traits::MultiscalarMul;\n\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 => {\n        //     vector::scalar_mul::straus::spec_avx2::Straus::multiscalar_mul::<I, J>(scalars, points)\n        // }\n        // #[cfg(all(curve25519_dalek_backend = \"simd\", nightly))]\n        // BackendKind::Avx512 => {\n        //     vector::scalar_mul::straus::spec_avx512ifma_avx512vl::Straus::multiscalar_mul::<I, J>(\n        //         scalars, points,\n        //     )\n        // }\n        BackendKind::Serial => {\n            serial::scalar_mul::straus::Straus::multiscalar_mul::<I, J>(scalars, points)\n        }\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/m().",
      "display_name": "m",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/m().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "fn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_sqrt_ratio().",
      "display_name": "is_sqrt_ratio",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_sqrt_ratio().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "        let t7 = &t6 * &t5;  // 9,8,7,6,5,4,3,2,1,0\n        let t8 = t7.pow2k(10);  // 19..10\n        let t9 = &t8 * &t7;  // 19..0\n        let t10 = t9.pow2k(20);  // 39..20\n        let t11 = &t10 * &t9;  // 39..0\n        let t12 = t11.pow2k(10);  // 49..10\n        let t13 = &t12 * &t7;  // 49..0\n        let t14 = t13.pow2k(50);  // 99..50\n        let t15 = &t14 * &t13;  // 99..0\n        let t16 = t15.pow2k(100);  // 199..100\n        let t17 = &t16 * &t15;  // 199..0\n        let t18 = t17.pow2k(50);  // 249..50\n        let t19 = &t18 * &t13;  // 249..0\n\n        (t19, t3)\n    }\n\n    /// Given a slice of pub(crate)lic `FieldElements`, replace each with its inverse.\n    ///\n    /// When an input `FieldElement` is zero, its value is unchanged.\n    #[cfg(feature = \"alloc\")]\n    pub(crate) fn batch_invert(\n        inputs: &mut [FieldElement],\n    )/* <VERIFICATION NOTE>\n     - Refactored for Verus: Index loops instead of iterators, manual Vec construction\n     - Choice type operations handled by wrappers in subtle_assumes.rs\n     - PROOF BYPASSES because of trait issues and proof obligations.\n    </VERIFICATION NOTE> */\n\n        ensures\n    // Each element is replaced appropriately:\n\n            forall|i: int|\n                #![auto]\n                0 <= i < inputs.len() ==> {\n                    // If input was non-zero, it's replaced with its inverse\n                    (field_element_as_nat(&old(inputs)[i]) != 0) ==> is_inverse_field(\n                        &old(inputs)[i],\n                        &inputs[i],\n                    ) &&\n                    // If input was zero, it remains zero\n                    (field_element_as_nat(&old(inputs)[i]) == 0) ==> field_element_as_nat(\n                        &inputs[i],\n                    ) == 0\n                },",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_cast_then_mask_51().",
      "display_name": "lemma_cast_then_mask_51",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_cast_then_mask_51().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub broadcast proof fn lemma_cast_then_mask_51(x: u128)\n    ensures\n        #![trigger (x as u64) & mask51]\n        (x as u64) & mask51 == x & (mask51 as u128),\n{\n    assert((x as u64) & 2251799813685247u64 == x & (2251799813685247u64 as u128)) by (bit_vector);\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb0().",
      "display_name": "load8_limb0",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb0().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn load8_limb0(input: &[u8])\n    requires\n        0 + 7 < input.len(),\n    ensures\n        (load8_at_spec(input, 0) as u64) & mask51 == (input[0] * pow2(0 * 8)) + (input[1] * pow2(\n            1 * 8,\n        )) + (input[2] * pow2(2 * 8)) + (input[3] * pow2(3 * 8)) + (input[4] * pow2(4 * 8)) + (\n        input[5] * pow2(5 * 8)) + ((input[6] as nat % pow2(3)) * pow2(6 * 8)),\n{\n    let i = 0;\n    let k = 0;\n\n    let j_div = 0;\n    let j_id = 6;\n    let j_shift = 7;\n\n    assert(load8_at_spec(input, 0) as u64 == (load8_at_spec(input, 0) as u64 >> 0)) by {\n        shr_zero_is_id(load8_at_spec(input, 0) as u64);\n    }\n\n    load8_limb_X(input, i, k, j_div, j_id, j_shift);\n\n    // Sanity check\n    assert((load8_at_spec(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n        / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n    pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64));\n\n    assert(pow2(0) == 1) by {\n        lemma2_to64();\n    }\n\n    broadcast use lemma_div_basics_2;  // x / 1 = x\n\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_unmasked_limbs().",
      "display_name": "compute_unmasked_limbs",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_unmasked_limbs().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/as_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/as_bytes_lemmas.rs",
      "file_name": "as_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_5_bytes_reconstruct().",
      "display_name": "lemma_5_bytes_reconstruct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_5_bytes_reconstruct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_5_bytes_reconstruct(\n    value: nat,\n    byte0: u8,\n    byte1: u8,\n    byte2: u8,\n    byte3: u8,\n    byte4: u8,\n)\n    requires\n        byte0 as nat == (value / pow2(0)) % 256,\n        byte1 as nat == (value / pow2(8)) % 256,\n        byte2 as nat == (value / pow2(16)) % 256,\n        byte3 as nat == (value / pow2(24)) % 256,\n        byte4 as nat == (value / pow2(32)) % 256,\n        value < pow2(40),  // 5 bytes = 40 bits\n\n    ensures\n        byte0 as nat * pow2(0) + byte1 as nat * pow2(8) + byte2 as nat * pow2(16) + byte3 as nat\n            * pow2(24) + byte4 as nat * pow2(32) == value,\n{\n    lemma2_to64();\n\n    assert(byte0 == (value % pow2(1 * 8)) && byte1 == (value % pow2(1 * 8 + 8)) / pow2(1 * 8)\n        && byte2 == (value % pow2(2 * 8 + 8)) / pow2(2 * 8) && byte3 == (value % pow2(3 * 8 + 8))\n        / pow2(3 * 8) && byte4 == (value % pow2(4 * 8 + 8)) / pow2(4 * 8)) by {\n        mask_div2(value, 0, 8);\n        mask_div2(value, 8, 8);\n        mask_div2(value, 16, 8);\n        mask_div2(value, 24, 8);\n        mask_div2(value, 32, 8);\n\n        assert(byte0 == value % pow2(1 * 8)) by {\n            lemma_div_basics_2((value % pow2(1 * 8)) as int);\n        }\n    }\n\n    assert forall|i: nat| 1 <= i <= 4 implies #[trigger] (value % pow2(i * 8)) + ((value % pow2(\n        i * 8 + 8,\n    )) / pow2(i * 8)) * pow2(i * 8) == value % pow2(i * 8 + 8) by {\n        let v = value % pow2(i * 8 + 8);\n        let d = pow2(i * 8);\n\n        assert(v == (v / d) * d + v % d) by {\n            lemma_fundamental_div_mod(v as int, d as int);\n        }\n\n        assert(pow2(i * 8 + 8) == pow2(i * 8) * pow2(8)) by {\n            lemma_pow2_adds(i * 8, 8);\n        }\n\n        assert(v % d == value % d) by {\n            lemma_pow2_pos(i * 8);\n            lemma_pow2_pos(8);\n            assert((value % (d * pow2(8))) % d == value % d) by {\n                lemma_mod_mod(value as int, d as int, pow2(8) as int);\n            }\n        }\n    }\n\n    assert(value % pow2(4 * 8 + 8) == value) by {\n        lemma_small_mod(value, pow2(40));\n    }\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "display_name": "as_radix_16",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "pub(crate) fn as_radix_16(&self) -> (result:\n    [i8; 64])\n// VERIFICATION NOTE: PROOF BYPASS\n\n    requires\n// Top bit must be clear (scalar < 2^255)\n\n        self.bytes[31] <= 127,\n    ensures\n// Result digits are in valid range\n\n        is_valid_radix_16(&result),\n        // Reconstruction property: digits reconstruct the scalar value\n        reconstruct_radix_16(result@) == scalar_to_nat(self) as int,\n{\n    // VERIFICATION NOTE: we tell verus not to verify debug assertions\n    #[cfg(not(verus_keep_ghost))]\n    debug_assert!(self[31] <= 127);\n    let mut output = [0i8;64];\n\n    // Step 1: change radix.\n    // Convert from radix 256 (bytes) to radix 16 (nibbles)\n    // VERIFICATION NOTE: Moved helper functions outside for Verus compatibility\n    /* <ORIGINAL CODE>\n            #[allow(clippy::identity_op)]\n            #[inline(always)]\n            fn bot_half(x: u8) -> u8 {\n                (x >> 0) & 15\n            }\n            #[inline(always)]\n            fn top_half(x: u8) -> u8 {\n                (x >> 4) & 15\n            }\n\n            for i in 0..32 {\n                output[2 * i] = bot_half(self[i]) as i8;\n                output[2 * i + 1] = top_half(self[i]) as i8;\n            }\n            </ORIGINAL CODE> */\n    for i in 0..32 {\n        output[2 * i] = bot_half(self.bytes[i]) as i8;\n        output[2 * i + 1] = top_half(self.bytes[i]) as i8;\n    }\n    // Precondition note: since self[31] <= 127, output[63] <= 7\n\n    // Step 2: recenter coefficients from [0,16) to [-8,8)\n    for i in 0..63 {\n        assume(false);\n        let carry = (output[i] + 8) >> 4;\n        output[i] -= carry << 4;\n        /* <ORIGINAL CODE> :\n                output[i + 1] += carry;\n                </ORIGINAL CODE> */\n        // VERIFICATION NOTE: Changed += to explicit assignment for Verus compatibility\n        // Verus doesn't support += on indexed arrays with computed indices\n        let next_idx = i + 1;\n        output[next_idx] += carry;\n    }\n    // Precondition note: output[63] is not recentered.  It\n    // increases by carry <= 1.  Thus output[63] <= 8.\n\n    // VERIFICATION NOTE: PROOF BYPASS - assume postconditions\n    proof {\n        assume(is_valid_radix_16(&output));\n        assume(reconstruct_radix_16(output@) == scalar_to_nat(self) as int);\n    }\n\n    output\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_nonzero().",
      "display_name": "lemma_mul_nonzero",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_nonzero().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_verus",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn default() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint::identity()\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#to_bytes().",
      "display_name": "to_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#to_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub const fn to_bytes(&self) -> (result: [u8; 32])\n        ensures\n            result == self.0,\n    {\n        self.0\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat_32_u8().",
      "display_name": "as_nat_32_u8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat_32_u8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "    ensures\n        (x as u128) * (y as u128) < (1u128 << 104),\n{\n    assert(1u128 << 52 == 1u64 << 52) by (bit_vector);\n    calc! {\n        (<)\n        (x as u128) * (y as u128); (<=) {\n            if x > 0 {\n                lemma_mul_strict_inequality(y as int, (1u128 << 52) as int, x as int);\n                assert(x * y < x * (1u128 << 52));\n            } else {\n                assert((0 as u128) * (y as u128) == 0);\n            }\n        }\n        (x as u128) * (1u128 << 52); (<) {\n            lemma_mul_strict_inequality(x as int, (1u128 << 52) as int, (1u128 << 52) as int);\n        }\n        (1u128 << 52) * (1u128 << 52);\n    }\n    assert((1u128 << 52) * (1u128 << 52) == (1u128 << 104)) by (compute);\n}",
      "is_libsignal": false,
      "caller_count": 10,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_shift_bounded().",
      "display_name": "c_i_shift_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_shift_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_add_then_shift().",
      "display_name": "lemma_add_then_shift",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_add_then_shift().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_add_then_shift(a: u64, b: u64)\n    requires\n        a < (1u64 << 52),\n        b < (1u64 << 52),\n    ensures\n        (a + b) < (1u64 << 53),\n        ((a + b) as u64 >> 51) < 4,\n{\n    lemma2_to64_rest();\n    assert((a + b) < 1u64 << 53) by {\n        assert((1u64 << 52) + (1u64 << 52) == 1u64 << 53) by (compute);\n    }\n    assert(1u64 << 53 == (1u64 << 51) * 4) by (bit_vector);\n    // 0 < b  /\\ a < b * c => a/b < c\n    lemma_multiply_divide_lt((a + b) as int, (1u64 << 51) as int, 4int);\n    shift_is_pow2(51);\n    shift_is_pow2(53);\n    assert((a + b) as u64 >> 51 == (a + b) as u64 / (pow2(51) as u64)) by {\n        lemma_u64_shr_is_div((a + b) as u64, 51);\n    }\n    assert(pow2(53) / pow2(51) == 4) by {\n        lemma_pow2_subtracts(51, 53);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_multiscalar_mul().",
      "display_name": "vartime_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn vartime_multiscalar_mul<I>(&self, static_scalars: I) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n    {\n        use core::iter;\n\n        Self::vartime_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            iter::empty::<Scalar>(),\n            iter::empty::<Self::Point>(),\n        )\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_congruent_nat().",
      "display_name": "scalar_congruent_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_congruent_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar_helpers.rs",
      "relative_path": "src/scalar_helpers.rs",
      "file_name": "scalar_helpers.rs",
      "parent_folder": "src",
      "body": "            assert(scalars@.subrange(0, n as int) =~= scalars@);\n        }\n\n        acc\n    }\n\n    /// Compute the sum of all scalars in a slice.\n    ///\n    /// # Returns\n    ///\n    /// The sum of all scalars modulo the group order.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// let scalars = [\n    ///     Scalar::from(2u64),\n    ///     Scalar::from(3u64),\n    ///     Scalar::from(5u64),\n    /// ];\n    ///\n    /// let sum = Scalar::sum_of_slice(&scalars);\n    /// assert_eq!(sum, Scalar::from(10u64));\n    /// ```\n    /* <VERIFICATION NOTE>\n     Refactored for Verus: Use index-based loop over slice\n    </VERIFICATION NOTE> */\n    #[allow(clippy::needless_range_loop, clippy::op_ref)]\n    pub fn sum_of_slice(scalars: &[Scalar]) -> (result: Scalar)\n        ensures\n    // Result is a valid scalar (bytes represent a value < group_order)\n\n            scalar_to_nat(&result) < group_order(),\n            // Result represents the sum of all scalars in the slice (mod group_order)\n            scalar_congruent_nat(&result, sum_of_scalars(scalars@)),\n    {\n        let n = scalars.len();\n        let mut acc = Scalar::ZERO;\n\n        proof {\n            // Assume properties of Scalar::ZERO\n            assume(scalar_to_nat(&acc) < group_order());\n            assume(scalar_to_nat(&acc) == 0);\n            assume(scalar_congruent_nat(&acc, sum_of_scalars(scalars@.subrange(0, 0))));\n        }\n\n        for i in 0..n\n            invariant\n                n == scalars.len(),\n                scalar_to_nat(&acc) < group_order(),\n                // acc represents the sum of scalars[0..i]\n                scalar_congruent_nat(&acc, sum_of_scalars(scalars@.subrange(0, i as int))),\n        {\n            proof {\n                // Assume preconditions for addition are satisfied\n                assume(false);\n            }\n            acc = &acc + &scalars[i];\n\n            proof {\n                // Assume the result maintains the invariant\n                assume(scalar_to_nat(&acc) < group_order());\n                assume(scalar_congruent_nat(\n                    &acc,\n                    sum_of_scalars(scalars@.subrange(0, (i + 1) as int)),\n                ));\n            }\n        }\n\n        proof {\n            // At this point, acc is the sum of all scalars\n            assert(scalars@.subrange(0, n as int) =~= scalars@);\n        }\n\n        acc\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/pow().",
      "display_name": "pow",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/pow().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c4_val().",
      "display_name": "c4_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c4_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_limbs5().",
      "display_name": "ct_eq_limbs5",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_limbs5().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn ct_eq_limbs5(a: &[u64; 5], b: &[u64; 5]) -> (c: Choice)\n    ensures\n        choice_is_true(c) == (*a == *b),\n{\n    a.ct_eq(b)\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_bytes().",
      "display_name": "to_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_mod_u8().",
      "display_name": "pow2_MUL_div_mod_u8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_mod_u8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "    assert(s5 == s4_0 / ps64 + a5 / ps64) by {\n        lemma_bitops_lifted(s4_0, input[i + 5] as u64, 5 * 8, s);\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_remainder_bound().",
      "display_name": "lemma_radix51_remainder_bound",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_remainder_bound().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_radix51_remainder_bound(r0: int, r1: int, r2: int, r3: int, r4: int)\n    requires\n        0 <= r0 < (pow2(51) as int),\n        0 <= r1 < (pow2(51) as int),\n        0 <= r2 < (pow2(51) as int),\n        0 <= r3 < (pow2(51) as int),\n        0 <= r4 < (pow2(51) as int),\n    ensures\n        r0 + r1 * (pow2(51) as int) + r2 * (pow2(102) as int) + r3 * (pow2(153) as int) + r4 * (\n        pow2(204) as int) < (pow2(255) as int),\n{\n    lemma_pow2_pos(51);\n    lemma_pow2_adds(51, 51);\n    lemma_pow2_adds(51, 102);\n    lemma_pow2_adds(51, 153);\n    lemma_pow2_adds(51, 204);\n\n    let sum = r0 + r1 * (pow2(51) as int) + r2 * (pow2(102) as int) + r3 * (pow2(153) as int) + r4\n        * (pow2(204) as int);\n\n    // Each term r_i * 2^(51*i) < 2^51 * 2^(51*i) = 2^(51*(i+1))\n\n    assert(r1 * pow2(51) <= pow2(102) - pow2(51)) by {\n        pow2_mul_general(r1 as nat, 51, 51);\n    }\n\n    assert(r2 * pow2(102) <= pow2(153) - pow2(102)) by {\n        pow2_mul_general(r2 as nat, 51, 102);\n    }\n\n    assert(r3 * pow2(153) <= pow2(204) - pow2(153)) by {\n        pow2_mul_general(r3 as nat, 51, 153);\n    }\n\n    assert(r4 * pow2(204) <= pow2(255) - pow2(204)) by {\n        pow2_mul_general(r4 as nat, 51, 204);\n    }\n\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb1_byte_contribution_52().",
      "display_name": "limb1_byte_contribution_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb1_byte_contribution_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub open spec fn limb1_byte_contribution_52(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    // Byte 6 high 4 bits (limbs[1]'s bits 0-3)\n    ((limbs[1] as nat % pow2(4)) * 16) * pow2(6 * 8) + bytes[7] as nat * pow2(7 * 8)\n        + bytes[8] as nat * pow2(8 * 8) + bytes[9] as nat * pow2(9 * 8) + bytes[10] as nat * pow2(\n        10 * 8,\n    ) + bytes[11] as nat * pow2(11 * 8) + bytes[12] as nat * pow2(12 * 8)\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_inverse_field_of_nat().",
      "display_name": "is_inverse_field_of_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_inverse_field_of_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field_specs.rs",
      "relative_path": "src/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "src",
      "body": "pub open spec fn is_inverse_field_of_nat(fe: &FieldElement51, n: nat) -> bool {\n    (field_element_as_nat(fe) * n) % p() == 1\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_4_terms().",
      "display_name": "mul_4_terms",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_4_terms().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn mul_4_terms(n: int, x1: int, x2: int, x3: int, x4: int)\n    ensures\n        n * (x1 + x2 + x3 + x4) == (x1 + x2 + x3 + x4) * n == n * x1 + n * x2 + n * x3 + n * x4,\n{\n    assert(n * (x1 + x2 + x3 + x4) == (x1 + x2 + x3 + x4) * n) by {\n        lemma_mul_is_commutative(n, x1 + x2 + x3 + x4);\n    }\n\n    assert(n * (x1 + x2 + x3 + x4) == n * (x1 + x2 + x3) + n * x4) by {\n        lemma_mul_is_distributive_add(n, x1 + x2 + x3, x4);\n    }\n\n    assert(n * (x1 + x2 + x3) == n * x1 + n * x2 + n * x3) by {\n        mul_3_terms(n, x1, x2, x3);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_to_nat().",
      "display_name": "scalar_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar_helpers.rs",
      "relative_path": "src/scalar_helpers.rs",
      "file_name": "scalar_helpers.rs",
      "parent_folder": "src",
      "body": "    /// assert_eq!(product, Scalar::from(30u64));\n    /// ```\n    #[allow(clippy::needless_range_loop, clippy::op_ref)]\n    pub fn product_of_slice(scalars: &[Scalar]) -> (result: Scalar)\n        ensures\n    // Result is a valid scalar (bytes represent a value < group_order)\n\n            scalar_to_nat(&result) < group_order(),\n            // Result represents the product of all scalars in the slice (mod group_order)\n            scalar_congruent_nat(&result, product_of_scalars(scalars@)),\n    {\n        let n = scalars.len();\n        let mut acc = Scalar::ONE;\n\n        proof {\n            // Assume properties of Scalar::ONE\n            assume(scalar_to_nat(&acc) < group_order());\n            assume(scalar_to_nat(&acc) == 1);\n            assume(scalar_congruent_nat(&acc, product_of_scalars(scalars@.subrange(0, 0))));\n        }\n\n        for i in 0..n\n            invariant\n                n == scalars.len(),\n                scalar_to_nat(&acc) < group_order(),\n                // acc represents the product of scalars[0..i]\n                scalar_congruent_nat(&acc, product_of_scalars(scalars@.subrange(0, i as int))),\n        {\n            proof {\n                // Assume preconditions for multiplication are satisfied\n                assume(false);\n            }\n            acc = &acc * &scalars[i];\n\n            proof {\n                // Assume the result maintains the invariant\n                assume(scalar_to_nat(&acc) < group_order());\n                assume(scalar_congruent_nat(\n                    &acc,\n                    product_of_scalars(scalars@.subrange(0, (i + 1) as int)),\n                ));\n            }\n        }\n\n        proof {\n            // At this point, acc is the product of all scalars\n            assert(scalars@.subrange(0, n as int) =~= scalars@);\n        }\n\n        acc\n    }",
      "is_libsignal": false,
      "caller_count": 12,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash_verus().",
      "display_name": "from_hash_verus",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash_verus().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn from_hash_verus(hash_bytes: [u8; 64]) -> (result: Scalar)\n        ensures\n            is_random_bytes(&hash_bytes) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        let result = Scalar::from_bytes_mod_order_wide(&hash_bytes);\n        assume(false);\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "display_name": "square2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    pub fn square2(&self) -> (r: FieldElement51)\n        requires\n    // The precondition in pow2k loop propagates to here\n\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54,\n        ensures\n            as_nat(r.limbs) % p() == (2 * pow(as_nat(self.limbs) as int, 2)) as nat % p(),\n    {\n        let mut square = self.pow2k(1);\n\n        // Since square is mut, we save the initial value\n        let ghost old_limbs = square.limbs;\n\n        proof {\n            // forall |i: int| 0 <= i < 5 ==> 2 * old_limbs[i] <= u64::MAX\n            assert forall|i: int| 0 <= i < 5 implies 2 * square.limbs[i] <= u64::MAX by {\n                // if LHS < RHS, then 2 * LHS < 2 * RHS\n                lemma_mul_left_inequality(2, square.limbs[i] as int, (1u64 << 54) as int);\n                assert(2 * (1u64 << 54) <= u64::MAX) by (compute);\n            }\n\n            let ka = [\n                (2 * square.limbs[0]) as u64,\n                (2 * square.limbs[1]) as u64,\n                (2 * square.limbs[2]) as u64,\n                (2 * square.limbs[3]) as u64,\n                (2 * square.limbs[4]) as u64,\n            ];\n\n            // as_nat(ka) == 2 * as_nat(square.limbs)\n            // and\n            // as_nat(ka) % p() == (2 * as_nat(square.limbs)) % p()\n            as_nat_k(square.limbs, 2);\n\n            // By pow2k ensures:\n            // as_nat(square.limbs) % p() == pow(as_nat(self.limbs) as int, pow2(1)) as nat % p()\n            // We just need pow2(1) == 2\n            lemma2_to64();\n\n            // p > 0\n            pow255_gt_19();\n\n            assert(as_nat(ka) % p() == ((2nat % p()) * (as_nat(square.limbs) % p())) % p() == ((2nat\n                % p()) * (pow(as_nat(self.limbs) as int, 2) as nat % p())) % p()) by {\n                lemma_mul_mod_noop(2, as_nat(square.limbs) as int, p() as int);\n            }\n\n            // as_nat(self.limbs)^2 >= 0\n            assert(pow(as_nat(self.limbs) as int, 2) >= 0) by {\n                lemma_pow_nat_is_nat(as_nat(self.limbs), 1);\n            }\n\n            assert(((2nat % p()) * (pow(as_nat(self.limbs) as int, 2) as nat % p())) % p() == (2 * (\n            pow(as_nat(self.limbs) as int, 2))) as nat % p()) by {\n                lemma_mul_mod_noop(2, pow(as_nat(self.limbs) as int, 2) as int, p() as int);\n            }\n\n            assert(as_nat(ka) % p() == (2 * (pow(as_nat(self.limbs) as int, 2))) as nat % p());\n        }\n\n        for i in 0..5\n            invariant\n                forall|j: int| 0 <= j < 5 ==> old_limbs[j] < (1u64 << 54),\n                forall|j: int| 0 <= j < i ==> #[trigger] square.limbs[j] == 2 * old_limbs[j],\n                forall|j: int| i <= j < 5 ==> #[trigger] square.limbs[j] == old_limbs[j],\n        {\n            proof {\n                assert(2 * (1u64 << 54) <= u64::MAX) by (compute);\n                lemma_mul_strict_inequality(square.limbs[i as int] as int, (1u64 << 54) as int, 2);\n            }\n            square.limbs[i] *= 2;\n        }\n\n        square\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_general_bound().",
      "display_name": "lemma_general_bound",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_general_bound().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_general_bound(a: Seq<u64>)\n    requires\n        forall|i: int| 0 <= i < a.len() ==> a[i] < (1u64 << 52),\n    ensures\n        seq_u64_to_nat(a) < pow2((52 * a.len() as nat)),\n    decreases a.len(),\n{\n    if a.len() == 0 {\n        assert(seq_u64_to_nat(a) == 0);\n        lemma2_to64();  // Gives us pow2(0) == 1 among other facts\n        assert(pow2(0) == 1);\n    } else {\n        // Inductive case\n        let tail = a.subrange(1, a.len() as int);\n\n        // Apply induction hypothesis on tail\n        assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] < (1u64 << 52)) by {\n            assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] == a[i + 1]);\n        };\n\n        assert(tail.len() == a.len() - 1);\n\n        // Apply induction hypothesis\n        lemma_general_bound(tail);\n        assert(seq_u64_to_nat(tail) < pow2((52 * tail.len() as nat)));\n\n        // Now prove for the full sequence\n        assert(seq_u64_to_nat(a) == seq_to_nat(a.map(|i, x| x as nat)));\n        assert(a.map(|i, x| x as nat).len() == a.len());\n        assert(a.map(|i, x| x as nat)[0] == a[0] as nat);\n        assert(a.map(|i, x| x as nat).subrange(1, a.len() as int) == a.subrange(\n            1,\n            a.len() as int,\n        ).map(|i, x| x as nat));\n        // Therefore:\n        assert(seq_u64_to_nat(a) == a[0] as nat + seq_u64_to_nat(a.subrange(1, a.len() as int))\n            * pow2(52));\n\n        assert(a.subrange(1, a.len() as int) == tail);\n\n        // From precondition\n        assert(a[0] < (1u64 << 52));\n        lemma2_to64_rest();\n        assert(0x10000000000000 == 1u64 << 52) by (compute_only);\n        assert(0x10000000000000 == pow2(52));\n        assert((1u64 << 52) == pow2(52));\n\n        // We have seq_u64_to_nat(a) == a[0] + seq_u64_to_nat(tail) * pow2(52)\n        // We know a[0] < pow2(52) and seq_u64_to_nat(tail) < pow2(52 * (a.len() - 1))\n\n        assert(a[0] as nat <= pow2(52) - 1);\n        assert(seq_u64_to_nat(tail) <= pow2(52 * (a.len() - 1) as nat) - 1);\n\n        assert(seq_u64_to_nat(a) <= (pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(\n            52,\n        )) by {\n            lemma_mul_inequality(\n                (pow2(52 * (a.len() - 1) as nat) - 1) as int,\n                pow2(52 * (a.len() - 1) as nat) as int,\n                pow2(52) as int,\n            );\n        };\n\n        // Expand the right side\n        assert((pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(52) == pow2(52) - 1\n            + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52)) by {\n            broadcast use lemma_mul_is_distributive_sub;\n\n        };\n\n        assert(pow2(52) - 1 + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52) == pow2(\n            52 * (a.len() - 1) as nat,\n        ) * pow2(52) - 1);\n\n        lemma_pow2_adds(52 * (a.len() - 1) as nat, 52);\n        assert(pow2(52 * (a.len() - 1) as nat) * pow2(52) == pow2(52 * (a.len() - 1) as nat + 52));\n        assert(52 * (a.len() - 1) as nat + 52 == 52 * a.len() as nat);\n\n        assert(seq_u64_to_nat(a) <= pow2(52 * a.len() as nat) - 1);\n        assert(seq_u64_to_nat(a) < pow2(52 * a.len() as nat));\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_is_division().",
      "display_name": "lemma_carry_propagation_is_division",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_is_division().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_carry_propagation_is_division(limbs: [u64; 5], q: u64)\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 52),\n        q == compute_q_spec(limbs),\n    ensures\n        q as nat == (as_nat(limbs) + 19) / pow2(255),\n{\n    // Setup: establish basic power-of-2 facts (needed for overflow checks)\n    lemma_carry_propagation_setup();\n\n    // Extract the carry values computed by the algorithm\n    let q0 = ((limbs[0] + 19) as u64 >> 51) as u64;\n    let q1 = ((limbs[1] + q0) as u64 >> 51) as u64;\n    let q2 = ((limbs[2] + q1) as u64 >> 51) as u64;\n    let q3 = ((limbs[3] + q2) as u64 >> 51) as u64;\n    let q4 = ((limbs[4] + q3) as u64 >> 51) as u64;\n\n    // Prove all carries are bounded by 3 (needed for no overflow)\n    lemma_all_carries_bounded_by_3(limbs);\n\n    // Prove no overflow for all stages (each limb < 2^52, each carry < 3)\n\n    // Stage 0: Process limbs[0] + 19\n    lemma_single_stage_division(limbs[0], 19, (limbs[0] + 19) as u64, q0);\n    let r0 = lemma_stage_division_theorem(limbs[0], 19, q0 as int);\n\n    // Stage 1: Process limbs[1] + q0\n    lemma_single_stage_division(limbs[1], q0, (limbs[1] + q0) as u64, q1);\n    let r1 = lemma_stage_division_theorem(limbs[1], q0 as int, q1 as int);\n\n    // Stage 2: Process limbs[2] + q1\n    lemma_single_stage_division(limbs[2], q1, (limbs[2] + q1) as u64, q2);\n    let r2 = lemma_stage_division_theorem(limbs[2], q1 as int, q2 as int);\n\n    // Stage 3: Process limbs[3] + q2\n    lemma_single_stage_division(limbs[3], q2, (limbs[3] + q2) as u64, q3);\n    let r3 = lemma_stage_division_theorem(limbs[3], q2 as int, q3 as int);\n\n    // Stage 4: Process limbs[4] + q3\n    lemma_single_stage_division(limbs[4], q3, (limbs[4] + q3) as u64, q4);\n    let r4 = lemma_stage_division_theorem(limbs[4], q3 as int, q4 as int);\n\n    // Telescoping property: show that q4 = (as_nat(limbs) + 19) / 2^255\n    // Use the remainders we just computed to directly prove the telescoping division\n    lemma_radix51_telescoping_direct(\n        limbs,\n        q0 as int,\n        q1 as int,\n        q2 as int,\n        q3 as int,\n        q4 as int,\n        r0,\n        r1,\n        r2,\n        r3,\n        r4,\n    );\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 CtOption#is_none().",
      "display_name": "is_none",
      "symbol": "rust-analyzer cargo subtle 2.6.1 CtOption#is_none().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn default() -> RistrettoPoint {\n        RistrettoPoint::identity()\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/words_to_nat().",
      "display_name": "words_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/words_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "                proof {\n                    assert(i < 4 && j < 8);\n                    assert((i as u64) * 8u64 < 32u64);\n                    let idx = (i as u64) * 8 + (j as u64);\n                    assert(idx < 32);\n                }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn identity() -> AffineNielsPoint {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::ONE,\n            y_minus_x: FieldElement::ONE,\n            xy2d: FieldElement::ZERO,\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_to_le_bytes().",
      "display_name": "u32_to_le_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_to_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//! To construct a `Scalar` as the hash of some input data, use\n//! [`Scalar::hash_from_bytes`], which takes a buffer, or\n//! [`Scalar::from_hash`], which allows an IUF API.\n//!\n#![cfg_attr(feature = \"digest\", doc = \"```\")]\n#![cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n//! # fn main() {\n//! use sha2::{Digest, Sha512};\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! // Hashing a single byte slice\n//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes().",
      "display_name": "hash_from_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn hash_from_bytes<D>(input: &[u8]) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64> + Default,\n\n        ensures\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        Scalar::from_hash(hash)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_from_le_bytes().",
      "display_name": "u16_from_le_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_from_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub fn u16_from_le_bytes(bytes: [u8; 2]) -> (x: u16)\n    ensures\n        x as nat == bytes_seq_to_nat(seq_from2(&bytes)),\n{\n    u16::from_le_bytes(bytes)\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "        let i = &constants::SQRT_M1;\n        let d = &constants::EDWARDS_D;\n        let one_minus_d_sq = &constants::ONE_MINUS_EDWARDS_D_SQUARED;\n        let d_minus_one_sq = &constants::EDWARDS_D_MINUS_ONE_SQUARED;\n        let mut c = constants::MINUS_ONE;\n\n        let one = FieldElement::ONE;\n\n        let r = i * &r_0.square();\n        let N_s = &(&r + &one) * one_minus_d_sq;\n        let D = &(&c - &(d * &r)) * &(&r + d);\n\n        let (Ns_D_is_sq, mut s) = FieldElement::sqrt_ratio_i(&N_s, &D);\n        let mut s_prime = &s * r_0;\n        let s_prime_is_pos = !s_prime.is_negative();\n        s_prime.conditional_negate(s_prime_is_pos);\n\n        s.conditional_assign(&s_prime, !Ns_D_is_sq);\n        c.conditional_assign(&r, !Ns_D_is_sq);\n\n        let N_t = &(&(&c * &(&r - &one)) * d_minus_one_sq) - &D;\n        let s_sq = s.square();\n\n        use crate::backend::serial::curve_models::CompletedPoint;\n\n        // The conversion from W_i is exactly the conversion from P1xP1.\n        RistrettoPoint(\n            CompletedPoint {\n                X: &(&s + &s) * &D,\n                Z: &N_t * &constants::SQRT_AD_MINUS_ONE,\n                Y: &FieldElement::ONE - &s_sq,\n                T: &FieldElement::ONE + &s_sq,\n            }",
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limbs_to_bytes().",
      "display_name": "lemma_limbs_to_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limbs_to_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::pow_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::shift_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_nat_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::compute_q_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::field_core::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::from_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::limbs_to_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::load8_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::negate_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2_51_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#SubAssign#sub_assign().",
      "display_name": "sub_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#SubAssign#sub_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn sub_assign(&mut self, _rhs: &'b EdwardsPoint) {\n        *self = (self as &EdwardsPoint) - _rhs;\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "display_name": "unpack",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "pub fn unpack(&self) -> (result:\n    UnpackedScalar)\n// VERIFICATION NOTE: VERIFIED (changed pub(crate) to pub)\n\n    ensures\n        limbs_bounded(&result),\n        to_nat(&result.limbs) == bytes_to_nat(&self.bytes),\n        to_nat(&result.limbs) < group_order(),\n{\n    UnpackedScalar::from_bytes(&self.bytes)\n}",
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Sum#sum().",
      "display_name": "sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Sum#sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(EdwardsPoint::identity(), |acc, item| acc + item.borrow())\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat_rec().",
      "display_name": "bytes_to_nat_rec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat_rec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "            } else {\n                assert((0 as u128) * (y as u128) == 0);",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_select_u64().",
      "display_name": "conditional_select_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_select_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "display_name": "conditional_negate",
      "symbol": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_nat().",
      "display_name": "field_element_as_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "use crate::field_specs::*;\n\nverus! {\n\n/* VERIFICATION NOTE: specializing to u64 backend for now */\n/// A `FieldElement` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// The `FieldElement` type is an alias for one of the platform-specific\n/// implementations.\npub(crate) type FieldElement = backend::serial::u64::field::FieldElement51;\n\nimpl Eq for FieldElement {\n\n}\n\nimpl PartialEq for FieldElement {\n    fn eq(&self, other: &FieldElement) -> (result:\n        bool)\n    // VERIFICATION NOTE: PROOF BYPASS AND SPEC BYPASS\n\n        ensures\n            result == (field_element_as_bytes(self) == field_element_as_bytes(\n                other,\n            )),\n    // SPEC BYPASS through placeholder field_element_as_bytes\n\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Choice::into\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.ct_eq(other).into()\n         </ORIGINAL CODE> */\n        let choice = self.ct_eq(other);\n        let result = choice_into(choice);\n\n        // VERIFICATION NOTE: vstd's external trait specification check cannot be satisfied\n        // vstd expects obeys_eq_spec() and eq_spec() from PartialEqSpecImpl trait,\n        // but that trait is not publicly exported, so we bypass with assume(false)\n        assume(false);\n\n        result\n    }\n}\n\nimpl ConstantTimeEq for FieldElement {\n    /// Test equality between two `FieldElement`s.  Since the\n    /// internal representation is not canonical, the field elements\n    /// are normalized to wire format before comparison.\n    fn ct_eq(&self, other: &FieldElement) -> (result:\n        Choice)/* <VERIFICATION NOTE>\n     - PROOF BYPASS AND SPEC BYPASS\n     - Use wrapper functions for ConstantTimeEq and CtOption\n    </VERIFICATION NOTE> */\n\n        ensures\n            choice_is_true(result) == (field_element_as_bytes(self) == field_element_as_bytes(\n                other,\n            )),\n    // SPEC BYPASS through placeholder field_element_as_bytes\n\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Verus compatibility instead of direct subtle call\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.as_bytes().ct_eq(&other.as_bytes())\n         </ORIGINAL CODE> */\n        let result = ct_eq_bytes32(&self.as_bytes(), &other.as_bytes());\n        assume(choice_is_true(result) == (field_element_as_bytes(self) == field_element_as_bytes(\n            other,\n        )));\n        result\n    }\n}\n\nimpl FieldElement {\n    /// Determine if this `FieldElement` is negative, in the sense\n    /// used in the ed25519 paper: `x` is negative if the low bit is\n    /// set.\n    ///\n    /// # Return\n    ///\n    /// If negative, return `Choice(1)`.  Otherwise, return `Choice(0)`.\n    pub(crate) fn is_negative(&self) -> (result:\n        Choice)/* VERIFICATION NOTE:\n    - PROOF BYPASS AND SPEC BYPASS\n    - we cannot write this directly; need to find a spec function for FieldElement51::as_bytes\n    ensures choice_is_true(result) == (self.as_bytes()[0] & 1 == 1)\n    - (note after slack call: maybe the first bit of as_bytes() is sufficient as a spec)\n    </VERIFICATION NOTE> */\n\n        ensures\n            choice_is_true(result) == (field_element_as_bytes(self)[0] & 1\n                == 1),\n    // SPEC BYPASS through placeholder field_element_as_bytes\n\n    {\n        let bytes = self.as_bytes();\n        let result = Choice::from(bytes[0] & 1);\n        assume(choice_is_true(result) == (field_element_as_bytes(self)[0] & 1 == 1));\n        result\n    }\n\n    /// Determine if this `FieldElement` is zero.\n    ///\n    /// # Return\n    ///\n    /// If zero, return `Choice(1)`.  Otherwise, return `Choice(0)`.\n    pub(crate) fn is_zero(&self) -> (result:\n        Choice)/* VERIFICATION NOTE:\n    - PROOF BYPASS AND SPEC BYPASS\n    - we cannot write this directly; need to find a spec function for FieldElement51::as_bytes\n    ensures choice_is_true(result) == (self.as_bytes() == [0u8; 32])\n    - (note: maybe an all_zeroes(as_bytes(...)) is sufficient as a spec)\n    </VERIFICATION NOTE> */\n\n        ensures\n            choice_is_true(result) == (field_element_as_bytes(self)\n                == seq![0u8; 32]),\n    // SPEC BYPASS through placeholder field_element_as_bytes\n\n    {\n        let zero = [0u8;32];\n        let bytes = self.as_bytes();\n\n        let result = ct_eq_bytes32(&bytes, &zero);\n        assume(choice_is_true(result) == (field_element_as_bytes(self) == seq![0u8; 32]));\n        result\n    }\n\n    /// Compute (self^(2^250-1), self^11), used as a helper function\n    /// within invert() and pow22523().\n    #[rustfmt::skip]  // keep alignment of explanatory comments\n    fn pow22501(&self) -> (result: (FieldElement, FieldElement))\n        ensures\n            field_element_as_nat(&result.0) == pow(\n                field_element_as_nat(self) as int,\n                (pow2(250) - 1) as nat,\n            ) % (p() as int),\n            field_element_as_nat(&result.1) == pow(field_element_as_nat(self) as int, 11) % (\n            p() as int),\n    {\n        // Instead of managing which temporary variables are used\n        // for what, we define as many as we need and leave stack\n        // allocation to the compiler\n        //\n        // Each temporary variable t_i is of the form (self)^e_i.\n        // Squaring t_i corresponds to multiplying e_i by 2,\n        // so the pow2k function shifts e_i left by k places.\n        // Multiplying t_i and t_j corresponds to adding e_i + e_j.\n        //\n        // Temporary t_i                      Nonzero bits of e_i\n        //\n        assume(false);\n        let t0 = self.square();  // 1         e_0 = 2^1\n        let t1 = t0.square().square();  // 3         e_1 = 2^3\n        let t2 = self * &t1;  // 3,0       e_2 = 2^3 + 2^0\n        let t3 = &t0 * &t2;  // 3,1,0\n        let t4 = t3.square();  // 4,2,1\n        let t5 = &t2 * &t4;  // 4,3,2,1,0\n        let t6 = t5.pow2k(5);  // 9,8,7,6,5\n        let t7 = &t6 * &t5;  // 9,8,7,6,5,4,3,2,1,0\n        let t8 = t7.pow2k(10);  // 19..10\n        let t9 = &t8 * &t7;  // 19..0\n        let t10 = t9.pow2k(20);  // 39..20\n        let t11 = &t10 * &t9;  // 39..0\n        let t12 = t11.pow2k(10);  // 49..10\n        let t13 = &t12 * &t7;  // 49..0\n        let t14 = t13.pow2k(50);  // 99..50\n        let t15 = &t14 * &t13;  // 99..0\n        let t16 = t15.pow2k(100);  // 199..100\n        let t17 = &t16 * &t15;  // 199..0\n        let t18 = t17.pow2k(50);  // 249..50\n        let t19 = &t18 * &t13;  // 249..0\n\n        (t19, t3)\n    }\n\n    /// Given a slice of pub(crate)lic `FieldElements`, replace each with its inverse.\n    ///\n    /// When an input `FieldElement` is zero, its value is unchanged.\n    #[cfg(feature = \"alloc\")]\n    pub(crate) fn batch_invert(\n        inputs: &mut [FieldElement],\n    )/* <VERIFICATION NOTE>\n     - Refactored for Verus: Index loops instead of iterators, manual Vec construction\n     - Choice type operations handled by wrappers in subtle_assumes.rs\n     - PROOF BYPASSES because of trait issues and proof obligations.\n    </VERIFICATION NOTE> */\n\n        ensures\n    // Each element is replaced appropriately:\n\n            forall|i: int|\n                #![auto]\n                0 <= i < inputs.len() ==> {\n                    // If input was non-zero, it's replaced with its inverse\n                    (field_element_as_nat(&old(inputs)[i]) != 0) ==> is_inverse_field(\n                        &old(inputs)[i],\n                        &inputs[i],\n                    ) &&\n                    // If input was zero, it remains zero\n                    (field_element_as_nat(&old(inputs)[i]) == 0) ==> field_element_as_nat(\n                        &inputs[i],\n                    ) == 0\n                },\n    {\n        // Montgomery's Trick and Fast Implementation of Masked AES\n        // Genelle, Prouff and Quisquater\n        // Section 3.2\n        let n = inputs.len();\n\n        // Extract ONE constant before loops (similar to scalar.rs pattern)\n        let one = FieldElement::ONE;\n\n        /* <VERIFICATION NOTE>\n         Build vec manually instead of vec![one; n] for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let mut scratch = vec![FieldElement::ONE; n];\n        </ORIGINAL CODE> */\n        let mut scratch = Vec::new();\n        for _ in 0..n {\n            scratch.push(one);\n        }\n\n        // Keep an accumulator of all of the previous products\n        let mut acc = one;\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        /* <VERIFICATION NOTE>\n         Rewritten with index loop instead of .zip() for Verus compatibility\n         Using choice_not() wrapper instead of ! operator\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         for (input, scratch) in inputs.iter().zip(scratch.iter_mut()) {\n            *scratch = acc;\n            // acc <- acc * input, but skipping zeros (constant-time)\n            acc.conditional_assign(&(&acc * input), !input.is_zero());\n        }\n        </ORIGINAL CODE> */\n        for i in 0..n {\n            assume(false);\n            scratch[i] = acc;\n            assume(false);\n            // acc <- acc * input, but skipping zeros (constant-time)\n            acc.conditional_assign(&(&acc * &inputs[i]), choice_not(inputs[i].is_zero()));\n        }\n\n        // acc is nonzero because we skipped zeros in inputs\n        // ORIGINAL: assert!(bool::from(!acc.is_zero()));\n        #[cfg(not(verus_keep_ghost))]\n        assert!(bool::from(choice_not(acc.is_zero())));\n\n        // Compute the inverse of all products\n        acc = acc.invert();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        /* <VERIFICATION NOTE>\n         Manual reverse loop instead of .rev().zip() for Verus compatibility\n         Using choice_not() wrapper instead of ! operator\n         Extract-modify-reassign pattern for mutable indexing\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         for (input, scratch) in inputs.iter_mut().rev().zip(scratch.into_iter().rev()) {\n            let tmp = &acc * input;\n            // input <- acc * scratch, then acc <- tmp\n            // Again, we skip zeros in a constant-time way\n            let nz = !input.is_zero();\n            input.conditional_assign(&(&acc * &scratch), nz);\n            acc.conditional_assign(&tmp, nz);\n        }\n        </ORIGINAL CODE> */\n\n        proof {\n            assume(scratch.len() == n);\n        }\n\n        let mut i: usize = n;\n        while i > 0\n            invariant\n                n == inputs.len(),\n                n == scratch.len(),\n            decreases i,\n        {\n            i -= 1;\n            proof {\n                assume(i < inputs.len());\n                assume(i < scratch.len());\n                assume(0 <= i);\n                assume(false);\n            }\n            let tmp = &acc * &inputs[i];\n            // input <- acc * scratch, then acc <- tmp\n            // Again, we skip zeros in a constant-time way\n            let nz = choice_not(inputs[i].is_zero());\n            // Verus doesn't support index for &mut, so we extract-modify-reassign\n            let mut input_i = inputs[i];\n            input_i.conditional_assign(&(&acc * &scratch[i]), nz);\n            inputs[i] = input_i;\n            acc.conditional_assign(&tmp, nz);\n        }\n\n        proof {\n            // Assume the postconditions hold\n            assume(forall|i: int|\n                #![auto]\n                0 <= i < inputs.len() ==> {\n                    (field_element_as_nat(&old(inputs)[i]) != 0) ==> is_inverse_field(\n                        &old(inputs)[i],\n                        &inputs[i],\n                    ) && (field_element_as_nat(&old(inputs)[i]) == 0) ==> field_element_as_nat(\n                        &inputs[i],\n                    ) == 0\n                });\n        }\n    }\n\n    /// Given a nonzero field element, compute its inverse.\n    ///\n    /// The inverse is computed as self^(p-2), since\n    /// x^(p-2)x = x^(p-1) = 1 (mod p).\n    ///\n    /// This function returns zero on input zero.\n    #[rustfmt::skip]  // keep alignment of explanatory comments\n    #[allow(clippy::let_and_return)]\n    pub(crate) fn invert(&self) -> (result:\n        FieldElement)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n    // If self is non-zero, result is the multiplicative inverse: result * self ≡ 1 (mod p)\n\n            field_element_as_nat(self) != 0 ==> (field_element_as_nat(&result)\n                * field_element_as_nat(self)) % p() == 1,\n            // If self is zero, result is zero\n            field_element_as_nat(self) == 0 ==> field_element_as_nat(&result) == 0,\n            field_element(&result) == field_inv(field_element(self)),\n    {\n        // The bits of p-2 = 2^255 -19 -2 are 11010111111...11.\n        //\n        //                                 nonzero bits of exponent\n        assume(false);\n        let (t19, t3) = self.pow22501();  // t19: 249..0 ; t3: 3,1,0\n        let t20 = t19.pow2k(5);  // 254..5\n        let t21 = &t20 * &t3;  // 254..5,3,1,0\n\n        t21\n    }\n\n    /// Raise this field element to the power (p-5)/8 = 2^252 -3.\n    #[rustfmt::skip]  // keep alignment of explanatory comments\n    #[allow(clippy::let_and_return)]\n    fn pow_p58(&self) -> (result: FieldElement)\n        ensures\n            field_element_as_nat(&result) == pow(\n                field_element_as_nat(self) as int,\n                (pow2(252) - 3) as nat,\n            ) % (p() as int),\n    {\n        // The bits of (p-5)/8 are 101111.....11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, _) = self.pow22501();  // 249..0\n        assume(false);\n        let t20 = t19.pow2k(2);  // 251..2\n        assume(false);\n        let t21 = self * &t20;  // 251..2,0\n\n        t21\n    }\n\n    /// Given `FieldElements` `u` and `v`, compute either `sqrt(u/v)`\n    /// or `sqrt(i*u/v)` in constant time.\n    ///\n    /// This function always returns the nonnegative square root.\n    ///\n    /// # Return\n    ///\n    /// - `(Choice(1), +sqrt(u/v))  ` if `v` is nonzero and `u/v` is square;\n    /// - `(Choice(1), zero)        ` if `u` is zero;\n    /// - `(Choice(0), zero)        ` if `v` is zero and `u` is nonzero;\n    /// - `(Choice(0), +sqrt(i*u/v))` if `u/v` is nonsquare (so `i*u/v` is square).\n    ///\n    pub(crate) fn sqrt_ratio_i(u: &FieldElement, v: &FieldElement) -> (result: (\n        Choice,\n        FieldElement,\n    ))\n        ensures\n    // When u = 0: always return (true, 0)\n\n            (field_element_as_nat(u) == 0) ==> (choice_is_true(result.0) && field_element_as_nat(\n                &result.1,\n            ) == 0),\n            // When v = 0 but u ≠ 0: return (false, 0) [division by zero case]\n            (field_element_as_nat(v) == 0 && field_element_as_nat(u) != 0) ==> (!choice_is_true(\n                result.0,\n            ) && field_element_as_nat(&result.1) == 0),\n            // When successful and v ≠ 0: r² * v ≡ u (mod p)\n            (choice_is_true(result.0) && field_element_as_nat(v) != 0) ==> is_sqrt_ratio(\n                u,\n                v,\n                &result.1,\n            ),\n            // When unsuccessful and v ≠ 0: r² * v ≡ i*u (mod p) [nonsquare case]\n            (!choice_is_true(result.0) && field_element_as_nat(v) != 0 && field_element_as_nat(u)\n                != 0) ==> is_sqrt_ratio_times_i(\n                u,\n                v,\n                &result.1,\n            ),\n    // VERIFICATION NOTE: PROOF BYPASS\n\n    {\n        // Using the same trick as in ed25519 decoding, we merge the\n        // inversion, the square root, and the square test as follows.\n        //\n        // To compute sqrt(α), we can compute β = α^((p+3)/8).\n        // Then β^2 = ±α, so multiplying β by sqrt(-1) if necessary\n        // gives sqrt(α).\n        //\n        // To compute 1/sqrt(α), we observe that\n        //    1/β = α^(p-1 - (p+3)/8) = α^((7p-11)/8)\n        //                            = α^3 * (α^7)^((p-5)/8).\n        //\n        // We can therefore compute sqrt(u/v) = sqrt(u)/sqrt(v)\n        // by first computing\n        //    r = u^((p+3)/8) v^(p-1-(p+3)/8)\n        //      = u u^((p-5)/8) v^3 (v^7)^((p-5)/8)\n        //      = (uv^3) (uv^7)^((p-5)/8).\n        //\n        // If v is nonzero and u/v is square, then r^2 = ±u/v,\n        //                                     so vr^2 = ±u.\n        // If vr^2 =  u, then sqrt(u/v) = r.\n        // If vr^2 = -u, then sqrt(u/v) = r*sqrt(-1).\n        //\n        // If v is zero, r is also zero.\n        proof {\n            assume(false);  // PROOF BYPASS\n        }\n        let v3 = &v.square() * v;\n        let v7 = &v3.square() * v;\n        let mut r = &(u * &v3) * &(u * &v7).pow_p58();\n        let check = v * &r.square();\n\n        let i = &constants::SQRT_M1;\n\n        let correct_sign_sqrt = check.ct_eq(u);\n\n        // ORIGINAL CODE:\n        // let flipped_sign_sqrt = check.ct_eq(&(-u));\n        // let flipped_sign_sqrt_i = check.ct_eq(&(&(-u) * i));\n        // REFACTORED: Use wrapper to avoid Verus internal error with negation\n        let u_neg = negate_field(u);\n        let flipped_sign_sqrt = check.ct_eq(&u_neg);\n        let flipped_sign_sqrt_i = check.ct_eq(&(&u_neg * i));\n\n        let r_prime = &constants::SQRT_M1 * &r;\n        // ORIGINAL CODE:\n        // r.conditional_assign(&r_prime, flipped_sign_sqrt | flipped_sign_sqrt_i);\n        // REFACTORED: Use wrapper for Choice bitwise OR\n        r.conditional_assign(&r_prime, choice_or(flipped_sign_sqrt, flipped_sign_sqrt_i));\n\n        // Choose the nonnegative square root.\n        let r_is_negative = r.is_negative();\n        // ORIGINAL CODE:\n        // r.conditional_negate(r_is_negative);\n        // REFACTORED: Use wrapper for conditional_negate\n        conditional_negate_field(&mut r, r_is_negative);\n\n        // ORIGINAL CODE:\n        // let was_nonzero_square = correct_sign_sqrt | flipped_sign_sqrt;\n        // REFACTORED: Use wrapper for Choice bitwise OR\n        let was_nonzero_square = choice_or(correct_sign_sqrt, flipped_sign_sqrt);\n\n        (was_nonzero_square, r)\n    }\n\n    /// Attempt to compute `sqrt(1/self)` in constant time.\n    ///\n    /// Convenience wrapper around `sqrt_ratio_i`.\n    ///\n    /// This function always returns the nonnegative square root.\n    ///\n    /// # Return\n    ///\n    /// - `(Choice(1), +sqrt(1/self))  ` if `self` is a nonzero square;\n    /// - `(Choice(0), zero)           ` if `self` is zero;\n    /// - `(Choice(0), +sqrt(i/self))  ` if `self` is a nonzero nonsquare;\n    ///\n    pub(crate) fn invsqrt(&self) -> (result: (\n        Choice,\n        FieldElement,\n    ))\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n    // When self = 0: return (false, 0)\n\n            (field_element_as_nat(self) == 0) ==> (!choice_is_true(result.0)\n                && field_element_as_nat(&result.1) == 0),\n            // When successful and self ≠ 0: r² * self ≡ 1 (mod p)\n            (choice_is_true(result.0)) ==> is_sqrt_ratio(&FieldElement::ONE, self, &result.1),\n            // When unsuccessful and self ≠ 0: r² * self ≡ i (mod p) [nonsquare case]\n            (!choice_is_true(result.0) && field_element_as_nat(self) != 0)\n                ==> is_sqrt_ratio_times_i(&FieldElement::ONE, self, &result.1),\n    {\n        assume(false);\n        FieldElement::sqrt_ratio_i(&FieldElement::ONE, self)\n    }\n}\n\n// verus!\n} // verus!",
      "is_libsignal": false,
      "caller_count": 13,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "display_name": "lizard_decode",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    pub fn lizard_decode<D: Digest>(&self) -> Option<[u8; 16]>\n    where\n        D: Digest<OutputSize = U32>,\n    {\n        let mut result: [u8; 16] = Default::default();\n        let mut h: [u8; 32] = Default::default();\n        let (mask, fes) = self.elligator_ristretto_flavor_inverse();\n        let mut n_found = 0;\n        for (j, fe_j) in fes.iter().enumerate() {\n            let mut ok = Choice::from((mask >> j) & 1);\n            let buf2 = fe_j.as_bytes(); // array\n            h.copy_from_slice(&D::digest(&buf2[8..24])); // array\n            h[8..24].copy_from_slice(&buf2[8..24]);\n            h[0] &= 254;\n            h[31] &= 63;\n            ok &= h.ct_eq(&buf2);\n            for i in 0..16 {\n                result[i] = u8::conditional_select(&result[i], &buf2[8 + i], ok);\n            }\n            n_found += ok.unwrap_u8();\n        }\n        if n_found == 1 {\n            Some(result)\n        } else {\n            None\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "display_name": "pack",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn pack(&self) -> (result: Scalar)/* VERIFICATION NOTE:\n    PROOF BYPASS\n    */\n\n        requires\n            limbs_bounded(self),\n        ensures\n            bytes_to_nat(&result.bytes) == to_nat(&self.limbs),\n            // VERIFICATION NOTE: If input is canonical (< group order), output satisfies Scalar invariants\n            to_nat(&self.limbs) < group_order() ==> is_canonical_scalar(&result),\n    {\n        let bytes = self.as_bytes();\n        proof {\n            // Bridge between recursive and non-recursive representations\n            // as_bytes() uses non-recursive versions, but pack() expects recursive versions\n            lemma_bytes_to_nat_rec_equals_bytes_to_nat(&bytes);\n            lemma_five_limbs_equals_to_nat(&self.limbs);\n        }\n        let result = Scalar { bytes: bytes };\n        // VERIFICATION NOTE: TODO: Prove these follow from as_bytes() spec\n        assume(to_nat(&self.limbs) < group_order() ==> is_canonical_scalar(&result));\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 9,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_subtracts().",
      "display_name": "lemma_pow2_subtracts",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_subtracts().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/sha512_hash_bytes().",
      "display_name": "sha512_hash_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/sha512_hash_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "use crate::scalar_specs::*;\n\n#[cfg(feature = \"digest\")]\n#[allow(unused_imports)]\nuse digest::Digest;\n\nverus! {\n\n/*** <VERIFICATION NOTE> Focus on u64; removed all other backend types </VERIFICATION NOTE> ***/\ntype UnpackedScalar = backend::serial::u64::scalar::Scalar52;\n\n/// The `Scalar` struct holds an element of \\\\(\\mathbb Z / \\ell\\mathbb Z \\\\).\n#[allow(clippy::derived_hash_with_manual_eq)]\n#[derive(Copy, Clone, Hash)]\npub struct Scalar {\n    /// `bytes` is a little-endian byte encoding of an integer representing a scalar modulo the\n    /// group order.\n    ///\n    /// # Invariant #1\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255}\\\\). That is, the most\n    /// significant bit of `bytes[31]` is 0.\n    ///\n    /// This is required for `EdwardsPoint` variable- and fixed-base multiplication, because most\n    /// integers above 2^255 are unrepresentable in our radix-16 NAF (see [`Self::as_radix_16`]).\n    /// The invariant is also required because our `MontgomeryPoint` multiplication assumes the MSB\n    /// is 0 (see `MontgomeryPoint::mul`).\n    ///\n    /// # Invariant #2 (weak)\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255} - 19 \\\\), i.e., it represents\n    /// a canonical representative of an element of \\\\( \\mathbb Z / \\ell\\mathbb Z \\\\). This is\n    /// stronger than invariant #1. It also sometimes has to be broken.\n    ///\n    /// This invariant is deliberately broken in the implementation of `EdwardsPoint::{mul_clamped,\n    /// mul_base_clamped}`, `MontgomeryPoint::{mul_clamped, mul_base_clamped}`, and\n    /// `BasepointTable::mul_base_clamped`. This is not an issue though. As mentioned above,\n    /// scalar-point multiplication is defined for any choice of `bytes` that satisfies invariant\n    /// #1. Since clamping guarantees invariant #1 is satisfied, these operations are well defined.\n    ///\n    /// Note: Scalar-point mult is the _only_ thing you can do safely with an unreduced scalar.\n    /// Scalar-scalar addition and subtraction are NOT correct when using unreduced scalars.\n    /// Multiplication is correct, but this is only due to a quirk of our implementation, and not\n    /// guaranteed to hold in general in the future.\n    ///\n    /// Note: It is not possible to construct an unreduced `Scalar` from the public API unless the\n    /// `legacy_compatibility` is enabled (thus making `Scalar::from_bits` public). Thus, for all\n    /// public non-legacy uses, invariant #2\n    /// always holds.\n    ///\n    /* <VERIFICATION NOTE>\n    Changed from pub(crate) to pub\n    </VERIFICATION NOTE> */\n    pub bytes: [u8; 32],/* <ORIGINAL CODE>\n    pub(crate) bytes: [u8; 32],\n    </ORIGINAL CODE> */\n}\n\n// This is a dummy function that we call from signal\n// to test that verus functions in libsignal know\n// about verus functions in curve-dalek\npub open spec fn is_a_scalar(s: Scalar) -> bool {\n    true\n}\n\nimpl Scalar {\n    /// Construct a `Scalar` by reducing a 256-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    // VERIFICATION NOTE: VERIFIED\n    pub fn from_bytes_mod_order(bytes: [u8; 32]) -> (result: Scalar)\n        ensures\n    // Result is equivalent to input modulo the group order\n\n            bytes_to_nat(&result.bytes) % group_order() == bytes_to_nat(&bytes) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        // Temporarily allow s_unreduced.bytes > 2^255 ...\n        let s_unreduced = Scalar { bytes };\n\n        // Then reduce mod the group order and return the reduced representative.\n        let s = s_unreduced.reduce();\n        /*** <VERIFICATION NOTE> We omit debug asserts from verification  </VERIFICATION NOTE> ***/\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }\n\n    /// Construct a `Scalar` by reducing a 512-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    // VERIFICATION NOTE: VERIFIED\n    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == bytes_wide_to_nat(input) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }\n\n    /// Attempt to construct a `Scalar` from a canonical byte representation.\n    ///\n    /// # Return\n    ///\n    /// - `Some(s)`, where `s` is the `Scalar` corresponding to `bytes`,\n    ///   if `bytes` is a canonical byte representation modulo the group order \\\\( \\ell \\\\);\n    /// - `None` if `bytes` is not a canonical byte representation.\n    /*\n    <VERIFICATION NOTE>\n      - Refactored to use wrapper functions instead of trait functions for ct_eq and ct_option_new\n      - Has proof bypass\n    </VERIFICATION NOTE> */\n    pub fn from_canonical_bytes(bytes: [u8; 32]) -> (result: CtOption<Scalar>)\n        ensures\n            bytes_to_nat(&bytes) < group_order() ==> ct_option_has_value(result),\n            bytes_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result),\n            ct_option_has_value(result) ==> bytes_to_nat(&ct_option_value(result).bytes)\n                % group_order() == bytes_to_nat(&bytes) % group_order(),\n    {\n        /* <ORIGINAL CODE>\n          let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let high_byte_shifted = bytes[31] >> 7;\n        let high_bit_unset = ct_eq_u8(&high_byte_shifted, &0);\n        /* </MODIFIED CODE> */\n\n        let candidate = Scalar { bytes };\n        let is_canonical = candidate.is_canonical();\n\n        /* <ORIGINAL CODE>\n          CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n          </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let condition = choice_and(high_bit_unset, is_canonical);\n        let result = ct_option_new(candidate, condition);\n        /* </MODIFIED CODE> */\n\n        // VERIFICATION NOTE: PROOF BYPASS\n        assume(bytes_to_nat(&bytes) < group_order() ==> ct_option_has_value(result));\n        assume(bytes_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result));\n        assume(ct_option_has_value(result) ==> bytes_to_nat(&ct_option_value(result).bytes)\n            % group_order() == bytes_to_nat(&bytes) % group_order());\n\n        result\n    }\n\n    /// Construct a `Scalar` from the low 255 bits of a 256-bit integer. This breaks the invariant\n    /// that scalars are always reduced. Scalar-scalar arithmetic, i.e., addition, subtraction,\n    /// multiplication, **does not work** on scalars produced from this function. You may only use\n    /// the output of this function for `EdwardsPoint::mul`, `MontgomeryPoint::mul`, and\n    /// `EdwardsPoint::vartime_double_scalar_mul_basepoint`. **Do not use this function** unless\n    /// you absolutely have to.\n    /* <VERIFICATION NOTE>\n        -This is not in default features and not in our current target list ==> spec omitted for now\n    </VERIFICATION NOTE> */\n    #[cfg(feature = \"legacy_compatibility\")]\n    #[deprecated(\n        since = \"4.0.0\",\n        note = \"This constructor outputs scalars with undefined scalar-scalar arithmetic. See docs.\"\n    )]\n    pub const fn from_bits(bytes: [u8; 32]) -> Scalar {\n        let mut s = Scalar { bytes };\n        // Ensure invariant #1 holds. That is, make s < 2^255 by masking the high bit.\n        s.bytes[31] &= 0b0111_1111;\n\n        s\n    }\n}\n\nimpl Eq for Scalar {\n\n}\n\nimpl PartialEq for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS (problem with traits)\n    fn eq(&self, other: &Self) -> (result: bool)\n        ensures\n            result == (&self.bytes == &other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Choice::into\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let result = self.ct_eq(other).into();\n         </ORIGINAL CODE> */\n        let choice = self.ct_eq(other);\n        assert(choice_is_true(choice) == (self.bytes == other.bytes));\n        let result = choice_into(choice);\n        assert(result == choice_is_true(choice));\n        assert(result == (self.bytes == other.bytes));\n\n        // VERIFICATION NOTE: vstd's external trait specification check cannot be satisfied\n        // vstd expects obeys_eq_spec() and eq_spec() from PartialEqSpecImpl trait,\n        // but that trait is not publicly exported, so we bypass with assume(false)\n        // while maintaining our own custom ensures clause above\n        assume(false);\n\n        result\n    }\n}\n\nimpl ConstantTimeEq for Scalar {\n    fn ct_eq(&self, other: &Self) -> (result: Choice)\n        ensures\n            choice_is_true(result) == (self.bytes == other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Verus compatibility instead of direct subtle call\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.bytes.ct_eq(&other.bytes)\n         </ORIGINAL CODE> */\n        ct_eq_bytes32(&self.bytes, &other.bytes)\n    }\n}\n\nimpl Index<usize> for Scalar {\n    type Output = u8;\n\n    /// Index the bytes of the representative for this `Scalar`.  Mutation is not permitted.\n    fn index(&self, _index: usize) -> (result: &u8)\n        requires\n            _index < 32,\n        ensures\n            result == &self.bytes[_index as int],\n    {\n        &(self.bytes[_index])\n    }\n}\n\nimpl Debug for Scalar {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar{{\\n\\tbytes: {:?},\\n}}\", &self.bytes)\n    }\n}\n\nimpl<'a> MulAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    fn mul_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n            is_canonical_scalar(self),\n    {\n        /* <ORIGINAL CODE>\n         *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n        /* <VERIFICATION NOTE>\n         In the modified code, we store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&old(self).bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        *self = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&self.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n    }\n}\n\ndefine_mul_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_mul_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn mul_req(self, rhs: &Scalar) -> bool {\n        true  // No preconditions\n\n    }\n\n    open spec fn mul_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'b> Mul<&'b Scalar> for &Scalar {\n    type Output = Scalar;\n\n    // VERIFICATION NOTE: VERIFIED\n    fn mul(self, _rhs: &'b Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n    {\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n            * bytes_to_nat(&_rhs.bytes)) % group_order());\n        /* </MODIFIED CODE> */\n        /* <ORIGINAL CODE>\n         let result = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n\n        result\n    }\n}\n\ndefine_mul_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_add_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn add_req(self, rhs: &Scalar) -> bool {\n        true  // No preconditions yet\n\n    }\n\n    open spec fn add_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'a> Add<&'a Scalar> for &Scalar {\n    type Output = Scalar;\n\n    /* <VERIFICATION NOTE>\n    PROOF BYPASS; may need to add preconditions to spec\n    </VERIFICATION NOTE> */\n    #[allow(non_snake_case)]\n    fn add(self, _rhs: &'a Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(&_rhs.bytes))\n                % group_order(),\n    {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::add requires inputs < group_order()\n        // By Scalar invariant #2, scalars should be canonical\n        // However, we cannot add requires clauses to trait implementations,\n        // so we assume this property holds\n        proof {\n            assume(to_nat(&self_unpacked.limbs) < group_order());\n            assume(to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::add(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) == (to_nat(&self_unpacked.limbs) + to_nat(\n                &rhs_unpacked.limbs,\n            )) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) == to_nat(&result_unpacked.limbs));\n            assert(bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }\n}\n\ndefine_add_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> AddAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    #[allow(clippy::op_ref)]\n    fn add_assign(&mut self, _rhs: &'a Scalar)\n        ensures\n            bytes_to_nat(&self.bytes) == (bytes_to_nat(&old(self).bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order(),\n    {\n        *self = &*self + _rhs;\n    }\n}\n\ndefine_add_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_sub_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn sub_req(self, rhs: &Scalar) -> bool {\n        is_canonical_scalar(self) && is_canonical_scalar(rhs)\n    }\n\n    open spec fn sub_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'b> Sub<&'b Scalar> for &Scalar {\n    type Output = Scalar;\n\n    // VERIFICATION NOTE: PROOF BYPASS (problems with traits and preconditions)\n    // PRECONDITION is_canonical_scalar(self) && is_canonical_scalar(_rhs)\n    #[allow(non_snake_case)]\n    fn sub(self, _rhs: &'b Scalar) -> (result:\n        Scalar)/* VERIFICATION NOTE: preconditions are added to the SpecImpl above\n    requires\n      is_canonical_scalar(self),\n      is_canonical_scalar(_rhs),\n    */\n\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        /* <ORIGINAL CODE>\n         UnpackedScalar::sub(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::sub requires: -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()\n        proof {\n            assume(-group_order() <= to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs));\n            assume(to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::sub(&self_unpacked, &rhs_unpacked);\n        proof {\n            // Postconditions from sub - need to strengthen, review connections\n            assume(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                - to_nat(&rhs_unpacked.limbs)) % (group_order() as int));\n            assume(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int));\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }\n}\n\ndefine_sub_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> SubAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    #[allow(clippy::op_ref)]\n    fn sub_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        *self = &*self - _rhs;\n    }\n}\n\ndefine_sub_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &Scalar {\n    open spec fn obeys_neg_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn neg_req(self) -> bool {\n        true  // No preconditions - scalars are canonical by invariant\n\n    }\n\n    open spec fn neg_spec(self) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl Neg for &Scalar {\n    type Output = Scalar;\n\n    #[allow(non_snake_case)]\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        /* <ORIGINAL CODE>\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        proof {\n            // Preconditions for mul_internal and sub\n            assume(limbs_bounded(&constants::R));\n            assume(limbs_bounded(&UnpackedScalar::ZERO));\n        }\n\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n\n        proof {\n            assume(limbs_bounded(&self_mod_l));\n            // sub requires: -group_order() <= 0 - to_nat(&self_mod_l.limbs) < group_order()\n            assume(-group_order() <= to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(\n                &self_mod_l.limbs,\n            ));\n            assume(to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(&self_mod_l.limbs) < group_order());\n        }\n\n        let result = UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack();\n        proof {\n            // TODO: Prove that -self + self == 0 (mod group_order)\n            assume((scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0);\n        }\n\n        /* </MODIFIED CODE> */\n        result\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for Scalar {\n    open spec fn obeys_neg_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn neg_req(self) -> bool {\n        true  // No specific preconditions - scalars are canonical by invariant\n\n    }\n\n    open spec fn neg_spec(self) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl Neg for Scalar {\n    type Output = Scalar;\n\n    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        let result = (&self).neg();\n        proof {\n            assume((scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0);\n        }\n        result\n    }/* <ORIGINAL CODE>\n    fn neg(self) -> Scalar {\n        -&self\n    }\n    </ORIGINAL CODE> */\n\n}\n\nimpl ConditionallySelectable for Scalar {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> (Self) {\n        let mut bytes = [0u8;32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            /* <VERIFICATION NOTE>\n            Use wrapper function for Verus compatibility instead of direct subtle call\n            </VERIFICATION NOTE> */\n            /* <ORIGINAL CODE>\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n            </ORIGINAL CODE> */\n            /* <MODIFIED CODE> */\n            bytes[i] = select_u8(&a.bytes[i], &b.bytes[i], choice);\n            /* </MODIFIED CODE> */\n        }\n        Scalar { bytes }\n    }\n}\n\n/* <VERIFICATION NOTE>\n Trait implementations for Product and Sum declared as external_body since they use iterators which are not supported by Verus.\n</VERIFICATION NOTE> */\n\nimpl<T> Product<T> for Scalar where T: Borrow<Scalar> {\n    /* <ORIGINAL CODE>\n    fn product<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ONE, |acc, item| acc * item.borrow())\n    }\n    </ORIGINAL CODE> */\n    /* <VERIFICATION NOTE>\n     Added verifier::external_body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    /* <MODIFIED CODE> - FOR EVENTUAL VERIFICATION*/\n    fn product<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified product_of_slice function\n        Scalar::product_of_slice(&scalars)\n    }  /* </MODIFIED CODE> */\n\n}\n\nimpl<T> Sum<T> for Scalar where T: Borrow<Scalar> {\n    #[verifier::external_body]\n    fn sum<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }/* <MODIFIED CODE> - if needed in for verification in the future\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified sum_of_slice function\n        Scalar::sum_of_slice(&scalars)\n    }\n     </MODIFIED CODE> */\n\n}\n\nimpl Default for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn default() -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == 0 as nat,\n    {\n        let result = Scalar::ZERO;\n        assume(scalar_to_nat(&result) == 0 as nat);\n        result\n    }\n}\n\nimpl From<u8> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn from(x: u8) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        let mut s_bytes = [0u8;32];\n        s_bytes[0] = x;\n\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u16> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u16) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u16_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u32> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u32) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u32_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        let result = Scalar { bytes: s_bytes };\n        /* </MODIFIED CODE> */\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u64> for Scalar {\n    /// Construct a scalar from the given `u64`.\n    ///\n    /// # Inputs\n    ///\n    /// An `u64` to convert to a `Scalar`.\n    ///\n    /// # Returns\n    ///\n    /// A `Scalar` corresponding to the input `u64`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let fourtytwo = Scalar::from(42u64);\n    /// let six = Scalar::from(6u64);\n    /// let seven = Scalar::from(7u64);\n    ///\n    /// assert!(fourtytwo == six * seven);\n    /// ```\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u64) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u64_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u128> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u128) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u128_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for Scalar {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self) {\n        self.bytes.zeroize();\n    }\n}\n\nimpl Scalar {\n    /// The scalar \\\\( 0 \\\\).\n    // pub const ZERO: Self = Self { bytes: [0u8; 32] };\n    /* <VERIFICATION NOTE>\n    Changed to explicit initialization\n    </VERIFICATION NOTE> */\n    /* <ORIGINAL CODE>\n    pub const ZERO: Self = Self { bytes: [0u8; 32] };\n    </ORIGINAL CODE> */\n    pub const ZERO: Scalar = Scalar {\n        bytes: [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n        ],\n    };\n\n    /// The scalar \\\\( 1 \\\\).\n    pub const ONE: Self = Self {\n        bytes: [\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n        ],\n    };\n\n    /* <VERIFICATION NOTE>\n     Verification of random method postponed - requires rand_core feature to be enabled.\n    </VERIFICATION NOTE> */\n    #[cfg(any(test, feature = \"rand_core\"))]\n    /// Return a `Scalar` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `CryptoRngCore`\n    ///   (i.e. `CryptoRng` + `RngCore`) interface.\n    ///\n    /// # Returns\n    ///\n    /// A random scalar within \\\\(\\mathbb{Z} / \\ell\\mathbb{Z}\\\\).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # fn main() {\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// use rand_core::OsRng;\n    ///\n    /// let mut csprng = OsRng;\n    /// let a: Scalar = Scalar::random(&mut csprng);\n    /// # }\n    /* <VERIFICATION NOTE>\n     No verifier::external_body annotation but it is NOT verified\n    </VERIFICATION NOTE> */\n    pub fn random<R: CryptoRngCore + ?Sized>(rng: &mut R) -> (result: Self)\n        ensures\n            is_random_scalar(&result),\n            is_canonical_scalar(&result),\n    {\n        let mut scalar_bytes = [0u8;64];\n        rng.fill_bytes(&mut scalar_bytes);\n        Scalar::from_bytes_mod_order_wide(&scalar_bytes)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Hash a slice of bytes into a scalar using a specified hash function.\n    ///\n    /// This function hashes the input using the specified `Digest` type and then reduces\n    /// the result modulo the group order to produce a scalar.\n    ///\n    /// Convenience wrapper around `from_hash`.\n    ///\n    /// # Example\n    ///\n    #[cfg_attr(feature = \"digest\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// use sha2::Sha512;\n    /// # fn main() {\n    /// let msg = \"To really appreciate architecture, you may even need to commit a murder\";\n    /// let s = Scalar::hash_from_bytes::<Sha512>(msg.as_bytes());\n    /// # }\n    /// ```\n    /* <VERIFICATION NOTE>\n     Marked as external_body due to complexity of Digest trait.\n     For Verus verification, use hash_from_bytes_verus instead.\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    pub fn hash_from_bytes<D>(input: &[u8]) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64> + Default,\n\n        ensures\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        Scalar::from_hash(hash)\n    }\n\n    /// Verus-compatible version of hash_from_bytes that uses SHA-512.\n    ///\n    /// This function is designed for Verus verification and directly computes\n    /// a SHA-512 hash. For regular code with generic hash functions, use `hash_from_bytes` instead.\n    ///\n    /// # Inputs\n    ///\n    /// * `input`: a byte slice to hash\n    ///\n    /// # Returns\n    ///\n    /// A scalar reduced modulo the group order\n    pub fn hash_from_bytes_verus(input: &[u8]) -> (result: Scalar)\n        ensures\n            is_random_bytes(input) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        use crate::core_assumes as assumes;\n        let hash_bytes: [u8; 64] = assumes::sha512_hash_bytes(input);\n        Scalar::from_hash_verus(hash_bytes)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Construct a scalar from a 64-byte (512-bit) hash output.\n    ///\n    /// This reduces the hash output modulo the group order.\n    /// Typically used after calling `finalize()` on a SHA-512 hasher.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// use sha2::{Digest, Sha512};\n    ///\n    /// # fn main() {\n    /// let mut h = Sha512::new();\n    /// h.update(b\"To really appreciate architecture, you may even need to commit a murder.\");\n    /// h.update(b\"While the programs used for The Manhattan Transcripts are of the most extreme\");\n    /// h.update(b\"nature, they also parallel the most common formula plot: the archetype of\");\n    /// h.update(b\"murder. Other phantasms were occasionally used to underline the fact that\");\n    /// h.update(b\"perhaps all architecture, rather than being about functional standards, is\");\n    /// h.update(b\"about love and death.\");\n    ///\n    /// let hash_bytes: [u8; 64] = h.finalize().into();\n    /// let s = Scalar::from_hash(hash_bytes);\n    ///\n    /// println!(\"{:?}\", s.to_bytes());\n    /// assert_eq!(\n    ///     s.to_bytes(),\n    ///     [  21,  88, 208, 252,  63, 122, 210, 152,\n    ///       154,  38,  15,  23,  16, 167,  80, 150,\n    ///       192, 221,  77, 226,  62,  25, 224, 148,\n    ///       239,  48, 176,  10, 185,  69, 168,  11, ],\n    /// );\n    /// # }\n    /// ```\n    /* <VERIFICATION NOTE>\n     Marked as external_body due to GenericArray having private fields.\n     For Verus verification, see from_hash_verus below.\n    </VERIFICATION NOTE> */\n    #[cfg(feature = \"digest\")]\n    #[verifier::external_body]\n    pub fn from_hash<D>(hash: D) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64>,\n\n        ensures\n    //is_random_digest(&hash) ==> is_random_scalar(&result),\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut output = [0u8;64];\n        output.copy_from_slice(hash.finalize().as_slice());\n        Scalar::from_bytes_mod_order_wide(&output)\n    }\n\n    /// Verus-compatible version of from_hash that takes pre-finalized hash bytes.\n    ///\n    /// This function is designed for Verus verification and takes a byte array directly\n    /// instead of a generic Digest type. For regular code, use `from_hash` instead.\n    ///\n    /// # Inputs\n    ///\n    /// * `hash_bytes`: a 64-byte array representing the output of a hash function\n    ///\n    /// # Returns\n    ///\n    /// A scalar reduced modulo the group order\n    pub fn from_hash_verus(hash_bytes: [u8; 64]) -> (result: Scalar)\n        ensures\n            is_random_bytes(&hash_bytes) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        let result = Scalar::from_bytes_mod_order_wide(&hash_bytes);\n        assume(false);\n        result\n    }\n\n    /// Convert this `Scalar` to its underlying sequence of bytes.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.to_bytes() == [0u8; 32]);\n    /// ```\n    pub const fn to_bytes(&self) -> (result: [u8; 32])\n        ensures\n            result == self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        self.bytes\n    }\n\n    /// View the little-endian byte encoding of the integer representing this Scalar.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.as_bytes() == &[0u8; 32]);\n    /// ```\n    pub const fn as_bytes(&self) -> (result: &[u8; 32])\n        ensures\n            result == &self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        &self.bytes\n    }\n}\n\nimpl Scalar {\n    /// Given a nonzero `Scalar`, compute its multiplicative inverse.\n    ///\n    /// # Warning\n    ///\n    /// `self` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Returns\n    ///\n    /// The multiplicative inverse of the this `Scalar`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // x = 2238329342913194256032495932344128051776374960164957527413114840482143558222\n    /// let X: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x4e, 0x5a, 0xb4, 0x34, 0x5d, 0x47, 0x08, 0x84,\n    ///         0x59, 0x13, 0xb4, 0x64, 0x1b, 0xc2, 0x7d, 0x52,\n    ///         0x52, 0xa5, 0x85, 0x10, 0x1b, 0xcc, 0x42, 0x44,\n    ///         0xd4, 0x49, 0xf4, 0xa8, 0x79, 0xd9, 0xf2, 0x04,\n    ///     ]);\n    /// // 1/x = 6859937278830797291664592131120606308688036382723378951768035303146619657244\n    /// let XINV: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x1c, 0xdc, 0x17, 0xfc, 0xe0, 0xe9, 0xa5, 0xbb,\n    ///         0xd9, 0x24, 0x7e, 0x56, 0xbb, 0x01, 0x63, 0x47,\n    ///         0xbb, 0xba, 0x31, 0xed, 0xd5, 0xa9, 0xbb, 0x96,\n    ///         0xd5, 0x0b, 0xcd, 0x7a, 0x3f, 0x96, 0x2a, 0x0f,\n    ///     ]);\n    ///\n    /// let inv_X: Scalar = X.invert();\n    /// assert!(XINV == inv_X);\n    /// let should_be_one: Scalar = &inv_X * &X;\n    /// assert!(should_be_one == Scalar::ONE);\n    /// ```\n    // VERIFICATION NOTE: VERIFIED\n    pub fn invert(&self) -> (result: Scalar)\n        requires\n            is_canonical_scalar(self),\n        ensures\n    // Result is the multiplicative inverse: result * self ≡ 1 (mod group_order)\n\n            (scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1,\n            is_canonical_scalar(\n                &result,\n            ),\n    // VERIFICATION NOTE: is this true and/or necessary?\n    // Result is canonical\n    // scalar_to_nat(&result) < group_order(),\n    // result.bytes[31] <= 127,\n\n    {\n        let unpacked = self.unpack();\n        let inv_unpacked = unpacked.invert();\n        let result = inv_unpacked.pack();\n        assert((scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1);\n        assume(is_canonical_scalar(&result));\n        result\n    }\n\n    /// Given a slice of nonzero (possibly secret) `Scalar`s,\n    /// compute their inverses in a batch.\n    ///\n    /// # Return\n    ///\n    /// Each element of `inputs` is replaced by its inverse.\n    ///\n    /// The product of all inverses is returned.\n    ///\n    /// # Warning\n    ///\n    /// All input `Scalars` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// # fn main() {\n    /// let mut scalars = [\n    ///     Scalar::from(3u64),\n    ///     Scalar::from(5u64),\n    ///     Scalar::from(7u64),\n    ///     Scalar::from(11u64),\n    /// ];\n    ///\n    /// let allinv = Scalar::batch_invert(&mut scalars);\n    ///\n    /// assert_eq!(allinv, Scalar::from(3*5*7*11u64).invert());\n    /// assert_eq!(scalars[0], Scalar::from(3u64).invert());\n    /// assert_eq!(scalars[1], Scalar::from(5u64).invert());\n    /// assert_eq!(scalars[2], Scalar::from(7u64).invert());\n    /// assert_eq!(scalars[3], Scalar::from(11u64).invert());\n    /// # }\n    /// ```\n    #[cfg(feature = \"alloc\")]\n    // Theo: Verus doesn't like the zeroize in this function. I think the long-term\n    // solution is to use assume_specification to tell Verus what zeroize does.\n    // In the short-term, I've just told verus to ignore the body.\n    // (SB update: alternative is to exclude just the zeroize call, as below)\n    pub fn batch_invert(inputs: &mut [Scalar]) -> (result:\n        Scalar)/* <VERIFICATION NOTE>\n     Refactored for Verus: Index loops instead of iterators, manual Vec construction, ..\n    </VERIFICATION NOTE> */\n\n        ensures\n    // Result is the modular inverse of the product of all original inputs\n\n            is_inverse_of_nat(&result, product_of_scalars(old(inputs)@)),\n            // Each input is replaced with its inverse\n            forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ),\n    {\n        // This code is essentially identical to the FieldElement\n        // implementation, and is documented there.  Unfortunately,\n        // it's not easy to write it generically, since here we want\n        // to use `UnpackedScalar`s internally, and `Scalar`s\n        // externally, but there's no corresponding distinction for\n        // field elements.\n        let n = inputs.len();\n        let one_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(limbs_bounded(&one_unpacked));\n        }\n\n        let one: UnpackedScalar = one_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&one));\n        }\n\n        /* <VERIFICATION NOTE>\n         Build vec manually instead of vec![one; n] for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let mut scratch = vec![one; n];\n         </ORIGINAL CODE> */\n        let mut scratch = Vec::new();\n        for _ in 0..n {\n            scratch.push(one);\n        }\n\n        // Keep an accumulator of all of the previous products\n        let acc_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(scratch.len() == n);\n            assume(limbs_bounded(&acc_unpacked));\n        }\n\n        let mut acc = acc_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        /* <VERIFICATION NOTE>\n         Rewritten with index loop instead of .zip() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         for (input, scratch) in inputs.iter_mut().zip(scratch.iter_mut()) {\n             *scratch = acc;\n        //     // Avoid unnecessary Montgomery multiplication in second pass by\n        //     // keeping inputs in Montgomery form\n             let tmp = input.unpack().as_montgomery();\n             *input = tmp.pack();\n             acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n         }\n        </ORIGINAL CODE> */\n        for i in 0..n\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                limbs_bounded(&acc),\n        {\n            scratch[i] = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = input_unpacked.as_montgomery();\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n\n            proof {\n                assume(limbs_bounded(&acc));\n            }\n        }\n\n        proof {\n            // Assert that all scratch elements have bounded limbs\n            assume(forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]));\n        }\n\n        // acc is nonzero iff all inputs are nonzero\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert!(acc.pack() != Scalar::ZERO);\n\n        // Compute the inverse of all products\n        // ORIGINAL CODE: acc = acc.montgomery_invert().from_montgomery();\n        acc = acc.montgomery_invert();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        acc = acc.from_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // We need to return the product of all inverses later\n        let ret = acc.pack();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        /* <VERIFICATION NOTE>\n         Manual reverse loop instead of .rev() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.iter().rev()) {\n             let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n             *input = UnpackedScalar::montgomery_mul(&acc, scratch).pack();\n             acc = tmp;\n         }\n        </ORIGINAL CODE> */\n        let mut i: usize = n;\n        while i > 0\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                i <= n,\n                limbs_bounded(&acc),\n                forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]),\n            decreases i,\n        {\n            i -= 1;\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input_unpacked);\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = UnpackedScalar::montgomery_mul(&acc, &scratch[i]).pack();\n            acc = tmp;\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        #[cfg(not(verus_keep_ghost))]\n        Zeroize::zeroize(&mut scratch);\n\n        proof {\n            // Assume the postconditions\n            assume(is_inverse_of_nat(&ret, product_of_scalars(old(inputs)@)));\n            assume(forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ));\n        }\n\n        ret\n    }\n}\n\n#[cfg(feature = \"serde\")]\nuse serde::de::Visitor;\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[cfg(feature = \"serde\")]\n/// Visitor for deserializing a Scalar from a sequence of 32 bytes.\n///\n/* VERIFICATION NOTE:\n- We don't cover serde feature yet\n- The ScalarVisitor struct is defined at module level rather than inside the\n`Deserialize::deserialize` since Verus doesn't support nested types\n</VERIFICATION NOTE> */\nstruct ScalarVisitor;\n\n#[cfg(feature = \"serde\")]\nimpl<'de> Visitor<'de> for ScalarVisitor {\n    type Value = Scalar;\n\n    #[verifier::external_body]\n    fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        {\n            formatter.write_str(\n                \"a sequence of 32 bytes whose little-endian interpretation is less than the \\\n                        basepoint order ℓ\",\n            )\n        }\n    }\n\n    #[verifier::external_body]\n    fn visit_seq<A>(self, mut seq: A) -> Result<Scalar, A::Error> where\n        A: serde::de::SeqAccess<'de>,\n     {\n        let mut bytes = [0u8;32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            bytes[i] = seq.next_element()?.ok_or_else(\n                || serde::de::Error::invalid_length(i, &\"expected 32 bytes\"),\n            )?;\n        }\n        Option::from(Scalar::from_canonical_bytes(bytes)).ok_or_else(\n            || serde::de::Error::custom(\"scalar was not canonically encoded\"),\n        )\n    }\n}\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl Serialize for Scalar {\n    #[verifier::external_body]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl<'de> Deserialize<'de> for Scalar {\n    #[verifier::external_body]\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error> where D: Deserializer<'de> {\n        /* VERIFICATION NOTE:\n        Originally struct ScalarVisitor defined here, but moved up to the top of the file\n        </VERIFICATION NOTE> */\n        deserializer.deserialize_tuple(32, ScalarVisitor)\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#PartialEq#eq().",
      "display_name": "eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#PartialEq#eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn eq(&self, other: &Self) -> (result: bool)\n        ensures\n            result == (&self.bytes == &other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Choice::into\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let result = self.ct_eq(other).into();\n         </ORIGINAL CODE> */\n        let choice = self.ct_eq(other);\n        assert(choice_is_true(choice) == (self.bytes == other.bytes));\n        let result = choice_into(choice);\n        assert(result == choice_is_true(choice));\n        assert(result == (self.bytes == other.bytes));\n\n        // VERIFICATION NOTE: vstd's external trait specification check cannot be satisfied\n        // vstd expects obeys_eq_spec() and eq_spec() from PartialEqSpecImpl trait,\n        // but that trait is not publicly exported, so we bypass with assume(false)\n        // while maintaining our own custom ensures clause above\n        assume(false);\n\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn zeroize(&mut self) {\n        self.bytes.zeroize();\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_left_inequality().",
      "display_name": "lemma_mul_left_inequality",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_left_inequality().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/Mul#mul().",
      "display_name": "mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/Mul#mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn mul(self, point: &MontgomeryPoint) -> MontgomeryPoint {\n        point * self\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#size_hint().",
      "display_name": "size_hint",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#size_hint().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_decomposition().",
      "display_name": "shr_decomposition",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_decomposition().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn shr_decomposition(v: u64, a: nat, b: nat)\n    requires\n        (a + b) < 64,\n    ensures\n        (v >> (a + b)) == ((v >> a) >> b),\n{\n    if (a == 0 || b == 0) {\n        broadcast use shr_zero_is_id;\n\n    } else {\n        lemma2_to64_rest();  // pow2(64)\n        lemma_pow2_strictly_increases(a, a + b);\n        lemma_pow2_strictly_increases(b, a + b);\n        lemma_pow2_strictly_increases(a + b, 64);  // pow2(a + b) fits in u64\n\n        // 2^(a + b) == 2^a * 2^b\n        lemma_pow2_adds(a, b);\n        // v >> a + b = v / 2^(a+b)\n        lemma_u64_shr_is_div(v, (a + b) as u64);\n        // v >> a = v / 2^a\n        lemma_u64_shr_is_div(v, a as u64);\n        // (v / 2^a) << b = (v / 2^a) / 2^b\n        lemma_u64_shr_is_div((v / (pow2(a) as u64)) as u64, b as u64);\n\n        // 2^k > 0\n        lemma_pow2_pos(a);\n        lemma_pow2_pos(b);\n\n        // v / 2^a / 2^b = v / 2^(a + b)\n        lemma_div_denominator(v as int, pow2(a) as int, pow2(b) as int);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat_32_u8_rec().",
      "display_name": "as_nat_32_u8_rec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat_32_u8_rec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/field_core.rs",
      "file_name": "field_core.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn as_nat_32_u8_rec(limbs: &[u8; 32], index: nat) -> nat\n    decreases 32 - index,\n{\n    if index >= 32 {\n        0\n    } else {\n        (limbs[index as int] as nat) * pow2(index * 8) + as_nat_32_u8_rec(limbs, index + 1)\n    }\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "display_name": "lemma2_to64_rest",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 26,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#SubAssign#sub_assign().",
      "display_name": "sub_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#SubAssign#sub_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "display_name": "mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/mod.rs",
      "relative_path": "src/backend/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "backend",
      "body": "//! **INTERNALS:** Pluggable implementations for different architectures.\n//!\n//! The backend code is split into two parts: a serial backend,\n//! and a vector backend.\n//!\n//! The [`serial`] backend contains 32- and 64-bit implementations of\n//! field arithmetic and scalar arithmetic, as well as implementations\n//! of point operations using the mixed-model strategy (passing\n//! between different curve models depending on the operation).\n//!\n//! The [`vector`] backend contains implementations of vectorized\n//! field arithmetic, used to implement point operations using a novel\n//! implementation strategy derived from parallel formulas of Hisil,\n//! Wong, Carter, and Dawson.\n//!\n//! Because the two strategies give rise to different curve models,\n//! it's not possible to reuse exactly the same scalar multiplication\n//! code (or to write it generically), so both serial and vector\n//! backends contain matching implementations of scalar multiplication\n//! algorithms.  These are intended to be selected by a `#[cfg]`-based\n//! type alias.\n//!\n//! The [`vector`] backend is selected by the `simd_backend` cargo\n//! feature; it uses the [`serial`] backend for non-vectorized operations.\nuse crate::EdwardsPoint;\nuse crate::Scalar;\n\npub mod serial;\n\n// #[cfg(curve25519_dalek_backend = \"simd\")]\n// pub mod vector;\n\n#[derive(Copy, Clone)]\nenum BackendKind {\n    // #[cfg(curve25519_dalek_backend = \"simd\")]\n    // Avx2,\n    // #[cfg(all(curve25519_dalek_backend = \"simd\", nightly))]\n    // Avx512,\n    Serial,\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c2_val().",
      "display_name": "c2_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c2_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Add#add().",
      "display_name": "add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Add#add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn add(self, other: &'b AffineNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PP = &Y_plus_X * &other.y_plus_x;\n        let MM = &Y_minus_X * &other.y_minus_x;\n        let Txy2d = &self.T * &other.xy2d;\n        let Z2 = &self.Z + &self.Z;\n\n        CompletedPoint {\n            X: &PP - &MM,\n            Y: &PP + &MM,\n            Z: &Z2 + &Txy2d,\n            T: &Z2 - &Txy2d,\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"CompressedEdwardsY: {:?}\", self.as_bytes())\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode().",
      "display_name": "test_lizard_encode",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    fn test_lizard_encode() {\n        test_lizard_encode_helper(\n            &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            &[\n                0xf0, 0xb7, 0xe3, 0x44, 0x84, 0xf7, 0x4c, 0xf0, 0xf, 0x15, 0x2, 0x4b, 0x73, 0x85,\n                0x39, 0x73, 0x86, 0x46, 0xbb, 0xbe, 0x1e, 0x9b, 0xc7, 0x50, 0x9a, 0x67, 0x68, 0x15,\n                0x22, 0x7e, 0x77, 0x4f,\n            ],\n        );\n\n        test_lizard_encode_helper(\n            &[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            &[\n                0xcc, 0x92, 0xe8, 0x1f, 0x58, 0x5a, 0xfc, 0x5c, 0xaa, 0xc8, 0x86, 0x60, 0xd8, 0xd1,\n                0x7e, 0x90, 0x25, 0xa4, 0x44, 0x89, 0xa3, 0x63, 0x4, 0x21, 0x23, 0xf6, 0xaf, 0x7,\n                0x2, 0x15, 0x6e, 0x65,\n            ],\n        );\n\n        test_lizard_encode_helper(\n            &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n            &[\n                0xc8, 0x30, 0x57, 0x3f, 0x8a, 0x8e, 0x77, 0x78, 0x67, 0x1f, 0x76, 0xcd, 0xc7, 0x96,\n                0xdc, 0xa, 0x23, 0x5c, 0xf1, 0x77, 0xf1, 0x97, 0xd9, 0xfc, 0xba, 0x6, 0xe8, 0x4e,\n                0x96, 0x24, 0x74, 0x44,\n            ],\n        );\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_truncate_middle().",
      "display_name": "lemma_truncate_middle",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_truncate_middle().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_verus",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/product_of_scalars().",
      "display_name": "product_of_scalars",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/product_of_scalars().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar_helpers.rs",
      "relative_path": "src/scalar_helpers.rs",
      "file_name": "scalar_helpers.rs",
      "parent_folder": "src",
      "body": "                n == scalars.len(),\n                scalar_to_nat(&acc) < group_order(),\n                // acc represents the product of scalars[0..i]\n                scalar_congruent_nat(&acc, product_of_scalars(scalars@.subrange(0, i as int))),\n        {\n            proof {\n                // Assume preconditions for multiplication are satisfied\n                assume(false);\n            }\n            acc = &acc * &scalars[i];\n\n            proof {\n                // Assume the result maintains the invariant\n                assume(scalar_to_nat(&acc) < group_order());\n                assume(scalar_congruent_nat(\n                    &acc,\n                    product_of_scalars(scalars@.subrange(0, (i + 1) as int)),\n                ));\n            }\n        }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#decompress().",
      "display_name": "decompress",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#decompress().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn decompress(&self) -> Option<RistrettoPoint> {\n        let (s_encoding_is_canonical, s_is_negative, s) = decompress::step_1(self);\n\n        if (!s_encoding_is_canonical | s_is_negative).into() {\n            return None;\n        }\n\n        let (ok, t_is_negative, y_is_zero, res) = decompress::step_2(s);\n\n        if (!ok | t_is_negative | y_is_zero).into() {\n            None\n        } else {\n            Some(res)\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_shr_51_le().",
      "display_name": "lemma_shr_51_le",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_shr_51_le().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "use crate::backend::serial::u64::field_lemmas::as_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_nat_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::compute_q_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::field_core::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::from_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::limbs_to_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::load8_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::negate_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2_51_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "display_name": "montgomery_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "            /* <VERIFICATION NOTE>\n            Use wrapper function for Verus compatibility instead of direct subtle call\n            </VERIFICATION NOTE> */\n            /* <ORIGINAL CODE>\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n            </ORIGINAL CODE> */\n            /* <MODIFIED CODE> */\n            bytes[i] = select_u8(&a.bytes[i], &b.bytes[i], choice);\n            /* </MODIFIED CODE> */\n        }\n        Scalar { bytes }\n    }",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq/Seq#skip().",
      "display_name": "skip",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq/Seq#skip().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar_specs.rs",
      "relative_path": "src/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn identity() -> Self;\n}\n\n/// Trait for testing if a curve point is equivalent to the identity point.\npub trait IsIdentity {\n    /// Return true if this element is the identity element of the curve.\n    fn is_identity(&self) -> bool;\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "display_name": "sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_assign_u64().",
      "display_name": "conditional_assign_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_assign_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow2_square().",
      "display_name": "lemma_pow2_square",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow2_square().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_Mod_u8().",
      "display_name": "pow2_MUL_div_Mod_u8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_Mod_u8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "    let s0 = s0_0 / ps64;\n\n    assert(s0_0 < pow2(1 * 8));\n    assert(s0_0 + a1 <= u64::MAX);\n\n    let s1_0 = (s0_0 + a1) as u64;\n    let s1 = s1_0 / ps64;\n\n    assert(s1_0 < pow2(2 * 8));\n    assert(s1 == s0_0 / ps64 + a1 / ps64) by {\n        lemma_bitops_lifted(s0_0, input[i + 1] as u64, 1 * 8, s);\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "display_name": "mul_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn mul_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n            is_canonical_scalar(self),\n    {\n        /* <ORIGINAL CODE>\n         *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n        /* <VERIFICATION NOTE>\n         In the modified code, we store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&old(self).bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        *self = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&self.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_extraction_commutes_with_mod().",
      "display_name": "lemma_byte_extraction_commutes_with_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_extraction_commutes_with_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_byte_extraction_commutes_with_mod(x: nat, k: nat, m: nat)\n    requires\n        k * 8 + 8\n            <= m,  // The byte we're extracting is entirely below the modulo boundary\n\n    ensures\n        (x / pow2(k * 8)) % 256 == ((x % pow2(m)) / pow2(k * 8)) % 256,\n{\n    // Call the generalized version with b=8 (byte size)\n    lemma_chunk_extraction_commutes_with_mod(x, k, 8, m);\n\n    // Establish that pow2(8) == 256\n    lemma2_to64();\n}",
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/masked_lt().",
      "display_name": "masked_lt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/masked_lt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "use super::field_core::*;\n\nverus! {\n\n// Specialization for b = 51\npub proof fn lemma_two_factoring_51(k: nat, ai: u64)\n    ensures\n        pow2(k + 51) * ai == pow2(k) * (pow2(51) * ai),\n{\n    lemma_two_factoring(k, 51, ai);\n}\n\npub proof fn lemma_add_then_shift(a: u64, b: u64)\n    requires\n        a < (1u64 << 52),\n        b < (1u64 << 52),\n    ensures\n        (a + b) < (1u64 << 53),\n        ((a + b) as u64 >> 51) < 4,\n{\n    lemma2_to64_rest();\n    assert((a + b) < 1u64 << 53) by {\n        assert((1u64 << 52) + (1u64 << 52) == 1u64 << 53) by (compute);\n    }\n    assert(1u64 << 53 == (1u64 << 51) * 4) by (bit_vector);\n    // 0 < b  /\\ a < b * c => a/b < c\n    lemma_multiply_divide_lt((a + b) as int, (1u64 << 51) as int, 4int);\n    shift_is_pow2(51);\n    shift_is_pow2(53);\n    assert((a + b) as u64 >> 51 == (a + b) as u64 / (pow2(51) as u64)) by {\n        lemma_u64_shr_is_div((a + b) as u64, 51);\n    }\n    assert(pow2(53) / pow2(51) == 4) by {\n        lemma_pow2_subtracts(51, 53);\n    }\n}\n\n// >> preserves [<=]. Unfortunately, these operations are u128 and\n// we need lemma_u128_shr_is_div.\npub proof fn lemma_shr_51_le(a: u128, b: u128)\n    requires\n        a <= b,\n    ensures\n        (a >> 51) <= (b >> 51),\n{\n    lemma_pow2_pos(51);\n    lemma2_to64_rest();  // pow2(51) value\n    lemma_u128_shr_is_div(a, 51);\n    lemma_u128_shr_is_div(b, 51);\n    lemma_div_is_ordered(a as int, b as int, 51);\n}\n\n// Corollary of above, using the identity (a << x) >> x == a for u64::MAX\npub proof fn lemma_shr_51_fits_u64(a: u128)\n    requires\n        a <= (u64::MAX as u128) << 51,\n    ensures\n        (a >> 51) <= (u64::MAX as u128),\n{\n    assert(((u64::MAX as u128) << 51) >> 51 == (u64::MAX as u128)) by (compute);\n    lemma_shr_51_le(a, (u64::MAX as u128) << 51);\n}\n\n// Auxiliary datatype lemma\n// Should work for any k <= 64, but the proofs are convoluted and we can't use BV\n// (x as u64) = x % 2^64, so x = 2^64 * (x / 2^64) + (x as u64). Thus\n// (x as u64) % 2^k = (x as u64) % 2^k, because 2^k | 2^64 * (...) for k <= 64\npub proof fn lemma_cast_then_mod_51(x: u128)\n    ensures\n        (x as u64) % (pow2(51) as u64) == x % (pow2(51) as u128),\n{\n    lemma2_to64_rest();  // pow2(51 | 64)\n    assert((x as u64) % 0x8000000000000 == x % 0x8000000000000) by (bit_vector);\n}\n\npub proof fn lemma_mul_sub(ci: int, cj: int, cj_0: int, k: nat)\n    ensures\n        pow2(k) * (ci - pow2(51) * (cj - cj_0)) == pow2(k) * ci - pow2(k + 51) * cj + pow2(k + 51)\n            * cj_0,\n{\n    // 2^k (ci - X) = 2^k ci - 2^k X\n    lemma_mul_is_distributive_sub(pow2(k) as int, ci, pow2(51) * (cj - cj_0));\n    // 2^k (2^51 * Y) = (2^k * 2^51) * Y\n    lemma_mul_is_associative(pow2(k) as int, pow2(51) as int, cj - cj_0);\n    // 2^k * 2^51 = 2^(k + 51)\n    lemma_pow2_adds(k, 51);\n    // 2^(k + 51) * (cj - cj_0) = 2^(k + 51) * cj - 2^(k + 51) * cj_0\n    lemma_mul_is_distributive_sub(pow2(k + 51) as int, cj, cj_0);\n}\n\n// Masking with low_bits_mask(51) gives a value bounded by 2^51\npub proof fn masked_lt_51(v: u64)\n    ensures\n        v & mask51 < (1u64 << 51),\n{\n    l51_bit_mask_lt();  // mask51 == low_bits_mask(51)\n    masked_lt(v, 51);\n}\n\n// lemma_div_and_mod specialization for k = 51, using mask51 == low_bits_mask(51)\npub proof fn lemma_div_and_mod_51(ai: u64, bi: u64, v: u64)\n    requires\n        ai == v >> 51,\n        bi == v & mask51,\n    ensures\n        ai == v / (pow2(51) as u64),\n        bi == v % (pow2(51) as u64),\n        v == ai * pow2(51) + bi,\n{\n    l51_bit_mask_lt();  // mask51 == low_bits_mask(51)\n    lemma_div_and_mod(ai, bi, v, 51);\n}\n\npub broadcast proof fn lemma_cast_then_mask_51(x: u128)\n    ensures\n        #![trigger (x as u64) & mask51]\n        (x as u64) & mask51 == x & (mask51 as u128),\n{\n    assert((x as u64) & 2251799813685247u64 == x & (2251799813685247u64 as u128)) by (bit_vector);\n}\n\nfn main() {\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_shl_le_u64().",
      "display_name": "lemma_shl_le_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_shl_le_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn lemma_shl_le_u64(a: u64, b: u64, k: nat)\n    requires\n        a <= b,\n        k < 64,\n        (b * pow2(k)) <= u64::MAX,\n    ensures\n        (a << k) <= (b << k),\n{\n    mul_le(a as nat, b as nat, pow2(k), pow2(k));\n    lemma_u64_shl_is_mul(a, k as u64);\n    lemma_u64_shl_is_mul(b, k as u64);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div().",
      "display_name": "pow2_MUL_div",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn pow2_MUL_div(x: nat, k: nat, s: nat)\n    requires\n        k >= s,\n    ensures\n        (x * pow2(k)) / pow2(s) == x * pow2((k - s) as nat),\n{\n    assert(pow2(s) > 0) by {\n        lemma_pow2_pos(s);\n    }\n\n    let d = (k - s) as nat;\n    assert(pow2(k) == pow2(d) * pow2(s)) by {\n        lemma_pow2_adds(d, s);\n    }\n    assert(x * pow2(k) == (x * pow2(d)) * pow2(s)) by {\n        lemma_mul_is_associative(x as int, pow2(d) as int, pow2(s) as int);\n    }\n    assert(((x * pow2(d)) * pow2(s)) / pow2(s) == x * pow2(d)) by {\n        lemma_div_by_multiple((x * pow2(d)) as int, pow2(s) as int);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#ConditionallySelectable#conditional_select().",
      "display_name": "conditional_select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#ConditionallySelectable#conditional_select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn conditional_select(\n        a: &ProjectivePoint,\n        b: &ProjectivePoint,\n        choice: Choice,\n    ) -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::conditional_select(&a.U, &b.U, choice),\n            W: FieldElement::conditional_select(&a.W, &b.W, choice),\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#as_bytes().",
      "display_name": "as_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#as_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub const fn as_bytes(&self) -> (result: &[u8; 32])\n        ensures\n            result == self.0,\n    {\n        &self.0\n    }",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_bound().",
      "display_name": "lemma_mod_bound",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_bound().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 12,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#decode_253_bits().",
      "display_name": "decode_253_bits",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#decode_253_bits().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    pub fn decode_253_bits(&self) -> (u8, [[u8; 32]; 8]) {\n        let mut ret = [[0u8; 32]; 8];\n        let (mask, fes) = self.elligator_ristretto_flavor_inverse();\n\n        for j in 0..8 {\n            ret[j] = fes[j].as_bytes();\n        }\n        (mask, ret)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/BasepointTable#mul_base_clamped().",
      "display_name": "mul_base_clamped",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/BasepointTable#mul_base_clamped().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn mul_base_clamped(&self, bytes: [u8; 32]) -> Self::Point {\n        // Basepoint multiplication is defined for all values of `bytes` up to and including\n        // 2^255 - 1. The limit comes from the fact that scalar.as_radix_16() doesn't work for\n        // most scalars larger than 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        self.mul_base(&s)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_basics().",
      "display_name": "lemma_mul_basics",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_basics().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/lemma_pow_positive().",
      "display_name": "lemma_pow_positive",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/lemma_pow_positive().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_verus",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_pow2_260_greater_than_2_group_order().",
      "display_name": "lemma_pow2_260_greater_than_2_group_order",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_pow2_260_greater_than_2_group_order().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_pow2_260_greater_than_2_group_order()\n    ensures\n        pow2(260) > 2 * group_order(),\n{\n    // The group order is approximately 2^252, so 2 * group_order ≈ 2^253\n    // And 2^260 >> 2^253\n    assert(pow2(260) == pow2(252) * pow2(8)) by {\n        lemma_pow2_adds(252, 8);\n    };\n    assert(pow2(8) == 256) by {\n        lemma2_to64();\n    };\n    lemma_pow252();\n    // Now Verus knows what the powers of 2 mean, so it can figure out the rest\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "display_name": "limbs_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//use rand_core::{CryptoRng, RngCore};\n",
      "is_libsignal": false,
      "caller_count": 33,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Neg#neg().",
      "display_name": "neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Neg#neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn neg(self) -> EdwardsPoint {\n        -&self\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb1_byte_contribution().",
      "display_name": "limb1_byte_contribution",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb1_byte_contribution().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "spec fn limb1_byte_contribution(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    // Byte 6 high 5 bits (limbs[1]'s bits 0-4)\n    ((limbs[1] as nat % pow2(5)) * 8) * pow2(6 * 8) + bytes[7] as nat * pow2(7 * 8)\n        + bytes[8] as nat * pow2(8 * 8) + bytes[9] as nat * pow2(9 * 8) + bytes[10] as nat * pow2(\n        10 * 8,\n    ) + bytes[11] as nat * pow2(11 * 8)\n        +\n    // Byte 12 low 6 bits (limbs[1]'s bits 45-50)\n    ((limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(12 * 8)\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/a0_0_val().",
      "display_name": "a0_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/a0_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn a0_0_val(a: [u64; 5]) -> u64 {\n    (c0_val(a) as u64) & mask51\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_denominator().",
      "display_name": "lemma_div_denominator",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_denominator().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 9,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/main().",
      "display_name": "main",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/main().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/negate_lemmas.rs",
      "file_name": "negate_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "fn main() {\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/lemma_low_bits_mask_values().",
      "display_name": "lemma_low_bits_mask_values",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/lemma_low_bits_mask_values().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/mask_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/mask_lemmas.rs",
      "file_name": "mask_lemmas.rs",
      "parent_folder": "common_verus",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#cmp().",
      "display_name": "cmp",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#cmp().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
      "relative_path": "src/backend/serial/scalar_mul/pippenger.rs",
      "file_name": "pippenger.rs",
      "parent_folder": "scalar_mul",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#PartialEq#eq().",
      "display_name": "eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#PartialEq#eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn eq(&self, other: &EdwardsPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo rand 0.8.5 thread/rngs/thread_rng().",
      "display_name": "thread_rng",
      "symbol": "rust-analyzer cargo rand 0.8.5 thread/rngs/thread_rng().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_valid_radix_2w().",
      "display_name": "is_valid_radix_2w",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_valid_radix_2w().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\nuse crate::backend;\nuse crate::constants;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::scalar_specs::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::scalar_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n\n#[allow(unused_imports)]\nuse crate::core_assumes::*;\n\n#[allow(unused_imports)]\nuse crate::scalar_specs::*;\n\n#[cfg(feature = \"digest\")]\n#[allow(unused_imports)]\nuse digest::Digest;\n\nverus! {\n\n/*** <VERIFICATION NOTE> Focus on u64; removed all other backend types </VERIFICATION NOTE> ***/\ntype UnpackedScalar = backend::serial::u64::scalar::Scalar52;\n\n/// The `Scalar` struct holds an element of \\\\(\\mathbb Z / \\ell\\mathbb Z \\\\).\n#[allow(clippy::derived_hash_with_manual_eq)]\n#[derive(Copy, Clone, Hash)]\npub struct Scalar {\n    /// `bytes` is a little-endian byte encoding of an integer representing a scalar modulo the\n    /// group order.\n    ///\n    /// # Invariant #1\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255}\\\\). That is, the most\n    /// significant bit of `bytes[31]` is 0.\n    ///\n    /// This is required for `EdwardsPoint` variable- and fixed-base multiplication, because most\n    /// integers above 2^255 are unrepresentable in our radix-16 NAF (see [`Self::as_radix_16`]).\n    /// The invariant is also required because our `MontgomeryPoint` multiplication assumes the MSB\n    /// is 0 (see `MontgomeryPoint::mul`).\n    ///\n    /// # Invariant #2 (weak)\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255} - 19 \\\\), i.e., it represents\n    /// a canonical representative of an element of \\\\( \\mathbb Z / \\ell\\mathbb Z \\\\). This is\n    /// stronger than invariant #1. It also sometimes has to be broken.\n    ///\n    /// This invariant is deliberately broken in the implementation of `EdwardsPoint::{mul_clamped,\n    /// mul_base_clamped}`, `MontgomeryPoint::{mul_clamped, mul_base_clamped}`, and\n    /// `BasepointTable::mul_base_clamped`. This is not an issue though. As mentioned above,\n    /// scalar-point multiplication is defined for any choice of `bytes` that satisfies invariant\n    /// #1. Since clamping guarantees invariant #1 is satisfied, these operations are well defined.\n    ///\n    /// Note: Scalar-point mult is the _only_ thing you can do safely with an unreduced scalar.\n    /// Scalar-scalar addition and subtraction are NOT correct when using unreduced scalars.\n    /// Multiplication is correct, but this is only due to a quirk of our implementation, and not\n    /// guaranteed to hold in general in the future.\n    ///\n    /// Note: It is not possible to construct an unreduced `Scalar` from the public API unless the\n    /// `legacy_compatibility` is enabled (thus making `Scalar::from_bits` public). Thus, for all\n    /// public non-legacy uses, invariant #2\n    /// always holds.\n    ///\n    /* <VERIFICATION NOTE>\n    Changed from pub(crate) to pub\n    </VERIFICATION NOTE> */\n    pub bytes: [u8; 32],/* <ORIGINAL CODE>\n    pub(crate) bytes: [u8; 32],\n    </ORIGINAL CODE> */\n}\n\n// This is a dummy function that we call from signal\n// to test that verus functions in libsignal know\n// about verus functions in curve-dalek\npub open spec fn is_a_scalar(s: Scalar) -> bool {\n    true\n}\n\nimpl Scalar {\n    /// Construct a `Scalar` by reducing a 256-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    // VERIFICATION NOTE: VERIFIED\n    pub fn from_bytes_mod_order(bytes: [u8; 32]) -> (result: Scalar)\n        ensures\n    // Result is equivalent to input modulo the group order\n\n            bytes_to_nat(&result.bytes) % group_order() == bytes_to_nat(&bytes) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        // Temporarily allow s_unreduced.bytes > 2^255 ...\n        let s_unreduced = Scalar { bytes };\n\n        // Then reduce mod the group order and return the reduced representative.\n        let s = s_unreduced.reduce();\n        /*** <VERIFICATION NOTE> We omit debug asserts from verification  </VERIFICATION NOTE> ***/\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }\n\n    /// Construct a `Scalar` by reducing a 512-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    // VERIFICATION NOTE: VERIFIED\n    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == bytes_wide_to_nat(input) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }\n\n    /// Attempt to construct a `Scalar` from a canonical byte representation.\n    ///\n    /// # Return\n    ///\n    /// - `Some(s)`, where `s` is the `Scalar` corresponding to `bytes`,\n    ///   if `bytes` is a canonical byte representation modulo the group order \\\\( \\ell \\\\);\n    /// - `None` if `bytes` is not a canonical byte representation.\n    /*\n    <VERIFICATION NOTE>\n      - Refactored to use wrapper functions instead of trait functions for ct_eq and ct_option_new\n      - Has proof bypass\n    </VERIFICATION NOTE> */\n    pub fn from_canonical_bytes(bytes: [u8; 32]) -> (result: CtOption<Scalar>)\n        ensures\n            bytes_to_nat(&bytes) < group_order() ==> ct_option_has_value(result),\n            bytes_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result),\n            ct_option_has_value(result) ==> bytes_to_nat(&ct_option_value(result).bytes)\n                % group_order() == bytes_to_nat(&bytes) % group_order(),\n    {\n        /* <ORIGINAL CODE>\n          let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let high_byte_shifted = bytes[31] >> 7;\n        let high_bit_unset = ct_eq_u8(&high_byte_shifted, &0);\n        /* </MODIFIED CODE> */\n\n        let candidate = Scalar { bytes };\n        let is_canonical = candidate.is_canonical();\n\n        /* <ORIGINAL CODE>\n          CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n          </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let condition = choice_and(high_bit_unset, is_canonical);\n        let result = ct_option_new(candidate, condition);\n        /* </MODIFIED CODE> */\n\n        // VERIFICATION NOTE: PROOF BYPASS\n        assume(bytes_to_nat(&bytes) < group_order() ==> ct_option_has_value(result));\n        assume(bytes_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result));\n        assume(ct_option_has_value(result) ==> bytes_to_nat(&ct_option_value(result).bytes)\n            % group_order() == bytes_to_nat(&bytes) % group_order());\n\n        result\n    }\n\n    /// Construct a `Scalar` from the low 255 bits of a 256-bit integer. This breaks the invariant\n    /// that scalars are always reduced. Scalar-scalar arithmetic, i.e., addition, subtraction,\n    /// multiplication, **does not work** on scalars produced from this function. You may only use\n    /// the output of this function for `EdwardsPoint::mul`, `MontgomeryPoint::mul`, and\n    /// `EdwardsPoint::vartime_double_scalar_mul_basepoint`. **Do not use this function** unless\n    /// you absolutely have to.\n    /* <VERIFICATION NOTE>\n        -This is not in default features and not in our current target list ==> spec omitted for now\n    </VERIFICATION NOTE> */\n    #[cfg(feature = \"legacy_compatibility\")]\n    #[deprecated(\n        since = \"4.0.0\",\n        note = \"This constructor outputs scalars with undefined scalar-scalar arithmetic. See docs.\"\n    )]\n    pub const fn from_bits(bytes: [u8; 32]) -> Scalar {\n        let mut s = Scalar { bytes };\n        // Ensure invariant #1 holds. That is, make s < 2^255 by masking the high bit.\n        s.bytes[31] &= 0b0111_1111;\n\n        s\n    }\n}\n\nimpl Eq for Scalar {\n\n}\n\nimpl PartialEq for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS (problem with traits)\n    fn eq(&self, other: &Self) -> (result: bool)\n        ensures\n            result == (&self.bytes == &other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Choice::into\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let result = self.ct_eq(other).into();\n         </ORIGINAL CODE> */\n        let choice = self.ct_eq(other);\n        assert(choice_is_true(choice) == (self.bytes == other.bytes));\n        let result = choice_into(choice);\n        assert(result == choice_is_true(choice));\n        assert(result == (self.bytes == other.bytes));\n\n        // VERIFICATION NOTE: vstd's external trait specification check cannot be satisfied\n        // vstd expects obeys_eq_spec() and eq_spec() from PartialEqSpecImpl trait,\n        // but that trait is not publicly exported, so we bypass with assume(false)\n        // while maintaining our own custom ensures clause above\n        assume(false);\n\n        result\n    }\n}\n\nimpl ConstantTimeEq for Scalar {\n    fn ct_eq(&self, other: &Self) -> (result: Choice)\n        ensures\n            choice_is_true(result) == (self.bytes == other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Verus compatibility instead of direct subtle call\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.bytes.ct_eq(&other.bytes)\n         </ORIGINAL CODE> */\n        ct_eq_bytes32(&self.bytes, &other.bytes)\n    }\n}\n\nimpl Index<usize> for Scalar {\n    type Output = u8;\n\n    /// Index the bytes of the representative for this `Scalar`.  Mutation is not permitted.\n    fn index(&self, _index: usize) -> (result: &u8)\n        requires\n            _index < 32,\n        ensures\n            result == &self.bytes[_index as int],\n    {\n        &(self.bytes[_index])\n    }\n}\n\nimpl Debug for Scalar {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar{{\\n\\tbytes: {:?},\\n}}\", &self.bytes)\n    }\n}\n\nimpl<'a> MulAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    fn mul_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n            is_canonical_scalar(self),\n    {\n        /* <ORIGINAL CODE>\n         *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n        /* <VERIFICATION NOTE>\n         In the modified code, we store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&old(self).bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        *self = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&self.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n    }\n}\n\ndefine_mul_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_mul_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn mul_req(self, rhs: &Scalar) -> bool {\n        true  // No preconditions\n\n    }\n\n    open spec fn mul_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'b> Mul<&'b Scalar> for &Scalar {\n    type Output = Scalar;\n\n    // VERIFICATION NOTE: VERIFIED\n    fn mul(self, _rhs: &'b Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n    {\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n            * bytes_to_nat(&_rhs.bytes)) % group_order());\n        /* </MODIFIED CODE> */\n        /* <ORIGINAL CODE>\n         let result = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n\n        result\n    }\n}\n\ndefine_mul_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_add_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn add_req(self, rhs: &Scalar) -> bool {\n        true  // No preconditions yet\n\n    }\n\n    open spec fn add_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'a> Add<&'a Scalar> for &Scalar {\n    type Output = Scalar;\n\n    /* <VERIFICATION NOTE>\n    PROOF BYPASS; may need to add preconditions to spec\n    </VERIFICATION NOTE> */\n    #[allow(non_snake_case)]\n    fn add(self, _rhs: &'a Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(&_rhs.bytes))\n                % group_order(),\n    {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::add requires inputs < group_order()\n        // By Scalar invariant #2, scalars should be canonical\n        // However, we cannot add requires clauses to trait implementations,\n        // so we assume this property holds\n        proof {\n            assume(to_nat(&self_unpacked.limbs) < group_order());\n            assume(to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::add(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) == (to_nat(&self_unpacked.limbs) + to_nat(\n                &rhs_unpacked.limbs,\n            )) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) == to_nat(&result_unpacked.limbs));\n            assert(bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }\n}\n\ndefine_add_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> AddAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    #[allow(clippy::op_ref)]\n    fn add_assign(&mut self, _rhs: &'a Scalar)\n        ensures\n            bytes_to_nat(&self.bytes) == (bytes_to_nat(&old(self).bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order(),\n    {\n        *self = &*self + _rhs;\n    }\n}\n\ndefine_add_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_sub_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn sub_req(self, rhs: &Scalar) -> bool {\n        is_canonical_scalar(self) && is_canonical_scalar(rhs)\n    }\n\n    open spec fn sub_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'b> Sub<&'b Scalar> for &Scalar {\n    type Output = Scalar;\n\n    // VERIFICATION NOTE: PROOF BYPASS (problems with traits and preconditions)\n    // PRECONDITION is_canonical_scalar(self) && is_canonical_scalar(_rhs)\n    #[allow(non_snake_case)]\n    fn sub(self, _rhs: &'b Scalar) -> (result:\n        Scalar)/* VERIFICATION NOTE: preconditions are added to the SpecImpl above\n    requires\n      is_canonical_scalar(self),\n      is_canonical_scalar(_rhs),\n    */\n\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        /* <ORIGINAL CODE>\n         UnpackedScalar::sub(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::sub requires: -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()\n        proof {\n            assume(-group_order() <= to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs));\n            assume(to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::sub(&self_unpacked, &rhs_unpacked);\n        proof {\n            // Postconditions from sub - need to strengthen, review connections\n            assume(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                - to_nat(&rhs_unpacked.limbs)) % (group_order() as int));\n            assume(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int));\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }\n}\n\ndefine_sub_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> SubAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    #[allow(clippy::op_ref)]\n    fn sub_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        *self = &*self - _rhs;\n    }\n}\n\ndefine_sub_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &Scalar {\n    open spec fn obeys_neg_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn neg_req(self) -> bool {\n        true  // No preconditions - scalars are canonical by invariant\n\n    }\n\n    open spec fn neg_spec(self) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl Neg for &Scalar {\n    type Output = Scalar;\n\n    #[allow(non_snake_case)]\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        /* <ORIGINAL CODE>\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        proof {\n            // Preconditions for mul_internal and sub\n            assume(limbs_bounded(&constants::R));\n            assume(limbs_bounded(&UnpackedScalar::ZERO));\n        }\n\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n\n        proof {\n            assume(limbs_bounded(&self_mod_l));\n            // sub requires: -group_order() <= 0 - to_nat(&self_mod_l.limbs) < group_order()\n            assume(-group_order() <= to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(\n                &self_mod_l.limbs,\n            ));\n            assume(to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(&self_mod_l.limbs) < group_order());\n        }\n\n        let result = UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack();\n        proof {\n            // TODO: Prove that -self + self == 0 (mod group_order)\n            assume((scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0);\n        }\n\n        /* </MODIFIED CODE> */\n        result\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for Scalar {\n    open spec fn obeys_neg_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn neg_req(self) -> bool {\n        true  // No specific preconditions - scalars are canonical by invariant\n\n    }\n\n    open spec fn neg_spec(self) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl Neg for Scalar {\n    type Output = Scalar;\n\n    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        let result = (&self).neg();\n        proof {\n            assume((scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0);\n        }\n        result\n    }/* <ORIGINAL CODE>\n    fn neg(self) -> Scalar {\n        -&self\n    }\n    </ORIGINAL CODE> */\n\n}\n\nimpl ConditionallySelectable for Scalar {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> (Self) {\n        let mut bytes = [0u8;32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            /* <VERIFICATION NOTE>\n            Use wrapper function for Verus compatibility instead of direct subtle call\n            </VERIFICATION NOTE> */\n            /* <ORIGINAL CODE>\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n            </ORIGINAL CODE> */\n            /* <MODIFIED CODE> */\n            bytes[i] = select_u8(&a.bytes[i], &b.bytes[i], choice);\n            /* </MODIFIED CODE> */\n        }\n        Scalar { bytes }\n    }\n}\n\n/* <VERIFICATION NOTE>\n Trait implementations for Product and Sum declared as external_body since they use iterators which are not supported by Verus.\n</VERIFICATION NOTE> */\n\nimpl<T> Product<T> for Scalar where T: Borrow<Scalar> {\n    /* <ORIGINAL CODE>\n    fn product<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ONE, |acc, item| acc * item.borrow())\n    }\n    </ORIGINAL CODE> */\n    /* <VERIFICATION NOTE>\n     Added verifier::external_body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    /* <MODIFIED CODE> - FOR EVENTUAL VERIFICATION*/\n    fn product<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified product_of_slice function\n        Scalar::product_of_slice(&scalars)\n    }  /* </MODIFIED CODE> */\n\n}\n\nimpl<T> Sum<T> for Scalar where T: Borrow<Scalar> {\n    #[verifier::external_body]\n    fn sum<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }/* <MODIFIED CODE> - if needed in for verification in the future\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified sum_of_slice function\n        Scalar::sum_of_slice(&scalars)\n    }\n     </MODIFIED CODE> */\n\n}\n\nimpl Default for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn default() -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == 0 as nat,\n    {\n        let result = Scalar::ZERO;\n        assume(scalar_to_nat(&result) == 0 as nat);\n        result\n    }\n}\n\nimpl From<u8> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn from(x: u8) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        let mut s_bytes = [0u8;32];\n        s_bytes[0] = x;\n\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u16> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u16) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u16_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u32> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u32) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u32_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        let result = Scalar { bytes: s_bytes };\n        /* </MODIFIED CODE> */\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u64> for Scalar {\n    /// Construct a scalar from the given `u64`.\n    ///\n    /// # Inputs\n    ///\n    /// An `u64` to convert to a `Scalar`.\n    ///\n    /// # Returns\n    ///\n    /// A `Scalar` corresponding to the input `u64`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let fourtytwo = Scalar::from(42u64);\n    /// let six = Scalar::from(6u64);\n    /// let seven = Scalar::from(7u64);\n    ///\n    /// assert!(fourtytwo == six * seven);\n    /// ```\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u64) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u64_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u128> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u128) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u128_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for Scalar {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self) {\n        self.bytes.zeroize();\n    }\n}\n\nimpl Scalar {\n    /// The scalar \\\\( 0 \\\\).\n    // pub const ZERO: Self = Self { bytes: [0u8; 32] };\n    /* <VERIFICATION NOTE>\n    Changed to explicit initialization\n    </VERIFICATION NOTE> */\n    /* <ORIGINAL CODE>\n    pub const ZERO: Self = Self { bytes: [0u8; 32] };\n    </ORIGINAL CODE> */\n    pub const ZERO: Scalar = Scalar {\n        bytes: [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n        ],\n    };\n\n    /// The scalar \\\\( 1 \\\\).\n    pub const ONE: Self = Self {\n        bytes: [\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n        ],\n    };\n\n    /* <VERIFICATION NOTE>\n     Verification of random method postponed - requires rand_core feature to be enabled.\n    </VERIFICATION NOTE> */\n    #[cfg(any(test, feature = \"rand_core\"))]\n    /// Return a `Scalar` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `CryptoRngCore`\n    ///   (i.e. `CryptoRng` + `RngCore`) interface.\n    ///\n    /// # Returns\n    ///\n    /// A random scalar within \\\\(\\mathbb{Z} / \\ell\\mathbb{Z}\\\\).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # fn main() {\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// use rand_core::OsRng;\n    ///\n    /// let mut csprng = OsRng;\n    /// let a: Scalar = Scalar::random(&mut csprng);\n    /// # }\n    /* <VERIFICATION NOTE>\n     No verifier::external_body annotation but it is NOT verified\n    </VERIFICATION NOTE> */\n    pub fn random<R: CryptoRngCore + ?Sized>(rng: &mut R) -> (result: Self)\n        ensures\n            is_random_scalar(&result),\n            is_canonical_scalar(&result),\n    {\n        let mut scalar_bytes = [0u8;64];\n        rng.fill_bytes(&mut scalar_bytes);\n        Scalar::from_bytes_mod_order_wide(&scalar_bytes)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Hash a slice of bytes into a scalar using a specified hash function.\n    ///\n    /// This function hashes the input using the specified `Digest` type and then reduces\n    /// the result modulo the group order to produce a scalar.\n    ///\n    /// Convenience wrapper around `from_hash`.\n    ///\n    /// # Example\n    ///\n    #[cfg_attr(feature = \"digest\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// use sha2::Sha512;\n    /// # fn main() {\n    /// let msg = \"To really appreciate architecture, you may even need to commit a murder\";\n    /// let s = Scalar::hash_from_bytes::<Sha512>(msg.as_bytes());\n    /// # }\n    /// ```\n    /* <VERIFICATION NOTE>\n     Marked as external_body due to complexity of Digest trait.\n     For Verus verification, use hash_from_bytes_verus instead.\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    pub fn hash_from_bytes<D>(input: &[u8]) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64> + Default,\n\n        ensures\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        Scalar::from_hash(hash)\n    }\n\n    /// Verus-compatible version of hash_from_bytes that uses SHA-512.\n    ///\n    /// This function is designed for Verus verification and directly computes\n    /// a SHA-512 hash. For regular code with generic hash functions, use `hash_from_bytes` instead.\n    ///\n    /// # Inputs\n    ///\n    /// * `input`: a byte slice to hash\n    ///\n    /// # Returns\n    ///\n    /// A scalar reduced modulo the group order\n    pub fn hash_from_bytes_verus(input: &[u8]) -> (result: Scalar)\n        ensures\n            is_random_bytes(input) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        use crate::core_assumes as assumes;\n        let hash_bytes: [u8; 64] = assumes::sha512_hash_bytes(input);\n        Scalar::from_hash_verus(hash_bytes)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Construct a scalar from a 64-byte (512-bit) hash output.\n    ///\n    /// This reduces the hash output modulo the group order.\n    /// Typically used after calling `finalize()` on a SHA-512 hasher.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// use sha2::{Digest, Sha512};\n    ///\n    /// # fn main() {\n    /// let mut h = Sha512::new();\n    /// h.update(b\"To really appreciate architecture, you may even need to commit a murder.\");\n    /// h.update(b\"While the programs used for The Manhattan Transcripts are of the most extreme\");\n    /// h.update(b\"nature, they also parallel the most common formula plot: the archetype of\");\n    /// h.update(b\"murder. Other phantasms were occasionally used to underline the fact that\");\n    /// h.update(b\"perhaps all architecture, rather than being about functional standards, is\");\n    /// h.update(b\"about love and death.\");\n    ///\n    /// let hash_bytes: [u8; 64] = h.finalize().into();\n    /// let s = Scalar::from_hash(hash_bytes);\n    ///\n    /// println!(\"{:?}\", s.to_bytes());\n    /// assert_eq!(\n    ///     s.to_bytes(),\n    ///     [  21,  88, 208, 252,  63, 122, 210, 152,\n    ///       154,  38,  15,  23,  16, 167,  80, 150,\n    ///       192, 221,  77, 226,  62,  25, 224, 148,\n    ///       239,  48, 176,  10, 185,  69, 168,  11, ],\n    /// );\n    /// # }\n    /// ```\n    /* <VERIFICATION NOTE>\n     Marked as external_body due to GenericArray having private fields.\n     For Verus verification, see from_hash_verus below.\n    </VERIFICATION NOTE> */\n    #[cfg(feature = \"digest\")]\n    #[verifier::external_body]\n    pub fn from_hash<D>(hash: D) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64>,\n\n        ensures\n    //is_random_digest(&hash) ==> is_random_scalar(&result),\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut output = [0u8;64];\n        output.copy_from_slice(hash.finalize().as_slice());\n        Scalar::from_bytes_mod_order_wide(&output)\n    }\n\n    /// Verus-compatible version of from_hash that takes pre-finalized hash bytes.\n    ///\n    /// This function is designed for Verus verification and takes a byte array directly\n    /// instead of a generic Digest type. For regular code, use `from_hash` instead.\n    ///\n    /// # Inputs\n    ///\n    /// * `hash_bytes`: a 64-byte array representing the output of a hash function\n    ///\n    /// # Returns\n    ///\n    /// A scalar reduced modulo the group order\n    pub fn from_hash_verus(hash_bytes: [u8; 64]) -> (result: Scalar)\n        ensures\n            is_random_bytes(&hash_bytes) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        let result = Scalar::from_bytes_mod_order_wide(&hash_bytes);\n        assume(false);\n        result\n    }\n\n    /// Convert this `Scalar` to its underlying sequence of bytes.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.to_bytes() == [0u8; 32]);\n    /// ```\n    pub const fn to_bytes(&self) -> (result: [u8; 32])\n        ensures\n            result == self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        self.bytes\n    }\n\n    /// View the little-endian byte encoding of the integer representing this Scalar.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.as_bytes() == &[0u8; 32]);\n    /// ```\n    pub const fn as_bytes(&self) -> (result: &[u8; 32])\n        ensures\n            result == &self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        &self.bytes\n    }\n}\n\nimpl Scalar {\n    /// Given a nonzero `Scalar`, compute its multiplicative inverse.\n    ///\n    /// # Warning\n    ///\n    /// `self` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Returns\n    ///\n    /// The multiplicative inverse of the this `Scalar`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // x = 2238329342913194256032495932344128051776374960164957527413114840482143558222\n    /// let X: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x4e, 0x5a, 0xb4, 0x34, 0x5d, 0x47, 0x08, 0x84,\n    ///         0x59, 0x13, 0xb4, 0x64, 0x1b, 0xc2, 0x7d, 0x52,\n    ///         0x52, 0xa5, 0x85, 0x10, 0x1b, 0xcc, 0x42, 0x44,\n    ///         0xd4, 0x49, 0xf4, 0xa8, 0x79, 0xd9, 0xf2, 0x04,\n    ///     ]);\n    /// // 1/x = 6859937278830797291664592131120606308688036382723378951768035303146619657244\n    /// let XINV: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x1c, 0xdc, 0x17, 0xfc, 0xe0, 0xe9, 0xa5, 0xbb,\n    ///         0xd9, 0x24, 0x7e, 0x56, 0xbb, 0x01, 0x63, 0x47,\n    ///         0xbb, 0xba, 0x31, 0xed, 0xd5, 0xa9, 0xbb, 0x96,\n    ///         0xd5, 0x0b, 0xcd, 0x7a, 0x3f, 0x96, 0x2a, 0x0f,\n    ///     ]);\n    ///\n    /// let inv_X: Scalar = X.invert();\n    /// assert!(XINV == inv_X);\n    /// let should_be_one: Scalar = &inv_X * &X;\n    /// assert!(should_be_one == Scalar::ONE);\n    /// ```\n    // VERIFICATION NOTE: VERIFIED\n    pub fn invert(&self) -> (result: Scalar)\n        requires\n            is_canonical_scalar(self),\n        ensures\n    // Result is the multiplicative inverse: result * self ≡ 1 (mod group_order)\n\n            (scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1,\n            is_canonical_scalar(\n                &result,\n            ),\n    // VERIFICATION NOTE: is this true and/or necessary?\n    // Result is canonical\n    // scalar_to_nat(&result) < group_order(),\n    // result.bytes[31] <= 127,\n\n    {\n        let unpacked = self.unpack();\n        let inv_unpacked = unpacked.invert();\n        let result = inv_unpacked.pack();\n        assert((scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1);\n        assume(is_canonical_scalar(&result));\n        result\n    }\n\n    /// Given a slice of nonzero (possibly secret) `Scalar`s,\n    /// compute their inverses in a batch.\n    ///\n    /// # Return\n    ///\n    /// Each element of `inputs` is replaced by its inverse.\n    ///\n    /// The product of all inverses is returned.\n    ///\n    /// # Warning\n    ///\n    /// All input `Scalars` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// # fn main() {\n    /// let mut scalars = [\n    ///     Scalar::from(3u64),\n    ///     Scalar::from(5u64),\n    ///     Scalar::from(7u64),\n    ///     Scalar::from(11u64),\n    /// ];\n    ///\n    /// let allinv = Scalar::batch_invert(&mut scalars);\n    ///\n    /// assert_eq!(allinv, Scalar::from(3*5*7*11u64).invert());\n    /// assert_eq!(scalars[0], Scalar::from(3u64).invert());\n    /// assert_eq!(scalars[1], Scalar::from(5u64).invert());\n    /// assert_eq!(scalars[2], Scalar::from(7u64).invert());\n    /// assert_eq!(scalars[3], Scalar::from(11u64).invert());\n    /// # }\n    /// ```\n    #[cfg(feature = \"alloc\")]\n    // Theo: Verus doesn't like the zeroize in this function. I think the long-term\n    // solution is to use assume_specification to tell Verus what zeroize does.\n    // In the short-term, I've just told verus to ignore the body.\n    // (SB update: alternative is to exclude just the zeroize call, as below)\n    pub fn batch_invert(inputs: &mut [Scalar]) -> (result:\n        Scalar)/* <VERIFICATION NOTE>\n     Refactored for Verus: Index loops instead of iterators, manual Vec construction, ..\n    </VERIFICATION NOTE> */\n\n        ensures\n    // Result is the modular inverse of the product of all original inputs\n\n            is_inverse_of_nat(&result, product_of_scalars(old(inputs)@)),\n            // Each input is replaced with its inverse\n            forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ),\n    {\n        // This code is essentially identical to the FieldElement\n        // implementation, and is documented there.  Unfortunately,\n        // it's not easy to write it generically, since here we want\n        // to use `UnpackedScalar`s internally, and `Scalar`s\n        // externally, but there's no corresponding distinction for\n        // field elements.\n        let n = inputs.len();\n        let one_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(limbs_bounded(&one_unpacked));\n        }\n\n        let one: UnpackedScalar = one_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&one));\n        }\n\n        /* <VERIFICATION NOTE>\n         Build vec manually instead of vec![one; n] for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let mut scratch = vec![one; n];\n         </ORIGINAL CODE> */\n        let mut scratch = Vec::new();\n        for _ in 0..n {\n            scratch.push(one);\n        }\n\n        // Keep an accumulator of all of the previous products\n        let acc_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(scratch.len() == n);\n            assume(limbs_bounded(&acc_unpacked));\n        }\n\n        let mut acc = acc_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        /* <VERIFICATION NOTE>\n         Rewritten with index loop instead of .zip() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         for (input, scratch) in inputs.iter_mut().zip(scratch.iter_mut()) {\n             *scratch = acc;\n        //     // Avoid unnecessary Montgomery multiplication in second pass by\n        //     // keeping inputs in Montgomery form\n             let tmp = input.unpack().as_montgomery();\n             *input = tmp.pack();\n             acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n         }\n        </ORIGINAL CODE> */\n        for i in 0..n\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                limbs_bounded(&acc),\n        {\n            scratch[i] = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = input_unpacked.as_montgomery();\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n\n            proof {\n                assume(limbs_bounded(&acc));\n            }\n        }\n\n        proof {\n            // Assert that all scratch elements have bounded limbs\n            assume(forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]));\n        }\n\n        // acc is nonzero iff all inputs are nonzero\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert!(acc.pack() != Scalar::ZERO);\n\n        // Compute the inverse of all products\n        // ORIGINAL CODE: acc = acc.montgomery_invert().from_montgomery();\n        acc = acc.montgomery_invert();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        acc = acc.from_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // We need to return the product of all inverses later\n        let ret = acc.pack();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        /* <VERIFICATION NOTE>\n         Manual reverse loop instead of .rev() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.iter().rev()) {\n             let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n             *input = UnpackedScalar::montgomery_mul(&acc, scratch).pack();\n             acc = tmp;\n         }\n        </ORIGINAL CODE> */\n        let mut i: usize = n;\n        while i > 0\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                i <= n,\n                limbs_bounded(&acc),\n                forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]),\n            decreases i,\n        {\n            i -= 1;\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input_unpacked);\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = UnpackedScalar::montgomery_mul(&acc, &scratch[i]).pack();\n            acc = tmp;\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        #[cfg(not(verus_keep_ghost))]\n        Zeroize::zeroize(&mut scratch);\n\n        proof {\n            // Assume the postconditions\n            assume(is_inverse_of_nat(&ret, product_of_scalars(old(inputs)@)));\n            assume(forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ));\n        }\n\n        ret\n    }\n}\n\n#[cfg(feature = \"serde\")]\nuse serde::de::Visitor;\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[cfg(feature = \"serde\")]\n/// Visitor for deserializing a Scalar from a sequence of 32 bytes.\n///\n/* VERIFICATION NOTE:\n- We don't cover serde feature yet\n- The ScalarVisitor struct is defined at module level rather than inside the\n`Deserialize::deserialize` since Verus doesn't support nested types\n</VERIFICATION NOTE> */\nstruct ScalarVisitor;\n\n#[cfg(feature = \"serde\")]\nimpl<'de> Visitor<'de> for ScalarVisitor {\n    type Value = Scalar;\n\n    #[verifier::external_body]\n    fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        {\n            formatter.write_str(\n                \"a sequence of 32 bytes whose little-endian interpretation is less than the \\\n                        basepoint order ℓ\",\n            )\n        }\n    }\n\n    #[verifier::external_body]\n    fn visit_seq<A>(self, mut seq: A) -> Result<Scalar, A::Error> where\n        A: serde::de::SeqAccess<'de>,\n     {\n        let mut bytes = [0u8;32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            bytes[i] = seq.next_element()?.ok_or_else(\n                || serde::de::Error::invalid_length(i, &\"expected 32 bytes\"),\n            )?;\n        }\n        Option::from(Scalar::from_canonical_bytes(bytes)).ok_or_else(\n            || serde::de::Error::custom(\"scalar was not canonically encoded\"),\n        )\n    }\n}\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl Serialize for Scalar {\n    #[verifier::external_body]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl<'de> Deserialize<'de> for Scalar {\n    #[verifier::external_body]\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error> where D: Deserializer<'de> {\n        /* VERIFICATION NOTE:\n        Originally struct ScalarVisitor defined here, but moved up to the top of the file\n        </VERIFICATION NOTE> */\n        deserializer.deserialize_tuple(32, ScalarVisitor)\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec().",
      "display_name": "load8_at_plus_version_rec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn load8_at_plus_version_rec(input: &[u8], i: usize, k: nat) -> u64\n    decreases k,\n{\n    if (k == 0) {\n        (input[i as int] as u64)\n    } else {\n        // k > 0\n        (load8_at_plus_version_rec(input, i, (k - 1) as nat) + ((input[i + k] as u64) << k\n            * 8)) as u64\n    }\n}",
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "display_name": "len",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar_helpers.rs",
      "relative_path": "src/scalar_helpers.rs",
      "file_name": "scalar_helpers.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_from_bytes().",
      "display_name": "field_element_from_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_from_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/curve_specs.rs",
      "relative_path": "src/curve_specs.rs",
      "file_name": "curve_specs.rs",
      "parent_folder": "src",
      "body": "    x % p() == 0 && y % p() == 1\n}\n\n/// Spec: Check if an EdwardsPoint represents the identity point\n/// The identity point is (0, 1) in affine coordinates\n/// In projective coordinates (X:Y:Z:T), this means X/Z = 0 and Y/Z = 1\n/// Which is equivalent to X ≡ 0 (mod p) and Y ≡ Z (mod p) with Z ≠ 0\npub open spec fn is_identity(point: crate::edwards::EdwardsPoint) -> bool {\n    let x = field_element(&point.X);\n    let y = field_element(&point.Y);\n    let z = field_element(&point.Z);\n\n    z != 0 && x == 0 && y == z\n}",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#efgh().",
      "display_name": "efgh",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#efgh().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "            fn efgh(&self) -> FieldElement {\n                &self.eg * &self.fh\n            }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 Choice#unwrap_u8().",
      "display_name": "unwrap_u8",
      "symbol": "rust-analyzer cargo subtle 2.6.1 Choice#unwrap_u8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#ConditionallySelectable#conditional_assign().",
      "display_name": "conditional_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#ConditionallySelectable#conditional_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.y_plus_x.conditional_assign(&other.y_plus_x, choice);\n        self.y_minus_x.conditional_assign(&other.y_minus_x, choice);\n        self.xy2d.conditional_assign(&other.xy2d, choice);\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_nine_limbs_equals_slice128_to_nat().",
      "display_name": "lemma_nine_limbs_equals_slice128_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_nine_limbs_equals_slice128_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_nine_limbs_equals_slice128_to_nat(limbs: &[u128; 9])\n    ensures\n        nine_limbs_to_nat_aux(limbs) == slice128_to_nat(limbs),\n{\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        slice128_to_nat(limbs); {}\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 10);\n        }\n        (limbs[0] as nat) + ((limbs[1] as nat) + ((limbs[2] as nat) + ((limbs[3] as nat) + ((\n        limbs[4] as nat) + ((limbs[5] as nat) + ((limbs[6] as nat) + ((limbs[7] as nat) + (\n        limbs[8] as nat) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52))\n            * pow2(52)) * pow2(52); {\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(104, 52);\n            lemma_pow2_adds(156, 52);\n            lemma_pow2_adds(208, 52);\n            lemma_pow2_adds(260, 52);\n            lemma_pow2_adds(312, 52);\n            lemma_pow2_adds(364, 52);\n            broadcast use group_mul_is_distributive;\n            broadcast use lemma_mul_is_associative;\n\n        }\n        nine_limbs_to_nat_aux(limbs);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq/Seq#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq/Seq#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#vartime_double_scalar_mul_basepoint().",
      "display_name": "vartime_double_scalar_mul_basepoint",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#vartime_double_scalar_mul_basepoint().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "// ------------------------------------------------------------------------\n\n// Use the full trait path to avoid Group::identity overlapping Identity::identity in the\n// rest of the module (e.g. tests).\n#[cfg(feature = \"group\")]\nimpl group::Group for RistrettoPoint {\n    type Scalar = Scalar;\n\n    fn random(mut rng: impl RngCore) -> Self {\n        // NOTE: this is duplicated due to different `rng` bounds\n        let mut uniform_bytes = [0u8; 64];\n        rng.fill_bytes(&mut uniform_bytes);\n        RistrettoPoint::from_uniform_bytes(&uniform_bytes)\n    }\n\n    fn identity() -> Self {\n        Identity::identity()\n    }\n\n    fn generator() -> Self {\n        constants::RISTRETTO_BASEPOINT_POINT\n    }\n\n    fn is_identity(&self) -> Choice {\n        self.ct_eq(&Identity::identity())\n    }\n\n    fn double(&self) -> Self {\n        self + self\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#is_canonical().",
      "display_name": "is_canonical",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#is_canonical().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "fn is_canonical(&self) -> (result: Choice)\n    ensures\n// Result is true iff the scalar satisfies Scalar invariants #1 and #2\n\n        choice_is_true(result) == is_canonical_scalar(self),\n{\n    let result = self.ct_eq(&self.reduce());\n    // TODO: Prove the postcondition from ct_eq and reduce specs\n    assume(choice_is_true(result) == is_canonical_scalar(self));\n    result\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat_52().",
      "display_name": "lemma_sum_equals_byte_nat_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub proof fn lemma_sum_equals_byte_nat_52(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 52),\n        bytes_match_limbs_packing_52(limbs, bytes),\n    ensures\n        limb0_byte_contribution_52(limbs, bytes) + limb1_byte_contribution_52(limbs, bytes)\n            + limb2_byte_contribution_52(limbs, bytes) + limb3_byte_contribution_52(limbs, bytes)\n            + limb4_byte_contribution_52(limbs, bytes) == as_nat_32_u8(&bytes),\n{\n    // The sum lemma is actually straightforward because as_nat_32_u8\n    // is just the sum of all bytes weighted by their positions, and the\n    // limb contribution functions partition this sum.\n    //\n    // Limb 0 contributes: bytes[0-5] fully + low 4 bits of byte 6\n    // Limb 1 contributes: high 4 bits of byte 6 + bytes[7-12] fully\n    // Limb 2 contributes: bytes[13-18] fully + low 4 bits of byte 19\n    // Limb 3 contributes: high 4 bits of byte 19 + bytes[20-25] fully\n    // Limb 4 contributes: bytes[26-31] fully\n    //\n    // When we add these up, each byte is counted exactly once, and the\n    // boundary bytes (6 and 19) are correctly split between adjacent limbs.\n    //\n    // The proof follows by expanding the definitions and grouping terms.\n    lemma2_to64();\n    shift_is_pow2(52);\n\n    // Prove limbs are bounded by pow2(52)\n    assert(forall|i: int| 0 <= i < 5 ==> limbs[i] < pow2(52)) by {\n        assert((1u64 << 52) == pow2(52)) by {\n            shift_is_pow2(52);\n        }\n    }\n\n    // Key: at the boundaries (bytes 6 and 19), the limb contributions partition\n    // the byte value correctly using the predicate bytes_match_limbs_packing_52\n\n    // From the predicate, we know:\n    // bytes[6] == ((limbs[0] >> 48) | (limbs[1] << 4)) as u8\n    // bytes[19] == ((limbs[2] >> 48) | (limbs[3] << 4)) as u8\n\n    // This ensures that:\n    // - Limb 0's high 4 bits + Limb 1's low 4 bits = byte 6\n    // - Limb 2's high 4 bits + Limb 3's low 4 bits = byte 19\n\n    // Define the boundary byte splits\n    let byte6_low = ((limbs[0] as nat / pow2(48)) % 16) * pow2(6 * 8);\n    let byte6_high = ((limbs[1] as nat % pow2(4)) * 16) * pow2(6 * 8);\n\n    let byte19_low = ((limbs[2] as nat / pow2(48)) % 16) * pow2(19 * 8);\n    let byte19_high = ((limbs[3] as nat % pow2(4)) * 16) * pow2(19 * 8);\n\n    // Prove each boundary byte reconstruction using lemma_boundary_byte_combines_52\n    // Byte 6: lemma_boundary_byte_combines_52 proves bytes[6] == (limbs[0]/2^48)%16 + (limbs[1]%2^4)*16\n    assert(bytes[6] as nat == (limbs[0] as nat / pow2(48)) % 16 + (limbs[1] as nat % pow2(4)) * 16)\n        by {\n        lemma_boundary_byte_combines_52(limbs[0], limbs[1], bytes[6], 48, 4);\n    }\n    // Distributivity gives us: (a+b)*c == a*c + b*c\n    assert(bytes[6] as nat * pow2(6 * 8) == ((limbs[0] as nat / pow2(48)) % 16) * pow2(6 * 8) + ((\n    limbs[1] as nat % pow2(4)) * 16) * pow2(6 * 8)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(6 * 8) as int,\n            ((limbs[0] as nat / pow2(48)) % 16) as int,\n            ((limbs[1] as nat % pow2(4)) * 16) as int,\n        );\n    }\n    assert(bytes[6] as nat * pow2(6 * 8) == byte6_low + byte6_high);\n\n    // Byte 19: same pattern\n    assert(bytes[19] as nat == (limbs[2] as nat / pow2(48)) % 16 + (limbs[3] as nat % pow2(4)) * 16)\n        by {\n        lemma_boundary_byte_combines_52(limbs[2], limbs[3], bytes[19], 48, 4);\n    }\n    assert(bytes[19] as nat * pow2(19 * 8) == ((limbs[2] as nat / pow2(48)) % 16) * pow2(19 * 8) + (\n    (limbs[3] as nat % pow2(4)) * 16) * pow2(19 * 8)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(19 * 8) as int,\n            ((limbs[2] as nat / pow2(48)) % 16) as int,\n            ((limbs[3] as nat % pow2(4)) * 16) as int,\n        );\n    }\n    assert(bytes[19] as nat * pow2(19 * 8) == byte19_low + byte19_high);\n\n    // Construct the expression with split boundary bytes\n    let after_split = (bytes[0] as nat) + (bytes[1] as nat) * pow2(1 * 8) + (bytes[2] as nat)\n        * pow2(2 * 8) + (bytes[3] as nat) * pow2(3 * 8) + (bytes[4] as nat) * pow2(4 * 8) + (\n    bytes[5] as nat) * pow2(5 * 8) + byte6_low + byte6_high + (bytes[7] as nat) * pow2(7 * 8) + (\n    bytes[8] as nat) * pow2(8 * 8) + (bytes[9] as nat) * pow2(9 * 8) + (bytes[10] as nat) * pow2(\n        10 * 8,\n    ) + (bytes[11] as nat) * pow2(11 * 8) + (bytes[12] as nat) * pow2(12 * 8) + (bytes[13] as nat)\n        * pow2(13 * 8) + (bytes[14] as nat) * pow2(14 * 8) + (bytes[15] as nat) * pow2(15 * 8) + (\n    bytes[16] as nat) * pow2(16 * 8) + (bytes[17] as nat) * pow2(17 * 8) + (bytes[18] as nat)\n        * pow2(18 * 8) + byte19_low + byte19_high + (bytes[20] as nat) * pow2(20 * 8) + (\n    bytes[21] as nat) * pow2(21 * 8) + (bytes[22] as nat) * pow2(22 * 8) + (bytes[23] as nat)\n        * pow2(23 * 8) + (bytes[24] as nat) * pow2(24 * 8) + (bytes[25] as nat) * pow2(25 * 8) + (\n    bytes[26] as nat) * pow2(26 * 8) + (bytes[27] as nat) * pow2(27 * 8) + (bytes[28] as nat)\n        * pow2(28 * 8) + (bytes[29] as nat) * pow2(29 * 8) + (bytes[30] as nat) * pow2(30 * 8) + (\n    bytes[31] as nat) * pow2(31 * 8);\n\n    assert(bytes[0] as nat * pow2(0 * 8) == bytes[0] as nat * 1);\n    assert(after_split == as_nat_32_u8(&bytes));\n\n    // The mathematical fact: after splitting boundary bytes, this equals the sum of limb contributions\n    assert(after_split == limb0_byte_contribution_52(limbs, bytes) + limb1_byte_contribution_52(\n        limbs,\n        bytes,\n    ) + limb2_byte_contribution_52(limbs, bytes) + limb3_byte_contribution_52(limbs, bytes)\n        + limb4_byte_contribution_52(limbs, bytes));\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 12
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#random().",
      "display_name": "random",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#random().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn random<R: CryptoRngCore + ?Sized>(rng: &mut R) -> (result: Self)\n        ensures\n            is_random_scalar(&result),\n            is_canonical_scalar(&result),\n    {\n        let mut scalar_bytes = [0u8;64];\n        rng.fill_bytes(&mut scalar_bytes);\n        Scalar::from_bytes_mod_order_wide(&scalar_bytes)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/variable_base_mul().",
      "display_name": "variable_base_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/variable_base_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "             && is_valid_edwards_point(\n                result.unwrap(),\n            )\n            // The X coordinate sign bit matches the sign bit from the compressed representation\n             && field_element_sign_bit(&result.unwrap().X) == (self.0[31] >> 7),\n            !is_valid_y_coordinate(field_element_from_bytes(&self.0)) <==> result.is_none(),\n    {\n        let (is_valid_y_coord, X, Y, Z) = decompress::step_1(self);\n\n        proof {\n            assert(choice_is_true(is_valid_y_coord) ==> is_valid_y_coordinate(\n                field_element_from_bytes(&self.0),\n            ));\n            assert(choice_is_true(is_valid_y_coord) ==> on_edwards_curve(\n                field_element(&X),\n                field_element(&Y),\n            ));\n        }\n        if choice_into(is_valid_y_coord) {\n            assert(choice_is_true(is_valid_y_coord));\n            assert(field_element(&Y) == field_element_from_bytes(&self.0));\n            let point = decompress::step_2(self, X, Y, Z);\n            let result = Some(point);\n            assume(false);\n            result\n        } else {\n            assert(!choice_is_true(is_valid_y_coord));\n            assert(!is_valid_y_coordinate(field_element_from_bytes(&self.0)));\n            let result = None;\n            result\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_carry_out_equals_q().",
      "display_name": "lemma_carry_out_equals_q",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_carry_out_equals_q().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_carry_out_equals_q(input_limbs: [u64; 5], q: u64)\n    requires\n        forall|i: int| 0 <= i < 5 ==> input_limbs[i] < (1u64 << 52),\n        q == 0 || q == 1,\n        as_nat(input_limbs) >= p() <==> q == 1,\n        as_nat(input_limbs) < 2 * p(),  // From reduce()'s postcondition\n\n    ensures\n        ({\n            let l0 = (input_limbs[0] + 19 * q) as u64;\n            let l1 = (input_limbs[1] + (l0 >> 51)) as u64;\n            let l2 = (input_limbs[2] + (l1 >> 51)) as u64;\n            let l3 = (input_limbs[3] + (l2 >> 51)) as u64;\n            let l4 = (input_limbs[4] + (l3 >> 51)) as u64;\n            (l4 >> 51) == q\n        }),",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoBasepointTable#basepoint().",
      "display_name": "basepoint",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoBasepointTable#basepoint().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn basepoint(&self) -> RistrettoPoint {\n        RistrettoPoint(self.0.basepoint())\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "display_name": "lemma_reduce",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "use crate::backend::serial::u64::field_lemmas::load8_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::negate_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2_51_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 17
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/Add#add().",
      "display_name": "add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/Add#add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn add(self, other: &'b RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 + other.0)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "display_name": "from_canonical_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn from_canonical_bytes(bytes: [u8; 32]) -> (result: CtOption<Scalar>)\n        ensures\n            bytes_to_nat(&bytes) < group_order() ==> ct_option_has_value(result),\n            bytes_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result),\n            ct_option_has_value(result) ==> bytes_to_nat(&ct_option_value(result).bytes)\n                % group_order() == bytes_to_nat(&bytes) % group_order(),\n    {\n        /* <ORIGINAL CODE>\n          let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let high_byte_shifted = bytes[31] >> 7;\n        let high_bit_unset = ct_eq_u8(&high_byte_shifted, &0);\n        /* </MODIFIED CODE> */\n\n        let candidate = Scalar { bytes };\n        let is_canonical = candidate.is_canonical();\n\n        /* <ORIGINAL CODE>\n          CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n          </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let condition = choice_and(high_bit_unset, is_canonical);\n        let result = ct_option_new(candidate, condition);\n        /* </MODIFIED CODE> */\n\n        // VERIFICATION NOTE: PROOF BYPASS\n        assume(bytes_to_nat(&bytes) < group_order() ==> ct_option_has_value(result));\n        assume(bytes_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result));\n        assume(ct_option_has_value(result) ==> bytes_to_nat(&ct_option_value(result).bytes)\n            % group_order() == bytes_to_nat(&bytes) % group_order());\n\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_expansion().",
      "display_name": "lemma_radix51_telescoping_expansion",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_expansion().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_radix51_telescoping_expansion(\n    q0: int,\n    q1: int,\n    q2: int,\n    q3: int,\n    q4: int,\n    r0: int,\n    r1: int,\n    r2: int,\n    r3: int,\n    r4: int,\n)\n    requires\n        true,\n    ensures\n        (q0 * pow2(51) as int + r0 - 19) + (q1 * pow2(51) as int + r1 - q0) * pow2(51) as int + (q2\n            * pow2(51) as int + r2 - q1) * pow2(102) as int + (q3 * pow2(51) as int + r3 - q2)\n            * pow2(153) as int + (q4 * pow2(51) as int + r4 - q3) * pow2(204) as int + 19 == q4\n            * pow2(51) as int * pow2(204) as int + r0 + r1 * pow2(51) as int + r2 * pow2(102) as int\n            + r3 * pow2(153) as int + r4 * pow2(204) as int,\n{\n    // Establish power relationships: 2^51 * 2^k = 2^(51+k)\n    lemma_pow2_adds(51, 51);\n    lemma_pow2_adds(51, 102);\n    lemma_pow2_adds(51, 153);\n    lemma_pow2_adds(51, 204);\n\n    // Manually expand each multiplication and show the cancellations explicitly\n    let lhs = (q0 * pow2(51) as int + r0 - 19) + (q1 * pow2(51) as int + r1 - q0) * pow2(51) as int\n        + (q2 * pow2(51) as int + r2 - q1) * pow2(102) as int + (q3 * pow2(51) as int + r3 - q2)\n        * pow2(153) as int + (q4 * pow2(51) as int + r4 - q3) * pow2(204) as int + 19;\n\n    // Expand the multiplications using distributivity\n    assert((q1 * pow2(51) as int + r1 - q0) * pow2(51) as int == q1 * pow2(51) as int * pow2(\n        51,\n    ) as int + r1 * pow2(51) as int - q0 * pow2(51) as int) by {\n        lemma_mul_is_distributive_sub_other_way(pow2(51) as int, q1 * pow2(51) as int + r1, q0);\n        lemma_mul_is_distributive_add_other_way(pow2(51) as int, q1 * pow2(51) as int, r1);\n    }\n\n    assert((q2 * pow2(51) as int + r2 - q1) * pow2(102) as int == q2 * pow2(51) as int * pow2(\n        102,\n    ) as int + r2 * pow2(102) as int - q1 * pow2(102) as int) by {\n        lemma_mul_is_distributive_sub_other_way(pow2(102) as int, q2 * pow2(51) as int + r2, q1);\n        lemma_mul_is_distributive_add_other_way(pow2(102) as int, q2 * pow2(51) as int, r2);\n    }\n\n    assert((q3 * pow2(51) as int + r3 - q2) * pow2(153) as int == q3 * pow2(51) as int * pow2(\n        153,\n    ) as int + r3 * pow2(153) as int - q2 * pow2(153) as int) by {\n        lemma_mul_is_distributive_sub_other_way(pow2(153) as int, q3 * pow2(51) as int + r3, q2);\n        lemma_mul_is_distributive_add_other_way(pow2(153) as int, q3 * pow2(51) as int, r3);\n    }\n\n    assert((q4 * pow2(51) as int + r4 - q3) * pow2(204) as int == q4 * pow2(51) as int * pow2(\n        204,\n    ) as int + r4 * pow2(204) as int - q3 * pow2(204) as int) by {\n        lemma_mul_is_distributive_sub_other_way(pow2(204) as int, q4 * pow2(51) as int + r4, q3);\n        lemma_mul_is_distributive_add_other_way(pow2(204) as int, q4 * pow2(51) as int, r4);\n    }\n\n    // Now LHS equals (after substituting the expansions):\n    // = q0*2^51 + r0 - 19\n    //   + q1*2^51*2^51 + r1*2^51 - q0*2^51\n    //   + q2*2^51*2^102 + r2*2^102 - q1*2^102\n    //   + q3*2^51*2^153 + r3*2^153 - q2*2^153\n    //   + q4*2^51*2^204 + r4*2^204 - q3*2^204\n    //   + 19\n\n    // Use the power relationships to simplify products\n    assert(q1 * pow2(51) as int * pow2(51) as int == q1 * pow2(102) as int) by {\n        lemma_mul_is_associative(q1, pow2(51) as int, pow2(51) as int);\n    }\n    assert(q2 * pow2(51) as int * pow2(102) as int == q2 * pow2(153) as int) by {\n        lemma_mul_is_associative(q2, pow2(51) as int, pow2(102) as int);\n    }\n    assert(q3 * pow2(51) as int * pow2(153) as int == q3 * pow2(204) as int) by {\n        lemma_mul_is_associative(q3, pow2(51) as int, pow2(153) as int);\n    }\n\n    // Now we can see the cancellations more clearly:\n    // = (q0*2^51 - q0*2^51) + (q1*2^102 - q1*2^102) + (q2*2^153 - q2*2^153) + (q3*2^204 - q3*2^204)\n    //   + q4*2^51*2^204 + r0 + r1*2^51 + r2*2^102 + r3*2^153 + r4*2^204 + (-19 + 19)\n    // = q4*2^51*2^204 + r0 + r1*2^51 + r2*2^102 + r3*2^153 + r4*2^204\n\n    // The SMT solver should now see this is pure linear arithmetic\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_6_terms().",
      "display_name": "mul_6_terms",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_6_terms().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn mul_6_terms(n: int, x1: int, x2: int, x3: int, x4: int, x5: int, x6: int)\n    ensures\n        n * (x1 + x2 + x3 + x4 + x5 + x6) == (x1 + x2 + x3 + x4 + x5 + x6) * n == n * x1 + n * x2\n            + n * x3 + n * x4 + n * x5 + n * x6,\n{\n    assert(n * (x1 + x2 + x3 + x4 + x5 + x6) == (x1 + x2 + x3 + x4 + x5 + x6) * n) by {\n        lemma_mul_is_commutative(n, x1 + x2 + x3 + x4 + x5 + x6);\n    }\n\n    assert(n * (x1 + x2 + x3 + x4 + x5 + x6) == n * (x1 + x2 + x3 + x4 + x5) + n * x6) by {\n        lemma_mul_is_distributive_add(n, x1 + x2 + x3 + x4 + x5, x6);\n    }\n\n    assert(n * (x1 + x2 + x3 + x4 + x5) == n * x1 + n * x2 + n * x3 + n * x4 + n * x5) by {\n        mul_5_terms(n, x1, x2, x3, x4, x5);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base_clamped().",
      "display_name": "mul_base_clamped",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base_clamped().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_base_clamped(bytes: [u8; 32]) -> Self {\n        // See reasoning in Self::mul_clamped why it is OK to make an unreduced Scalar here. We\n        // note that fixed-base multiplication is also defined for all values of `bytes` less than\n        // 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        Self::mul_base(&s)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_swap().",
      "display_name": "conditional_swap",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_swap().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_u8().",
      "display_name": "ct_eq_u8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_u8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//!\n//! assert!(a == two);\n//! ```\n//!\n//! There is also a constructor that reduces a \\\\(512\\\\)-bit integer,\n//! [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! To construct a `Scalar` as the hash of some input data, use\n//! [`Scalar::hash_from_bytes`], which takes a buffer, or\n//! [`Scalar::from_hash`], which allows an IUF API.\n//!\n#![cfg_attr(feature = \"digest\", doc = \"```\")]\n#![cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n//! # fn main() {\n//! use sha2::{Digest, Sha512};\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! // Hashing a single byte slice\n//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_optional_multiscalar_mul().",
      "display_name": "straus_optional_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_optional_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    {\n        &self.0\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/low_bits_masks_fit_u64().",
      "display_name": "low_bits_masks_fit_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/low_bits_masks_fit_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "            * 8)) as u64\n    }\n}\n\npub proof fn load8_at_plus_version_rec_is_bounded(input: &[u8], i: usize, k: nat)\n    requires\n        k <= 7,\n    ensures\n        load8_at_plus_version_rec(input, i, k) < pow2(8 * (k + 1)),\n    decreases k,\n{\n    assert(u8::MAX < pow2(8)) by {\n        lemma2_to64();\n    }\n\n    if (k == 0) {\n        // just needs the the pre-if assert\n    } else {\n        // k > 0\n        // Let f(k) := load8_at_plus_version_rec(input, i, k)\n        // IH: f(k - 1) < pow2(8 * k)\n        assert(load8_at_plus_version_rec(input, i, (k - 1) as nat) < pow2(8 * k)) by {\n            load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n        }\n\n        let c = (input[i + k] as u64);\n        assert(c < pow2(8));\n\n        // f(k) = f(k - 1) + c * pow2(8 * k)\n        assert(c << (8 * k) == c * pow2(8 * k)) by {\n            assert((input[i + k] as u64) * pow2(8 * k) <= u64::MAX) by {\n                assert(u64::MAX == pow2(64) - 1) by {\n                    lemma2_to64_rest();\n                }\n                assert(c * pow2(8 * k) < pow2(64)) by {\n                    assert(c * pow2(8 * k) < pow2(8) * pow2(8 * k)) by {\n                        lemma_mul_strict_inequality(c as int, pow2(8) as int, pow2(8 * k) as int);\n                    }\n                    assert(pow2(8) * pow2(8 * k) <= pow2(64)) by {\n                        assert(pow2(8 * k) <= pow2(56)) by {\n                            if (k < 7) {\n                                lemma_pow2_strictly_increases(8 * k, 56);\n                            }\n                        }\n                        lemma_pow2_pos(8);\n                        lemma_mul_inequality(pow2(8 * k) as int, pow2(56) as int, pow2(8) as int);\n                        lemma_pow2_adds(8, 56);\n                    }\n                }\n            }\n            lemma_u64_shl_is_mul(c, (8 * k) as u64);\n        }\n\n        // f(k - 1) < 1 * 2^(8k)\n        // c <= 2^8 - 1\n        // f(k -1) + c * 2^8k < 2^8 * 2^8k = 2^(8 * (k + 1))\n\n        assert(load8_at_plus_version_rec(input, i, k) < pow2(8 * k) + c * pow2(8 * k));\n\n        assert(pow2(8 * k) + c * pow2(8 * k) <= pow2(8 * (k + 1))) by {\n            // x + c * x == c ( x + 1 )\n            assert(pow2(8 * k) + c * pow2(8 * k) == pow2(8 * k) * (c + 1)) by {\n                lemma_mul_is_distributive_add(pow2(8 * k) as int, c as int, 1);\n            }\n            assert(c + 1 <= pow2(8));\n\n            assert(pow2(8 * k) * (c + 1) <= pow2(8 * (k + 1))) by {\n                lemma_mul_inequality((c + 1) as int, pow2(8) as int, pow2(8 * k) as int);\n                lemma_pow2_adds(8, 8 * k);\n                lemma_mul_is_distributive_add(8, 1, k as int);\n            }\n        }\n    }\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "display_name": "conditional_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "                CompressedRistretto(s.as_bytes())\n            })\n            .collect()\n    }\n\n    /// Return the coset self + E\\[4\\], for debugging.\n    fn coset4(&self) -> [EdwardsPoint; 4] {\n        [\n            self.0,\n            self.0 + constants::EIGHT_TORSION[2],\n            self.0 + constants::EIGHT_TORSION[4],\n            self.0 + constants::EIGHT_TORSION[6],\n        ]\n    }",
      "is_libsignal": false,
      "caller_count": 9,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "display_name": "montgomery_invert",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn montgomery_invert(&self) -> (result:\n        UnpackedScalar)/* VERIFICATION NOTE:\n    PROOF BYPASS\n    */\n\n        requires\n            limbs_bounded(&self),\n        ensures\n            limbs_bounded(&result),\n            (to_nat(&result.limbs) * to_nat(&self.limbs)) % group_order() == (montgomery_radix()\n                * montgomery_radix())\n                % group_order(),\n    // Equivalent to: from_montgomery(result) * from_montgomery(self) ≡ 1 (mod L)\n    // Expressed in Montgomery form: (result/R) * (self/R) ≡ 1, i.e., result * self ≡ R² (mod L)\n\n    {\n        // Uses the addition chain from\n        // https://briansmith.org/ecc-inversion-addition-chains-01#curve25519_scalar_inversion\n        let _1 = *self;\n        assume(limbs_bounded(&_1));\n        let _10 = _1.montgomery_square();\n        assume(limbs_bounded(&_10));\n        let _100 = _10.montgomery_square();\n        assume(limbs_bounded(&_100));\n        let _11 = UnpackedScalar::montgomery_mul(&_10, &_1);\n        assume(limbs_bounded(&_11));\n        let _101 = UnpackedScalar::montgomery_mul(&_10, &_11);\n        assume(limbs_bounded(&_101));\n        let _111 = UnpackedScalar::montgomery_mul(&_10, &_101);\n        assume(limbs_bounded(&_111));\n        let _1001 = UnpackedScalar::montgomery_mul(&_10, &_111);\n        assume(limbs_bounded(&_1001));\n        let _1011 = UnpackedScalar::montgomery_mul(&_10, &_1001);\n        assume(limbs_bounded(&_1011));\n        let _1111 = UnpackedScalar::montgomery_mul(&_100, &_1011);\n        assume(limbs_bounded(&_1111));\n\n        // _10000\n        let mut y = UnpackedScalar::montgomery_mul(&_1111, &_1);\n        assume(limbs_bounded(&y));\n\n        square_multiply(&mut y, 123 + 3, &_101);\n        square_multiply(&mut y, 2 + 2, &_11);\n        square_multiply(&mut y, 1 + 4, &_1111);\n        square_multiply(&mut y, 1 + 4, &_1111);\n        square_multiply(&mut y, 4, &_1001);\n        square_multiply(&mut y, 2, &_11);\n        square_multiply(&mut y, 1 + 4, &_1111);\n        square_multiply(&mut y, 1 + 3, &_101);\n        square_multiply(&mut y, 3 + 3, &_101);\n        square_multiply(&mut y, 3, &_111);\n        square_multiply(&mut y, 1 + 4, &_1111);\n        square_multiply(&mut y, 2 + 3, &_111);\n        square_multiply(&mut y, 2 + 2, &_11);\n        square_multiply(&mut y, 1 + 4, &_1011);\n        square_multiply(&mut y, 2 + 4, &_1011);\n        square_multiply(&mut y, 6 + 4, &_1001);\n        square_multiply(&mut y, 2 + 2, &_11);\n        square_multiply(&mut y, 3 + 2, &_11);\n        square_multiply(&mut y, 3 + 2, &_11);\n        square_multiply(&mut y, 1 + 4, &_1001);\n        square_multiply(&mut y, 1 + 3, &_111);\n        square_multiply(&mut y, 2 + 4, &_1111);\n        square_multiply(&mut y, 1 + 4, &_1011);\n        square_multiply(&mut y, 3, &_101);\n        square_multiply(&mut y, 2 + 4, &_1111);\n        square_multiply(&mut y, 3, &_101);\n        square_multiply(&mut y, 1 + 2, &_11);\n\n        proof {\n            assume(limbs_bounded(&y));\n            assume((to_nat(&y.limbs) * to_nat(&self.limbs)) % group_order() == (montgomery_radix()\n                * montgomery_radix()) % group_order());\n        }\n\n        y\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "display_name": "as_projective",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "            field_element(&result.T) == field_mul(\n                field_element(&result.X),\n                field_element(&result.Y),\n            ),\n    {\n        // FieldElement::sqrt_ratio_i always returns the nonnegative square root,\n        // so we negate according to the supplied sign bit.\n        let compressed_sign_bit = Choice::from(repr.as_bytes()[31] >> 7);\n\n        /* <VERIFICATION NOTE>\n         Using conditional_negate_field wrapper and assuming preconditions for trait operations.\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n        X.conditional_negate(compressed_sign_bit);\n        </ORIGINAL CODE> */\n        let ghost original_X = X;\n        conditional_negate_field(&mut X, compressed_sign_bit);\n\n        proof {\n            // For Mul (X * Y): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> X.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> Y.limbs[i] < (1u64 << 54));\n\n            // Assume conditional_negate_field behaves correctly\n            assume(field_element(&X) == if choice_is_true(compressed_sign_bit) {\n                field_neg(field_element(&original_X))\n            } else {\n                field_element(&original_X)\n            });\n        }\n\n        let result = EdwardsPoint { X, Y, Z, T: &X * &Y };\n\n        proof {\n            // Assume multiplication produces correct field_mul result\n            assume(field_element(&result.T) == field_mul(\n                field_element(&result.X),\n                field_element(&result.Y),\n            ));\n        }\n\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "display_name": "is_negative",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "//! \\\\( P, Q \\\\) may represent the same coset in the same way that two\n//! points with different \\\\(X,Y,Z\\\\) coordinates may represent the\n//! same point.  The group operations are carried out with no overhead\n//! using Edwards formulas.\n//!\n//! Notes on the details of the encoding can be found in the\n//! [Details][ristretto_notes] section of the Ristretto website.\n//!\n//! [cryptonote]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000898.html\n//! [ed25519_hkd]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000858.html\n//! [ristretto_coffee]:\n//! https://en.wikipedia.org/wiki/Ristretto\n//! [ristretto_notes]:\n//! https://ristretto.group/details/index.html\n//! [why_ristretto]:\n//! https://ristretto.group/why_ristretto.html\n//! [ristretto_main]:\n//! https://ristretto.group/\n\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\n\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};",
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_u64_max_shifting().",
      "display_name": "lemma_u64_max_shifting",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_u64_max_shifting().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/reduce_lemmas.rs",
      "file_name": "reduce_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "    lemma2_to64();\n    pow255_gt_19();\n\n    let r = spec_reduce(limbs);\n\n    assert(1u64 << 51 == pow2(51)) by {\n        shift_is_pow2(51);\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/words_to_nat_gen_u64().",
      "display_name": "words_to_nat_gen_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/words_to_nat_gen_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
      "relative_path": "src/backend/serial/u64/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "u64",
      "body": "pub open spec fn words_to_nat_gen_u64(words: &[u64], num_words: int, bits_per_word: int) -> nat\n    decreases num_words,\n{\n    if num_words <= 0 {\n        0\n    } else {\n        let word_value = (words[num_words - 1] as nat) * pow2(\n            ((num_words - 1) * bits_per_word) as nat,\n        );\n        word_value + words_to_nat_gen_u64(words, num_words - 1, bits_per_word)\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc string/ToString#to_string().",
      "display_name": "to_string",
      "symbol": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc string/ToString#to_string().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_from_montgomery_limbs_conversion().",
      "display_name": "lemma_from_montgomery_limbs_conversion",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_from_montgomery_limbs_conversion().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_from_montgomery_limbs_conversion(limbs: &[u128; 9], self_limbs: &[u64; 5])\n    requires\n        forall|j: int| #![auto] 0 <= j < 5 ==> limbs[j] == self_limbs[j] as u128,\n        forall|j: int| 5 <= j < 9 ==> limbs[j] == 0,\n    ensures\n        slice128_to_nat(limbs) == to_nat(self_limbs),\n{\n    lemma_nine_limbs_equals_slice128_to_nat(limbs);\n    lemma_five_limbs_equals_to_nat(self_limbs);\n    assert(limbs[0] == self_limbs[0] as u128);\n    assert(nine_limbs_to_nat_aux(limbs) == (self_limbs[0] as nat) + (self_limbs[1] as nat) * pow2(\n        52,\n    ) + (self_limbs[2] as nat) * pow2(104) + (self_limbs[3] as nat) * pow2(156) + (\n    self_limbs[4] as nat) * pow2(208) + 0 * pow2(260) + 0 * pow2(312) + 0 * pow2(364) + 0 * pow2(\n        416,\n    ));\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"NafLookupTable5({:?})\", self.0)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Mul#mul().",
      "display_name": "mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Mul#mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_basics_2().",
      "display_name": "lemma_div_basics_2",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_basics_2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConditionallySelectable#conditional_select().",
      "display_name": "conditional_select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConditionallySelectable#conditional_select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    /// discrete log of the output point with respect to any other\n    /// point should be unknown.  The map is applied twice and the\n    /// results are added, to ensure a uniform distribution.\n    ///\n    /// # Example\n    ///\n    #[cfg_attr(feature = \"digest\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n    /// # use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use sha2::Sha512;\n    ///\n    /// # // Need fn main() here in comment so the doctest compiles\n    /// # // See https://doc.rust-lang.org/book/documentation.html#documentation-as-tests\n    /// # fn main() {\n    /// let msg = \"To really appreciate architecture, you may even need to commit a murder\";\n    /// let P = RistrettoPoint::hash_from_bytes::<Sha512>(msg.as_bytes());\n    /// # }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_nondecreasing().",
      "display_name": "shl_nondecreasing",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_nondecreasing().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn shl_nondecreasing(v: u64, a: nat, b: nat)\n    requires\n        a <= b < 64,\n        v * pow2(b) <= u64::MAX,\n    ensures\n        (v << a) <= (v << b),\n{\n    lemma2_to64();  // pow2(0)\n\n    if (a == b) {\n        // trivial\n    } else if (a == 0) {\n        // a != b <=> b > 0\n        lemma_pow2_strictly_increases(0, b);\n        lemma_u64_shl_is_mul(v, 0);\n        lemma_u64_shl_is_mul(v, b as u64);\n        mul_le(v as nat, v as nat, pow2(0), pow2(b));\n    } else {\n        // if a != 0 and a != b then 0 < d < b\n        let d = b - a;\n\n        // v << b = (v << (b - a)) << a\n        shl_decomposition(v, d as nat, a);\n\n        assert(v << d == v * pow2(d as nat)) by {\n            // we need the precond v * pow2(d) < M\n            lemma_pow2_strictly_increases(d as nat, b);\n            mul_le(v as nat, v as nat, pow2(d as nat), pow2(b));\n            lemma_u64_shl_is_mul(v, d as u64);\n        }\n\n        assert(v <= v << d) by {\n            shl_zero_is_id(v);\n            lemma_u64_shl_is_mul(v, 0);\n            lemma_pow2_strictly_increases(0, d as nat);\n            mul_le(v as nat, v as nat, pow2(0), pow2(d as nat));\n        }\n\n        lemma_pow2_adds(a, d as nat);\n\n        assert((v << (d as u64)) * pow2(a) <= u64::MAX) by {\n            lemma_mul_is_associative(v as int, pow2(d as nat) as int, pow2(a) as int);\n        }\n\n        // [v <= v << d] => [(v << a) <= (v << d) << a]\n        lemma_shl_le_u64(v, v << (d as u64), a);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/slice128_to_nat().",
      "display_name": "slice128_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/slice128_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "#[allow(unused_imports)]\nuse vstd::calc;\nuse vstd::prelude::*;\n\n#[allow(unused_imports)]\nuse super::common_verus::shift_lemmas::*;\n\nverus! {\n\n/// Verification: scalar * scalar.invert() ≡ 1 mod L\nproof fn verify_invert_correct(\n    x: Scalar52,\n)\n//     requires to_scalar(&x.limbs) != 0\n//    ensures (to_scalar(&x.limbs) * invert_spec(&x.limbs)) % group_order() == 1\n{\n    assume(false);\n\n}\n\npub proof fn lemma_52_52(x: u64, y: u64)\n    requires\n        x < (1u64 << 52),\n        y < (1u64 << 52),\n    ensures\n        (x as u128) * (y as u128) < (1u128 << 104),\n{\n    assert(1u128 << 52 == 1u64 << 52) by (bit_vector);\n    calc! {\n        (<)\n        (x as u128) * (y as u128); (<=) {\n            if x > 0 {\n                lemma_mul_strict_inequality(y as int, (1u128 << 52) as int, x as int);\n                assert(x * y < x * (1u128 << 52));\n            } else {\n                assert((0 as u128) * (y as u128) == 0);\n            }\n        }\n        (x as u128) * (1u128 << 52); (<) {\n            lemma_mul_strict_inequality(x as int, (1u128 << 52) as int, (1u128 << 52) as int);\n        }\n        (1u128 << 52) * (1u128 << 52);\n    }\n    assert((1u128 << 52) * (1u128 << 52) == (1u128 << 104)) by (compute);\n}\n\npub proof fn lemma_square_internal_no_overflow()\n    ensures\n        (1u128 << 105) + (1u128 << 105) == (1u128 << 106),\n        (1u128 << 105) + (1u128 << 104) < (1u128 << 106),\n        (1u128 << 104) * 2 == (1u128 << 105),\n        (1u128 << 106) + (1u128 << 104) < (1u128 << 107),\n{\n    assert((1u128 << 105) + (1u128 << 105) == (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 105) + (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 104) * 2 == (1u128 << 105)) by (bit_vector);\n    assert((1u128 << 106) + (1u128 << 104) < (1u128 << 107)) by (bit_vector);\n}\n\npub proof fn lemma_square_internal_correct(a: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        z[0] == (a[0] * a[0]),\n        z[1] == (a[0] * a[1]) * 2,\n        z[2] == (a[0] * a[2]) * 2 + (a[1] * a[1]),\n        z[3] == (a[0] * a[3]) * 2 + (a[1] * a[2]) * 2,\n        z[4] == (a[0] * a[4]) * 2 + (a[1] * a[3]) * 2 + (a[2] * a[2]),\n        z[5] == (a[1] * a[4]) * 2 + (a[2] * a[3]) * 2,\n        z[6] == (a[2] * a[4]) * 2 + (a[3] * a[3]),\n        z[7] == (a[3] * a[4]) * 2,\n        z[8] == (a[4] * a[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(a),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*a) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n}\n\npub proof fn lemma_mul_internal_no_overflow()\n    ensures\n        (1u128 << 104) + (1u128 << 104) == (1u128 << 105),\n        3u128 * (1u128 << 104) < (1u128 << 106),\n        4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104),\n        (1u128 << 2) * (1u128 << 104) == (1u128 << 106),\n        8u128 == (1u128 << 3),\n        (1u128 << 3) * (1u128 << 104) == (1u128 << 107),\n{\n    assert((1u128 << 104) + (1u128 << 104) == (1u128 << 105)) by (bit_vector);\n    assert(3u128 * (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert(4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104)) by (bit_vector);\n    assert((1u128 << 2) * (1u128 << 104) == (1u128 << 106)) by (bit_vector);\n    assert(8u128 == (1u128 << 3)) by (bit_vector);\n    assert((1u128 << 3) * (1u128 << 104) == (1u128 << 107)) by (bit_vector);\n}\n\npub proof fn lemma_mul_internal_correct(a: &[u64; 5], b: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        forall|i: int| 0 <= i < 5 ==> b[i] < (1u64 << 52),\n        z[0] == (a[0] * b[0]),\n        z[1] == (a[0] * b[1]) + (a[1] * b[0]),\n        z[2] == (a[0] * b[2]) + (a[1] * b[1]) + (a[2] * b[0]),\n        z[3] == (a[0] * b[3]) + (a[1] * b[2]) + (a[2] * b[1]) + (a[3] * b[0]),\n        z[4] == (a[0] * b[4]) + (a[1] * b[3]) + (a[2] * b[2]) + (a[3] * b[1]) + (a[4] * b[0]),\n        z[5] == (a[1] * b[4]) + (a[2] * b[3]) + (a[3] * b[2]) + (a[4] * b[1]),\n        z[6] == (a[2] * b[4]) + (a[3] * b[3]) + (a[4] * b[2]),\n        z[7] == (a[3] * b[4]) + (a[4] * b[3]),\n        z[8] == (a[4] * b[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(b),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*b) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n    lemma_five_limbs_equals_to_nat(&b);\n}\n\npub proof fn lemma_nine_limbs_equals_slice128_to_nat(limbs: &[u128; 9])\n    ensures\n        nine_limbs_to_nat_aux(limbs) == slice128_to_nat(limbs),\n{\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        slice128_to_nat(limbs); {}\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 10);\n        }\n        (limbs[0] as nat) + ((limbs[1] as nat) + ((limbs[2] as nat) + ((limbs[3] as nat) + ((\n        limbs[4] as nat) + ((limbs[5] as nat) + ((limbs[6] as nat) + ((limbs[7] as nat) + (\n        limbs[8] as nat) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52))\n            * pow2(52)) * pow2(52); {\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(104, 52);\n            lemma_pow2_adds(156, 52);\n            lemma_pow2_adds(208, 52);\n            lemma_pow2_adds(260, 52);\n            lemma_pow2_adds(312, 52);\n            lemma_pow2_adds(364, 52);\n            broadcast use group_mul_is_distributive;\n            broadcast use lemma_mul_is_associative;\n\n        }\n        nine_limbs_to_nat_aux(limbs);\n    }\n}\n\npub proof fn lemma_five_limbs_equals_to_nat(limbs: &[u64; 5])\n    ensures\n        five_limbs_to_nat_aux(*limbs) == to_nat(limbs),\n{\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        to_nat(limbs); {}\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 6);\n        }\n        (limbs[0] as nat) + ((limbs[1] as nat) + ((limbs[2] as nat) + ((limbs[3] as nat) + (\n        limbs[4] as nat) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52); {\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(104, 52);\n            lemma_pow2_adds(156, 52);\n            broadcast use group_mul_is_distributive;\n            broadcast use lemma_mul_is_associative;\n\n        }\n        (limbs[0] as nat) + pow2(52) * (limbs[1] as nat) + pow2(104) * (limbs[2] as nat) + pow2(156)\n            * (limbs[3] as nat) + pow2(208) * (limbs[4] as nat); {}\n        five_limbs_to_nat_aux(*limbs);\n    }\n}\n\npub proof fn lemma_bytes_to_nat_rec_equals_bytes_to_nat(bytes: &[u8; 32])\n    ensures\n        bytes_to_nat(bytes) == as_nat_32_u8(bytes),\n{\n    // Strategy: Unfold the recursive definition and show it matches the explicit sum\n    // The recursive definition bytes_to_nat_rec(bytes, 0) computes:\n    // bytes[0] * 2^0 + bytes[1] * 2^8 + ... + bytes[31] * 2^248\n    // First, reveal the recursive structure by showing a few key steps\n    reveal_with_fuel(bytes_to_nat_rec, 33);\n\n    // Now we need to show that the recursive unfolding equals the explicit sum\n    // The key is that pow2(0) == 1, so bytes[0] * pow2(0) == bytes[0]\n    assert(pow2(0) == 1) by {\n        lemma2_to64();\n    };\n\n    // Use calc block to show the transformation step by step\n    calc! {\n        (==)\n        bytes_to_nat(bytes); {}\n        bytes_to_nat_rec(bytes, 0); {\n            // Unfold recursively - Verus should be able to see this with fuel\n        }\n        (bytes[0] as nat) * pow2(0) + (bytes[1] as nat) * pow2(8) + (bytes[2] as nat) * pow2(16) + (\n        bytes[3] as nat) * pow2(24) + (bytes[4] as nat) * pow2(32) + (bytes[5] as nat) * pow2(40)\n            + (bytes[6] as nat) * pow2(48) + (bytes[7] as nat) * pow2(56) + (bytes[8] as nat)\n            * pow2(64) + (bytes[9] as nat) * pow2(72) + (bytes[10] as nat) * pow2(80) + (\n        bytes[11] as nat) * pow2(88) + (bytes[12] as nat) * pow2(96) + (bytes[13] as nat) * pow2(\n            104,\n        ) + (bytes[14] as nat) * pow2(112) + (bytes[15] as nat) * pow2(120) + (bytes[16] as nat)\n            * pow2(128) + (bytes[17] as nat) * pow2(136) + (bytes[18] as nat) * pow2(144) + (\n        bytes[19] as nat) * pow2(152) + (bytes[20] as nat) * pow2(160) + (bytes[21] as nat) * pow2(\n            168,\n        ) + (bytes[22] as nat) * pow2(176) + (bytes[23] as nat) * pow2(184) + (bytes[24] as nat)\n            * pow2(192) + (bytes[25] as nat) * pow2(200) + (bytes[26] as nat) * pow2(208) + (\n        bytes[27] as nat) * pow2(216) + (bytes[28] as nat) * pow2(224) + (bytes[29] as nat) * pow2(\n            232,\n        ) + (bytes[30] as nat) * pow2(240) + (bytes[31] as nat) * pow2(248); {\n            // Simplify bytes[0] * pow2(0) to bytes[0]\n            // Since pow2(0) == 1, we have x * 1 == x\n            assert((bytes[0] as nat) * pow2(0) == (bytes[0] as nat)) by {\n                assert(pow2(0) == 1);\n            };\n        }\n        (bytes[0] as nat) + (bytes[1] as nat) * pow2(8) + (bytes[2] as nat) * pow2(16) + (\n        bytes[3] as nat) * pow2(24) + (bytes[4] as nat) * pow2(32) + (bytes[5] as nat) * pow2(40)\n            + (bytes[6] as nat) * pow2(48) + (bytes[7] as nat) * pow2(56) + (bytes[8] as nat)\n            * pow2(64) + (bytes[9] as nat) * pow2(72) + (bytes[10] as nat) * pow2(80) + (\n        bytes[11] as nat) * pow2(88) + (bytes[12] as nat) * pow2(96) + (bytes[13] as nat) * pow2(\n            104,\n        ) + (bytes[14] as nat) * pow2(112) + (bytes[15] as nat) * pow2(120) + (bytes[16] as nat)\n            * pow2(128) + (bytes[17] as nat) * pow2(136) + (bytes[18] as nat) * pow2(144) + (\n        bytes[19] as nat) * pow2(152) + (bytes[20] as nat) * pow2(160) + (bytes[21] as nat) * pow2(\n            168,\n        ) + (bytes[22] as nat) * pow2(176) + (bytes[23] as nat) * pow2(184) + (bytes[24] as nat)\n            * pow2(192) + (bytes[25] as nat) * pow2(200) + (bytes[26] as nat) * pow2(208) + (\n        bytes[27] as nat) * pow2(216) + (bytes[28] as nat) * pow2(224) + (bytes[29] as nat) * pow2(\n            232,\n        ) + (bytes[30] as nat) * pow2(240) + (bytes[31] as nat) * pow2(248); {}\n        as_nat_32_u8(bytes);\n    }\n}\n\npub proof fn lemma_scalar_subtract_no_overflow(\n    carry: u64,\n    difference_limb: u64,\n    addend: u64,\n    i: u32,\n    l_value: &Scalar52,\n)\n    requires\n        i < 5,\n        difference_limb < (1u64 << 52),\n        addend == 0 || addend == l_value.limbs[i as int],\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n    ensures\n        (carry >> 52) + difference_limb + addend < (1u64 << 53),\n{\n    if i == 0 {\n        assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    } else if i == 1 {\n        assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n    } else if i == 2 {\n        assert(0x000000000014def9 < (1u64 << 52)) by (bit_vector);\n    } else if i == 3 {\n    } else {\n        assert(0x0000100000000000 < (1u64 << 52)) by (bit_vector);\n    }\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert(2 * (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}\n\npub proof fn lemma_borrow_and_mask_bounded(borrow: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        (borrow & mask) < (1u64 << 52),\n{\n    assert((borrow & mask) <= mask) by (bit_vector);\n}\n\npub proof fn lemma_carry_bounded_after_mask(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) <= 1,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}\n\npub proof fn lemma_add_loop_bounds(i: int, carry: u64, a_limb: u64, b_limb: u64)\n    requires\n        0 <= i < 5,\n        a_limb < (1u64 << 52),\n        b_limb < (1u64 << 52),\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n    ensures\n        (carry >> 52) + a_limb + b_limb < (1u64 << 53),\n{\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert((1u64 << 52) + (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}\n\npub proof fn lemma_add_carry_and_sum_bounds(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) < 2,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}\n\npub proof fn lemma_l_value_properties(l_value: &Scalar52, sum: &Scalar52)\n    requires\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n    ensures\n        forall|j: int| 0 <= j < 5 ==> l_value.limbs[j] < (1u64 << 52),\n{\n    assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n}\n\npub proof fn lemma_from_montgomery_limbs_conversion(limbs: &[u128; 9], self_limbs: &[u64; 5])\n    requires\n        forall|j: int| #![auto] 0 <= j < 5 ==> limbs[j] == self_limbs[j] as u128,\n        forall|j: int| 5 <= j < 9 ==> limbs[j] == 0,\n    ensures\n        slice128_to_nat(limbs) == to_nat(self_limbs),\n{\n    lemma_nine_limbs_equals_slice128_to_nat(limbs);\n    lemma_five_limbs_equals_to_nat(self_limbs);\n    assert(limbs[0] == self_limbs[0] as u128);\n    assert(nine_limbs_to_nat_aux(limbs) == (self_limbs[0] as nat) + (self_limbs[1] as nat) * pow2(\n        52,\n    ) + (self_limbs[2] as nat) * pow2(104) + (self_limbs[3] as nat) * pow2(156) + (\n    self_limbs[4] as nat) * pow2(208) + 0 * pow2(260) + 0 * pow2(312) + 0 * pow2(364) + 0 * pow2(\n        416,\n    ));\n}\n\npub proof fn lemma_rr_limbs_bounded()\n    ensures\n        0x000d63c715bea69fu64 < (1u64 << 52),\n{\n    // Verus can figure that out the other 4 limbs are bounded\n    assert(0x000d63c715bea69fu64 < (1u64 << 52)) by (bit_vector);\n}\n\n/// Need to use induction because the postcondition expands\n/// seq_u64_to_nat in the opposite way from how it's defined.\n/// The base case is straightforward, but it takes a few steps\n/// to get Verus to prove it.\n/// Induction case: Take off the first element using definition of\n/// seq_u64_to_nat, apply induction hypothesis to the remaining sequence,\n/// then put the first element back on and simplify all the powers.\npub proof fn lemma_seq_u64_to_nat_subrange_extend(seq: Seq<u64>, i: int)\n    requires\n        0 <= i < seq.len(),\n    ensures\n        seq_u64_to_nat(seq.subrange(0, i + 1)) == seq_u64_to_nat(seq.subrange(0, i)) + seq[i]\n            * pow2(52 * i as nat),\n    decreases i,\n{\n    if i == 0 {\n        reveal_with_fuel(seq_to_nat, 3);\n        assert(seq.len() > 0);\n        assert(seq.subrange(0, 1) == seq![seq[0]]);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, 0 + 1 as int)); {\n                assert(seq.subrange(0, 1) == seq![seq[0]]);\n            }\n            seq_u64_to_nat(seq![seq[0]]); {\n                let single_elem = seq![seq[0]];\n                let nat_single = single_elem.map(|idx, x| x as nat);\n                assert(nat_single == seq![seq[0] as nat]);\n                assert(seq_u64_to_nat(single_elem) == seq_to_nat(nat_single));\n                assert(nat_single.len() == 1);\n                assert(seq_to_nat(nat_single) == nat_single[0] + seq_to_nat(\n                    nat_single.subrange(1, 1),\n                ) * pow2(52));\n                assert(nat_single.subrange(1, 1).len() == 0);\n                assert(seq_to_nat(nat_single.subrange(1, 1)) == 0);\n                assert(seq_to_nat(nat_single) == nat_single[0]);\n                assert(nat_single[0] == seq[0] as nat);\n            }\n            seq[0] as nat; {\n                assert(pow2(0) == 1) by {\n                    lemma2_to64();\n                }\n                assert(52 * 0 == 0);\n                assert(pow2(52 * 0 as nat) == pow2(0));\n                assert((seq[0] * pow2(0)) as nat == (seq[0] * 1) as nat);\n                assert((seq[0] * 1) as nat == seq[0] as nat);\n            }\n            (seq[0] * pow2(52 * 0 as nat)) as nat; {\n                lemma_empty_seq_as_nat(seq);\n            }\n            (seq_u64_to_nat(seq.subrange(0, 0)) + seq[0] * pow2(52 * 0 as nat)) as nat;\n        }\n        return ;\n    } else {\n        let limbs1 = seq.subrange(0, i + 1).map(|i, x| x as nat);\n        let limbs2 = seq.subrange(0, i).map(|i, x| x as nat);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, i + 1)); {\n                assert(seq_to_nat(limbs1) == limbs1[0] + seq_to_nat(\n                    limbs1.subrange(1, limbs1.len() as int),\n                ) * pow2(52));\n            }\n            limbs1[0] + seq_to_nat(limbs1.subrange(1, limbs1.len() as int)) * pow2(52); {\n                assert(seq.subrange(1, i + 1).map(|i, x| x as nat) == limbs1.subrange(\n                    1,\n                    limbs1.len() as int,\n                ));\n            }\n            limbs1[0] + seq_u64_to_nat(seq.subrange(1, i + 1)) * pow2(52); {\n                let tail = seq.subrange(1, i + 1);\n                assert(i >= 1);\n                assert(0 <= i - 1 < tail.len());\n                lemma_seq_u64_to_nat_subrange_extend(tail, i - 1);\n                assert(seq_u64_to_nat(tail.subrange(0, i)) == seq_u64_to_nat(\n                    tail.subrange(0, i - 1),\n                ) + tail[i - 1] * pow2(52 * (i - 1) as nat));\n                assert(tail.subrange(0, i) == seq.subrange(1, i + 1));\n                assert(tail.subrange(0, i - 1) == seq.subrange(1, i));\n                assert(seq_u64_to_nat(seq.subrange(1, i + 1)) == seq_u64_to_nat(seq.subrange(1, i))\n                    + seq[i] * pow2(52 * (i - 1) as nat));\n            }\n            limbs1[0] + ((seq_u64_to_nat(seq.subrange(1, i)) + seq[i] * pow2(52 * (i - 1) as nat))\n                * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i)) * pow2(52) + seq[i] * pow2(\n                52 * (i - 1) as nat,\n            ) * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_associative;\n\n                lemma_pow2_adds(52 * (i - 1) as nat, 52);\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i)) * pow2(52) + seq[i] * pow2(\n                52 * i as nat,\n            )) as nat; {\n                assert(seq.subrange(1, i).map(|i, x| x as nat) == limbs2.subrange(\n                    1,\n                    limbs2.len() as int,\n                ));\n            }\n            (limbs2[0] + seq_to_nat(limbs2.subrange(1, limbs2.len() as int)) * pow2(52) + seq[i]\n                * pow2(52 * i as nat)) as nat; {\n                assert(seq_to_nat(limbs2) == limbs2[0] + seq_to_nat(\n                    limbs2.subrange(1, limbs2.len() as int),\n                ) * pow2(52));\n            }\n            (seq_to_nat(limbs2) + seq[i] * pow2(52 * i as nat)) as nat; {}\n            (seq_u64_to_nat(seq.subrange(0, i)) + seq[i] * pow2(52 * i as nat)) as nat;\n        }\n    }\n}\n\n/// Verus times out when this assertion is inside\n/// lemma_seq_u64_to_nat_subrange_extend\npub proof fn lemma_empty_seq_as_nat(a: Seq<u64>)\n    ensures\n        seq_u64_to_nat(a.subrange(0, 0)) == 0,\n{\n    assert(seq_u64_to_nat(a.subrange(0, 0)) == 0);\n}\n\n/// Using lemma_mod_add_multiples_vanish in a big proof made the proof hang\npub proof fn lemma_mod_cancel(a: &Scalar52, b: &Scalar52)\n    ensures\n        (group_order() + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int) == (to_nat(\n            &a.limbs,\n        ) - to_nat(&b.limbs)) % (group_order() as int),\n{\n    lemma_mod_add_multiples_vanish(\n        (to_nat(&a.limbs) - to_nat(&b.limbs)) as int,\n        group_order() as int,\n    );\n}\n\n/// The corollary of limbs_bounded(a)\npub proof fn lemma_bound_scalar(a: &Scalar52)\n    requires\n        limbs_bounded(a),\n    ensures\n        to_nat(&a.limbs) < pow2((52 * (5) as nat)),\n{\n    lemma_general_bound(a.limbs@);\n}\n\n/// The general case of lemma_bound_scalar so we\n/// can prove via straightforward induction.\npub proof fn lemma_general_bound(a: Seq<u64>)\n    requires\n        forall|i: int| 0 <= i < a.len() ==> a[i] < (1u64 << 52),\n    ensures\n        seq_u64_to_nat(a) < pow2((52 * a.len() as nat)),\n    decreases a.len(),\n{\n    if a.len() == 0 {\n        assert(seq_u64_to_nat(a) == 0);\n        lemma2_to64();  // Gives us pow2(0) == 1 among other facts\n        assert(pow2(0) == 1);\n    } else {\n        // Inductive case\n        let tail = a.subrange(1, a.len() as int);\n\n        // Apply induction hypothesis on tail\n        assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] < (1u64 << 52)) by {\n            assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] == a[i + 1]);\n        };\n\n        assert(tail.len() == a.len() - 1);\n\n        // Apply induction hypothesis\n        lemma_general_bound(tail);\n        assert(seq_u64_to_nat(tail) < pow2((52 * tail.len() as nat)));\n\n        // Now prove for the full sequence\n        assert(seq_u64_to_nat(a) == seq_to_nat(a.map(|i, x| x as nat)));\n        assert(a.map(|i, x| x as nat).len() == a.len());\n        assert(a.map(|i, x| x as nat)[0] == a[0] as nat);\n        assert(a.map(|i, x| x as nat).subrange(1, a.len() as int) == a.subrange(\n            1,\n            a.len() as int,\n        ).map(|i, x| x as nat));\n        // Therefore:\n        assert(seq_u64_to_nat(a) == a[0] as nat + seq_u64_to_nat(a.subrange(1, a.len() as int))\n            * pow2(52));\n\n        assert(a.subrange(1, a.len() as int) == tail);\n\n        // From precondition\n        assert(a[0] < (1u64 << 52));\n        lemma2_to64_rest();\n        assert(0x10000000000000 == 1u64 << 52) by (compute_only);\n        assert(0x10000000000000 == pow2(52));\n        assert((1u64 << 52) == pow2(52));\n\n        // We have seq_u64_to_nat(a) == a[0] + seq_u64_to_nat(tail) * pow2(52)\n        // We know a[0] < pow2(52) and seq_u64_to_nat(tail) < pow2(52 * (a.len() - 1))\n\n        assert(a[0] as nat <= pow2(52) - 1);\n        assert(seq_u64_to_nat(tail) <= pow2(52 * (a.len() - 1) as nat) - 1);\n\n        assert(seq_u64_to_nat(a) <= (pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(\n            52,\n        )) by {\n            lemma_mul_inequality(\n                (pow2(52 * (a.len() - 1) as nat) - 1) as int,\n                pow2(52 * (a.len() - 1) as nat) as int,\n                pow2(52) as int,\n            );\n        };\n\n        // Expand the right side\n        assert((pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(52) == pow2(52) - 1\n            + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52)) by {\n            broadcast use lemma_mul_is_distributive_sub;\n\n        };\n\n        assert(pow2(52) - 1 + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52) == pow2(\n            52 * (a.len() - 1) as nat,\n        ) * pow2(52) - 1);\n\n        lemma_pow2_adds(52 * (a.len() - 1) as nat, 52);\n        assert(pow2(52 * (a.len() - 1) as nat) * pow2(52) == pow2(52 * (a.len() - 1) as nat + 52));\n        assert(52 * (a.len() - 1) as nat + 52 == 52 * a.len() as nat);\n\n        assert(seq_u64_to_nat(a) <= pow2(52 * a.len() as nat) - 1);\n        assert(seq_u64_to_nat(a) < pow2(52 * a.len() as nat));\n    }\n}\n\n/// Claude wrote this proof. Could the proof be shorter?\n/// Moved this to a lemma to get under rlimit.\npub proof fn lemma_decompose(a: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        a == (a >> 52) * pow2(52) + (a & mask),\n{\n    // First, establish that bit shifting is division by pow2(52)\n    broadcast use lemma_u64_shr_is_div;\n\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    lemma2_to64_rest();  // Establishes pow2(52) == 0x10000000000000\n    assert((1u64 << 52) == 0x10000000000000) by (bit_vector);\n    assert(pow2(52) == 0x10000000000000);\n    assert((1u64 << 52) as nat == pow2(52));\n\n    assert(a >> 52 == a / (1u64 << 52));\n\n    // Apply fundamental division theorem: a = q * d + r\n    lemma_fundamental_div_mod(a as int, pow2(52) as int);\n    let q = a as nat / pow2(52);\n    let r = a as nat % pow2(52);\n    assert(a as nat == q * pow2(52) + r);\n    assert(0 <= r < pow2(52));\n\n    // Now prove that (a & mask) == r\n    // mask is all 1s in the lower 52 bits\n    assert(mask == (1u64 << 52) - 1);\n\n    // Key insight: a & mask gives us the lower 52 bits, which is exactly a % pow2(52)\n    lemma_u64_low_bits_mask_is_mod(a, 52);\n    assert(a & mask == a % (1u64 << 52));\n    assert((a % (1u64 << 52)) as nat == a as nat % pow2(52));\n    assert((a & mask) as nat == r);\n\n    // Now show that a >> 52 == q\n    assert((a >> 52) as nat == a as nat / pow2(52));\n    assert((a >> 52) as nat == q);\n\n    // Combine everything\n    assert(a as nat == (a >> 52) as nat * pow2(52) + (a & mask) as nat);\n}\n\n/// The loop invariant says that subtraction is correct if we only subtract\n/// the first i items of each array, plus there's a borrow term.\n/// The first parts of the calc statement expand using the previous invariant.\n/// Then we have cases depending if the wrapping_sub wrapped.\n/// If it didn't wrap, we show that borrow must be small, and borrow >> 52 == 0.\n/// If it did wrap, we show that borrow is so large that its bit-shifts are all\n/// the maximum amount.\n/// Either way, we then use the preconditions about what was mutated,\n/// and shuffle around the powers of 52.\npub proof fn lemma_sub_loop1_invariant(\n    difference: Scalar52,\n    borrow: u64,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    old_borrow: u64,\n    mask: u64,\n    difference_loop1_start: Scalar52,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> difference.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) == seq_u64_to_nat(difference_loop1_start.limbs@.subrange(0, i as int)) - (old_borrow\n            >> 63) * pow2((52 * (i) as nat)),\n        difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(\n            0,\n            i as int,\n        ),\n        difference.limbs[i as int] == borrow & mask,\n        borrow == a.limbs[i as int].wrapping_sub((b.limbs[i as int] + (old_borrow >> 63)) as u64),\n    ensures\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n            (52 * (i + 1) as nat),\n        ) == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i + 1),\n        ),\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] * pow2(52 * i as nat) - (\n        seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] * pow2(52 * i as nat)); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) + (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            assert(difference_loop1_start.limbs@.subrange(0, i as int)\n                == difference.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) - (old_borrow >> 63) * pow2(\n            52 * i as nat,\n        ) + (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n            - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n            assert(borrow == a.limbs[i as int].wrapping_sub(\n                (b.limbs[i as int] + (old_borrow >> 63)) as u64,\n            ));\n            assert(difference.limbs[i as int] == borrow & mask);\n            // Expand wrapping sub\n            if a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) < 0 {\n                assert(borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52)) by {\n                    assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    assert(b.limbs[i as int] <= (1u64 << 52) - 1);\n                    assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                        >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                    assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 <= 1u64 << 52);\n                    assert(borrow >= (a.limbs[i as int] - (1u64 << 52)\n                        + 0x1_0000_0000_0000_0000) as u64);\n                };\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n                        - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                            >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow\n                        - 0x1_0000_0000_0000_0000) * pow2(52 * i as nat); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((borrow >> 52)\n                        * pow2(52) + difference.limbs[i as int] - 0x1_0000_0000_0000_0000) * pow2(\n                        52 * i as nat,\n                    ); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                            broadcast use lemma_pow2_adds;\n\n                        };\n                        assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n                        broadcast use lemma_mul_is_distributive_sub_other_way;\n\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow\n                            >> 52) as nat * pow2(52 * (i + 1) as nat)) by {\n                            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                            lemma_mul_is_associative(\n                                (borrow >> 52) as int,\n                                pow2(52) as int,\n                                pow2(52 * i as nat) as int,\n                            );\n                        };\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) + difference.limbs[i as int] * pow2(52 * i as nat) - 0x1_0000_0000_0000_0000\n                        * pow2(52 * i as nat); {\n                        lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) - 0x1_0000_0000_0000_0000 * pow2(52 * i as nat); {\n                        assert(borrow >> 52 == (1u64 << 12) - 1) by (bit_vector)\n                            requires\n                                borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52),\n                        ;\n                        assert(0x1_0000_0000_0000_0000 * pow2(52 * i as nat) == (1u64 << 12) * pow2(\n                            52 * (i + 1) as nat,\n                        )) by {\n                            lemma2_to64();\n                            assert(0x1_0000_0000_0000_0000 == pow2(64));\n                            assert(1u64 << 12 == pow2(12)) by (compute);\n                            lemma_pow2_adds(64, 52 * i as nat);\n                            lemma_pow2_adds(12, 52 * (i + 1) as nat);\n                            assert(64 + 52 * i as nat == 12 + 52 * (i + 1) as nat);\n                        }\n                        lemma_mul_is_distributive_sub_other_way(\n                            pow2(52 * (i + 1) as nat) as int,\n                            (1u64 << 12) - 1,\n                            (1u64 << 12) as int,\n                        );\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (-1) * pow2(\n                        52 * (i + 1) as nat,\n                    ); {\n                        assert(borrow >> 63 == 1) by (bit_vector)\n                            requires\n                                borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52),\n                        ;\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n                        (52 * (i + 1) as nat),\n                    );\n                }\n            } else {\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n                        - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                            >> 63)) as u64)) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow) * pow2(\n                        52 * i as nat,\n                    ); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((borrow >> 52)\n                        * pow2(52) + difference.limbs[i as int]) * pow2(52 * i as nat); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                            broadcast use lemma_pow2_adds;\n\n                        };\n                        assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow\n                            >> 52) as nat * pow2(52 * (i + 1) as nat)) by {\n                            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                            lemma_mul_is_associative(\n                                (borrow >> 52) as int,\n                                pow2(52) as int,\n                                pow2(52 * i as nat) as int,\n                            );\n                        };\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) + difference.limbs[i as int] * pow2(52 * i as nat); {\n                        lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                        assert(borrow < 1u64 << 52) by {\n                            assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                                >> 63)) as u64)) as u64);\n                            assert(a.limbs[i as int] < (1u64 << 52));\n                            assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 >= 0);\n                        }\n                        assert(borrow >> 52 == 0) by (bit_vector)\n                            requires\n                                borrow < 1u64 << 52,\n                        ;\n                        assert(borrow >> 63 == 0) by (bit_vector)\n                            requires\n                                borrow < 1u64 << 52,\n                        ;\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n                        (52 * (i + 1) as nat),\n                    );\n                }\n            }\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n            (52 * (i + 1) as nat),\n        );\n    }\n}\n\n/// Just a proof by computation\npub(crate) proof fn lemma_l_equals_group_order()\n    ensures\n        to_nat(&constants::L.limbs) == group_order(),\n        seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order(),\n{\n    // First show that the subrange equals the full array\n    assert(constants::L.limbs@ == constants::L.limbs@.subrange(0, 5 as int));\n    assert(seq_u64_to_nat(constants::L.limbs@) == seq_u64_to_nat(\n        constants::L.limbs@.subrange(0, 5 as int),\n    ));\n    assert(to_nat(&constants::L.limbs) == seq_u64_to_nat(constants::L.limbs@));\n\n    assert(pow2(52) == 0x10000000000000) by {\n        lemma2_to64_rest();\n    };\n    lemma_pow2_adds(52, 52);\n    assert(pow2(104) == 0x100000000000000000000000000);\n    lemma_pow2_adds(104, 104);\n    assert(pow2(208) == 0x10000000000000000000000000000000000000000000000000000);\n    lemma_pow252();\n    lemma_five_limbs_equals_to_nat(&constants::L.limbs);\n    assert(five_limbs_to_nat_aux(constants::L.limbs) == group_order()) by (compute);\n}\n\npub proof fn lemma_pow252()\n    ensures\n        pow2(252) == 0x1000000000000000000000000000000000000000000000000000000000000000,\n{\n    assert(pow2(63) == 0x8000000000000000) by {\n        lemma2_to64_rest();\n    }\n    lemma_pow2_adds(63, 63);\n    assert(pow2(126) == 0x40000000000000000000000000000000);\n    lemma_pow2_adds(126, 126);\n}\n\npub proof fn lemma_pow2_260_greater_than_2_group_order()\n    ensures\n        pow2(260) > 2 * group_order(),\n{\n    // The group order is approximately 2^252, so 2 * group_order ≈ 2^253\n    // And 2^260 >> 2^253\n    assert(pow2(260) == pow2(252) * pow2(8)) by {\n        lemma_pow2_adds(252, 8);\n    };\n    assert(pow2(8) == 256) by {\n        lemma2_to64();\n    };\n    lemma_pow252();\n    // Now Verus knows what the powers of 2 mean, so it can figure out the rest\n}\n\n/// If borrow >> 63 == 0, we apply\n/// (1) `-group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()`,\n/// and that's enough to show that to_nat(&difference.limbs) is between\n/// 0 and group order.\n/// If borrow >> 63 == 1, we apply (1) to show that carry >> 52 can't be 0.\n/// This makes the excess terms in the borrow >> 63 == 1 precondition disappear\npub(crate) proof fn lemma_sub_correct_after_loops(\n    difference: Scalar52,\n    carry: u64,\n    a: &Scalar52,\n    b: &Scalar52,\n    difference_after_loop1: Scalar52,\n    borrow: u64,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        limbs_bounded(&difference),\n        limbs_bounded(&difference_after_loop1),\n        (carry >> 52) < 2,\n        -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order(),\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n            + seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ) + (carry >> 52) * pow2(52 * 5 as nat),\n        seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) - (borrow >> 63)\n            * pow2((52 * (5) as nat)),\n    ensures\n        to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int),\n{\n    assert(borrow >> 63 == 1 || borrow >> 63 == 0) by (bit_vector);\n    assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(&difference.limbs))\n        by {\n        assert(seq_u64_to_nat(difference.limbs@) == to_nat(&difference.limbs));\n        assert(difference.limbs@ == difference.limbs@.subrange(0, 5 as int));\n    }\n    assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs)) by {\n        assert(seq_u64_to_nat(b.limbs@) == to_nat(&b.limbs));\n        assert(b.limbs@ == b.limbs@.subrange(0, 5 as int));\n    }\n    assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs)) by {\n        assert(seq_u64_to_nat(a.limbs@) == to_nat(&a.limbs));\n        assert(a.limbs@ == a.limbs@.subrange(0, 5 as int));\n    }\n    if borrow >> 63 == 0 {\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) - (borrow >> 63) * pow2(\n            (52 * (5) as nat),\n        ));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)));\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) == to_nat(&difference.limbs));\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) >= 0);\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) < group_order());\n        lemma_small_mod((to_nat(&a.limbs) - to_nat(&b.limbs)) as nat, group_order());\n        assert(to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (\n        group_order() as int));\n    }\n    if borrow >> 63 == 1 {\n        assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            constants::L.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ));\n        assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n            == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ) - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) - pow2(\n            (52 * (5) as nat),\n        ));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ) - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) - pow2((52 * (5) as nat)));\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            a.limbs@.subrange(0, 5 as int),\n        ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ) + (carry >> 52) * pow2(52 * 5 as nat) - pow2((52 * (5) as nat)));\n        if carry >> 52 == 0 {\n            // Get a contradiction because the sides in the above equation have different signs\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n                a.limbs@.subrange(0, 5 as int),\n            ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) >= 0) by {\n                assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) >= group_order())\n                    by {\n                    lemma_l_equals_group_order();\n                };\n                assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs));\n                assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs));\n            };\n            assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) < pow2(\n                (52 * (5) as nat),\n            )) by {\n                assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(\n                    &difference.limbs,\n                ));\n                lemma_bound_scalar(&difference);\n            };\n            assert((carry >> 52) * pow2(52 * 5 as nat) == 0);\n            assert(false);\n        }\n        assert(carry >> 52 == 1);\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            a.limbs@.subrange(0, 5 as int),\n        ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ));\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + to_nat(&a.limbs)\n            - to_nat(&b.limbs) == to_nat(&difference.limbs));\n        assert(to_nat(&constants::L.limbs) == group_order()) by {\n            lemma_l_equals_group_order();\n        };\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order()) by {\n            lemma_l_equals_group_order();\n        };\n        assert(group_order() > 0);\n        calc! {\n            (==)\n            to_nat(&difference.limbs) as int; {}\n            group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs); {\n                assert(group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs) < group_order())\n                    by {\n                    assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n                        == to_nat(&difference_after_loop1.limbs)) by {\n                        assert(seq_u64_to_nat(difference_after_loop1.limbs@) == to_nat(\n                            &difference_after_loop1.limbs,\n                        ));\n                        assert(difference_after_loop1.limbs@\n                            == difference_after_loop1.limbs@.subrange(0, 5 as int));\n                    }\n                    assert(to_nat(&a.limbs) - to_nat(&b.limbs) == to_nat(\n                        &difference_after_loop1.limbs,\n                    ) - pow2((52 * (5) as nat)));\n                    lemma_bound_scalar(&difference_after_loop1);\n                };\n                lemma_small_mod(\n                    (group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) as nat,\n                    group_order(),\n                );\n            }\n            (group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int); {\n                lemma_mod_cancel(a, b);\n            }\n            (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int);\n        }\n    }\n}\n\n/// Moving this out to get under rlimit\npub proof fn lemma_old_carry(old_carry: u64)\n    requires\n        old_carry < 1u64 << 52,\n    ensures\n        old_carry >> 52 == 0,\n{\n    assert(old_carry >> 52 == 0) by (bit_vector)\n        requires\n            old_carry < 1u64 << 52,\n    ;\n}\n\n/// If borrow >> 63 == 0, we just prove that the loop step has no effect.\n/// If borrow >> 63 == 1, we substitute in the loop's updates\n/// like `difference.limbs[i as int] == carry & mask`.\n/// In that case we're proving that subtraction is correct if we only\n/// consider the first i items of each array, except there's also a\n/// `(carry >> 52) * pow2(52 * (i+1) as nat)` term that doesn't go away.\npub(crate) proof fn lemma_sub_loop2_invariant(\n    difference: Scalar52,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    mask: u64,\n    difference_after_loop1: Scalar52,\n    difference_loop2_start: Scalar52,\n    carry: u64,\n    old_carry: u64,\n    addend: u64,\n    borrow: u64,\n)\n    requires\n        0 <= i < 5,\n        mask == (1u64 << 52) - 1,\n        forall|j: int| 0 <= j < 5 ==> difference_loop2_start.limbs[j] < (1u64 << 52),\n        forall|j: int|\n            i <= j < 5 ==> difference_loop2_start.limbs[j] == difference_after_loop1.limbs[j],\n        forall|j: int|\n            (0 <= j < 5 && j != i) ==> difference_loop2_start.limbs[j] == difference.limbs[j],\n        mask == (1u64 << 52) - 1,\n        i == 0 ==> old_carry == 0,\n        i >= 1 ==> (old_carry >> 52) < 2,\n        (i >= 1 && borrow >> 63 == 0) ==> old_carry == difference_loop2_start.limbs[i - 1],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference_loop2_start,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int))\n            + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) == seq_u64_to_nat(\n            difference_loop2_start.limbs@.subrange(0, i as int),\n        ) + (old_carry >> 52) * pow2(52 * i as nat),\n        difference.limbs[i as int] == carry & mask,\n        difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(\n            0,\n            i as int,\n        ),\n        borrow >> 63 == 0 ==> addend == 0,\n        borrow >> 63 == 1 ==> addend == constants::L.limbs[i as int],\n        carry == (old_carry >> 52) + difference_loop2_start.limbs[i as int] + addend,\n    ensures\n        (i + 1 >= 1 && borrow >> 63 == 0) ==> carry == difference.limbs[i as int],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(\n            difference_after_loop1.limbs@.subrange(0, i + 1 as int),\n        ) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i + 1 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, i + 1 as int),\n        ) + (carry >> 52) * pow2(52 * (i + 1) as nat),\n{\n    if borrow >> 63 == 0 {\n        lemma_old_carry(old_carry);\n        assert(addend == 0);\n        assert(carry == difference_loop2_start.limbs[i as int]);\n        assert(carry & mask == carry) by (bit_vector)\n            requires\n                carry < 1u64 << 52,\n                mask == (1u64 << 52) - 1,\n        ;\n        assert(difference_after_loop1.limbs[i as int] == difference.limbs[i as int]);\n        assert(forall|j: int|\n            0 <= j < 5 ==> difference_after_loop1.limbs[j] == difference.limbs[j]);\n        assert(difference_after_loop1.limbs == difference.limbs);\n    }\n    if borrow >> 63 == 1 {\n        // When underflow, addend = L.limbs[i]\n        assert(addend == constants::L.limbs[i as int]);\n        // carry = (old_carry >> 52) + difference_after_loop1.limbs[i] + L.limbs[i]\n        // difference.limbs[i] = carry & mask\n        calc! {\n            (==)\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(\n                constants::L.limbs@.subrange(0, i + 1),\n            ); {\n                lemma_seq_u64_to_nat_subrange_extend(difference_after_loop1.limbs@, i as int);\n                lemma_seq_u64_to_nat_subrange_extend(constants::L.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int))\n                + difference_after_loop1.limbs[i as int] as nat * pow2(52 * i as nat)\n                + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int))\n                + constants::L.limbs[i as int] as nat * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n                constants::L.limbs@.subrange(0, i as int),\n            ) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                // Use invariant\n            }\n            seq_u64_to_nat(difference_loop2_start.limbs@.subrange(0, i as int)) + (old_carry\n                >> 52) as nat * pow2(52 * i as nat) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(difference_loop2_start.limbs@.subrange(0, i as int)\n                    == difference.limbs@.subrange(0, i as int));\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat\n                * pow2(52 * i as nat) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((old_carry >> 52) as nat\n                + difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(carry == (old_carry >> 52) + difference_after_loop1.limbs[i as int]\n                    + constants::L.limbs[i as int]);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + carry as nat * pow2(\n                52 * i as nat,\n            ); {\n                assert(carry == (carry >> 52) * (1u64 << 52) + (carry & mask)) by (bit_vector)\n                    requires\n                        mask == (1u64 << 52) - 1,\n                ;\n                assert(carry == (carry >> 52) * pow2(52) + difference.limbs[i as int]) by {\n                    lemma2_to64_rest();\n                    assert(0x10000000000000 == 1u64 << 52) by (compute_only);\n                };\n                assert(difference.limbs[i as int] == carry & mask);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((carry >> 52) as nat * pow2(\n                52,\n            ) + difference.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n                52,\n            ) * pow2(52 * i as nat) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                    broadcast use lemma_pow2_adds;\n\n                };\n                assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat\n                    * pow2(52 * (i + 1) as nat)) by {\n                    assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                    lemma_mul_is_associative(\n                        (carry >> 52) as int,\n                        pow2(52) as int,\n                        pow2(52 * i as nat) as int,\n                    );\n                };\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n                52 * (i + 1) as nat,\n            ) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (carry >> 52) as nat * pow2(\n                52 * (i + 1) as nat,\n            );\n        }\n    }\n}\n\n/// Proves that the addition loop maintains its invariant:\n/// a[0..i+1] + b[0..i+1] == sum[0..i+1] + (carry >> 52) * 2^(52*(i+1))\n/// See lemma_sub_loop1_invariant for more comments\npub proof fn lemma_add_loop_invariant(\n    sum: Scalar52,\n    carry: u64,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    old_carry: u64,\n    mask: u64,\n    sum_loop_start: Scalar52,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> sum.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) == seq_u64_to_nat(sum_loop_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) * pow2(\n            (52 * (i) as nat),\n        ),\n        sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int),\n        sum.limbs[i as int] == carry & mask,\n        carry == a.limbs[i as int] + b.limbs[i as int] + (old_carry >> 52),\n    ensures\n        seq_u64_to_nat(sum.limbs@.subrange(0, i + 1)) + (carry >> 52) * pow2((52 * (i + 1) as nat))\n            == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i + 1),\n        ),\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] as nat * pow2(\n            52 * i as nat,\n        ) + seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] as nat * pow2(\n            52 * i as nat,\n        ); {\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                a.limbs[i as int] as int,\n                b.limbs[i as int] as int,\n            );\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) + (a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(\n            52 * i as nat,\n        ) + (a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                (old_carry >> 52) as int,\n                (a.limbs[i as int] as nat + b.limbs[i as int] as nat) as int,\n            );\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + ((old_carry >> 52) as nat\n            + a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(carry == a.limbs[i as int] + b.limbs[i as int] + (old_carry >> 52));\n            assert(sum.limbs[i as int] == carry & mask);\n            // Decompose carry using the mask\n            lemma_decompose(carry, mask);\n            assert(carry == (carry >> 52) * pow2(52) + sum.limbs[i as int]);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + ((carry >> 52) as nat * pow2(52)\n            + sum.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                lemma_pow2_adds(52, 52 * i as nat);\n            };\n            assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                (carry >> 52) as nat * pow2(52) as int,\n                sum.limbs[i as int] as int,\n            );\n            assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat\n                * pow2(52 * (i + 1) as nat)) by {\n                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                lemma_mul_is_associative(\n                    (carry >> 52) as int,\n                    pow2(52) as int,\n                    pow2(52 * i as nat) as int,\n                );\n            };\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n            52 * (i + 1) as nat,\n        ) + sum.limbs[i as int] as nat * pow2(52 * i as nat); {\n            lemma_seq_u64_to_nat_subrange_extend(sum.limbs@, i as int);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i + 1)) + (carry >> 52) as nat * pow2(\n            (52 * (i + 1) as nat),\n        );\n    }\n}\n\n/// Get rid of the subranges from the invariant statement.\n/// Since a and b are less than group order, we can show that carry >> 52\n/// has to be 0, else the RHS is too large\npub proof fn lemma_add_sum_simplify(a: &Scalar52, b: &Scalar52, sum: &Scalar52, carry: u64)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        to_nat(&a.limbs) < group_order(),\n        to_nat(&b.limbs) < group_order(),\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n        (carry >> 52) < 2,\n        seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) + (carry >> 52) as nat * pow2(\n            (52 * (5) as nat),\n        ),\n    ensures\n        to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs),\n{\n    // First establish the relationship between the different representations\n    assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs)) by {\n        assert(a.limbs@ == a.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(a.limbs@) == to_nat(&a.limbs));\n    }\n    assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs)) by {\n        assert(b.limbs@ == b.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(b.limbs@) == to_nat(&b.limbs));\n    }\n    assert(seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) == to_nat(&sum.limbs)) by {\n        assert(sum.limbs@ == sum.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(sum.limbs@) == to_nat(&sum.limbs));\n    }\n\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs) + (carry >> 52) * pow2(\n        (52 * (5) as nat),\n    ));\n\n    // From the loop invariant, we have: a + b == sum + (carry >> 52) * 2^260\n    assert(52 * 5 == 260) by (compute);\n    assert(pow2((52 * 5) as nat) == pow2(260));\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(\n        260,\n    ));\n\n    // Since a < group_order() and b < group_order(), we have a + b < 2 * group_order()\n    // This is just basic arithmetic: if x < A and y < A, then x + y < A + A = 2*A\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) < group_order() + group_order());\n    assert(group_order() + group_order() == 2 * group_order());\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) < 2 * group_order());\n\n    // Therefore: sum + (carry >> 52) * 2^260 < 2 * group_order()\n    assert(to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260) < 2 * group_order());\n\n    // Prove a contradiction if carry is nonzero\n    assert((carry >> 52) as nat * pow2(260) < 2 * group_order());\n    if carry >> 52 == 1 {\n        lemma_pow2_260_greater_than_2_group_order();\n        assert(1 as nat * pow2(260) < 2 * group_order());\n        assert(false);\n    }\n    assert(carry >> 52 == 0);\n\n    // Since carry >> 52 >= 0 and pow2(260) > 0, we have (carry >> 52) * pow2(260) >= 0\n    // Therefore sum < sum + (carry >> 52) * pow2(260) < 2 * group_order()\n    lemma_pow2_pos(260);\n    assert(pow2(260) > 0);\n    assert((carry >> 52) as nat * pow2(260) >= 0);\n    assert(to_nat(&sum.limbs) <= to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260));\n    assert(to_nat(&sum.limbs) < 2 * group_order());\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_bytes().",
      "display_name": "is_random_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "use crate::constants;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::scalar_specs::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::scalar_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n\n#[allow(unused_imports)]\nuse crate::core_assumes::*;\n\n#[allow(unused_imports)]\nuse crate::scalar_specs::*;\n\n#[cfg(feature = \"digest\")]\n#[allow(unused_imports)]\nuse digest::Digest;\n\nverus! {\n\n/*** <VERIFICATION NOTE> Focus on u64; removed all other backend types </VERIFICATION NOTE> ***/\ntype UnpackedScalar = backend::serial::u64::scalar::Scalar52;\n\n/// The `Scalar` struct holds an element of \\\\(\\mathbb Z / \\ell\\mathbb Z \\\\).\n#[allow(clippy::derived_hash_with_manual_eq)]\n#[derive(Copy, Clone, Hash)]\npub struct Scalar {\n    /// `bytes` is a little-endian byte encoding of an integer representing a scalar modulo the\n    /// group order.\n    ///\n    /// # Invariant #1\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255}\\\\). That is, the most\n    /// significant bit of `bytes[31]` is 0.\n    ///\n    /// This is required for `EdwardsPoint` variable- and fixed-base multiplication, because most\n    /// integers above 2^255 are unrepresentable in our radix-16 NAF (see [`Self::as_radix_16`]).\n    /// The invariant is also required because our `MontgomeryPoint` multiplication assumes the MSB\n    /// is 0 (see `MontgomeryPoint::mul`).\n    ///\n    /// # Invariant #2 (weak)\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255} - 19 \\\\), i.e., it represents\n    /// a canonical representative of an element of \\\\( \\mathbb Z / \\ell\\mathbb Z \\\\). This is\n    /// stronger than invariant #1. It also sometimes has to be broken.\n    ///\n    /// This invariant is deliberately broken in the implementation of `EdwardsPoint::{mul_clamped,\n    /// mul_base_clamped}`, `MontgomeryPoint::{mul_clamped, mul_base_clamped}`, and\n    /// `BasepointTable::mul_base_clamped`. This is not an issue though. As mentioned above,\n    /// scalar-point multiplication is defined for any choice of `bytes` that satisfies invariant\n    /// #1. Since clamping guarantees invariant #1 is satisfied, these operations are well defined.\n    ///\n    /// Note: Scalar-point mult is the _only_ thing you can do safely with an unreduced scalar.\n    /// Scalar-scalar addition and subtraction are NOT correct when using unreduced scalars.\n    /// Multiplication is correct, but this is only due to a quirk of our implementation, and not\n    /// guaranteed to hold in general in the future.\n    ///\n    /// Note: It is not possible to construct an unreduced `Scalar` from the public API unless the\n    /// `legacy_compatibility` is enabled (thus making `Scalar::from_bits` public). Thus, for all\n    /// public non-legacy uses, invariant #2\n    /// always holds.\n    ///\n    /* <VERIFICATION NOTE>\n    Changed from pub(crate) to pub\n    </VERIFICATION NOTE> */\n    pub bytes: [u8; 32],/* <ORIGINAL CODE>\n    pub(crate) bytes: [u8; 32],\n    </ORIGINAL CODE> */\n}\n\n// This is a dummy function that we call from signal\n// to test that verus functions in libsignal know\n// about verus functions in curve-dalek\npub open spec fn is_a_scalar(s: Scalar) -> bool {\n    true\n}\n\nimpl Scalar {\n    /// Construct a `Scalar` by reducing a 256-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    // VERIFICATION NOTE: VERIFIED\n    pub fn from_bytes_mod_order(bytes: [u8; 32]) -> (result: Scalar)\n        ensures\n    // Result is equivalent to input modulo the group order\n\n            bytes_to_nat(&result.bytes) % group_order() == bytes_to_nat(&bytes) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        // Temporarily allow s_unreduced.bytes > 2^255 ...\n        let s_unreduced = Scalar { bytes };\n\n        // Then reduce mod the group order and return the reduced representative.\n        let s = s_unreduced.reduce();\n        /*** <VERIFICATION NOTE> We omit debug asserts from verification  </VERIFICATION NOTE> ***/\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }\n\n    /// Construct a `Scalar` by reducing a 512-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    // VERIFICATION NOTE: VERIFIED\n    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == bytes_wide_to_nat(input) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }\n\n    /// Attempt to construct a `Scalar` from a canonical byte representation.\n    ///\n    /// # Return\n    ///\n    /// - `Some(s)`, where `s` is the `Scalar` corresponding to `bytes`,\n    ///   if `bytes` is a canonical byte representation modulo the group order \\\\( \\ell \\\\);\n    /// - `None` if `bytes` is not a canonical byte representation.\n    /*\n    <VERIFICATION NOTE>\n      - Refactored to use wrapper functions instead of trait functions for ct_eq and ct_option_new\n      - Has proof bypass\n    </VERIFICATION NOTE> */\n    pub fn from_canonical_bytes(bytes: [u8; 32]) -> (result: CtOption<Scalar>)\n        ensures\n            bytes_to_nat(&bytes) < group_order() ==> ct_option_has_value(result),\n            bytes_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result),\n            ct_option_has_value(result) ==> bytes_to_nat(&ct_option_value(result).bytes)\n                % group_order() == bytes_to_nat(&bytes) % group_order(),\n    {\n        /* <ORIGINAL CODE>\n          let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let high_byte_shifted = bytes[31] >> 7;\n        let high_bit_unset = ct_eq_u8(&high_byte_shifted, &0);\n        /* </MODIFIED CODE> */\n\n        let candidate = Scalar { bytes };\n        let is_canonical = candidate.is_canonical();\n\n        /* <ORIGINAL CODE>\n          CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n          </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let condition = choice_and(high_bit_unset, is_canonical);\n        let result = ct_option_new(candidate, condition);\n        /* </MODIFIED CODE> */\n\n        // VERIFICATION NOTE: PROOF BYPASS\n        assume(bytes_to_nat(&bytes) < group_order() ==> ct_option_has_value(result));\n        assume(bytes_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result));\n        assume(ct_option_has_value(result) ==> bytes_to_nat(&ct_option_value(result).bytes)\n            % group_order() == bytes_to_nat(&bytes) % group_order());\n\n        result\n    }\n\n    /// Construct a `Scalar` from the low 255 bits of a 256-bit integer. This breaks the invariant\n    /// that scalars are always reduced. Scalar-scalar arithmetic, i.e., addition, subtraction,\n    /// multiplication, **does not work** on scalars produced from this function. You may only use\n    /// the output of this function for `EdwardsPoint::mul`, `MontgomeryPoint::mul`, and\n    /// `EdwardsPoint::vartime_double_scalar_mul_basepoint`. **Do not use this function** unless\n    /// you absolutely have to.\n    /* <VERIFICATION NOTE>\n        -This is not in default features and not in our current target list ==> spec omitted for now\n    </VERIFICATION NOTE> */\n    #[cfg(feature = \"legacy_compatibility\")]\n    #[deprecated(\n        since = \"4.0.0\",\n        note = \"This constructor outputs scalars with undefined scalar-scalar arithmetic. See docs.\"\n    )]\n    pub const fn from_bits(bytes: [u8; 32]) -> Scalar {\n        let mut s = Scalar { bytes };\n        // Ensure invariant #1 holds. That is, make s < 2^255 by masking the high bit.\n        s.bytes[31] &= 0b0111_1111;\n\n        s\n    }\n}\n\nimpl Eq for Scalar {\n\n}\n\nimpl PartialEq for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS (problem with traits)\n    fn eq(&self, other: &Self) -> (result: bool)\n        ensures\n            result == (&self.bytes == &other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Choice::into\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let result = self.ct_eq(other).into();\n         </ORIGINAL CODE> */\n        let choice = self.ct_eq(other);\n        assert(choice_is_true(choice) == (self.bytes == other.bytes));\n        let result = choice_into(choice);\n        assert(result == choice_is_true(choice));\n        assert(result == (self.bytes == other.bytes));\n\n        // VERIFICATION NOTE: vstd's external trait specification check cannot be satisfied\n        // vstd expects obeys_eq_spec() and eq_spec() from PartialEqSpecImpl trait,\n        // but that trait is not publicly exported, so we bypass with assume(false)\n        // while maintaining our own custom ensures clause above\n        assume(false);\n\n        result\n    }\n}\n\nimpl ConstantTimeEq for Scalar {\n    fn ct_eq(&self, other: &Self) -> (result: Choice)\n        ensures\n            choice_is_true(result) == (self.bytes == other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Verus compatibility instead of direct subtle call\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.bytes.ct_eq(&other.bytes)\n         </ORIGINAL CODE> */\n        ct_eq_bytes32(&self.bytes, &other.bytes)\n    }\n}\n\nimpl Index<usize> for Scalar {\n    type Output = u8;\n\n    /// Index the bytes of the representative for this `Scalar`.  Mutation is not permitted.\n    fn index(&self, _index: usize) -> (result: &u8)\n        requires\n            _index < 32,\n        ensures\n            result == &self.bytes[_index as int],\n    {\n        &(self.bytes[_index])\n    }\n}\n\nimpl Debug for Scalar {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar{{\\n\\tbytes: {:?},\\n}}\", &self.bytes)\n    }\n}\n\nimpl<'a> MulAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    fn mul_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n            is_canonical_scalar(self),\n    {\n        /* <ORIGINAL CODE>\n         *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n        /* <VERIFICATION NOTE>\n         In the modified code, we store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&old(self).bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        *self = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&self.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n    }\n}\n\ndefine_mul_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_mul_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn mul_req(self, rhs: &Scalar) -> bool {\n        true  // No preconditions\n\n    }\n\n    open spec fn mul_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'b> Mul<&'b Scalar> for &Scalar {\n    type Output = Scalar;\n\n    // VERIFICATION NOTE: VERIFIED\n    fn mul(self, _rhs: &'b Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n    {\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n            * bytes_to_nat(&_rhs.bytes)) % group_order());\n        /* </MODIFIED CODE> */\n        /* <ORIGINAL CODE>\n         let result = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n\n        result\n    }\n}\n\ndefine_mul_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_add_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn add_req(self, rhs: &Scalar) -> bool {\n        true  // No preconditions yet\n\n    }\n\n    open spec fn add_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'a> Add<&'a Scalar> for &Scalar {\n    type Output = Scalar;\n\n    /* <VERIFICATION NOTE>\n    PROOF BYPASS; may need to add preconditions to spec\n    </VERIFICATION NOTE> */\n    #[allow(non_snake_case)]\n    fn add(self, _rhs: &'a Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(&_rhs.bytes))\n                % group_order(),\n    {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::add requires inputs < group_order()\n        // By Scalar invariant #2, scalars should be canonical\n        // However, we cannot add requires clauses to trait implementations,\n        // so we assume this property holds\n        proof {\n            assume(to_nat(&self_unpacked.limbs) < group_order());\n            assume(to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::add(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) == (to_nat(&self_unpacked.limbs) + to_nat(\n                &rhs_unpacked.limbs,\n            )) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) == to_nat(&result_unpacked.limbs));\n            assert(bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }\n}\n\ndefine_add_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> AddAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    #[allow(clippy::op_ref)]\n    fn add_assign(&mut self, _rhs: &'a Scalar)\n        ensures\n            bytes_to_nat(&self.bytes) == (bytes_to_nat(&old(self).bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order(),\n    {\n        *self = &*self + _rhs;\n    }\n}\n\ndefine_add_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_sub_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn sub_req(self, rhs: &Scalar) -> bool {\n        is_canonical_scalar(self) && is_canonical_scalar(rhs)\n    }\n\n    open spec fn sub_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'b> Sub<&'b Scalar> for &Scalar {\n    type Output = Scalar;\n\n    // VERIFICATION NOTE: PROOF BYPASS (problems with traits and preconditions)\n    // PRECONDITION is_canonical_scalar(self) && is_canonical_scalar(_rhs)\n    #[allow(non_snake_case)]\n    fn sub(self, _rhs: &'b Scalar) -> (result:\n        Scalar)/* VERIFICATION NOTE: preconditions are added to the SpecImpl above\n    requires\n      is_canonical_scalar(self),\n      is_canonical_scalar(_rhs),\n    */\n\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        /* <ORIGINAL CODE>\n         UnpackedScalar::sub(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::sub requires: -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()\n        proof {\n            assume(-group_order() <= to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs));\n            assume(to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::sub(&self_unpacked, &rhs_unpacked);\n        proof {\n            // Postconditions from sub - need to strengthen, review connections\n            assume(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                - to_nat(&rhs_unpacked.limbs)) % (group_order() as int));\n            assume(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int));\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }\n}\n\ndefine_sub_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> SubAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    #[allow(clippy::op_ref)]\n    fn sub_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        *self = &*self - _rhs;\n    }\n}\n\ndefine_sub_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &Scalar {\n    open spec fn obeys_neg_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn neg_req(self) -> bool {\n        true  // No preconditions - scalars are canonical by invariant\n\n    }\n\n    open spec fn neg_spec(self) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl Neg for &Scalar {\n    type Output = Scalar;\n\n    #[allow(non_snake_case)]\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        /* <ORIGINAL CODE>\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        proof {\n            // Preconditions for mul_internal and sub\n            assume(limbs_bounded(&constants::R));\n            assume(limbs_bounded(&UnpackedScalar::ZERO));\n        }\n\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n\n        proof {\n            assume(limbs_bounded(&self_mod_l));\n            // sub requires: -group_order() <= 0 - to_nat(&self_mod_l.limbs) < group_order()\n            assume(-group_order() <= to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(\n                &self_mod_l.limbs,\n            ));\n            assume(to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(&self_mod_l.limbs) < group_order());\n        }\n\n        let result = UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack();\n        proof {\n            // TODO: Prove that -self + self == 0 (mod group_order)\n            assume((scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0);\n        }\n\n        /* </MODIFIED CODE> */\n        result\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for Scalar {\n    open spec fn obeys_neg_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn neg_req(self) -> bool {\n        true  // No specific preconditions - scalars are canonical by invariant\n\n    }\n\n    open spec fn neg_spec(self) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl Neg for Scalar {\n    type Output = Scalar;\n\n    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        let result = (&self).neg();\n        proof {\n            assume((scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0);\n        }\n        result\n    }/* <ORIGINAL CODE>\n    fn neg(self) -> Scalar {\n        -&self\n    }\n    </ORIGINAL CODE> */\n\n}\n\nimpl ConditionallySelectable for Scalar {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> (Self) {\n        let mut bytes = [0u8;32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            /* <VERIFICATION NOTE>\n            Use wrapper function for Verus compatibility instead of direct subtle call\n            </VERIFICATION NOTE> */\n            /* <ORIGINAL CODE>\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n            </ORIGINAL CODE> */\n            /* <MODIFIED CODE> */\n            bytes[i] = select_u8(&a.bytes[i], &b.bytes[i], choice);\n            /* </MODIFIED CODE> */\n        }\n        Scalar { bytes }\n    }\n}\n\n/* <VERIFICATION NOTE>\n Trait implementations for Product and Sum declared as external_body since they use iterators which are not supported by Verus.\n</VERIFICATION NOTE> */\n\nimpl<T> Product<T> for Scalar where T: Borrow<Scalar> {\n    /* <ORIGINAL CODE>\n    fn product<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ONE, |acc, item| acc * item.borrow())\n    }\n    </ORIGINAL CODE> */\n    /* <VERIFICATION NOTE>\n     Added verifier::external_body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    /* <MODIFIED CODE> - FOR EVENTUAL VERIFICATION*/\n    fn product<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified product_of_slice function\n        Scalar::product_of_slice(&scalars)\n    }  /* </MODIFIED CODE> */\n\n}\n\nimpl<T> Sum<T> for Scalar where T: Borrow<Scalar> {\n    #[verifier::external_body]\n    fn sum<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }/* <MODIFIED CODE> - if needed in for verification in the future\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified sum_of_slice function\n        Scalar::sum_of_slice(&scalars)\n    }\n     </MODIFIED CODE> */\n\n}\n\nimpl Default for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn default() -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == 0 as nat,\n    {\n        let result = Scalar::ZERO;\n        assume(scalar_to_nat(&result) == 0 as nat);\n        result\n    }\n}\n\nimpl From<u8> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn from(x: u8) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        let mut s_bytes = [0u8;32];\n        s_bytes[0] = x;\n\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u16> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u16) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u16_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u32> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u32) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u32_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        let result = Scalar { bytes: s_bytes };\n        /* </MODIFIED CODE> */\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u64> for Scalar {\n    /// Construct a scalar from the given `u64`.\n    ///\n    /// # Inputs\n    ///\n    /// An `u64` to convert to a `Scalar`.\n    ///\n    /// # Returns\n    ///\n    /// A `Scalar` corresponding to the input `u64`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let fourtytwo = Scalar::from(42u64);\n    /// let six = Scalar::from(6u64);\n    /// let seven = Scalar::from(7u64);\n    ///\n    /// assert!(fourtytwo == six * seven);\n    /// ```\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u64) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u64_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u128> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u128) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u128_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for Scalar {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self) {\n        self.bytes.zeroize();\n    }\n}\n\nimpl Scalar {\n    /// The scalar \\\\( 0 \\\\).\n    // pub const ZERO: Self = Self { bytes: [0u8; 32] };\n    /* <VERIFICATION NOTE>\n    Changed to explicit initialization\n    </VERIFICATION NOTE> */\n    /* <ORIGINAL CODE>\n    pub const ZERO: Self = Self { bytes: [0u8; 32] };\n    </ORIGINAL CODE> */\n    pub const ZERO: Scalar = Scalar {\n        bytes: [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n        ],\n    };\n\n    /// The scalar \\\\( 1 \\\\).\n    pub const ONE: Self = Self {\n        bytes: [\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n        ],\n    };\n\n    /* <VERIFICATION NOTE>\n     Verification of random method postponed - requires rand_core feature to be enabled.\n    </VERIFICATION NOTE> */\n    #[cfg(any(test, feature = \"rand_core\"))]\n    /// Return a `Scalar` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `CryptoRngCore`\n    ///   (i.e. `CryptoRng` + `RngCore`) interface.\n    ///\n    /// # Returns\n    ///\n    /// A random scalar within \\\\(\\mathbb{Z} / \\ell\\mathbb{Z}\\\\).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # fn main() {\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// use rand_core::OsRng;\n    ///\n    /// let mut csprng = OsRng;\n    /// let a: Scalar = Scalar::random(&mut csprng);\n    /// # }\n    /* <VERIFICATION NOTE>\n     No verifier::external_body annotation but it is NOT verified\n    </VERIFICATION NOTE> */\n    pub fn random<R: CryptoRngCore + ?Sized>(rng: &mut R) -> (result: Self)\n        ensures\n            is_random_scalar(&result),\n            is_canonical_scalar(&result),\n    {\n        let mut scalar_bytes = [0u8;64];\n        rng.fill_bytes(&mut scalar_bytes);\n        Scalar::from_bytes_mod_order_wide(&scalar_bytes)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Hash a slice of bytes into a scalar using a specified hash function.\n    ///\n    /// This function hashes the input using the specified `Digest` type and then reduces\n    /// the result modulo the group order to produce a scalar.\n    ///\n    /// Convenience wrapper around `from_hash`.\n    ///\n    /// # Example\n    ///\n    #[cfg_attr(feature = \"digest\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// use sha2::Sha512;\n    /// # fn main() {\n    /// let msg = \"To really appreciate architecture, you may even need to commit a murder\";\n    /// let s = Scalar::hash_from_bytes::<Sha512>(msg.as_bytes());\n    /// # }\n    /// ```\n    /* <VERIFICATION NOTE>\n     Marked as external_body due to complexity of Digest trait.\n     For Verus verification, use hash_from_bytes_verus instead.\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    pub fn hash_from_bytes<D>(input: &[u8]) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64> + Default,\n\n        ensures\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        Scalar::from_hash(hash)\n    }\n\n    /// Verus-compatible version of hash_from_bytes that uses SHA-512.\n    ///\n    /// This function is designed for Verus verification and directly computes\n    /// a SHA-512 hash. For regular code with generic hash functions, use `hash_from_bytes` instead.\n    ///\n    /// # Inputs\n    ///\n    /// * `input`: a byte slice to hash\n    ///\n    /// # Returns\n    ///\n    /// A scalar reduced modulo the group order\n    pub fn hash_from_bytes_verus(input: &[u8]) -> (result: Scalar)\n        ensures\n            is_random_bytes(input) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        use crate::core_assumes as assumes;\n        let hash_bytes: [u8; 64] = assumes::sha512_hash_bytes(input);\n        Scalar::from_hash_verus(hash_bytes)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Construct a scalar from a 64-byte (512-bit) hash output.\n    ///\n    /// This reduces the hash output modulo the group order.\n    /// Typically used after calling `finalize()` on a SHA-512 hasher.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// use sha2::{Digest, Sha512};\n    ///\n    /// # fn main() {\n    /// let mut h = Sha512::new();\n    /// h.update(b\"To really appreciate architecture, you may even need to commit a murder.\");\n    /// h.update(b\"While the programs used for The Manhattan Transcripts are of the most extreme\");\n    /// h.update(b\"nature, they also parallel the most common formula plot: the archetype of\");\n    /// h.update(b\"murder. Other phantasms were occasionally used to underline the fact that\");\n    /// h.update(b\"perhaps all architecture, rather than being about functional standards, is\");\n    /// h.update(b\"about love and death.\");\n    ///\n    /// let hash_bytes: [u8; 64] = h.finalize().into();\n    /// let s = Scalar::from_hash(hash_bytes);\n    ///\n    /// println!(\"{:?}\", s.to_bytes());\n    /// assert_eq!(\n    ///     s.to_bytes(),\n    ///     [  21,  88, 208, 252,  63, 122, 210, 152,\n    ///       154,  38,  15,  23,  16, 167,  80, 150,\n    ///       192, 221,  77, 226,  62,  25, 224, 148,\n    ///       239,  48, 176,  10, 185,  69, 168,  11, ],\n    /// );\n    /// # }\n    /// ```\n    /* <VERIFICATION NOTE>\n     Marked as external_body due to GenericArray having private fields.\n     For Verus verification, see from_hash_verus below.\n    </VERIFICATION NOTE> */\n    #[cfg(feature = \"digest\")]\n    #[verifier::external_body]\n    pub fn from_hash<D>(hash: D) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64>,\n\n        ensures\n    //is_random_digest(&hash) ==> is_random_scalar(&result),\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut output = [0u8;64];\n        output.copy_from_slice(hash.finalize().as_slice());\n        Scalar::from_bytes_mod_order_wide(&output)\n    }\n\n    /// Verus-compatible version of from_hash that takes pre-finalized hash bytes.\n    ///\n    /// This function is designed for Verus verification and takes a byte array directly\n    /// instead of a generic Digest type. For regular code, use `from_hash` instead.\n    ///\n    /// # Inputs\n    ///\n    /// * `hash_bytes`: a 64-byte array representing the output of a hash function\n    ///\n    /// # Returns\n    ///\n    /// A scalar reduced modulo the group order\n    pub fn from_hash_verus(hash_bytes: [u8; 64]) -> (result: Scalar)\n        ensures\n            is_random_bytes(&hash_bytes) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        let result = Scalar::from_bytes_mod_order_wide(&hash_bytes);\n        assume(false);\n        result\n    }\n\n    /// Convert this `Scalar` to its underlying sequence of bytes.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.to_bytes() == [0u8; 32]);\n    /// ```\n    pub const fn to_bytes(&self) -> (result: [u8; 32])\n        ensures\n            result == self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        self.bytes\n    }\n\n    /// View the little-endian byte encoding of the integer representing this Scalar.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.as_bytes() == &[0u8; 32]);\n    /// ```\n    pub const fn as_bytes(&self) -> (result: &[u8; 32])\n        ensures\n            result == &self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        &self.bytes\n    }\n}\n\nimpl Scalar {\n    /// Given a nonzero `Scalar`, compute its multiplicative inverse.\n    ///\n    /// # Warning\n    ///\n    /// `self` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Returns\n    ///\n    /// The multiplicative inverse of the this `Scalar`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // x = 2238329342913194256032495932344128051776374960164957527413114840482143558222\n    /// let X: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x4e, 0x5a, 0xb4, 0x34, 0x5d, 0x47, 0x08, 0x84,\n    ///         0x59, 0x13, 0xb4, 0x64, 0x1b, 0xc2, 0x7d, 0x52,\n    ///         0x52, 0xa5, 0x85, 0x10, 0x1b, 0xcc, 0x42, 0x44,\n    ///         0xd4, 0x49, 0xf4, 0xa8, 0x79, 0xd9, 0xf2, 0x04,\n    ///     ]);\n    /// // 1/x = 6859937278830797291664592131120606308688036382723378951768035303146619657244\n    /// let XINV: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x1c, 0xdc, 0x17, 0xfc, 0xe0, 0xe9, 0xa5, 0xbb,\n    ///         0xd9, 0x24, 0x7e, 0x56, 0xbb, 0x01, 0x63, 0x47,\n    ///         0xbb, 0xba, 0x31, 0xed, 0xd5, 0xa9, 0xbb, 0x96,\n    ///         0xd5, 0x0b, 0xcd, 0x7a, 0x3f, 0x96, 0x2a, 0x0f,\n    ///     ]);\n    ///\n    /// let inv_X: Scalar = X.invert();\n    /// assert!(XINV == inv_X);\n    /// let should_be_one: Scalar = &inv_X * &X;\n    /// assert!(should_be_one == Scalar::ONE);\n    /// ```\n    // VERIFICATION NOTE: VERIFIED\n    pub fn invert(&self) -> (result: Scalar)\n        requires\n            is_canonical_scalar(self),\n        ensures\n    // Result is the multiplicative inverse: result * self ≡ 1 (mod group_order)\n\n            (scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1,\n            is_canonical_scalar(\n                &result,\n            ),\n    // VERIFICATION NOTE: is this true and/or necessary?\n    // Result is canonical\n    // scalar_to_nat(&result) < group_order(),\n    // result.bytes[31] <= 127,\n\n    {\n        let unpacked = self.unpack();\n        let inv_unpacked = unpacked.invert();\n        let result = inv_unpacked.pack();\n        assert((scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1);\n        assume(is_canonical_scalar(&result));\n        result\n    }\n\n    /// Given a slice of nonzero (possibly secret) `Scalar`s,\n    /// compute their inverses in a batch.\n    ///\n    /// # Return\n    ///\n    /// Each element of `inputs` is replaced by its inverse.\n    ///\n    /// The product of all inverses is returned.\n    ///\n    /// # Warning\n    ///\n    /// All input `Scalars` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// # fn main() {\n    /// let mut scalars = [\n    ///     Scalar::from(3u64),\n    ///     Scalar::from(5u64),\n    ///     Scalar::from(7u64),\n    ///     Scalar::from(11u64),\n    /// ];\n    ///\n    /// let allinv = Scalar::batch_invert(&mut scalars);\n    ///\n    /// assert_eq!(allinv, Scalar::from(3*5*7*11u64).invert());\n    /// assert_eq!(scalars[0], Scalar::from(3u64).invert());\n    /// assert_eq!(scalars[1], Scalar::from(5u64).invert());\n    /// assert_eq!(scalars[2], Scalar::from(7u64).invert());\n    /// assert_eq!(scalars[3], Scalar::from(11u64).invert());\n    /// # }\n    /// ```\n    #[cfg(feature = \"alloc\")]\n    // Theo: Verus doesn't like the zeroize in this function. I think the long-term\n    // solution is to use assume_specification to tell Verus what zeroize does.\n    // In the short-term, I've just told verus to ignore the body.\n    // (SB update: alternative is to exclude just the zeroize call, as below)\n    pub fn batch_invert(inputs: &mut [Scalar]) -> (result:\n        Scalar)/* <VERIFICATION NOTE>\n     Refactored for Verus: Index loops instead of iterators, manual Vec construction, ..\n    </VERIFICATION NOTE> */\n\n        ensures\n    // Result is the modular inverse of the product of all original inputs\n\n            is_inverse_of_nat(&result, product_of_scalars(old(inputs)@)),\n            // Each input is replaced with its inverse\n            forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ),\n    {\n        // This code is essentially identical to the FieldElement\n        // implementation, and is documented there.  Unfortunately,\n        // it's not easy to write it generically, since here we want\n        // to use `UnpackedScalar`s internally, and `Scalar`s\n        // externally, but there's no corresponding distinction for\n        // field elements.\n        let n = inputs.len();\n        let one_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(limbs_bounded(&one_unpacked));\n        }\n\n        let one: UnpackedScalar = one_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&one));\n        }\n\n        /* <VERIFICATION NOTE>\n         Build vec manually instead of vec![one; n] for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let mut scratch = vec![one; n];\n         </ORIGINAL CODE> */\n        let mut scratch = Vec::new();\n        for _ in 0..n {\n            scratch.push(one);\n        }\n\n        // Keep an accumulator of all of the previous products\n        let acc_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(scratch.len() == n);\n            assume(limbs_bounded(&acc_unpacked));\n        }\n\n        let mut acc = acc_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        /* <VERIFICATION NOTE>\n         Rewritten with index loop instead of .zip() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         for (input, scratch) in inputs.iter_mut().zip(scratch.iter_mut()) {\n             *scratch = acc;\n        //     // Avoid unnecessary Montgomery multiplication in second pass by\n        //     // keeping inputs in Montgomery form\n             let tmp = input.unpack().as_montgomery();\n             *input = tmp.pack();\n             acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n         }\n        </ORIGINAL CODE> */\n        for i in 0..n\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                limbs_bounded(&acc),\n        {\n            scratch[i] = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = input_unpacked.as_montgomery();\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n\n            proof {\n                assume(limbs_bounded(&acc));\n            }\n        }\n\n        proof {\n            // Assert that all scratch elements have bounded limbs\n            assume(forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]));\n        }\n\n        // acc is nonzero iff all inputs are nonzero\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert!(acc.pack() != Scalar::ZERO);\n\n        // Compute the inverse of all products\n        // ORIGINAL CODE: acc = acc.montgomery_invert().from_montgomery();\n        acc = acc.montgomery_invert();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        acc = acc.from_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // We need to return the product of all inverses later\n        let ret = acc.pack();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        /* <VERIFICATION NOTE>\n         Manual reverse loop instead of .rev() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.iter().rev()) {\n             let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n             *input = UnpackedScalar::montgomery_mul(&acc, scratch).pack();\n             acc = tmp;\n         }\n        </ORIGINAL CODE> */\n        let mut i: usize = n;\n        while i > 0\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                i <= n,\n                limbs_bounded(&acc),\n                forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]),\n            decreases i,\n        {\n            i -= 1;\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input_unpacked);\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = UnpackedScalar::montgomery_mul(&acc, &scratch[i]).pack();\n            acc = tmp;\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        #[cfg(not(verus_keep_ghost))]\n        Zeroize::zeroize(&mut scratch);\n\n        proof {\n            // Assume the postconditions\n            assume(is_inverse_of_nat(&ret, product_of_scalars(old(inputs)@)));\n            assume(forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ));\n        }\n\n        ret\n    }\n}\n\n#[cfg(feature = \"serde\")]\nuse serde::de::Visitor;\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[cfg(feature = \"serde\")]\n/// Visitor for deserializing a Scalar from a sequence of 32 bytes.\n///\n/* VERIFICATION NOTE:\n- We don't cover serde feature yet\n- The ScalarVisitor struct is defined at module level rather than inside the\n`Deserialize::deserialize` since Verus doesn't support nested types\n</VERIFICATION NOTE> */\nstruct ScalarVisitor;\n\n#[cfg(feature = \"serde\")]\nimpl<'de> Visitor<'de> for ScalarVisitor {\n    type Value = Scalar;\n\n    #[verifier::external_body]\n    fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        {\n            formatter.write_str(\n                \"a sequence of 32 bytes whose little-endian interpretation is less than the \\\n                        basepoint order ℓ\",\n            )\n        }\n    }\n\n    #[verifier::external_body]\n    fn visit_seq<A>(self, mut seq: A) -> Result<Scalar, A::Error> where\n        A: serde::de::SeqAccess<'de>,\n     {\n        let mut bytes = [0u8;32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            bytes[i] = seq.next_element()?.ok_or_else(\n                || serde::de::Error::invalid_length(i, &\"expected 32 bytes\"),\n            )?;\n        }\n        Option::from(Scalar::from_canonical_bytes(bytes)).ok_or_else(\n            || serde::de::Error::custom(\"scalar was not canonically encoded\"),\n        )\n    }\n}\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl Serialize for Scalar {\n    #[verifier::external_body]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl<'de> Deserialize<'de> for Scalar {\n    #[verifier::external_body]\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error> where D: Deserializer<'de> {\n        /* VERIFICATION NOTE:\n        Originally struct ScalarVisitor defined here, but moved up to the top of the file\n        </VERIFICATION NOTE> */\n        deserializer.deserialize_tuple(32, ScalarVisitor)\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_clamped().",
      "display_name": "mul_clamped",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_clamped().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_clamped(self, bytes: [u8; 32]) -> Self {\n        // We have to construct a Scalar that is not reduced mod l, which breaks scalar invariant\n        // #2. But #2 is not necessary for correctness of variable-base multiplication. All that\n        // needs to hold is invariant #1, i.e., the scalar is less than 2^255. This is guaranteed\n        // by clamping.\n        // Further, we don't do any reduction or arithmetic with this clamped value, so there's no\n        // issues arising from the fact that the curve point is not necessarily in the prime-order\n        // subgroup.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        s * self\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_u64_to_nat().",
      "display_name": "seq_u64_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_u64_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "#[allow(unused_imports)]\nuse super::common_verus::shift_lemmas::*;\n\nverus! {\n\n/// Verification: scalar * scalar.invert() ≡ 1 mod L\nproof fn verify_invert_correct(\n    x: Scalar52,\n)\n//     requires to_scalar(&x.limbs) != 0\n//    ensures (to_scalar(&x.limbs) * invert_spec(&x.limbs)) % group_order() == 1\n{\n    assume(false);\n\n}\n\npub proof fn lemma_52_52(x: u64, y: u64)\n    requires\n        x < (1u64 << 52),\n        y < (1u64 << 52),\n    ensures\n        (x as u128) * (y as u128) < (1u128 << 104),\n{\n    assert(1u128 << 52 == 1u64 << 52) by (bit_vector);\n    calc! {\n        (<)\n        (x as u128) * (y as u128); (<=) {\n            if x > 0 {\n                lemma_mul_strict_inequality(y as int, (1u128 << 52) as int, x as int);\n                assert(x * y < x * (1u128 << 52));\n            } else {\n                assert((0 as u128) * (y as u128) == 0);\n            }\n        }\n        (x as u128) * (1u128 << 52); (<) {\n            lemma_mul_strict_inequality(x as int, (1u128 << 52) as int, (1u128 << 52) as int);\n        }\n        (1u128 << 52) * (1u128 << 52);\n    }\n    assert((1u128 << 52) * (1u128 << 52) == (1u128 << 104)) by (compute);\n}\n\npub proof fn lemma_square_internal_no_overflow()\n    ensures\n        (1u128 << 105) + (1u128 << 105) == (1u128 << 106),\n        (1u128 << 105) + (1u128 << 104) < (1u128 << 106),\n        (1u128 << 104) * 2 == (1u128 << 105),\n        (1u128 << 106) + (1u128 << 104) < (1u128 << 107),\n{\n    assert((1u128 << 105) + (1u128 << 105) == (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 105) + (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 104) * 2 == (1u128 << 105)) by (bit_vector);\n    assert((1u128 << 106) + (1u128 << 104) < (1u128 << 107)) by (bit_vector);\n}\n\npub proof fn lemma_square_internal_correct(a: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        z[0] == (a[0] * a[0]),\n        z[1] == (a[0] * a[1]) * 2,\n        z[2] == (a[0] * a[2]) * 2 + (a[1] * a[1]),\n        z[3] == (a[0] * a[3]) * 2 + (a[1] * a[2]) * 2,\n        z[4] == (a[0] * a[4]) * 2 + (a[1] * a[3]) * 2 + (a[2] * a[2]),\n        z[5] == (a[1] * a[4]) * 2 + (a[2] * a[3]) * 2,\n        z[6] == (a[2] * a[4]) * 2 + (a[3] * a[3]),\n        z[7] == (a[3] * a[4]) * 2,\n        z[8] == (a[4] * a[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(a),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*a) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n}\n\npub proof fn lemma_mul_internal_no_overflow()\n    ensures\n        (1u128 << 104) + (1u128 << 104) == (1u128 << 105),\n        3u128 * (1u128 << 104) < (1u128 << 106),\n        4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104),\n        (1u128 << 2) * (1u128 << 104) == (1u128 << 106),\n        8u128 == (1u128 << 3),\n        (1u128 << 3) * (1u128 << 104) == (1u128 << 107),\n{\n    assert((1u128 << 104) + (1u128 << 104) == (1u128 << 105)) by (bit_vector);\n    assert(3u128 * (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert(4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104)) by (bit_vector);\n    assert((1u128 << 2) * (1u128 << 104) == (1u128 << 106)) by (bit_vector);\n    assert(8u128 == (1u128 << 3)) by (bit_vector);\n    assert((1u128 << 3) * (1u128 << 104) == (1u128 << 107)) by (bit_vector);\n}\n\npub proof fn lemma_mul_internal_correct(a: &[u64; 5], b: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        forall|i: int| 0 <= i < 5 ==> b[i] < (1u64 << 52),\n        z[0] == (a[0] * b[0]),\n        z[1] == (a[0] * b[1]) + (a[1] * b[0]),\n        z[2] == (a[0] * b[2]) + (a[1] * b[1]) + (a[2] * b[0]),\n        z[3] == (a[0] * b[3]) + (a[1] * b[2]) + (a[2] * b[1]) + (a[3] * b[0]),\n        z[4] == (a[0] * b[4]) + (a[1] * b[3]) + (a[2] * b[2]) + (a[3] * b[1]) + (a[4] * b[0]),\n        z[5] == (a[1] * b[4]) + (a[2] * b[3]) + (a[3] * b[2]) + (a[4] * b[1]),\n        z[6] == (a[2] * b[4]) + (a[3] * b[3]) + (a[4] * b[2]),\n        z[7] == (a[3] * b[4]) + (a[4] * b[3]),\n        z[8] == (a[4] * b[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(b),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*b) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n    lemma_five_limbs_equals_to_nat(&b);\n}\n\npub proof fn lemma_nine_limbs_equals_slice128_to_nat(limbs: &[u128; 9])\n    ensures\n        nine_limbs_to_nat_aux(limbs) == slice128_to_nat(limbs),\n{\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        slice128_to_nat(limbs); {}\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 10);\n        }\n        (limbs[0] as nat) + ((limbs[1] as nat) + ((limbs[2] as nat) + ((limbs[3] as nat) + ((\n        limbs[4] as nat) + ((limbs[5] as nat) + ((limbs[6] as nat) + ((limbs[7] as nat) + (\n        limbs[8] as nat) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52))\n            * pow2(52)) * pow2(52); {\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(104, 52);\n            lemma_pow2_adds(156, 52);\n            lemma_pow2_adds(208, 52);\n            lemma_pow2_adds(260, 52);\n            lemma_pow2_adds(312, 52);\n            lemma_pow2_adds(364, 52);\n            broadcast use group_mul_is_distributive;\n            broadcast use lemma_mul_is_associative;\n\n        }\n        nine_limbs_to_nat_aux(limbs);\n    }\n}\n\npub proof fn lemma_five_limbs_equals_to_nat(limbs: &[u64; 5])\n    ensures\n        five_limbs_to_nat_aux(*limbs) == to_nat(limbs),\n{\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        to_nat(limbs); {}\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 6);\n        }\n        (limbs[0] as nat) + ((limbs[1] as nat) + ((limbs[2] as nat) + ((limbs[3] as nat) + (\n        limbs[4] as nat) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52); {\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(104, 52);\n            lemma_pow2_adds(156, 52);\n            broadcast use group_mul_is_distributive;\n            broadcast use lemma_mul_is_associative;\n\n        }\n        (limbs[0] as nat) + pow2(52) * (limbs[1] as nat) + pow2(104) * (limbs[2] as nat) + pow2(156)\n            * (limbs[3] as nat) + pow2(208) * (limbs[4] as nat); {}\n        five_limbs_to_nat_aux(*limbs);\n    }\n}\n\npub proof fn lemma_bytes_to_nat_rec_equals_bytes_to_nat(bytes: &[u8; 32])\n    ensures\n        bytes_to_nat(bytes) == as_nat_32_u8(bytes),\n{\n    // Strategy: Unfold the recursive definition and show it matches the explicit sum\n    // The recursive definition bytes_to_nat_rec(bytes, 0) computes:\n    // bytes[0] * 2^0 + bytes[1] * 2^8 + ... + bytes[31] * 2^248\n    // First, reveal the recursive structure by showing a few key steps\n    reveal_with_fuel(bytes_to_nat_rec, 33);\n\n    // Now we need to show that the recursive unfolding equals the explicit sum\n    // The key is that pow2(0) == 1, so bytes[0] * pow2(0) == bytes[0]\n    assert(pow2(0) == 1) by {\n        lemma2_to64();\n    };\n\n    // Use calc block to show the transformation step by step\n    calc! {\n        (==)\n        bytes_to_nat(bytes); {}\n        bytes_to_nat_rec(bytes, 0); {\n            // Unfold recursively - Verus should be able to see this with fuel\n        }\n        (bytes[0] as nat) * pow2(0) + (bytes[1] as nat) * pow2(8) + (bytes[2] as nat) * pow2(16) + (\n        bytes[3] as nat) * pow2(24) + (bytes[4] as nat) * pow2(32) + (bytes[5] as nat) * pow2(40)\n            + (bytes[6] as nat) * pow2(48) + (bytes[7] as nat) * pow2(56) + (bytes[8] as nat)\n            * pow2(64) + (bytes[9] as nat) * pow2(72) + (bytes[10] as nat) * pow2(80) + (\n        bytes[11] as nat) * pow2(88) + (bytes[12] as nat) * pow2(96) + (bytes[13] as nat) * pow2(\n            104,\n        ) + (bytes[14] as nat) * pow2(112) + (bytes[15] as nat) * pow2(120) + (bytes[16] as nat)\n            * pow2(128) + (bytes[17] as nat) * pow2(136) + (bytes[18] as nat) * pow2(144) + (\n        bytes[19] as nat) * pow2(152) + (bytes[20] as nat) * pow2(160) + (bytes[21] as nat) * pow2(\n            168,\n        ) + (bytes[22] as nat) * pow2(176) + (bytes[23] as nat) * pow2(184) + (bytes[24] as nat)\n            * pow2(192) + (bytes[25] as nat) * pow2(200) + (bytes[26] as nat) * pow2(208) + (\n        bytes[27] as nat) * pow2(216) + (bytes[28] as nat) * pow2(224) + (bytes[29] as nat) * pow2(\n            232,\n        ) + (bytes[30] as nat) * pow2(240) + (bytes[31] as nat) * pow2(248); {\n            // Simplify bytes[0] * pow2(0) to bytes[0]\n            // Since pow2(0) == 1, we have x * 1 == x\n            assert((bytes[0] as nat) * pow2(0) == (bytes[0] as nat)) by {\n                assert(pow2(0) == 1);\n            };\n        }\n        (bytes[0] as nat) + (bytes[1] as nat) * pow2(8) + (bytes[2] as nat) * pow2(16) + (\n        bytes[3] as nat) * pow2(24) + (bytes[4] as nat) * pow2(32) + (bytes[5] as nat) * pow2(40)\n            + (bytes[6] as nat) * pow2(48) + (bytes[7] as nat) * pow2(56) + (bytes[8] as nat)\n            * pow2(64) + (bytes[9] as nat) * pow2(72) + (bytes[10] as nat) * pow2(80) + (\n        bytes[11] as nat) * pow2(88) + (bytes[12] as nat) * pow2(96) + (bytes[13] as nat) * pow2(\n            104,\n        ) + (bytes[14] as nat) * pow2(112) + (bytes[15] as nat) * pow2(120) + (bytes[16] as nat)\n            * pow2(128) + (bytes[17] as nat) * pow2(136) + (bytes[18] as nat) * pow2(144) + (\n        bytes[19] as nat) * pow2(152) + (bytes[20] as nat) * pow2(160) + (bytes[21] as nat) * pow2(\n            168,\n        ) + (bytes[22] as nat) * pow2(176) + (bytes[23] as nat) * pow2(184) + (bytes[24] as nat)\n            * pow2(192) + (bytes[25] as nat) * pow2(200) + (bytes[26] as nat) * pow2(208) + (\n        bytes[27] as nat) * pow2(216) + (bytes[28] as nat) * pow2(224) + (bytes[29] as nat) * pow2(\n            232,\n        ) + (bytes[30] as nat) * pow2(240) + (bytes[31] as nat) * pow2(248); {}\n        as_nat_32_u8(bytes);\n    }\n}\n\npub proof fn lemma_scalar_subtract_no_overflow(\n    carry: u64,\n    difference_limb: u64,\n    addend: u64,\n    i: u32,\n    l_value: &Scalar52,\n)\n    requires\n        i < 5,\n        difference_limb < (1u64 << 52),\n        addend == 0 || addend == l_value.limbs[i as int],\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n    ensures\n        (carry >> 52) + difference_limb + addend < (1u64 << 53),\n{\n    if i == 0 {\n        assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    } else if i == 1 {\n        assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n    } else if i == 2 {\n        assert(0x000000000014def9 < (1u64 << 52)) by (bit_vector);\n    } else if i == 3 {\n    } else {\n        assert(0x0000100000000000 < (1u64 << 52)) by (bit_vector);\n    }\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert(2 * (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}\n\npub proof fn lemma_borrow_and_mask_bounded(borrow: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        (borrow & mask) < (1u64 << 52),\n{\n    assert((borrow & mask) <= mask) by (bit_vector);\n}\n\npub proof fn lemma_carry_bounded_after_mask(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) <= 1,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}\n\npub proof fn lemma_add_loop_bounds(i: int, carry: u64, a_limb: u64, b_limb: u64)\n    requires\n        0 <= i < 5,\n        a_limb < (1u64 << 52),\n        b_limb < (1u64 << 52),\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n    ensures\n        (carry >> 52) + a_limb + b_limb < (1u64 << 53),\n{\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert((1u64 << 52) + (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}\n\npub proof fn lemma_add_carry_and_sum_bounds(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) < 2,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}\n\npub proof fn lemma_l_value_properties(l_value: &Scalar52, sum: &Scalar52)\n    requires\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n    ensures\n        forall|j: int| 0 <= j < 5 ==> l_value.limbs[j] < (1u64 << 52),\n{\n    assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n}\n\npub proof fn lemma_from_montgomery_limbs_conversion(limbs: &[u128; 9], self_limbs: &[u64; 5])\n    requires\n        forall|j: int| #![auto] 0 <= j < 5 ==> limbs[j] == self_limbs[j] as u128,\n        forall|j: int| 5 <= j < 9 ==> limbs[j] == 0,\n    ensures\n        slice128_to_nat(limbs) == to_nat(self_limbs),\n{\n    lemma_nine_limbs_equals_slice128_to_nat(limbs);\n    lemma_five_limbs_equals_to_nat(self_limbs);\n    assert(limbs[0] == self_limbs[0] as u128);\n    assert(nine_limbs_to_nat_aux(limbs) == (self_limbs[0] as nat) + (self_limbs[1] as nat) * pow2(\n        52,\n    ) + (self_limbs[2] as nat) * pow2(104) + (self_limbs[3] as nat) * pow2(156) + (\n    self_limbs[4] as nat) * pow2(208) + 0 * pow2(260) + 0 * pow2(312) + 0 * pow2(364) + 0 * pow2(\n        416,\n    ));\n}\n\npub proof fn lemma_rr_limbs_bounded()\n    ensures\n        0x000d63c715bea69fu64 < (1u64 << 52),\n{\n    // Verus can figure that out the other 4 limbs are bounded\n    assert(0x000d63c715bea69fu64 < (1u64 << 52)) by (bit_vector);\n}\n\n/// Need to use induction because the postcondition expands\n/// seq_u64_to_nat in the opposite way from how it's defined.\n/// The base case is straightforward, but it takes a few steps\n/// to get Verus to prove it.\n/// Induction case: Take off the first element using definition of\n/// seq_u64_to_nat, apply induction hypothesis to the remaining sequence,\n/// then put the first element back on and simplify all the powers.\npub proof fn lemma_seq_u64_to_nat_subrange_extend(seq: Seq<u64>, i: int)\n    requires\n        0 <= i < seq.len(),\n    ensures\n        seq_u64_to_nat(seq.subrange(0, i + 1)) == seq_u64_to_nat(seq.subrange(0, i)) + seq[i]\n            * pow2(52 * i as nat),\n    decreases i,\n{\n    if i == 0 {\n        reveal_with_fuel(seq_to_nat, 3);\n        assert(seq.len() > 0);\n        assert(seq.subrange(0, 1) == seq![seq[0]]);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, 0 + 1 as int)); {\n                assert(seq.subrange(0, 1) == seq![seq[0]]);\n            }\n            seq_u64_to_nat(seq![seq[0]]); {\n                let single_elem = seq![seq[0]];\n                let nat_single = single_elem.map(|idx, x| x as nat);\n                assert(nat_single == seq![seq[0] as nat]);\n                assert(seq_u64_to_nat(single_elem) == seq_to_nat(nat_single));\n                assert(nat_single.len() == 1);\n                assert(seq_to_nat(nat_single) == nat_single[0] + seq_to_nat(\n                    nat_single.subrange(1, 1),\n                ) * pow2(52));\n                assert(nat_single.subrange(1, 1).len() == 0);\n                assert(seq_to_nat(nat_single.subrange(1, 1)) == 0);\n                assert(seq_to_nat(nat_single) == nat_single[0]);\n                assert(nat_single[0] == seq[0] as nat);\n            }\n            seq[0] as nat; {\n                assert(pow2(0) == 1) by {\n                    lemma2_to64();\n                }\n                assert(52 * 0 == 0);\n                assert(pow2(52 * 0 as nat) == pow2(0));\n                assert((seq[0] * pow2(0)) as nat == (seq[0] * 1) as nat);\n                assert((seq[0] * 1) as nat == seq[0] as nat);\n            }\n            (seq[0] * pow2(52 * 0 as nat)) as nat; {\n                lemma_empty_seq_as_nat(seq);\n            }\n            (seq_u64_to_nat(seq.subrange(0, 0)) + seq[0] * pow2(52 * 0 as nat)) as nat;\n        }\n        return ;\n    } else {\n        let limbs1 = seq.subrange(0, i + 1).map(|i, x| x as nat);\n        let limbs2 = seq.subrange(0, i).map(|i, x| x as nat);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, i + 1)); {\n                assert(seq_to_nat(limbs1) == limbs1[0] + seq_to_nat(\n                    limbs1.subrange(1, limbs1.len() as int),\n                ) * pow2(52));\n            }\n            limbs1[0] + seq_to_nat(limbs1.subrange(1, limbs1.len() as int)) * pow2(52); {\n                assert(seq.subrange(1, i + 1).map(|i, x| x as nat) == limbs1.subrange(\n                    1,\n                    limbs1.len() as int,\n                ));\n            }\n            limbs1[0] + seq_u64_to_nat(seq.subrange(1, i + 1)) * pow2(52); {\n                let tail = seq.subrange(1, i + 1);\n                assert(i >= 1);\n                assert(0 <= i - 1 < tail.len());\n                lemma_seq_u64_to_nat_subrange_extend(tail, i - 1);\n                assert(seq_u64_to_nat(tail.subrange(0, i)) == seq_u64_to_nat(\n                    tail.subrange(0, i - 1),\n                ) + tail[i - 1] * pow2(52 * (i - 1) as nat));\n                assert(tail.subrange(0, i) == seq.subrange(1, i + 1));\n                assert(tail.subrange(0, i - 1) == seq.subrange(1, i));\n                assert(seq_u64_to_nat(seq.subrange(1, i + 1)) == seq_u64_to_nat(seq.subrange(1, i))\n                    + seq[i] * pow2(52 * (i - 1) as nat));\n            }\n            limbs1[0] + ((seq_u64_to_nat(seq.subrange(1, i)) + seq[i] * pow2(52 * (i - 1) as nat))\n                * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i)) * pow2(52) + seq[i] * pow2(\n                52 * (i - 1) as nat,\n            ) * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_associative;\n\n                lemma_pow2_adds(52 * (i - 1) as nat, 52);\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i)) * pow2(52) + seq[i] * pow2(\n                52 * i as nat,\n            )) as nat; {\n                assert(seq.subrange(1, i).map(|i, x| x as nat) == limbs2.subrange(\n                    1,\n                    limbs2.len() as int,\n                ));\n            }\n            (limbs2[0] + seq_to_nat(limbs2.subrange(1, limbs2.len() as int)) * pow2(52) + seq[i]\n                * pow2(52 * i as nat)) as nat; {\n                assert(seq_to_nat(limbs2) == limbs2[0] + seq_to_nat(\n                    limbs2.subrange(1, limbs2.len() as int),\n                ) * pow2(52));\n            }\n            (seq_to_nat(limbs2) + seq[i] * pow2(52 * i as nat)) as nat; {}\n            (seq_u64_to_nat(seq.subrange(0, i)) + seq[i] * pow2(52 * i as nat)) as nat;\n        }\n    }\n}\n\n/// Verus times out when this assertion is inside\n/// lemma_seq_u64_to_nat_subrange_extend\npub proof fn lemma_empty_seq_as_nat(a: Seq<u64>)\n    ensures\n        seq_u64_to_nat(a.subrange(0, 0)) == 0,\n{\n    assert(seq_u64_to_nat(a.subrange(0, 0)) == 0);\n}\n\n/// Using lemma_mod_add_multiples_vanish in a big proof made the proof hang\npub proof fn lemma_mod_cancel(a: &Scalar52, b: &Scalar52)\n    ensures\n        (group_order() + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int) == (to_nat(\n            &a.limbs,\n        ) - to_nat(&b.limbs)) % (group_order() as int),\n{\n    lemma_mod_add_multiples_vanish(\n        (to_nat(&a.limbs) - to_nat(&b.limbs)) as int,\n        group_order() as int,\n    );\n}\n\n/// The corollary of limbs_bounded(a)\npub proof fn lemma_bound_scalar(a: &Scalar52)\n    requires\n        limbs_bounded(a),\n    ensures\n        to_nat(&a.limbs) < pow2((52 * (5) as nat)),\n{\n    lemma_general_bound(a.limbs@);\n}\n\n/// The general case of lemma_bound_scalar so we\n/// can prove via straightforward induction.\npub proof fn lemma_general_bound(a: Seq<u64>)\n    requires\n        forall|i: int| 0 <= i < a.len() ==> a[i] < (1u64 << 52),\n    ensures\n        seq_u64_to_nat(a) < pow2((52 * a.len() as nat)),\n    decreases a.len(),\n{\n    if a.len() == 0 {\n        assert(seq_u64_to_nat(a) == 0);\n        lemma2_to64();  // Gives us pow2(0) == 1 among other facts\n        assert(pow2(0) == 1);\n    } else {\n        // Inductive case\n        let tail = a.subrange(1, a.len() as int);\n\n        // Apply induction hypothesis on tail\n        assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] < (1u64 << 52)) by {\n            assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] == a[i + 1]);\n        };\n\n        assert(tail.len() == a.len() - 1);\n\n        // Apply induction hypothesis\n        lemma_general_bound(tail);\n        assert(seq_u64_to_nat(tail) < pow2((52 * tail.len() as nat)));\n\n        // Now prove for the full sequence\n        assert(seq_u64_to_nat(a) == seq_to_nat(a.map(|i, x| x as nat)));\n        assert(a.map(|i, x| x as nat).len() == a.len());\n        assert(a.map(|i, x| x as nat)[0] == a[0] as nat);\n        assert(a.map(|i, x| x as nat).subrange(1, a.len() as int) == a.subrange(\n            1,\n            a.len() as int,\n        ).map(|i, x| x as nat));\n        // Therefore:\n        assert(seq_u64_to_nat(a) == a[0] as nat + seq_u64_to_nat(a.subrange(1, a.len() as int))\n            * pow2(52));\n\n        assert(a.subrange(1, a.len() as int) == tail);\n\n        // From precondition\n        assert(a[0] < (1u64 << 52));\n        lemma2_to64_rest();\n        assert(0x10000000000000 == 1u64 << 52) by (compute_only);\n        assert(0x10000000000000 == pow2(52));\n        assert((1u64 << 52) == pow2(52));\n\n        // We have seq_u64_to_nat(a) == a[0] + seq_u64_to_nat(tail) * pow2(52)\n        // We know a[0] < pow2(52) and seq_u64_to_nat(tail) < pow2(52 * (a.len() - 1))\n\n        assert(a[0] as nat <= pow2(52) - 1);\n        assert(seq_u64_to_nat(tail) <= pow2(52 * (a.len() - 1) as nat) - 1);\n\n        assert(seq_u64_to_nat(a) <= (pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(\n            52,\n        )) by {\n            lemma_mul_inequality(\n                (pow2(52 * (a.len() - 1) as nat) - 1) as int,\n                pow2(52 * (a.len() - 1) as nat) as int,\n                pow2(52) as int,\n            );\n        };\n\n        // Expand the right side\n        assert((pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(52) == pow2(52) - 1\n            + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52)) by {\n            broadcast use lemma_mul_is_distributive_sub;\n\n        };\n\n        assert(pow2(52) - 1 + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52) == pow2(\n            52 * (a.len() - 1) as nat,\n        ) * pow2(52) - 1);\n\n        lemma_pow2_adds(52 * (a.len() - 1) as nat, 52);\n        assert(pow2(52 * (a.len() - 1) as nat) * pow2(52) == pow2(52 * (a.len() - 1) as nat + 52));\n        assert(52 * (a.len() - 1) as nat + 52 == 52 * a.len() as nat);\n\n        assert(seq_u64_to_nat(a) <= pow2(52 * a.len() as nat) - 1);\n        assert(seq_u64_to_nat(a) < pow2(52 * a.len() as nat));\n    }\n}\n\n/// Claude wrote this proof. Could the proof be shorter?\n/// Moved this to a lemma to get under rlimit.\npub proof fn lemma_decompose(a: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        a == (a >> 52) * pow2(52) + (a & mask),\n{\n    // First, establish that bit shifting is division by pow2(52)\n    broadcast use lemma_u64_shr_is_div;\n\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    lemma2_to64_rest();  // Establishes pow2(52) == 0x10000000000000\n    assert((1u64 << 52) == 0x10000000000000) by (bit_vector);\n    assert(pow2(52) == 0x10000000000000);\n    assert((1u64 << 52) as nat == pow2(52));\n\n    assert(a >> 52 == a / (1u64 << 52));\n\n    // Apply fundamental division theorem: a = q * d + r\n    lemma_fundamental_div_mod(a as int, pow2(52) as int);\n    let q = a as nat / pow2(52);\n    let r = a as nat % pow2(52);\n    assert(a as nat == q * pow2(52) + r);\n    assert(0 <= r < pow2(52));\n\n    // Now prove that (a & mask) == r\n    // mask is all 1s in the lower 52 bits\n    assert(mask == (1u64 << 52) - 1);\n\n    // Key insight: a & mask gives us the lower 52 bits, which is exactly a % pow2(52)\n    lemma_u64_low_bits_mask_is_mod(a, 52);\n    assert(a & mask == a % (1u64 << 52));\n    assert((a % (1u64 << 52)) as nat == a as nat % pow2(52));\n    assert((a & mask) as nat == r);\n\n    // Now show that a >> 52 == q\n    assert((a >> 52) as nat == a as nat / pow2(52));\n    assert((a >> 52) as nat == q);\n\n    // Combine everything\n    assert(a as nat == (a >> 52) as nat * pow2(52) + (a & mask) as nat);\n}\n\n/// The loop invariant says that subtraction is correct if we only subtract\n/// the first i items of each array, plus there's a borrow term.\n/// The first parts of the calc statement expand using the previous invariant.\n/// Then we have cases depending if the wrapping_sub wrapped.\n/// If it didn't wrap, we show that borrow must be small, and borrow >> 52 == 0.\n/// If it did wrap, we show that borrow is so large that its bit-shifts are all\n/// the maximum amount.\n/// Either way, we then use the preconditions about what was mutated,\n/// and shuffle around the powers of 52.\npub proof fn lemma_sub_loop1_invariant(\n    difference: Scalar52,\n    borrow: u64,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    old_borrow: u64,\n    mask: u64,\n    difference_loop1_start: Scalar52,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> difference.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) == seq_u64_to_nat(difference_loop1_start.limbs@.subrange(0, i as int)) - (old_borrow\n            >> 63) * pow2((52 * (i) as nat)),\n        difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(\n            0,\n            i as int,\n        ),\n        difference.limbs[i as int] == borrow & mask,\n        borrow == a.limbs[i as int].wrapping_sub((b.limbs[i as int] + (old_borrow >> 63)) as u64),\n    ensures\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n            (52 * (i + 1) as nat),\n        ) == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i + 1),\n        ),\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] * pow2(52 * i as nat) - (\n        seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] * pow2(52 * i as nat)); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) + (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            assert(difference_loop1_start.limbs@.subrange(0, i as int)\n                == difference.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) - (old_borrow >> 63) * pow2(\n            52 * i as nat,\n        ) + (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n            - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n            assert(borrow == a.limbs[i as int].wrapping_sub(\n                (b.limbs[i as int] + (old_borrow >> 63)) as u64,\n            ));\n            assert(difference.limbs[i as int] == borrow & mask);\n            // Expand wrapping sub\n            if a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) < 0 {\n                assert(borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52)) by {\n                    assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    assert(b.limbs[i as int] <= (1u64 << 52) - 1);\n                    assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                        >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                    assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 <= 1u64 << 52);\n                    assert(borrow >= (a.limbs[i as int] - (1u64 << 52)\n                        + 0x1_0000_0000_0000_0000) as u64);\n                };\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n                        - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                            >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow\n                        - 0x1_0000_0000_0000_0000) * pow2(52 * i as nat); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((borrow >> 52)\n                        * pow2(52) + difference.limbs[i as int] - 0x1_0000_0000_0000_0000) * pow2(\n                        52 * i as nat,\n                    ); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                            broadcast use lemma_pow2_adds;\n\n                        };\n                        assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n                        broadcast use lemma_mul_is_distributive_sub_other_way;\n\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow\n                            >> 52) as nat * pow2(52 * (i + 1) as nat)) by {\n                            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                            lemma_mul_is_associative(\n                                (borrow >> 52) as int,\n                                pow2(52) as int,\n                                pow2(52 * i as nat) as int,\n                            );\n                        };\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) + difference.limbs[i as int] * pow2(52 * i as nat) - 0x1_0000_0000_0000_0000\n                        * pow2(52 * i as nat); {\n                        lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) - 0x1_0000_0000_0000_0000 * pow2(52 * i as nat); {\n                        assert(borrow >> 52 == (1u64 << 12) - 1) by (bit_vector)\n                            requires\n                                borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52),\n                        ;\n                        assert(0x1_0000_0000_0000_0000 * pow2(52 * i as nat) == (1u64 << 12) * pow2(\n                            52 * (i + 1) as nat,\n                        )) by {\n                            lemma2_to64();\n                            assert(0x1_0000_0000_0000_0000 == pow2(64));\n                            assert(1u64 << 12 == pow2(12)) by (compute);\n                            lemma_pow2_adds(64, 52 * i as nat);\n                            lemma_pow2_adds(12, 52 * (i + 1) as nat);\n                            assert(64 + 52 * i as nat == 12 + 52 * (i + 1) as nat);\n                        }\n                        lemma_mul_is_distributive_sub_other_way(\n                            pow2(52 * (i + 1) as nat) as int,\n                            (1u64 << 12) - 1,\n                            (1u64 << 12) as int,\n                        );\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (-1) * pow2(\n                        52 * (i + 1) as nat,\n                    ); {\n                        assert(borrow >> 63 == 1) by (bit_vector)\n                            requires\n                                borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52),\n                        ;\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n                        (52 * (i + 1) as nat),\n                    );\n                }\n            } else {\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n                        - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                            >> 63)) as u64)) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow) * pow2(\n                        52 * i as nat,\n                    ); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((borrow >> 52)\n                        * pow2(52) + difference.limbs[i as int]) * pow2(52 * i as nat); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                            broadcast use lemma_pow2_adds;\n\n                        };\n                        assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow\n                            >> 52) as nat * pow2(52 * (i + 1) as nat)) by {\n                            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                            lemma_mul_is_associative(\n                                (borrow >> 52) as int,\n                                pow2(52) as int,\n                                pow2(52 * i as nat) as int,\n                            );\n                        };\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) + difference.limbs[i as int] * pow2(52 * i as nat); {\n                        lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                        assert(borrow < 1u64 << 52) by {\n                            assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                                >> 63)) as u64)) as u64);\n                            assert(a.limbs[i as int] < (1u64 << 52));\n                            assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 >= 0);\n                        }\n                        assert(borrow >> 52 == 0) by (bit_vector)\n                            requires\n                                borrow < 1u64 << 52,\n                        ;\n                        assert(borrow >> 63 == 0) by (bit_vector)\n                            requires\n                                borrow < 1u64 << 52,\n                        ;\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n                        (52 * (i + 1) as nat),\n                    );\n                }\n            }\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n            (52 * (i + 1) as nat),\n        );\n    }\n}\n\n/// Just a proof by computation\npub(crate) proof fn lemma_l_equals_group_order()\n    ensures\n        to_nat(&constants::L.limbs) == group_order(),\n        seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order(),\n{\n    // First show that the subrange equals the full array\n    assert(constants::L.limbs@ == constants::L.limbs@.subrange(0, 5 as int));\n    assert(seq_u64_to_nat(constants::L.limbs@) == seq_u64_to_nat(\n        constants::L.limbs@.subrange(0, 5 as int),\n    ));\n    assert(to_nat(&constants::L.limbs) == seq_u64_to_nat(constants::L.limbs@));\n\n    assert(pow2(52) == 0x10000000000000) by {\n        lemma2_to64_rest();\n    };\n    lemma_pow2_adds(52, 52);\n    assert(pow2(104) == 0x100000000000000000000000000);\n    lemma_pow2_adds(104, 104);\n    assert(pow2(208) == 0x10000000000000000000000000000000000000000000000000000);\n    lemma_pow252();\n    lemma_five_limbs_equals_to_nat(&constants::L.limbs);\n    assert(five_limbs_to_nat_aux(constants::L.limbs) == group_order()) by (compute);\n}\n\npub proof fn lemma_pow252()\n    ensures\n        pow2(252) == 0x1000000000000000000000000000000000000000000000000000000000000000,\n{\n    assert(pow2(63) == 0x8000000000000000) by {\n        lemma2_to64_rest();\n    }\n    lemma_pow2_adds(63, 63);\n    assert(pow2(126) == 0x40000000000000000000000000000000);\n    lemma_pow2_adds(126, 126);\n}\n\npub proof fn lemma_pow2_260_greater_than_2_group_order()\n    ensures\n        pow2(260) > 2 * group_order(),\n{\n    // The group order is approximately 2^252, so 2 * group_order ≈ 2^253\n    // And 2^260 >> 2^253\n    assert(pow2(260) == pow2(252) * pow2(8)) by {\n        lemma_pow2_adds(252, 8);\n    };\n    assert(pow2(8) == 256) by {\n        lemma2_to64();\n    };\n    lemma_pow252();\n    // Now Verus knows what the powers of 2 mean, so it can figure out the rest\n}\n\n/// If borrow >> 63 == 0, we apply\n/// (1) `-group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()`,\n/// and that's enough to show that to_nat(&difference.limbs) is between\n/// 0 and group order.\n/// If borrow >> 63 == 1, we apply (1) to show that carry >> 52 can't be 0.\n/// This makes the excess terms in the borrow >> 63 == 1 precondition disappear\npub(crate) proof fn lemma_sub_correct_after_loops(\n    difference: Scalar52,\n    carry: u64,\n    a: &Scalar52,\n    b: &Scalar52,\n    difference_after_loop1: Scalar52,\n    borrow: u64,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        limbs_bounded(&difference),\n        limbs_bounded(&difference_after_loop1),\n        (carry >> 52) < 2,\n        -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order(),\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n            + seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ) + (carry >> 52) * pow2(52 * 5 as nat),\n        seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) - (borrow >> 63)\n            * pow2((52 * (5) as nat)),\n    ensures\n        to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int),\n{\n    assert(borrow >> 63 == 1 || borrow >> 63 == 0) by (bit_vector);\n    assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(&difference.limbs))\n        by {\n        assert(seq_u64_to_nat(difference.limbs@) == to_nat(&difference.limbs));\n        assert(difference.limbs@ == difference.limbs@.subrange(0, 5 as int));\n    }\n    assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs)) by {\n        assert(seq_u64_to_nat(b.limbs@) == to_nat(&b.limbs));\n        assert(b.limbs@ == b.limbs@.subrange(0, 5 as int));\n    }\n    assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs)) by {\n        assert(seq_u64_to_nat(a.limbs@) == to_nat(&a.limbs));\n        assert(a.limbs@ == a.limbs@.subrange(0, 5 as int));\n    }\n    if borrow >> 63 == 0 {\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) - (borrow >> 63) * pow2(\n            (52 * (5) as nat),\n        ));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)));\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) == to_nat(&difference.limbs));\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) >= 0);\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) < group_order());\n        lemma_small_mod((to_nat(&a.limbs) - to_nat(&b.limbs)) as nat, group_order());\n        assert(to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (\n        group_order() as int));\n    }\n    if borrow >> 63 == 1 {\n        assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            constants::L.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ));\n        assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n            == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ) - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) - pow2(\n            (52 * (5) as nat),\n        ));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ) - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) - pow2((52 * (5) as nat)));\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            a.limbs@.subrange(0, 5 as int),\n        ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ) + (carry >> 52) * pow2(52 * 5 as nat) - pow2((52 * (5) as nat)));\n        if carry >> 52 == 0 {\n            // Get a contradiction because the sides in the above equation have different signs\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n                a.limbs@.subrange(0, 5 as int),\n            ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) >= 0) by {\n                assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) >= group_order())\n                    by {\n                    lemma_l_equals_group_order();\n                };\n                assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs));\n                assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs));\n            };\n            assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) < pow2(\n                (52 * (5) as nat),\n            )) by {\n                assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(\n                    &difference.limbs,\n                ));\n                lemma_bound_scalar(&difference);\n            };\n            assert((carry >> 52) * pow2(52 * 5 as nat) == 0);\n            assert(false);\n        }\n        assert(carry >> 52 == 1);\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            a.limbs@.subrange(0, 5 as int),\n        ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ));\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + to_nat(&a.limbs)\n            - to_nat(&b.limbs) == to_nat(&difference.limbs));\n        assert(to_nat(&constants::L.limbs) == group_order()) by {\n            lemma_l_equals_group_order();\n        };\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order()) by {\n            lemma_l_equals_group_order();\n        };\n        assert(group_order() > 0);\n        calc! {\n            (==)\n            to_nat(&difference.limbs) as int; {}\n            group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs); {\n                assert(group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs) < group_order())\n                    by {\n                    assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n                        == to_nat(&difference_after_loop1.limbs)) by {\n                        assert(seq_u64_to_nat(difference_after_loop1.limbs@) == to_nat(\n                            &difference_after_loop1.limbs,\n                        ));\n                        assert(difference_after_loop1.limbs@\n                            == difference_after_loop1.limbs@.subrange(0, 5 as int));\n                    }\n                    assert(to_nat(&a.limbs) - to_nat(&b.limbs) == to_nat(\n                        &difference_after_loop1.limbs,\n                    ) - pow2((52 * (5) as nat)));\n                    lemma_bound_scalar(&difference_after_loop1);\n                };\n                lemma_small_mod(\n                    (group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) as nat,\n                    group_order(),\n                );\n            }\n            (group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int); {\n                lemma_mod_cancel(a, b);\n            }\n            (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int);\n        }\n    }\n}\n\n/// Moving this out to get under rlimit\npub proof fn lemma_old_carry(old_carry: u64)\n    requires\n        old_carry < 1u64 << 52,\n    ensures\n        old_carry >> 52 == 0,\n{\n    assert(old_carry >> 52 == 0) by (bit_vector)\n        requires\n            old_carry < 1u64 << 52,\n    ;\n}\n\n/// If borrow >> 63 == 0, we just prove that the loop step has no effect.\n/// If borrow >> 63 == 1, we substitute in the loop's updates\n/// like `difference.limbs[i as int] == carry & mask`.\n/// In that case we're proving that subtraction is correct if we only\n/// consider the first i items of each array, except there's also a\n/// `(carry >> 52) * pow2(52 * (i+1) as nat)` term that doesn't go away.\npub(crate) proof fn lemma_sub_loop2_invariant(\n    difference: Scalar52,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    mask: u64,\n    difference_after_loop1: Scalar52,\n    difference_loop2_start: Scalar52,\n    carry: u64,\n    old_carry: u64,\n    addend: u64,\n    borrow: u64,\n)\n    requires\n        0 <= i < 5,\n        mask == (1u64 << 52) - 1,\n        forall|j: int| 0 <= j < 5 ==> difference_loop2_start.limbs[j] < (1u64 << 52),\n        forall|j: int|\n            i <= j < 5 ==> difference_loop2_start.limbs[j] == difference_after_loop1.limbs[j],\n        forall|j: int|\n            (0 <= j < 5 && j != i) ==> difference_loop2_start.limbs[j] == difference.limbs[j],\n        mask == (1u64 << 52) - 1,\n        i == 0 ==> old_carry == 0,\n        i >= 1 ==> (old_carry >> 52) < 2,\n        (i >= 1 && borrow >> 63 == 0) ==> old_carry == difference_loop2_start.limbs[i - 1],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference_loop2_start,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int))\n            + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) == seq_u64_to_nat(\n            difference_loop2_start.limbs@.subrange(0, i as int),\n        ) + (old_carry >> 52) * pow2(52 * i as nat),\n        difference.limbs[i as int] == carry & mask,\n        difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(\n            0,\n            i as int,\n        ),\n        borrow >> 63 == 0 ==> addend == 0,\n        borrow >> 63 == 1 ==> addend == constants::L.limbs[i as int],\n        carry == (old_carry >> 52) + difference_loop2_start.limbs[i as int] + addend,\n    ensures\n        (i + 1 >= 1 && borrow >> 63 == 0) ==> carry == difference.limbs[i as int],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(\n            difference_after_loop1.limbs@.subrange(0, i + 1 as int),\n        ) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i + 1 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, i + 1 as int),\n        ) + (carry >> 52) * pow2(52 * (i + 1) as nat),\n{\n    if borrow >> 63 == 0 {\n        lemma_old_carry(old_carry);\n        assert(addend == 0);\n        assert(carry == difference_loop2_start.limbs[i as int]);\n        assert(carry & mask == carry) by (bit_vector)\n            requires\n                carry < 1u64 << 52,\n                mask == (1u64 << 52) - 1,\n        ;\n        assert(difference_after_loop1.limbs[i as int] == difference.limbs[i as int]);\n        assert(forall|j: int|\n            0 <= j < 5 ==> difference_after_loop1.limbs[j] == difference.limbs[j]);\n        assert(difference_after_loop1.limbs == difference.limbs);\n    }\n    if borrow >> 63 == 1 {\n        // When underflow, addend = L.limbs[i]\n        assert(addend == constants::L.limbs[i as int]);\n        // carry = (old_carry >> 52) + difference_after_loop1.limbs[i] + L.limbs[i]\n        // difference.limbs[i] = carry & mask\n        calc! {\n            (==)\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(\n                constants::L.limbs@.subrange(0, i + 1),\n            ); {\n                lemma_seq_u64_to_nat_subrange_extend(difference_after_loop1.limbs@, i as int);\n                lemma_seq_u64_to_nat_subrange_extend(constants::L.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int))\n                + difference_after_loop1.limbs[i as int] as nat * pow2(52 * i as nat)\n                + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int))\n                + constants::L.limbs[i as int] as nat * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n                constants::L.limbs@.subrange(0, i as int),\n            ) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                // Use invariant\n            }\n            seq_u64_to_nat(difference_loop2_start.limbs@.subrange(0, i as int)) + (old_carry\n                >> 52) as nat * pow2(52 * i as nat) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(difference_loop2_start.limbs@.subrange(0, i as int)\n                    == difference.limbs@.subrange(0, i as int));\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat\n                * pow2(52 * i as nat) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((old_carry >> 52) as nat\n                + difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(carry == (old_carry >> 52) + difference_after_loop1.limbs[i as int]\n                    + constants::L.limbs[i as int]);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + carry as nat * pow2(\n                52 * i as nat,\n            ); {\n                assert(carry == (carry >> 52) * (1u64 << 52) + (carry & mask)) by (bit_vector)\n                    requires\n                        mask == (1u64 << 52) - 1,\n                ;\n                assert(carry == (carry >> 52) * pow2(52) + difference.limbs[i as int]) by {\n                    lemma2_to64_rest();\n                    assert(0x10000000000000 == 1u64 << 52) by (compute_only);\n                };\n                assert(difference.limbs[i as int] == carry & mask);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((carry >> 52) as nat * pow2(\n                52,\n            ) + difference.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n                52,\n            ) * pow2(52 * i as nat) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                    broadcast use lemma_pow2_adds;\n\n                };\n                assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat\n                    * pow2(52 * (i + 1) as nat)) by {\n                    assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                    lemma_mul_is_associative(\n                        (carry >> 52) as int,\n                        pow2(52) as int,\n                        pow2(52 * i as nat) as int,\n                    );\n                };\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n                52 * (i + 1) as nat,\n            ) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (carry >> 52) as nat * pow2(\n                52 * (i + 1) as nat,\n            );\n        }\n    }\n}\n\n/// Proves that the addition loop maintains its invariant:\n/// a[0..i+1] + b[0..i+1] == sum[0..i+1] + (carry >> 52) * 2^(52*(i+1))\n/// See lemma_sub_loop1_invariant for more comments\npub proof fn lemma_add_loop_invariant(\n    sum: Scalar52,\n    carry: u64,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    old_carry: u64,\n    mask: u64,\n    sum_loop_start: Scalar52,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> sum.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) == seq_u64_to_nat(sum_loop_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) * pow2(\n            (52 * (i) as nat),\n        ),\n        sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int),\n        sum.limbs[i as int] == carry & mask,\n        carry == a.limbs[i as int] + b.limbs[i as int] + (old_carry >> 52),\n    ensures\n        seq_u64_to_nat(sum.limbs@.subrange(0, i + 1)) + (carry >> 52) * pow2((52 * (i + 1) as nat))\n            == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i + 1),\n        ),\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] as nat * pow2(\n            52 * i as nat,\n        ) + seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] as nat * pow2(\n            52 * i as nat,\n        ); {\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                a.limbs[i as int] as int,\n                b.limbs[i as int] as int,\n            );\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) + (a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(\n            52 * i as nat,\n        ) + (a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                (old_carry >> 52) as int,\n                (a.limbs[i as int] as nat + b.limbs[i as int] as nat) as int,\n            );\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + ((old_carry >> 52) as nat\n            + a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(carry == a.limbs[i as int] + b.limbs[i as int] + (old_carry >> 52));\n            assert(sum.limbs[i as int] == carry & mask);\n            // Decompose carry using the mask\n            lemma_decompose(carry, mask);\n            assert(carry == (carry >> 52) * pow2(52) + sum.limbs[i as int]);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + ((carry >> 52) as nat * pow2(52)\n            + sum.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                lemma_pow2_adds(52, 52 * i as nat);\n            };\n            assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                (carry >> 52) as nat * pow2(52) as int,\n                sum.limbs[i as int] as int,\n            );\n            assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat\n                * pow2(52 * (i + 1) as nat)) by {\n                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                lemma_mul_is_associative(\n                    (carry >> 52) as int,\n                    pow2(52) as int,\n                    pow2(52 * i as nat) as int,\n                );\n            };\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n            52 * (i + 1) as nat,\n        ) + sum.limbs[i as int] as nat * pow2(52 * i as nat); {\n            lemma_seq_u64_to_nat_subrange_extend(sum.limbs@, i as int);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i + 1)) + (carry >> 52) as nat * pow2(\n            (52 * (i + 1) as nat),\n        );\n    }\n}\n\n/// Get rid of the subranges from the invariant statement.\n/// Since a and b are less than group order, we can show that carry >> 52\n/// has to be 0, else the RHS is too large\npub proof fn lemma_add_sum_simplify(a: &Scalar52, b: &Scalar52, sum: &Scalar52, carry: u64)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        to_nat(&a.limbs) < group_order(),\n        to_nat(&b.limbs) < group_order(),\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n        (carry >> 52) < 2,\n        seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) + (carry >> 52) as nat * pow2(\n            (52 * (5) as nat),\n        ),\n    ensures\n        to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs),\n{\n    // First establish the relationship between the different representations\n    assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs)) by {\n        assert(a.limbs@ == a.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(a.limbs@) == to_nat(&a.limbs));\n    }\n    assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs)) by {\n        assert(b.limbs@ == b.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(b.limbs@) == to_nat(&b.limbs));\n    }\n    assert(seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) == to_nat(&sum.limbs)) by {\n        assert(sum.limbs@ == sum.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(sum.limbs@) == to_nat(&sum.limbs));\n    }\n\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs) + (carry >> 52) * pow2(\n        (52 * (5) as nat),\n    ));\n\n    // From the loop invariant, we have: a + b == sum + (carry >> 52) * 2^260\n    assert(52 * 5 == 260) by (compute);\n    assert(pow2((52 * 5) as nat) == pow2(260));\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(\n        260,\n    ));\n\n    // Since a < group_order() and b < group_order(), we have a + b < 2 * group_order()\n    // This is just basic arithmetic: if x < A and y < A, then x + y < A + A = 2*A\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) < group_order() + group_order());\n    assert(group_order() + group_order() == 2 * group_order());\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) < 2 * group_order());\n\n    // Therefore: sum + (carry >> 52) * 2^260 < 2 * group_order()\n    assert(to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260) < 2 * group_order());\n\n    // Prove a contradiction if carry is nonzero\n    assert((carry >> 52) as nat * pow2(260) < 2 * group_order());\n    if carry >> 52 == 1 {\n        lemma_pow2_260_greater_than_2_group_order();\n        assert(1 as nat * pow2(260) < 2 * group_order());\n        assert(false);\n    }\n    assert(carry >> 52 == 0);\n\n    // Since carry >> 52 >= 0 and pow2(260) > 0, we have (carry >> 52) * pow2(260) >= 0\n    // Therefore sum < sum + (carry >> 52) * pow2(260) < 2 * group_order()\n    lemma_pow2_pos(260);\n    assert(pow2(260) > 0);\n    assert((carry >> 52) as nat * pow2(260) >= 0);\n    assert(to_nat(&sum.limbs) <= to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260));\n    assert(to_nat(&sum.limbs) < 2 * group_order());\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 11,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_mixed_multiscalar_mul().",
      "display_name": "vartime_mixed_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_mixed_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn vartime_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator,\n        K::Item: Borrow<Self::Point>,\n    {\n        Self::optional_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            dynamic_scalars,\n            dynamic_points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/negate_proof().",
      "display_name": "negate_proof",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/negate_proof().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "use vstd::prelude::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::bit_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::div_mod_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mask_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mul_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::pow_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::shift_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_nat_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::compute_q_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::field_core::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::from_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::limbs_to_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::load8_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::negate_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2_51_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#PartialEq#eq().",
      "display_name": "eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#PartialEq#eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "    fn eq(&self, other: &FieldElement) -> (result:\n        bool)\n    // VERIFICATION NOTE: PROOF BYPASS AND SPEC BYPASS\n\n        ensures\n            result == (field_element_as_bytes(self) == field_element_as_bytes(\n                other,\n            )),\n    // SPEC BYPASS through placeholder field_element_as_bytes\n\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Choice::into\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.ct_eq(other).into()\n         </ORIGINAL CODE> */\n        let choice = self.ct_eq(other);\n        let result = choice_into(choice);\n\n        // VERIFICATION NOTE: vstd's external trait specification check cannot be satisfied\n        // vstd expects obeys_eq_spec() and eq_spec() from PartialEqSpecImpl trait,\n        // but that trait is not publicly exported, so we bypass with assume(false)\n        assume(false);\n\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb4_byte_contribution_52().",
      "display_name": "limb4_byte_contribution_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb4_byte_contribution_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub open spec fn limb4_byte_contribution_52(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    bytes[26] as nat * pow2(26 * 8) + bytes[27] as nat * pow2(27 * 8) + bytes[28] as nat * pow2(\n        28 * 8,\n    ) + bytes[29] as nat * pow2(29 * 8) + bytes[30] as nat * pow2(30 * 8) + bytes[31] as nat * pow2(\n        31 * 8,\n    )\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "display_name": "as_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    /// a canonical representative of an element of \\\\( \\mathbb Z / \\ell\\mathbb Z \\\\). This is\n    /// stronger than invariant #1. It also sometimes has to be broken.\n    ///\n    /// This invariant is deliberately broken in the implementation of `EdwardsPoint::{mul_clamped,\n    /// mul_base_clamped}`, `MontgomeryPoint::{mul_clamped, mul_base_clamped}`, and",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#xcoset4().",
      "display_name": "xcoset4",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#xcoset4().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    pub fn xcoset4(&self) -> [EdwardsPoint; 4] {\n        [\n            self.0,\n            self.0 + constants::EIGHT_TORSION[2],\n            self.0 + constants::EIGHT_TORSION[4],\n            self.0 + constants::EIGHT_TORSION[6],\n        ]\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_two_factoring().",
      "display_name": "lemma_two_factoring",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_two_factoring().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "    ensures\n        (a >> 51) <= (u64::MAX as u128),\n{\n    assert(((u64::MAX as u128) << 51) >> 51 == (u64::MAX as u128)) by (compute);\n    lemma_shr_51_le(a, (u64::MAX as u128) << 51);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#ConstantTimeEq#ct_eq().",
      "display_name": "ct_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#ConstantTimeEq#ct_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn ct_eq(&self, other: &RistrettoPoint) -> Choice {\n        let X1Y2 = &self.0.X * &other.0.Y;\n        let Y1X2 = &self.0.Y * &other.0.X;\n        let X1X2 = &self.0.X * &other.0.X;\n        let Y1Y2 = &self.0.Y * &other.0.Y;\n\n        X1Y2.ct_eq(&Y1X2) | X1X2.ct_eq(&Y1Y2)\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_rr_limbs_bounded().",
      "display_name": "lemma_rr_limbs_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_rr_limbs_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_rr_limbs_bounded()\n    ensures\n        0x000d63c715bea69fu64 < (1u64 << 52),\n{\n    // Verus can figure that out the other 4 limbs are bounded\n    assert(0x000d63c715bea69fu64 < (1u64 << 52)) by (bit_vector);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_scalar_subtract_no_overflow().",
      "display_name": "lemma_scalar_subtract_no_overflow",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_scalar_subtract_no_overflow().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_scalar_subtract_no_overflow(\n    carry: u64,\n    difference_limb: u64,\n    addend: u64,\n    i: u32,\n    l_value: &Scalar52,\n)\n    requires\n        i < 5,\n        difference_limb < (1u64 << 52),\n        addend == 0 || addend == l_value.limbs[i as int],\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n    ensures\n        (carry >> 52) + difference_limb + addend < (1u64 << 53),\n{\n    if i == 0 {\n        assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    } else if i == 1 {\n        assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n    } else if i == 2 {\n        assert(0x000000000014def9 < (1u64 << 52)) by (bit_vector);\n    } else if i == 3 {\n    } else {\n        assert(0x0000100000000000 < (1u64 << 52)) by (bit_vector);\n    }\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert(2 * (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "use zeroize::Zeroize;\n\nuse crate::constants;\n\nuse crate::field::FieldElement;\nuse crate::scalar::{clamp_integer, Scalar};\n",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn zeroize(&mut self) {\n        self.limbs.zeroize();\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_mul_le_implies_div_le().",
      "display_name": "lemma_mul_le_implies_div_le",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_mul_le_implies_div_le().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/div_mod_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn lemma_mul_le_implies_div_le(a: nat, b: nat, c: nat)\n    requires\n        b > 0,\n        a * b <= c,\n    ensures\n        a <= c / b,\n{\n    lemma_div_is_ordered((a * b) as int, c as int, b as int);\n    lemma_div_by_multiple(a as int, b as int);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/bot_half().",
      "display_name": "bot_half",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/bot_half().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "fn bot_half(x: u8) -> (result:\n    u8)/* <VERIFICATION NOTE>\n- PROOF BYPASS\n- Adjust the spec as needed for the proof of as_radix_16\n</VERIFICATION NOTE> */\n\n    ensures\n// Result is the lower 4 bits (lower nibble) of x\n\n        result == x % 16,\n        // Result is in range [0, 15]\n        result <= 15,\n{\n    let result = (x >> 0) & 15;\n    proof {\n        // VERIFICATION NOTE: PROOF BYPASS - bitvector reasoning for bit masking\n        assert((x >> 0) & 15 == x % 16) by (bit_vector);\n    }\n    result\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/reconstruct().",
      "display_name": "reconstruct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/reconstruct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//!\n//! assert_eq!(a, a2);\n//! # }\n//! ```\n//!\n//! See also `Scalar::hash_from_bytes` and `Scalar::from_hash` that\n//! reduces a \\\\(512\\\\)-bit integer, if the optional `digest` feature\n//! has been enabled.\n\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::{Product, Sum};\nuse core::ops::Index;",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_sqrt_ratio_times_i().",
      "display_name": "is_sqrt_ratio_times_i",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_sqrt_ratio_times_i().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "        let t14 = t13.pow2k(50);  // 99..50\n        let t15 = &t14 * &t13;  // 99..0\n        let t16 = t15.pow2k(100);  // 199..100\n        let t17 = &t16 * &t15;  // 199..0\n        let t18 = t17.pow2k(50);  // 249..50\n        let t19 = &t18 * &t13;  // 249..0\n\n        (t19, t3)\n    }\n\n    /// Given a slice of pub(crate)lic `FieldElements`, replace each with its inverse.\n    ///\n    /// When an input `FieldElement` is zero, its value is unchanged.\n    #[cfg(feature = \"alloc\")]\n    pub(crate) fn batch_invert(\n        inputs: &mut [FieldElement],\n    )/* <VERIFICATION NOTE>\n     - Refactored for Verus: Index loops instead of iterators, manual Vec construction\n     - Choice type operations handled by wrappers in subtle_assumes.rs\n     - PROOF BYPASSES because of trait issues and proof obligations.\n    </VERIFICATION NOTE> */\n\n        ensures\n    // Each element is replaced appropriately:\n\n            forall|i: int|\n                #![auto]\n                0 <= i < inputs.len() ==> {\n                    // If input was non-zero, it's replaced with its inverse\n                    (field_element_as_nat(&old(inputs)[i]) != 0) ==> is_inverse_field(\n                        &old(inputs)[i],\n                        &inputs[i],\n                    ) &&\n                    // If input was zero, it remains zero\n                    (field_element_as_nat(&old(inputs)[i]) == 0) ==> field_element_as_nat(\n                        &inputs[i],\n                    ) == 0\n                },",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_q_arr().",
      "display_name": "compute_q_arr",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_q_arr().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/as_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/as_bytes_lemmas.rs",
      "file_name": "as_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "    assert(l3 >> 51 <= 2) by {\n        lemma_shr_le_u64(l3, ((1u64 << 52) + 2) as u64, 51);\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "display_name": "lemma_mod_multiples_basic",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/negate_lemmas.rs",
      "file_name": "negate_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MultiscalarMul#multiscalar_mul().",
      "display_name": "multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MultiscalarMul#multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "/// use curve25519_dalek::scalar::Scalar;\n///\n/// let a = Scalar::from(87329482u64);\n/// let P = &a * RISTRETTO_BASEPOINT_TABLE;\n/// ```\n#[cfg(feature = \"precomputed-tables\")]\n#[derive(Clone)]\n#[repr(transparent)]\npub struct RistrettoBasepointTable(pub(crate) EdwardsBasepointTable);\n\n#[cfg(feature = \"precomputed-tables\")]\nimpl<'a, 'b> Mul<&'b Scalar> for &'a RistrettoBasepointTable {\n    type Output = RistrettoPoint;\n\n    fn mul(self, scalar: &'b Scalar) -> RistrettoPoint {\n        RistrettoPoint(&self.0 * scalar)\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/words_to_nat_gen_u32().",
      "display_name": "words_to_nat_gen_u32",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/words_to_nat_gen_u32().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
      "relative_path": "src/backend/serial/u64/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "u64",
      "body": "pub open spec fn words_to_nat_gen_u32(words: &[u32], num_words: int, bits_per_word: int) -> nat\n    decreases num_words,\n{\n    if num_words <= 0 {\n        0\n    } else {\n        let word_value = (words[num_words - 1] as nat) * pow2(\n            ((num_words - 1) * bits_per_word) as nat,\n        );\n        word_value + words_to_nat_gen_u32(words, num_words - 1, bits_per_word)\n    }\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#PartialEq#eq().",
      "display_name": "eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#PartialEq#eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn eq(&self, other: &MontgomeryPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/copy_from_slice().",
      "display_name": "copy_from_slice",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/copy_from_slice().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#as_bytes().",
      "display_name": "as_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#as_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select_u8().",
      "display_name": "select_u8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select_u8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Option<Scalar> = Scalar::from_canonical_bytes(l_plus_two_bytes).into();\n//!\n//! assert!(a.is_none());\n//! ```\n//!\n//! Another way to create a `Scalar` is by reducing a \\\\(256\\\\)-bit integer mod\n//! \\\\( \\ell \\\\), for which one may use the\n//! [`Scalar::from_bytes_mod_order`](struct.Scalar.html#method.from_bytes_mod_order)\n//! method.  In the case of the second example above, this would reduce the\n//! resultant scalar \\\\( \\mod \\ell \\\\), producing \\\\( 2 \\\\):\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let l_plus_two_bytes: [u8; 32] = [\n//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Scalar = Scalar::from_bytes_mod_order(l_plus_two_bytes);\n//!\n//! let two: Scalar = Scalar::ONE + Scalar::ONE;\n//!\n//! assert!(a == two);\n//! ```\n//!\n//! There is also a constructor that reduces a \\\\(512\\\\)-bit integer,\n//! [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! To construct a `Scalar` as the hash of some input data, use\n//! [`Scalar::hash_from_bytes`], which takes a buffer, or\n//! [`Scalar::from_hash`], which allows an IUF API.\n//!\n#![cfg_attr(feature = \"digest\", doc = \"```\")]\n#![cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n//! # fn main() {\n//! use sha2::{Digest, Sha512};\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! // Hashing a single byte slice\n//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Sum#sum().",
      "display_name": "sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Sum#sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn sum<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }/* <MODIFIED CODE> - if needed in for verification in the future",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/rec_version_is_exec().",
      "display_name": "rec_version_is_exec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/rec_version_is_exec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\n#[allow(unused_imports)]\nuse vstd::bits::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::bit_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::div_mod_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mask_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mul_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::pow_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::shift_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_nat_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::compute_q_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::field_core::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::from_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::limbs_to_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::load8_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::negate_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2_51_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "display_name": "lemma_mul_is_distributive_add_other_way",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 14,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/top_half().",
      "display_name": "top_half",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/top_half().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "fn top_half(x: u8) -> (result:\n    u8)/* <VERIFICATION NOTE>\n- PROOF BYPASS\n- Adjust the spec as needed for the proof of as_radix_16\n</VERIFICATION NOTE> */\n\n    ensures\n// Result is the upper 4 bits (upper nibble) of x\n\n        result == x / 16,\n        // Result is in range [0, 15]\n        result <= 15,\n{\n    let result = (x >> 4) & 15;\n    proof {\n        // VERIFICATION NOTE: PROOF BYPASS - bitvector reasoning for bit masking\n        assert((x >> 4) & 15 == x / 16) by (bit_vector);\n    }\n    result\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "display_name": "step_1",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub(super) fn step_1(repr: &CompressedEdwardsY) -> (result: (\n        Choice,\n        FieldElement,\n        FieldElement,\n        FieldElement,\n    ))  // Result components: (is_valid, X, Y, Z)// VERIFICATION NOTE: PROOF BYPASSFORMATTER_NOT_INLINE_MARKER\n        ensures\n    // The returned Y field element matches the one extracted from the compressed representation\n\n            field_element(&result.2) == field_element_from_bytes(&repr.0),\n            // The returned Z field element is 1\n            field_element(&result.3) == 1,\n            // The choice is true iff the Y is valid and (X, Y) is on the curve\n            choice_is_true(result.0) <==> is_valid_y_coordinate(field_element(&result.2)),\n            choice_is_true(result.0) ==> on_edwards_curve(\n                field_element(&result.1),\n                field_element(&result.2),\n            ),\n    {\n        let Y = FieldElement::from_bytes(repr.as_bytes());\n        assert(field_element_from_bytes(&repr.0) == field_element(&Y));\n        let Z = FieldElement::ONE;\n        proof {\n            assume(forall|i: int| 0 <= i < 5 ==> Y.limbs[i] < 1u64 << 54);\n        }\n        let YY = Y.square();\n\n        /* <VERIFICATION NOTE>\n        Assume preconditions for field operations with *SpecImpl traits.\n        </VERIFICATION NOTE> */\n        proof {\n            // For Sub (YY - Z): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> YY.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> Z.limbs[i] < (1u64 << 54));\n\n            // For Mul (YY * EDWARDS_D): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> constants::EDWARDS_D.limbs[i] < (1u64 << 54));\n        }\n        let u = &YY - &Z;  // u =  y²-1\n        let yy_times_d = &YY * &constants::EDWARDS_D;\n        proof {\n            // For Add (yy_times_d + Z): requires no overflow\n            assume(forall|i: int|\n                0 <= i < 5 ==> #[trigger] (yy_times_d.limbs[i] + Z.limbs[i]) <= u64::MAX);\n        }\n        let v = &yy_times_d + &Z;  // v = dy²+1\n\n        let (is_valid_y_coord, X) = FieldElement::sqrt_ratio_i(&u, &v);\n\n        proof {\n            // Assume postconditions that depend on sqrt_ratio_i behavior\n            assume(field_element(&Z) == 1);\n            // Note: Using <==> (bi-implication) to match the postcondition exactly\n            assume(choice_is_true(is_valid_y_coord) <==> is_valid_y_coordinate(field_element(&Y)));\n            assume(choice_is_true(is_valid_y_coord) ==> on_edwards_curve(\n                field_element(&X),\n                field_element(&Y),\n            ));\n        }\n        (is_valid_y_coord, X, Y, Z)\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn identity() -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::identity())\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/main().",
      "display_name": "main",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/main().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "fn main() {\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_hash().",
      "display_name": "from_hash",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_hash().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn from_hash<D>(hash: D) -> RistrettoPoint\n    where\n        D: Digest<OutputSize = U64> + Default,\n    {\n        // dealing with generic arrays is clumsy, until const generics land\n        let output = hash.finalize();\n        let mut output_bytes = [0u8; 64];\n        output_bytes.copy_from_slice(output.as_slice());\n\n        RistrettoPoint::from_uniform_bytes(&output_bytes)\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "display_name": "is_zero",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "use core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_to_le_bytes().",
      "display_name": "u128_to_le_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_to_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }\n//! ```\n//!\n//! See also `Scalar::hash_from_bytes` and `Scalar::from_hash` that\n//! reduces a \\\\(512\\\\)-bit integer, if the optional `digest` feature\n//! has been enabled.\n\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::{Product, Sum};\nuse core::ops::Index;",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_equality_converse().",
      "display_name": "lemma_mul_equality_converse",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_equality_converse().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_verus",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_five_limbs_equals_to_nat().",
      "display_name": "lemma_five_limbs_equals_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_five_limbs_equals_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    /// a canonical representative of an element of \\\\( \\mathbb Z / \\ell\\mathbb Z \\\\). This is\n    /// stronger than invariant #1. It also sometimes has to be broken.\n    ///\n    /// This invariant is deliberately broken in the implementation of `EdwardsPoint::{mul_clamped,\n    /// mul_base_clamped}`, `MontgomeryPoint::{mul_clamped, mul_base_clamped}`, and",
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/as_nat_32_mod_255().",
      "display_name": "as_nat_32_mod_255",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/as_nat_32_mod_255().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_or_version_rec().",
      "display_name": "load8_at_or_version_rec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_or_version_rec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn load8_at_or_version_rec(input: &[u8], i: usize, k: nat) -> u64\n    decreases k,\n{\n    if (k == 0) {\n        (input[i as int] as u64)\n    } else {\n        // k > 0\n        load8_at_or_version_rec(input, i, (k - 1) as nat) | ((input[i + k] as u64) << k * 8)\n    }\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_from_limb_shift().",
      "display_name": "lemma_byte_from_limb_shift",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_from_limb_shift().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_byte_from_limb_shift(limb: u64, shift: u64, byte: u8)\n    requires\n        limb < pow2(51),\n        shift < 64,\n        byte == (limb >> shift) as u8,\n    ensures\n        byte as nat == (limb as nat / pow2(shift as nat)) % 256,\n{\n    // Bitwise shift to arithmetic conversion\n    // When we shift right by `shift` bits and cast to u8, we extract 8 bits starting at position `shift`\n    // In arithmetic terms: (limb / 2^shift) % 256\n    lemma2_to64();\n    lemma_u64_shr_is_div(limb, shift);\n    assert((limb >> shift) as nat == limb as nat / pow2(shift as nat));\n\n    // The u8 cast takes the low 8 bits, which is % 256\n    assert((limb >> shift) as u8 == (limb >> shift) as nat % 256) by {\n        lemma_u8_cast_is_mod_256(limb >> shift);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "display_name": "lemma_limb3_contribution_correctness",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_limb3_contribution_correctness(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[2] < pow2(51),  // Need limb 2 for boundary byte 19\n        limbs[3] < pow2(51),\n        bytes_match_limbs_packing(limbs, bytes),\n    ensures\n        limb3_byte_contribution(limbs, bytes) == limbs[3] as nat * pow2(153),\n{\n    // Limb 3 stored in bytes 19-25, positioned at 2^153\n    // - Byte 19 (high 7 bits): limbs[3]'s bits 0-6\n    // - Bytes 20-24: limbs[3]'s bits 7-46 (40 bits)\n    // - Byte 25 (low 4 bits): limbs[3]'s bits 47-50\n    // Total: 7 + 40 + 4 = 51 bits\n    lemma2_to64();\n    lemma_pow2_adds(152, 1);  // 2^153 = 2^152 * 2\n\n    // Stabilization placeholders\n    assert(pow2(0) == pow2(0 * 8));\n    assert(pow2(8) == pow2(1 * 8));\n    assert(pow2(16) == pow2(2 * 8));\n    assert(pow2(24) == pow2(3 * 8));\n    assert(pow2(32) == pow2(4 * 8));\n\n    // KEY INSIGHT: From bytes_match_limbs_packing:\n    // bytes[20] = (limbs[3] >> 7) as u8\n    // bytes[21] = (limbs[3] >> 15) as u8\n    // ... and so on\n    //\n    // So limb3_byte_contribution is:\n    //   (limbs[3] % 2^7) * 2 * 2^152 +              // Low 7 bits at position 2^153\n    //   (limbs[3] >> 7 ... >> 39) * positions +     // Middle 40 bits at position 2^160\n    //   (limbs[3] / 2^47) % 2^4 * 2^200             // High 4 bits at position 2^200\n    //\n    // This is limbs[3] * 2^153!\n\n    // Step 1: Extract arithmetic values for bytes 20-24\n    // These bytes come from limbs[3] >> 7, 15, 23, 31, 39\n    lemma_byte_from_limb_shift(limbs[3], 7, bytes[20]);\n\n    lemma_byte_from_limb_shift(limbs[3], 15, bytes[21]);\n\n    lemma_byte_from_limb_shift(limbs[3], 23, bytes[22]);\n\n    lemma_byte_from_limb_shift(limbs[3], 31, bytes[23]);\n\n    lemma_byte_from_limb_shift(limbs[3], 39, bytes[24]);\n\n    // Step 2: Prove that bytes[20-24] reconstruct ((limbs[3] / 2^7) % 2^40) at position 2^160\n    //\n    // From lemma_byte_from_limb_shift, we have:\n    // bytes[20] as nat == (limbs[3] / pow2(7)) % 256\n    // bytes[21] as nat == (limbs[3] / pow2(15)) % 256\n    // bytes[22] as nat == (limbs[3] / pow2(23)) % 256\n    // bytes[23] as nat == (limbs[3] / pow2(31)) % 256\n    // bytes[24] as nat == (limbs[3] / pow2(39)) % 256\n    //\n    // The key insight: these bytes extract consecutive 8-bit chunks from (limbs[3] / 2^7)\n\n    // First, rewrite the byte extractions in terms of (limbs[3] / 2^7)\n    // bytes[20] == (limbs[3] / 2^7) / 2^0 % 256\n    lemma_pow2_adds(0, 7);\n    lemma_div_denominator(limbs[3] as int, pow2(7) as int, pow2(0) as int);\n    assert(bytes[20] as nat == (limbs[3] as nat / pow2(7)) / pow2(0) % 256);\n\n    // bytes[21] == (limbs[3] / 2^15) % 256 == (limbs[3] / 2^7) / 2^8 % 256\n    lemma_pow2_adds(7, 8);\n    lemma_div_denominator(limbs[3] as int, pow2(7) as int, pow2(8) as int);\n    assert(limbs[3] as nat / pow2(15) == (limbs[3] as nat / pow2(7)) / pow2(8));\n    assert(bytes[21] as nat == (limbs[3] as nat / pow2(7)) / pow2(8) % 256);\n\n    // bytes[22] == (limbs[3] / 2^23) % 256 == (limbs[3] / 2^7) / 2^16 % 256\n    lemma_pow2_adds(7, 16);\n    assert(pow2(7) * pow2(16) == pow2(23));\n    lemma_div_denominator(limbs[3] as int, pow2(7) as int, pow2(16) as int);\n    assert(limbs[3] as nat / pow2(23) == (limbs[3] as nat / pow2(7)) / pow2(16));\n\n    // bytes[23] == (limbs[3] / 2^31) % 256 == (limbs[3] / 2^7) / 2^24 % 256\n    lemma_pow2_adds(7, 24);\n    lemma_div_denominator(limbs[3] as int, pow2(7) as int, pow2(24) as int);\n\n    // bytes[24] == (limbs[3] / 2^39) % 256 == (limbs[3] / 2^7) / 2^32 % 256\n    lemma_pow2_adds(7, 32);\n    lemma_pow2_pos(32);\n    lemma_div_denominator(limbs[3] as int, pow2(7) as int, pow2(32) as int);\n    assert(limbs[3] as nat / pow2(39) == (limbs[3] as nat / pow2(7)) / pow2(32));\n    assert(bytes[24] as nat == (limbs[3] as nat / pow2(7)) / pow2(32) % 256);\n\n    // Now handle the % 2^40 truncation\n    // Since limbs[3] < 2^51, we have limbs[3] / 2^7 < 2^44\n    lemma_div_bound(limbs[3] as nat, 7, 51);\n\n    // The bytes extract bits at positions [0..8), [8..16), [16..24), [24..32), [32..40)\n    // from (limbs[3] / 2^7). Since all these bit positions are < 40, taking % 2^40\n    // doesn't change the extracted bytes (same argument as limbs 1 & 2).\n\n    let middle_value = (limbs[3] as nat / pow2(7)) % pow2(40);\n\n    // Prove middle_value < 2^40 (trivial by definition of %)\n    lemma_pow2_pos(40);\n    lemma_mod_bound(middle_value as int, pow2(40) as int);\n\n    // Now prove that the bytes extract from middle_value\n    let v = limbs[3] as nat / pow2(7);\n    assert(bytes[23] as nat == v / pow2(24) % 256);\n    assert(bytes[24] as nat == v / pow2(32) % 256);\n\n    // Use lemma_byte_extraction_commutes_with_mod to show extraction commutes with % 2^40\n    // For byte at position k, we need k*8 + 8 <= 40\n    lemma_byte_extraction_commutes_with_mod(v, 0, 40);  // 0*8 + 8 = 8 <= 40 ✓\n    assert(bytes[20] as nat == (middle_value / pow2(0)) % 256);\n\n    lemma_byte_extraction_commutes_with_mod(v, 1, 40);  // 1*8 + 8 = 16 <= 40 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 2, 40);  // 2*8 + 8 = 24 <= 40 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 3, 40);  // 3*8 + 8 = 32 <= 40 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 4, 40);  // 4*8 + 8 = 40 <= 40 ✓\n\n    // Now apply lemma_5_bytes_reconstruct\n    lemma_5_bytes_reconstruct(middle_value, bytes[20], bytes[21], bytes[22], bytes[23], bytes[24]);\n\n    // This gives us:\n    assert(bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8) + bytes[22] as nat * pow2(16)\n        + bytes[23] as nat * pow2(24) + bytes[24] as nat * pow2(32) == middle_value);\n\n    // Now multiply both sides by 2^160 to get the bytes at their actual positions\n    lemma_mul_is_distributive_add(\n        pow2(160) as int,\n        (bytes[20] as nat * pow2(0)) as int,\n        (bytes[21] as nat * pow2(8)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(160) as int,\n        (bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8)) as int,\n        (bytes[22] as nat * pow2(16)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(160) as int,\n        (bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8) + bytes[22] as nat * pow2(\n            16,\n        )) as int,\n        (bytes[23] as nat * pow2(24)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(160) as int,\n        (bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8) + bytes[22] as nat * pow2(16)\n            + bytes[23] as nat * pow2(24)) as int,\n        (bytes[24] as nat * pow2(32)) as int,\n    );\n\n    // Distribute the multiplication into each term\n    lemma_mul_is_associative(bytes[20] as int, pow2(0) as int, pow2(160) as int);\n    lemma_mul_is_associative(bytes[21] as int, pow2(8) as int, pow2(160) as int);\n    lemma_mul_is_associative(bytes[22] as int, pow2(16) as int, pow2(160) as int);\n    lemma_mul_is_associative(bytes[23] as int, pow2(24) as int, pow2(160) as int);\n    lemma_mul_is_associative(bytes[24] as int, pow2(32) as int, pow2(160) as int);\n\n    // Simplify using pow2 addition: 2^160 * 2^k = 2^(160+k)\n    lemma_pow2_adds(160, 0);\n\n    lemma_pow2_adds(160, 8);\n\n    lemma_pow2_adds(160, 16);\n    assert(pow2(160) * pow2(16) == pow2(176));\n\n    lemma_pow2_adds(160, 24);\n\n    lemma_pow2_adds(160, 32);\n\n    // Final result\n    assert(bytes[20] as nat * pow2(20 * 8) + bytes[21] as nat * pow2(21 * 8) + bytes[22] as nat\n        * pow2(22 * 8) + bytes[23] as nat * pow2(23 * 8) + bytes[24] as nat * pow2(24 * 8)\n        == middle_value * pow2(160));\n\n    // Step 3: Handle boundary bytes\n    // Low 7 bits (byte 19 high part): (limbs[3] % 2^7) * 2 * 2^152 = (limbs[3] % 2^7) * 2^153\n    // High 4 bits (byte 25 low part): (limbs[3] / 2^47) % 2^4 * 2^200\n\n    assert(2 * pow2(152) == pow2(153)) by {\n        lemma_pow2_adds(152, 1);\n    }\n\n    // From the proof above, we have:\n    let middle_bytes_sum = bytes[20] as nat * pow2(20 * 8) + bytes[21] as nat * pow2(21 * 8)\n        + bytes[22] as nat * pow2(22 * 8) + bytes[23] as nat * pow2(23 * 8) + bytes[24] as nat\n        * pow2(24 * 8);\n\n    let middle_value_at_position = ((limbs[3] as nat / pow2(7)) % pow2(40)) * pow2(160);\n\n    // Substitute into contribution\n    let contribution = limb3_byte_contribution(limbs, bytes);\n    assert(contribution == ((limbs[3] as nat % pow2(7)) * 2) * pow2(152) + middle_bytes_sum + ((\n    limbs[3] as nat / pow2(47)) % pow2(4)) * pow2(200));\n\n    assert(contribution == ((limbs[3] as nat % pow2(7)) * 2) * pow2(152) + middle_value_at_position\n        + ((limbs[3] as nat / pow2(47)) % pow2(4)) * pow2(200));\n\n    // Step 3: Prove the reconstruction identity for limbs[3]\n    // limbs[3] = (limbs[3] % 2^7) + ((limbs[3] / 2^7) % 2^40) * 2^7 + ((limbs[3] / 2^47) % 2^4) * 2^47\n\n    // First, reconstruct limbs[3] / 2^7 from its low 40 bits and high part\n    lemma_pow2_pos(40);\n    let shifted_value = limbs[3] as nat / pow2(7);\n    lemma_fundamental_div_mod(shifted_value as int, pow2(40) as int);\n    assert(pow2(40) * (shifted_value / pow2(40)) == (shifted_value / pow2(40)) * pow2(40)) by {\n        lemma_mul_is_commutative(pow2(40) as int, (shifted_value / pow2(40)) as int);\n    }\n\n    // Show that (limbs[3] / 2^7) / 2^40 = limbs[3] / 2^47\n    lemma_div_denominator(limbs[3] as int, pow2(7) as int, pow2(40) as int);\n    lemma_pow2_adds(7, 40);\n\n    // So: limbs[3] / 2^7 = ((limbs[3] / 2^7) % 2^40) + (limbs[3] / 2^47) * 2^40\n    assert(shifted_value == (shifted_value % pow2(40)) + (limbs[3] as nat / pow2(47)) * pow2(40));\n\n    // Next, reconstruct limbs[3] from its low 7 bits and (limbs[3] / 2^7)\n    lemma_pow2_pos(7);\n    lemma_fundamental_div_mod(limbs[3] as int, pow2(7) as int);\n    assert(pow2(7) * shifted_value == shifted_value * pow2(7)) by {\n        lemma_mul_is_commutative(pow2(7) as int, shifted_value as int);\n    }\n\n    // Substitute the reconstruction of shifted_value (limbs[3] / 2^7)\n    assert(limbs[3] as nat == (limbs[3] as nat % pow2(7)) + ((shifted_value % pow2(40)) + (\n    limbs[3] as nat / pow2(47)) * pow2(40)) * pow2(7));\n\n    // Distribute the * 2^7\n    assert(limbs[3] as nat == (limbs[3] as nat % pow2(7)) + (shifted_value % pow2(40)) * pow2(7) + (\n    limbs[3] as nat / pow2(47)) * pow2(40) * pow2(7)) by {\n        lemma_mul_is_distributive_add(\n            pow2(7) as int,\n            (shifted_value % pow2(40)) as int,\n            (limbs[3] as nat / pow2(47) * pow2(40)) as int,\n        );\n    }\n\n    // Use 2^40 * 2^7 = 2^47\n    lemma_pow2_adds(40, 7);\n    assert((limbs[3] as nat / pow2(47)) * pow2(40) * pow2(7) == (limbs[3] as nat / pow2(47)) * pow2(\n        47,\n    )) by {\n        lemma_mul_is_associative(\n            (limbs[3] as nat / pow2(47)) as int,\n            pow2(40) as int,\n            pow2(7) as int,\n        );\n    }\n\n    assert(limbs[3] as nat == (limbs[3] as nat % pow2(7)) + ((limbs[3] as nat / pow2(7)) % pow2(40))\n        * pow2(7) + (limbs[3] as nat / pow2(47)) * pow2(47));\n\n    // Handle the % 2^4 on the high bits\n    // Since limbs[3] < 2^51, we have limbs[3] / 2^47 < 2^4\n    lemma_div_bound(limbs[3] as nat, 47, 51);\n    lemma_small_mod(limbs[3] as nat / pow2(47), pow2(4));\n\n    // Therefore:\n    assert(limbs[3] as nat == (limbs[3] as nat % pow2(7)) + ((limbs[3] as nat / pow2(7)) % pow2(40))\n        * pow2(7) + ((limbs[3] as nat / pow2(47)) % pow2(4)) * pow2(47));\n\n    // Step 4: Now connect the contribution to limbs[3] * 2^153\n    // We have: contribution = ((limbs[3] % 2^7) * 2) * 2^152 + middle_value_at_position + ((limbs[3] / 2^47) % 2^4) * 2^200\n    // Where: middle_value_at_position = ((limbs[3] / 2^7) % 2^40) * 2^160\n\n    // First, simplify the low term: ((limbs[3] % 2^7) * 2) * 2^152 = (limbs[3] % 2^7) * (2 * 2^152) = (limbs[3] % 2^7) * 2^153\n    // We proved earlier that 2 * 2^152 = 2^153\n    let low_part = (limbs[3] as nat % pow2(7));\n    assert(((limbs[3] as nat % pow2(7)) * 2) * pow2(152) == low_part * (2 * pow2(152))) by {\n        lemma_mul_is_associative(low_part as int, 2, pow2(152) as int);\n    }\n\n    // So contribution = (limbs[3] % 2^7) * 2^153 + ((limbs[3] / 2^7) % 2^40) * 2^160 + ((limbs[3] / 2^47) % 2^4) * 2^200\n    assert(contribution == low_part * pow2(153) + ((limbs[3] as nat / pow2(7)) % pow2(40)) * pow2(\n        160,\n    ) + ((limbs[3] as nat / pow2(47)) % pow2(4)) * pow2(200));\n\n    // Rewrite using 2^160 = 2^153 * 2^7 and 2^200 = 2^153 * 2^47\n    lemma_pow2_adds(153, 7);\n    lemma_pow2_adds(153, 47);\n\n    assert(contribution == low_part * pow2(153) + ((limbs[3] as nat / pow2(7)) % pow2(40)) * (pow2(\n        153,\n    ) * pow2(7)) + ((limbs[3] as nat / pow2(47)) % pow2(4)) * (pow2(153) * pow2(47)));\n\n    // Apply associativity to move pow2(153) to the left\n    let middle_part = (limbs[3] as nat / pow2(7)) % pow2(40);\n    let high_part = (limbs[3] as nat / pow2(47)) % pow2(4);\n\n    assert(middle_part * (pow2(153) * pow2(7)) == (middle_part * pow2(153)) * pow2(7)) by {\n        lemma_mul_is_associative(middle_part as int, pow2(153) as int, pow2(7) as int);\n    }\n    assert((middle_part * pow2(153)) * pow2(7) == pow2(153) * middle_part * pow2(7)) by {\n        lemma_mul_is_commutative((middle_part * pow2(153)) as int, pow2(7) as int);\n    }\n    assert(pow2(153) * middle_part * pow2(7) == pow2(153) * (middle_part * pow2(7))) by {\n        lemma_mul_is_associative(pow2(153) as int, middle_part as int, pow2(7) as int);\n    }\n\n    assert(high_part * (pow2(153) * pow2(47)) == (high_part * pow2(153)) * pow2(47)) by {\n        lemma_mul_is_associative(high_part as int, pow2(153) as int, pow2(47) as int);\n    }\n    assert((high_part * pow2(153)) * pow2(47) == pow2(153) * high_part * pow2(47)) by {\n        lemma_mul_is_commutative((high_part * pow2(153)) as int, pow2(47) as int);\n    }\n    assert(pow2(153) * high_part * pow2(47) == pow2(153) * (high_part * pow2(47))) by {\n        lemma_mul_is_associative(pow2(153) as int, high_part as int, pow2(47) as int);\n    }\n\n    // Now factor out pow2(153)\n    assert(contribution == low_part * pow2(153) + pow2(153) * (middle_part * pow2(7)) + pow2(153)\n        * (high_part * pow2(47)));\n\n    // Use distributivity to factor out pow2(153)\n    assert(contribution == pow2(153) * (low_part + middle_part * pow2(7) + high_part * pow2(47)))\n        by {\n        lemma_mul_is_distributive_add(\n            pow2(153) as int,\n            low_part as int,\n            (middle_part * pow2(7)) as int,\n        );\n        lemma_mul_is_distributive_add(\n            pow2(153) as int,\n            (low_part + middle_part * pow2(7)) as int,\n            (high_part * pow2(47)) as int,\n        );\n    }\n\n    // The part in parentheses equals limbs[3] by our reconstruction identity!\n    assert(contribution == limbs[3] as nat * pow2(153)) by {\n        lemma_mul_is_commutative(pow2(153) as int, limbs[3] as int);\n    }\n\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 17
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#basepoint().",
      "display_name": "basepoint",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#basepoint().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core impls/cmp/Ord#cmp().",
      "display_name": "cmp",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core impls/cmp/Ord#cmp().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs",
      "relative_path": "src/backend/serial/scalar_mul/vartime_double_base.rs",
      "file_name": "vartime_double_base.rs",
      "parent_folder": "scalar_mul",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        writeln!(f, \"NafLookupTable8([\")?;\n        for i in 0..64 {\n            writeln!(f, \"\\t{:?},\", &self.0[i])?;\n        }\n        write!(f, \"])\")\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>;\n\n    /// Given `static_scalars`, an iterator of public scalars\n    /// \\\\(b_i\\\\), compute\n    /// $$\n    /// Q = b_1 B_1 + \\cdots + b_m B_m,\n    /// $$\n    /// where the \\\\(B_j\\\\) are the points that were supplied to `new`.\n    ///\n    /// It is an error to call this function with iterators of\n    /// inconsistent lengths.\n    ///\n    /// The trait bound aims for maximum flexibility: the input must\n    /// be convertible to iterators (`I: IntoIter`), and the\n    /// iterator's items must be `Borrow<Scalar>`, to allow iterators\n    /// returning either `Scalar`s or `&Scalar`s.\n    fn vartime_multiscalar_mul<I>(&self, static_scalars: I) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n    {\n        use core::iter;\n\n        Self::vartime_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            iter::empty::<Scalar>(),\n            iter::empty::<Self::Point>(),\n        )\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn default() -> AffineNielsPoint {\n        AffineNielsPoint::identity()\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Product#product().",
      "display_name": "product",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Product#product().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn product<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified product_of_slice function\n        Scalar::product_of_slice(&scalars)\n    }  /* </MODIFIED CODE> */",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/differential_add_and_double().",
      "display_name": "differential_add_and_double",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/differential_add_and_double().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "fn differential_add_and_double(\n    P: &mut ProjectivePoint,\n    Q: &mut ProjectivePoint,\n    affine_PmQ: &FieldElement,\n) {\n    let t0 = &P.U + &P.W;\n    let t1 = &P.U - &P.W;\n    let t2 = &Q.U + &Q.W;\n    let t3 = &Q.U - &Q.W;\n\n    let t4 = t0.square();   // (U_P + W_P)^2 = U_P^2 + 2 U_P W_P + W_P^2\n    let t5 = t1.square();   // (U_P - W_P)^2 = U_P^2 - 2 U_P W_P + W_P^2\n\n    let t6 = &t4 - &t5;     // 4 U_P W_P\n\n    let t7 = &t0 * &t3;     // (U_P + W_P) (U_Q - W_Q) = U_P U_Q + W_P U_Q - U_P W_Q - W_P W_Q\n    let t8 = &t1 * &t2;     // (U_P - W_P) (U_Q + W_Q) = U_P U_Q - W_P U_Q + U_P W_Q - W_P W_Q\n\n    let t9  = &t7 + &t8;    // 2 (U_P U_Q - W_P W_Q)\n    let t10 = &t7 - &t8;    // 2 (W_P U_Q - U_P W_Q)\n\n    let t11 =  t9.square(); // 4 (U_P U_Q - W_P W_Q)^2\n    let t12 = t10.square(); // 4 (W_P U_Q - U_P W_Q)^2\n\n    let t13 = &APLUS2_OVER_FOUR * &t6; // (A + 2) U_P U_Q\n\n    let t14 = &t4 * &t5;    // ((U_P + W_P)(U_P - W_P))^2 = (U_P^2 - W_P^2)^2\n    let t15 = &t13 + &t5;   // (U_P - W_P)^2 + (A + 2) U_P W_P\n\n    let t16 = &t6 * &t15;   // 4 (U_P W_P) ((U_P - W_P)^2 + (A + 2) U_P W_P)\n\n    let t17 = affine_PmQ * &t12; // U_D * 4 (W_P U_Q - U_P W_Q)^2\n    let t18 = t11;               // W_D * 4 (U_P U_Q - W_P W_Q)^2\n\n    P.U = t14;  // U_{P'} = (U_P + W_P)^2 (U_P - W_P)^2\n    P.W = t16;  // W_{P'} = (4 U_P W_P) ((U_P - W_P)^2 + ((A + 2)/4) 4 U_P W_P)\n    Q.U = t18;  // U_{Q'} = W_D * 4 (U_P U_Q - W_P W_Q)^2\n    Q.W = t17;  // W_{Q'} = U_D * 4 (W_P U_Q - U_P W_Q)^2\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "display_name": "ct_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "//!\n//! * an implementation of the\n//! [`VartimeMultiscalarMul`](../traits/trait.VartimeMultiscalarMul.html)\n//! trait for variable-time variable-base multiscalar multiplication;\n//!\n//! ## Random Points and Hashing to Ristretto\n//!\n//! The Ristretto group comes equipped with an Elligator map.  This is\n//! used to implement\n//!\n//! * `RistrettoPoint::random()`, which generates random points from an\n//! RNG - enabled by `rand_core` feature;\n//!\n//! * `RistrettoPoint::from_hash()` and\n//! `RistrettoPoint::hash_from_bytes()`, which perform hashing to the\n//! group.\n//!\n//! The Elligator map itself is not currently exposed.\n//!\n//! ## Implementation\n//!\n//! The Decaf suggestion is to use a quotient group, such as \\\\(\\mathcal\n//! E / \\mathcal E\\[4\\]\\\\) or \\\\(2 \\mathcal E / \\mathcal E\\[2\\] \\\\), to\n//! implement a prime-order group using a non-prime-order curve.\n//!\n//! This requires only changing\n//!\n//! 1. the function for equality checking (so that two representatives\n//!    of the same coset are considered equal);\n//! 2. the function for encoding (so that two representatives of the\n//!    same coset are encoded as identical bitstrings);\n//! 3. the function for decoding (so that only the canonical encoding of\n//!    a coset is accepted).\n//!\n//! Internally, each coset is represented by a curve point; two points\n//! \\\\( P, Q \\\\) may represent the same coset in the same way that two\n//! points with different \\\\(X,Y,Z\\\\) coordinates may represent the\n//! same point.  The group operations are carried out with no overhead\n//! using Edwards formulas.\n//!\n//! Notes on the details of the encoding can be found in the\n//! [Details][ristretto_notes] section of the Ristretto website.\n//!\n//! [cryptonote]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000898.html\n//! [ed25519_hkd]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000858.html\n//! [ristretto_coffee]:\n//! https://en.wikipedia.org/wiki/Ristretto\n//! [ristretto_notes]:\n//! https://ristretto.group/details/index.html\n//! [why_ristretto]:\n//! https://ristretto.group/why_ristretto.html\n//! [ristretto_main]:\n//! https://ristretto.group/\n\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\n\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};",
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Neg#neg().",
      "display_name": "neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Neg#neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn neg(self) -> RistrettoPoint {\n        -&self\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "display_name": "compress",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn compress(&self) -> CompressedEdwardsY {\n        let recip = self.Z.invert();\n        let ghost z_abs = field_element(&self.Z);\n        assert(field_element(&recip) == field_inv(z_abs));\n        assume(false);\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        let mut s: [u8; 32];\n\n        s = y.as_bytes();\n        s[31] ^= x.is_negative().unwrap_u8() << 7;\n        CompressedEdwardsY(s)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "display_name": "field_element",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/curve_specs.rs",
      "relative_path": "src/curve_specs.rs",
      "file_name": "curve_specs.rs",
      "parent_folder": "src",
      "body": "/// Spec: The identity point in affine coordinates (0, 1)\npub open spec fn edwards_identity_affine() -> (nat, nat) {\n    (0, 1)\n}",
      "is_libsignal": false,
      "caller_count": 19,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#expect().",
      "display_name": "expect",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#expect().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#AddAssign#add_assign().",
      "display_name": "add_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#AddAssign#add_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn add_assign(&mut self, _rhs: &'b EdwardsPoint) {\n        *self = (self as &EdwardsPoint) + _rhs;\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_select().",
      "display_name": "conditional_select",
      "symbol": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_add_multiples_vanish().",
      "display_name": "lemma_mod_add_multiples_vanish",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_add_multiples_vanish().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#MulAssign#mul_assign().",
      "display_name": "mul_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#MulAssign#mul_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_8_terms().",
      "display_name": "mul_8_terms",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_8_terms().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "    }\n}\n\npub proof fn from_bytes_as_nat_012(bytes: &[u8; 32])\n    ensures\n        (load8_at_spec(bytes, 0) as u64 & mask51) + pow2(51) * ((load8_at_spec(bytes, 6) as u64\n            >> 3) & mask51) + pow2(102) * ((load8_at_spec(bytes, 12) as u64 >> 6) & mask51) == (\n        bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (bytes[2] * pow2(2 * 8)) + (bytes[3]\n            * pow2(3 * 8)) + (bytes[4] * pow2(4 * 8)) + (bytes[5] * pow2(5 * 8)) + (bytes[6] * pow2(\n            6 * 8,\n        )) + (bytes[7] * pow2(7 * 8)) + (bytes[8] * pow2(8 * 8)) + (bytes[9] * pow2(9 * 8)) + (\n        bytes[10] * pow2(10 * 8)) + (bytes[11] * pow2(11 * 8)) + (bytes[12] * pow2(12 * 8)) + (\n        bytes[13] * pow2(13 * 8)) + (bytes[14] * pow2(14 * 8)) + (bytes[15] * pow2(15 * 8)) + (\n        bytes[16] * pow2(16 * 8)) + (bytes[17] * pow2(17 * 8)) + (bytes[18] * pow2(18 * 8)) + ((\n        bytes[19] as nat % pow2(1)) * pow2((19 * 8) as nat)),\n{\n    assert((load8_at_spec(bytes, 0) as u64 & mask51) + pow2(51) * ((load8_at_spec(bytes, 6) as u64\n        >> 3) & mask51) == (bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (bytes[2] * pow2(\n        2 * 8,\n    )) + (bytes[3] * pow2(3 * 8)) + (bytes[4] * pow2(4 * 8)) + (bytes[5] * pow2(5 * 8)) + (bytes[6]\n        * pow2(6 * 8)) + (bytes[7] * pow2(7 * 8)) + (bytes[8] * pow2(8 * 8)) + (bytes[9] * pow2(\n        9 * 8,\n    )) + (bytes[10] * pow2(10 * 8)) + (bytes[11] * pow2(11 * 8)) + ((bytes[12] as nat % pow2(6))\n        * pow2((12 * 8) as nat))) by {\n        from_bytes_as_nat_01(bytes);\n    }\n\n    assert(((load8_at_spec(bytes, 12) as u64) >> 6) & mask51 == (bytes[12] as nat / pow2(6)) + (\n    bytes[13] * pow2((1 * 8 - 6) as nat)) + (bytes[14] * pow2((2 * 8 - 6) as nat)) + (bytes[15]\n        * pow2((3 * 8 - 6) as nat)) + (bytes[16] * pow2((4 * 8 - 6) as nat)) + (bytes[17] * pow2(\n        (5 * 8 - 6) as nat,\n    )) + (bytes[18] * pow2((6 * 8 - 6) as nat)) + ((bytes[19] as nat % pow2(1)) * pow2(\n        (7 * 8 - 6) as nat,\n    ))) by {\n        load8_limb2(bytes);\n    }\n\n    assert(pow2(102) * ((load8_at_spec(bytes, 12) as u64 >> 6) & mask51) == pow2(102) * (\n    bytes[12] as nat / pow2(6)) + pow2(102) * (bytes[13] * pow2((1 * 8 - 6) as nat)) + pow2(102) * (\n    bytes[14] * pow2((2 * 8 - 6) as nat)) + pow2(102) * (bytes[15] * pow2((3 * 8 - 6) as nat))\n        + pow2(102) * (bytes[16] * pow2((4 * 8 - 6) as nat)) + pow2(102) * (bytes[17] * pow2(\n        (5 * 8 - 6) as nat,\n    )) + pow2(102) * (bytes[18] * pow2((6 * 8 - 6) as nat)) + pow2(102) * ((bytes[19] as nat % pow2(\n        1,\n    )) * pow2((7 * 8 - 6) as nat))) by {\n        mul_8_terms(\n            pow2(102) as int,\n            (bytes[12] as nat / pow2(6)) as int,\n            (bytes[13] * pow2((1 * 8 - 6) as nat)) as int,\n            (bytes[14] * pow2((2 * 8 - 6) as nat)) as int,\n            (bytes[15] * pow2((3 * 8 - 6) as nat)) as int,\n            (bytes[16] * pow2((4 * 8 - 6) as nat)) as int,\n            (bytes[17] * pow2((5 * 8 - 6) as nat)) as int,\n            (bytes[18] * pow2((6 * 8 - 6) as nat)) as int,\n            ((bytes[19] as nat % pow2(1)) * pow2((7 * 8 - 6) as nat)) as int,\n        );\n    }\n\n    assert(((bytes[12] as nat % pow2(6)) * pow2((12 * 8) as nat)) + pow2(102) * (bytes[12] as nat\n        / pow2(6)) == bytes[12] * pow2(12 * 8)) by {\n        assemble_mod_div(bytes[12] as nat, 6, 12 * 8);\n    }\n\n    assert(pow2(102) * (bytes[13] * pow2((1 * 8 - 6) as nat)) + pow2(102) * (bytes[14] * pow2(\n        (2 * 8 - 6) as nat,\n    )) + pow2(102) * (bytes[15] * pow2((3 * 8 - 6) as nat)) + pow2(102) * (bytes[16] * pow2(\n        (4 * 8 - 6) as nat,\n    )) + pow2(102) * (bytes[17] * pow2((5 * 8 - 6) as nat)) + pow2(102) * (bytes[18] * pow2(\n        (6 * 8 - 6) as nat,\n    )) + pow2(102) * ((bytes[19] as nat % pow2(1)) * pow2((7 * 8 - 6) as nat)) == (bytes[13] * pow2(\n        13 * 8,\n    )) + (bytes[14] * pow2(14 * 8)) + (bytes[15] * pow2(15 * 8)) + (bytes[16] * pow2(16 * 8)) + (\n    bytes[17] * pow2(17 * 8)) + (bytes[18] * pow2(18 * 8)) + ((bytes[19] as nat % pow2(1)) * pow2(\n        (19 * 8) as nat,\n    ))) by {\n        assemble_pow_a_pow(bytes[13] as nat, 12, 1, 6);\n        assemble_pow_a_pow(bytes[14] as nat, 12, 2, 6);\n        assemble_pow_a_pow(bytes[15] as nat, 12, 3, 6);\n        assemble_pow_a_pow(bytes[16] as nat, 12, 4, 6);\n        assemble_pow_a_pow(bytes[17] as nat, 12, 5, 6);\n        assemble_pow_a_pow(bytes[18] as nat, 12, 6, 6);\n        assemble_pow_a_pow(bytes[19] as nat % pow2(1), 12, 7, 6);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "display_name": "from_montgomery",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn sum<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }/* <MODIFIED CODE> - if needed in for verification in the future",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_has_value().",
      "display_name": "ct_option_has_value",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_has_value().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "use group::ff::{FieldBits, PrimeFieldBits};\n",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_pow_a_pow().",
      "display_name": "assemble_pow_a_pow",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_pow_a_pow().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn assemble_pow_a_pow(a: nat, j: nat, k: nat, l: nat)\n    requires\n        k * 8 > l,\n    ensures\n        pow2(j * 8 + l) * (a * pow2((k * 8 - l) as nat)) == a * pow2((j + k) * 8),\n{\n    let d = (k * 8 - l) as nat;\n    let dd = j * 8 + l;\n    let pjl = pow2(j * 8 + l);\n\n    assert(pjl * (a * pow2(d)) == (a * pow2(d)) * pjl) by {\n        lemma_mul_is_commutative(pjl as int, a * pow2(d) as int);\n    }\n\n    assert((a * pow2(d)) * pjl == a * pow2(d + dd)) by {\n        lemma_mul_is_associative(a as int, pow2(d) as int, pjl as int);\n        lemma_pow2_adds(d, dd);\n    }\n\n    assert(d + dd == (j + k) * 8) by {\n        assert((j + k) * 8 == j * 8 + k * 8) by {\n            lemma_mul_is_distributive_add_other_way(8, d as int, dd as int);\n        }\n    }\n}",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_some().",
      "display_name": "ct_option_is_some",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_some().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn ct_option_is_some<T>(opt: &CtOption<T>) -> (c: Choice)\n    ensures\n        choice_is_true(c) == ct_option_has_value(*opt),\n{\n    opt.is_some()\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "display_name": "add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn add(self, _rhs: &'a Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(&_rhs.bytes))\n                % group_order(),\n    {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::add requires inputs < group_order()\n        // By Scalar invariant #2, scalars should be canonical\n        // However, we cannot add requires clauses to trait implementations,\n        // so we assume this property holds\n        proof {\n            assume(to_nat(&self_unpacked.limbs) < group_order());\n            assume(to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::add(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) == (to_nat(&self_unpacked.limbs) + to_nat(\n                &rhs_unpacked.limbs,\n            )) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) == to_nat(&result_unpacked.limbs));\n            assert(bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "display_name": "load8_limb_X",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn load8_limb_X(input: &[u8], i: usize, k: nat, j_div: nat, j_id: nat, j_shift: nat)\n    requires\n        i + 7 < input.len(),\n        k <= 12,\n        forall|j: nat| 0 <= j < j_div ==> pow2_mul_DIV_MOD_u8_t51_cond(k, j),\n        forall|j: nat| j_div <= j < j_id ==> pow2_MUL_div_MOD_u8_t51_cond(k, j),\n        forall|j: nat| j_id <= j < j_shift ==> pow2_MUL_div_Mod_u8_t51_cond(k, j),\n        forall|j: nat| j_shift <= j < 8 ==> pow2_MUL_div_mod_u8_t51_cond(k, j),\n    ensures\n        forall|j: nat|\n            0 <= j < j_div ==> #[trigger] ((input[(i + j) as int] * pow2(j * 8)) as u64 / (pow2(\n                k,\n            ) as u64)) % (pow2(51) as u64) == (input[(i + j) as int]) as nat / pow2(\n                (k - j * 8) as nat,\n            ),\n        forall|j: nat|\n            j_div <= j < j_id ==> #[trigger] ((input[(i + j) as int] * pow2(j * 8)) as u64 / (pow2(\n                k,\n            ) as u64)) % (pow2(51) as u64) == (input[(i + j) as int]) * pow2((j * 8 - k) as nat),\n        forall|j: nat|\n            j_id <= j < j_shift ==> #[trigger] ((input[(i + j) as int] * pow2(j * 8)) as u64 / (\n            pow2(k) as u64)) % (pow2(51) as u64) == (input[(i + j) as int] as nat % pow2(\n                (51 - (j * 8 - k)) as nat,\n            )) * pow2((j * 8 - k) as nat),\n        forall|j: nat|\n            j_shift <= j < 8 ==> #[trigger] ((input[(i + j) as int] * pow2(j * 8)) as u64 / (pow2(\n                k,\n            ) as u64)) % (pow2(51) as u64) == 0,\n        (load8_at_spec(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64),\n{\n    let p51 = pow2(51) as u64;\n\n    assert(0 < pow2(k) <= u64::MAX) by {\n        lemma_pow2_pos(k);\n        pow2_le_max64(k);\n    }\n\n    let pk = pow2(k) as u64;\n\n    load8_limb_base(input, i, k as u64);\n\n    // first: all div, no mul\n    assert forall|j: nat| 0 <= j < j_div implies #[trigger] ((input[(i + j) as int] * pow2(\n        j * 8,\n    )) as u64 / pk) % p51 == (input[(i + j) as int]) as nat / pow2((k - j * 8) as nat) by {\n        assert(pow2_mul_DIV_MOD_u8_t51_cond(k, j));  // trigger forall\n        pow2_mul_DIV_MOD_u8(input[(i + j) as int], j * 8, k, 51);\n    }\n\n    // (product >> k) < 2^51\n    assert forall|j: nat| j_div <= j < j_id implies #[trigger] ((input[(i + j) as int] * pow2(\n        j * 8,\n    )) as u64 / pk) % p51 == (input[(i + j) as int]) * pow2((j * 8 - k) as nat) by {\n        assert(pow2_MUL_div_MOD_u8_t51_cond(k, j));  // trigger forall\n        pow2_MUL_div_MOD_u8(input[(i + j) as int], j * 8, k, 51);\n    }\n\n    // partial shift\n    assert forall|j: nat| j_id <= j < j_shift implies #[trigger] ((input[(i + j) as int] * pow2(\n        j * 8,\n    )) as u64 / pk) % p51 == (input[(i + j) as int] as nat % pow2((51 - (j * 8 - k)) as nat))\n        * pow2((j * 8 - k) as nat) by {\n        assert(pow2_MUL_div_Mod_u8_t51_cond(k, j));  // trigger forall\n        pow2_MUL_div_Mod_u8(input[(i + j) as int], j * 8, k, 51);\n    }\n\n    // zero\n    assert forall|j: nat| j_shift <= j < 8 implies #[trigger] ((input[(i + j) as int] * pow2(\n        j * 8,\n    )) as u64 / pk) % p51 == 0 by {\n        assert(pow2_MUL_div_mod_u8_t51_cond(k, j));  // trigger forall\n        pow2_MUL_div_mod_u8(input[(i + j) as int], j * 8, k, 51);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 13
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "display_name": "lemma_limb1_contribution_correctness",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_limb1_contribution_correctness(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[0] < pow2(51),  // Need limb 0 for boundary byte 6\n        limbs[1] < pow2(51),\n        bytes_match_limbs_packing(limbs, bytes),\n    ensures\n        limb1_byte_contribution(limbs, bytes) == limbs[1] as nat * pow2(51),\n{\n    // Limb 1 is stored in bytes 6-12, but positioned at 2^51\n    // - Byte 6 (high 5 bits): limbs[1]'s bits 0-4\n    // - Bytes 7-11: limbs[1]'s bits 5-44 (40 bits)\n    // - Byte 12 (low 6 bits): limbs[1]'s bits 45-50\n    // Total: 5 + 40 + 6 = 51 bits\n    lemma2_to64();\n    lemma_pow2_adds(48, 3);\n\n    // Stabilization placeholders\n    assert(pow2(0) == pow2(0 * 8));\n    assert(pow2(8) == pow2(1 * 8));\n    assert(pow2(16) == pow2(2 * 8));\n    assert(pow2(24) == pow2(3 * 8));\n    assert(pow2(32) == pow2(4 * 8));\n\n    // KEY INSIGHT: From bytes_match_limbs_packing, we know:\n    // bytes[7] = (limbs[1] >> 5) as u8\n    // bytes[8] = (limbs[1] >> 13) as u8\n    // ... and so on\n    //\n    // So limb1_byte_contribution is actually:\n    //   (limbs[1] % 2^5) * 8 * 2^48 +              // Low 5 bits at position 2^51\n    //   (limbs[1] >> 5 ... >> 37) * positions +    // Middle 40 bits starting at position 2^56\n    //   (limbs[1] / 2^45) % 2^6 * 2^96             // High 6 bits at position 2^96\n    //\n    // This is just limbs[1] * 2^51 with bits partitioned across the byte array!\n\n    // Strategy: Show that the contribution reconstructs limbs[1] * 2^51\n    // We'll use the same approach as limb 0:\n    // 1. Convert bytes 7-11 to arithmetic form\n    // 2. Show they reconstruct (limbs[1] >> 5) at position 2^56\n    // 3. Handle boundary bits\n    // 4. Combine using div-mod theorem\n\n    // Step 1: Extract arithmetic values for bytes 7-11\n    // These bytes come from limbs[1] >> 5, 13, 21, 29, 37\n    lemma_byte_from_limb_shift(limbs[1], 5, bytes[7]);\n\n    lemma_byte_from_limb_shift(limbs[1], 13, bytes[8]);\n\n    lemma_byte_from_limb_shift(limbs[1], 21, bytes[9]);\n\n    lemma_byte_from_limb_shift(limbs[1], 29, bytes[10]);\n\n    lemma_byte_from_limb_shift(limbs[1], 37, bytes[11]);\n\n    // Step 2: Recognize that bytes 7-11 weighted by their positions reconstruct\n    // (limbs[1] >> 5) at position 2^56 = 2^(7*8)\n    //\n    // bytes[7]*2^56 + bytes[8]*2^64 + ... = (limbs[1] >> 5) * 2^56\n    //\n    // Note: The byte positions in limb1_byte_contribution are:\n    // bytes[7] * pow2(7*8) = bytes[7] * 2^56\n    // bytes[8] * pow2(8*8) = bytes[8] * 2^64 = bytes[8] * 2^(56+8)\n    // etc.\n\n    // Prove that bytes[7-11] reconstruct ((limbs[1] / 2^5) % 2^40) at position 2^56\n    //\n    // From lemma_byte_from_limb_shift, we have:\n    // bytes[7] as nat == (limbs[1] / pow2(5)) % 256\n    // bytes[8] as nat == (limbs[1] / pow2(13)) % 256\n    // bytes[9] as nat == (limbs[1] / pow2(21)) % 256\n    // bytes[10] as nat == (limbs[1] / pow2(29)) % 256\n    // bytes[11] as nat == (limbs[1] / pow2(37)) % 256\n    //\n    // The key insight: these bytes extract consecutive 8-bit chunks from (limbs[1] / 2^5)\n\n    // First, rewrite the byte extractions in terms of (limbs[1] / 2^5)\n    // bytes[7] == (limbs[1] / 2^5) / 2^0 % 256\n    lemma_pow2_adds(0, 5);\n    lemma_div_denominator(limbs[1] as int, pow2(5) as int, pow2(0) as int);\n\n    // bytes[8] == (limbs[1] / 2^13) % 256 == (limbs[1] / 2^5) / 2^8 % 256\n    lemma_pow2_adds(5, 8);\n    lemma_div_denominator(limbs[1] as int, pow2(5) as int, pow2(8) as int);\n\n    // bytes[9] == (limbs[1] / 2^21) % 256 == (limbs[1] / 2^5) / 2^16 % 256\n    lemma_pow2_adds(5, 16);\n    lemma_div_denominator(limbs[1] as int, pow2(5) as int, pow2(16) as int);\n\n    // bytes[10] == (limbs[1] / 2^29) % 256 == (limbs[1] / 2^5) / 2^24 % 256\n    lemma_pow2_adds(5, 24);\n    lemma_div_denominator(limbs[1] as int, pow2(5) as int, pow2(24) as int);\n\n    // bytes[11] == (limbs[1] / 2^37) % 256 == (limbs[1] / 2^5) / 2^32 % 256\n    lemma_pow2_adds(5, 32);\n    lemma_div_denominator(limbs[1] as int, pow2(5) as int, pow2(32) as int);\n\n    // Now handle the % 2^40 truncation\n    // Since limbs[1] < 2^51, we have limbs[1] / 2^5 < 2^46\n    lemma_div_bound(limbs[1] as nat, 5, 51);\n\n    // The bytes extract bits at positions [0..8), [8..16), [16..24), [24..32), [32..40)\n    // from (limbs[1] / 2^5). Since all these bit positions are < 40, taking % 2^40\n    // doesn't change the extracted bytes.\n    //\n    // For k < 40, if we extract byte k from value v, we get: (v / 2^(k*8)) % 256\n    // If v < 2^46, then taking (v % 2^40) only affects bits 40+\n    // So for k*8 < 40 (i.e., k < 5), we have:\n    //   (v / 2^(k*8)) % 256 == ((v % 2^40) / 2^(k*8)) % 256\n    //\n    // Since our bytes extract at offsets 0, 8, 16, 24, 32 (all < 40), they extract\n    // from (limbs[1] / 2^5) % 2^40 the same way.\n\n    let middle_value = (limbs[1] as nat / pow2(5)) % pow2(40);\n\n    // Prove middle_value < 2^40 (trivial by definition of %)\n    lemma_pow2_pos(40);\n    assert(pow2(40) > 0);\n    lemma_mod_bound(middle_value as int, pow2(40) as int);\n\n    // Now prove that the bytes extract from middle_value\n    // Since we're extracting at bit positions [0, 8, 16, 24, 32], all < 40,\n    // extracting from (limbs[1] / 2^5) or from ((limbs[1] / 2^5) % 2^40) gives the same result\n    //\n    // For byte extraction at position k where k*8 < 40:\n    //   (v / 2^(k*8)) % 256 == ((v % 2^40) / 2^(k*8)) % 256\n    //\n    // This is because v % 2^40 only affects bits >= 40, and byte extraction at k*8\n    // only looks at bits [k*8, k*8+8), which are all < 40.\n\n    let v = limbs[1] as nat / pow2(5);\n\n    // Use lemma_byte_extraction_commutes_with_mod to show extraction commutes with % 2^40\n    // For byte at position k, we need k*8 + 8 <= 40\n    lemma_byte_extraction_commutes_with_mod(v, 0, 40);  // 0*8 + 8 = 8 <= 40 ✓\n    assert(bytes[7] as nat == (middle_value / pow2(0)) % 256);\n\n    lemma_byte_extraction_commutes_with_mod(v, 1, 40);  // 1*8 + 8 = 16 <= 40 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 2, 40);  // 2*8 + 8 = 24 <= 40 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 3, 40);  // 3*8 + 8 = 32 <= 40 ✓\n\n    lemma_byte_extraction_commutes_with_mod(v, 4, 40);  // 4*8 + 8 = 40 <= 40 ✓\n\n    // Now apply lemma_5_bytes_reconstruct\n    lemma_5_bytes_reconstruct(middle_value, bytes[7], bytes[8], bytes[9], bytes[10], bytes[11]);\n\n    // This gives us:\n    assert(bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8) + bytes[9] as nat * pow2(16)\n        + bytes[10] as nat * pow2(24) + bytes[11] as nat * pow2(32) == middle_value);\n\n    // Now multiply both sides by 2^56 to get the bytes at their actual positions\n    lemma_mul_is_distributive_add(\n        pow2(56) as int,\n        (bytes[7] as nat * pow2(0)) as int,\n        (bytes[8] as nat * pow2(8)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(56) as int,\n        (bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8)) as int,\n        (bytes[9] as nat * pow2(16)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(56) as int,\n        (bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8) + bytes[9] as nat * pow2(16)) as int,\n        (bytes[10] as nat * pow2(24)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(56) as int,\n        (bytes[7] as nat * pow2(0) + bytes[8] as nat * pow2(8) + bytes[9] as nat * pow2(16)\n            + bytes[10] as nat * pow2(24)) as int,\n        (bytes[11] as nat * pow2(32)) as int,\n    );\n\n    // Distribute the multiplication into each term\n    lemma_mul_is_associative(bytes[7] as int, pow2(0) as int, pow2(56) as int);\n    lemma_mul_is_associative(bytes[8] as int, pow2(8) as int, pow2(56) as int);\n    lemma_mul_is_associative(bytes[9] as int, pow2(16) as int, pow2(56) as int);\n    lemma_mul_is_associative(bytes[10] as int, pow2(24) as int, pow2(56) as int);\n    lemma_mul_is_associative(bytes[11] as int, pow2(32) as int, pow2(56) as int);\n\n    // Simplify using pow2 addition: 2^56 * 2^k = 2^(56+k)\n    lemma_pow2_adds(56, 0);\n\n    lemma_pow2_adds(56, 8);\n\n    lemma_pow2_adds(56, 16);\n\n    lemma_pow2_adds(56, 24);\n\n    lemma_pow2_adds(56, 32);\n    assert(pow2(88) == pow2(11 * 8));\n\n    // Final result§\n    assert(bytes[7] as nat * pow2(7 * 8) + bytes[8] as nat * pow2(8 * 8) + bytes[9] as nat * pow2(\n        9 * 8,\n    ) + bytes[10] as nat * pow2(10 * 8) + bytes[11] as nat * pow2(11 * 8) == middle_value * pow2(\n        56,\n    ));\n\n    // Step 3: Handle boundary bytes\n    // Low 5 bits (byte 6 high part): (limbs[1] % 2^5) * 8 * 2^48 = (limbs[1] % 2^5) * 2^51\n    // High 6 bits (byte 12 low part): (limbs[1] / 2^45) % 2^6 * 2^96\n\n    assert(8 * pow2(48) == pow2(51)) by {\n        lemma_pow2_adds(48, 3);\n    }\n\n    // Step 4: Prove the final equality using division-modulo reconstruction\n    // Goal: Show limb1_byte_contribution == limbs[1] * 2^51\n\n    // First, expand limb1_byte_contribution using its definition\n    let contribution = limb1_byte_contribution(limbs, bytes);\n    assert(contribution == ((limbs[1] as nat % pow2(5)) * 8) * pow2(6 * 8) + bytes[7] as nat * pow2(\n        7 * 8,\n    ) + bytes[8] as nat * pow2(8 * 8) + bytes[9] as nat * pow2(9 * 8) + bytes[10] as nat * pow2(\n        10 * 8,\n    ) + bytes[11] as nat * pow2(11 * 8) + ((limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(12 * 8));\n\n    // Create a variable for the middle bytes sum\n    let middle_bytes_sum = bytes[7] as nat * pow2(7 * 8) + bytes[8] as nat * pow2(8 * 8)\n        + bytes[9] as nat * pow2(9 * 8) + bytes[10] as nat * pow2(10 * 8) + bytes[11] as nat * pow2(\n        11 * 8,\n    );\n\n    // From the proof above, we have:\n    // middle_bytes_sum == ((limbs[1] / pow2(5)) % pow2(40)) * pow2(56)\n    let middle_value_at_position = ((limbs[1] as nat / pow2(5)) % pow2(40)) * pow2(56);\n\n    // Substitute into contribution\n    assert(contribution == ((limbs[1] as nat % pow2(5)) * 8) * pow2(48) + middle_bytes_sum + ((\n    limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(96));\n\n    assert(contribution == ((limbs[1] as nat % pow2(5)) * 8) * pow2(48) + middle_value_at_position\n        + ((limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(96));\n\n    // Now complete the algebraic proof using division-modulo reconstruction\n    // Goal: Show contribution = limbs[1] * 2^51\n\n    // Step 1: Simplify the low contribution term\n    // We have: ((limbs[1] % 2^5) * 8) * 2^48\n    // We proved earlier that 8 * 2^48 = 2^51\n    // So: ((limbs[1] % 2^5) * 8) * 2^48 = (limbs[1] % 2^5) * (8 * 2^48) = (limbs[1] % 2^5) * 2^51\n    // For now, accept this simplification (requires multiplication associativity)\n    let low_term = (limbs[1] as nat % pow2(5)) * pow2(51);\n    let middle_term = ((limbs[1] as nat / pow2(5)) % pow2(40)) * pow2(56);\n    let high_term = ((limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(96);\n\n    // Step 2: Establish power relationships needed for factoring\n    lemma_pow2_adds(51, 5);  // 2^56 = 2^51 * 2^5\n\n    lemma_pow2_adds(51, 45);  // 2^96 = 2^51 * 2^45\n\n    // Step 3: Prove limbs[1] can be reconstructed from the three parts\n    // We'll show: limbs[1] = (limbs[1] % 2^5) + ((limbs[1] / 2^5) % 2^40) * 2^5 + ((limbs[1] / 2^45) % 2^6) * 2^45\n\n    // First, reconstruct limbs[1] / 2^5 from its low 40 bits and high part\n    lemma_pow2_pos(40);\n    let shifted_value = limbs[1] as nat / pow2(5);\n    lemma_fundamental_div_mod(shifted_value as int, pow2(40) as int);\n    // lemma_fundamental_div_mod gives: shifted_value == pow2(40) * (shifted_value / pow2(40)) + (shifted_value % pow2(40))\n    // We need: shifted_value == (shifted_value % pow2(40)) + (shifted_value / pow2(40)) * pow2(40)\n    assert(pow2(40) * (shifted_value / pow2(40)) == (shifted_value / pow2(40)) * pow2(40)) by {\n        lemma_mul_is_commutative(pow2(40) as int, (shifted_value / pow2(40)) as int);\n    }\n\n    // Show that (limbs[1] / 2^5) / 2^40 = limbs[1] / 2^45\n    lemma_div_denominator(limbs[1] as int, pow2(5) as int, pow2(40) as int);\n    lemma_pow2_adds(5, 40);\n\n    // So: limbs[1] / 2^5 = ((limbs[1] / 2^5) % 2^40) + (limbs[1] / 2^45) * 2^40\n    assert(shifted_value == (shifted_value % pow2(40)) + (limbs[1] as nat / pow2(45)) * pow2(40));\n\n    // Next, reconstruct limbs[1] from its low 5 bits and (limbs[1] / 2^5)\n    lemma_pow2_pos(5);\n    lemma_fundamental_div_mod(limbs[1] as int, pow2(5) as int);\n    // lemma_fundamental_div_mod gives: limbs[1] == pow2(5) * (limbs[1] / pow2(5)) + (limbs[1] % pow2(5))\n    assert(pow2(5) * shifted_value == shifted_value * pow2(5)) by {\n        lemma_mul_is_commutative(pow2(5) as int, shifted_value as int);\n    }\n\n    // Substitute the reconstruction of shifted_value (limbs[1] / 2^5)\n    assert(limbs[1] as nat == (limbs[1] as nat % pow2(5)) + ((shifted_value % pow2(40)) + (\n    limbs[1] as nat / pow2(45)) * pow2(40)) * pow2(5));\n\n    // Distribute the * 2^5\n    assert(limbs[1] as nat == (limbs[1] as nat % pow2(5)) + (shifted_value % pow2(40)) * pow2(5) + (\n    limbs[1] as nat / pow2(45)) * pow2(40) * pow2(5)) by {\n        lemma_mul_is_distributive_add(\n            pow2(5) as int,\n            (shifted_value % pow2(40)) as int,\n            (limbs[1] as nat / pow2(45) * pow2(40)) as int,\n        );\n    }\n\n    // Use 2^40 * 2^5 = 2^45\n    lemma_pow2_adds(40, 5);\n    assert((limbs[1] as nat / pow2(45)) * pow2(40) * pow2(5) == (limbs[1] as nat / pow2(45)) * pow2(\n        45,\n    )) by {\n        lemma_mul_is_associative(\n            (limbs[1] as nat / pow2(45)) as int,\n            pow2(40) as int,\n            pow2(5) as int,\n        );\n    }\n\n    assert(limbs[1] as nat == (limbs[1] as nat % pow2(5)) + ((limbs[1] as nat / pow2(5)) % pow2(40))\n        * pow2(5) + (limbs[1] as nat / pow2(45)) * pow2(45));\n\n    // Handle the % 2^6 on the high bits\n    // Since limbs[1] < 2^51, we have limbs[1] / 2^45 < 2^6\n    lemma_div_bound(limbs[1] as nat, 45, 51);\n    lemma_small_mod(limbs[1] as nat / pow2(45), pow2(6));\n\n    // Therefore:\n    assert(limbs[1] as nat == (limbs[1] as nat % pow2(5)) + ((limbs[1] as nat / pow2(5)) % pow2(40))\n        * pow2(5) + ((limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(45));\n\n    // Step 4: Now connect the contribution to limbs[1] * 2^51\n    // We have: contribution = ((limbs[1] % 2^5) * 8) * 2^48 + middle_value_at_position + ((limbs[1] / 2^45) % 2^6) * 2^96\n    // Where: middle_value_at_position = ((limbs[1] / 2^5) % 2^40) * 2^56\n\n    // First, simplify the low term: ((limbs[1] % 2^5) * 8) * 2^48 = (limbs[1] % 2^5) * (8 * 2^48) = (limbs[1] % 2^5) * 2^51\n    // We proved earlier that 8 * 2^48 = 2^51\n    let low_part = (limbs[1] as nat % pow2(5));\n    assert(((limbs[1] as nat % pow2(5)) * 8) * pow2(48) == low_part * (8 * pow2(48))) by {\n        lemma_mul_is_associative(low_part as int, 8, pow2(48) as int);\n    }\n\n    // So contribution = (limbs[1] % 2^5) * 2^51 + ((limbs[1] / 2^5) % 2^40) * 2^56 + ((limbs[1] / 2^45) % 2^6) * 2^96\n    assert(contribution == low_part * pow2(51) + ((limbs[1] as nat / pow2(5)) % pow2(40)) * pow2(56)\n        + ((limbs[1] as nat / pow2(45)) % pow2(6)) * pow2(96));\n\n    // Rewrite using 2^56 = 2^51 * 2^5 and 2^96 = 2^51 * 2^45\n    assert(contribution == low_part * pow2(51) + ((limbs[1] as nat / pow2(5)) % pow2(40)) * (pow2(\n        51,\n    ) * pow2(5)) + ((limbs[1] as nat / pow2(45)) % pow2(6)) * (pow2(51) * pow2(45)));\n\n    // Apply associativity to move pow2(51) to the left\n    let middle_part = (limbs[1] as nat / pow2(5)) % pow2(40);\n    let high_part = (limbs[1] as nat / pow2(45)) % pow2(6);\n\n    assert(middle_part * (pow2(51) * pow2(5)) == (middle_part * pow2(51)) * pow2(5)) by {\n        lemma_mul_is_associative(middle_part as int, pow2(51) as int, pow2(5) as int);\n    }\n    assert((middle_part * pow2(51)) * pow2(5) == pow2(51) * middle_part * pow2(5)) by {\n        lemma_mul_is_commutative((middle_part * pow2(51)) as int, pow2(5) as int);\n    }\n    assert(pow2(51) * middle_part * pow2(5) == pow2(51) * (middle_part * pow2(5))) by {\n        lemma_mul_is_associative(pow2(51) as int, middle_part as int, pow2(5) as int);\n    }\n\n    assert(high_part * (pow2(51) * pow2(45)) == (high_part * pow2(51)) * pow2(45)) by {\n        lemma_mul_is_associative(high_part as int, pow2(51) as int, pow2(45) as int);\n    }\n    assert((high_part * pow2(51)) * pow2(45) == pow2(51) * high_part * pow2(45)) by {\n        lemma_mul_is_commutative((high_part * pow2(51)) as int, pow2(45) as int);\n    }\n    assert(pow2(51) * high_part * pow2(45) == pow2(51) * (high_part * pow2(45))) by {\n        lemma_mul_is_associative(pow2(51) as int, high_part as int, pow2(45) as int);\n    }\n\n    // Now factor out pow2(51)\n    assert(contribution == low_part * pow2(51) + pow2(51) * (middle_part * pow2(5)) + pow2(51) * (\n    high_part * pow2(45)));\n\n    // Use distributivity to factor out pow2(51)\n    assert(contribution == pow2(51) * (low_part + middle_part * pow2(5) + high_part * pow2(45)))\n        by {\n        lemma_mul_is_distributive_add(\n            pow2(51) as int,\n            low_part as int,\n            (middle_part * pow2(5)) as int,\n        );\n        lemma_mul_is_distributive_add(\n            pow2(51) as int,\n            (low_part + middle_part * pow2(5)) as int,\n            (high_part * pow2(45)) as int,\n        );\n    }\n\n    // The part in parentheses equals limbs[1] by our reconstruction identity!\n    assert(contribution == limbs[1] as nat * pow2(51)) by {\n        lemma_mul_is_commutative(pow2(51) as int, limbs[1] as int);\n    }\n\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 17
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "display_name": "main",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "body": "fn main() {\n    let target_arch = match std::env::var(\"CARGO_CFG_TARGET_ARCH\") {\n        Ok(arch) => arch,\n        _ => \"\".to_string(),\n    };\n\n    let curve25519_dalek_bits = match std::env::var(\"CARGO_CFG_CURVE25519_DALEK_BITS\").as_deref() {\n        Ok(\"32\") => DalekBits::Dalek32,\n        Ok(\"64\") => DalekBits::Dalek64,\n        _ => deterministic::determine_curve25519_dalek_bits(&target_arch),\n    };\n\n    println!(\"cargo:rustc-cfg=curve25519_dalek_bits=\\\"{curve25519_dalek_bits}\\\"\");\n\n    if rustc_version::version_meta()\n        .expect(\"failed to detect rustc version\")\n        .channel\n        == rustc_version::Channel::Nightly\n    {\n        println!(\"cargo:rustc-cfg=nightly\");\n    }\n\n    let rustc_version = rustc_version::version().expect(\"failed to detect rustc version\");\n    if rustc_version.major == 1 && rustc_version.minor <= 64 {\n        // Old versions of Rust complain when you have an `unsafe fn` and you use `unsafe {}` inside,\n        // so for those we want to apply the `#[allow(unused_unsafe)]` attribute to get rid of that warning.\n        println!(\"cargo:rustc-cfg=allow_unused_unsafe\");\n    }\n\n    // Backend overrides / defaults\n    let curve25519_dalek_backend =\n        match std::env::var(\"CARGO_CFG_CURVE25519_DALEK_BACKEND\").as_deref() {\n            Ok(\"fiat\") => \"fiat\",\n            Ok(\"serial\") => \"serial\",\n            Ok(\"simd\") => {\n                // simd can only be enabled on x86_64 & 64bit target_pointer_width\n                match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n                    true => \"simd\",\n                    // If override is not possible this must result to compile error\n                    // See: issues/532\n                    false => panic!(\"Could not override curve25519_dalek_backend to simd\"),\n                }\n            }\n            // default between serial / simd (if potentially capable)\n            _ => match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n                true => \"simd\",\n                false => \"serial\",\n            },\n        };\n    println!(\"cargo:rustc-cfg=curve25519_dalek_backend=\\\"{curve25519_dalek_backend}\\\"\");\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#unwrap().",
      "display_name": "unwrap",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#unwrap().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_square().",
      "display_name": "field_square",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_square().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/curve_specs.rs",
      "relative_path": "src/curve_specs.rs",
      "file_name": "curve_specs.rs",
      "parent_folder": "src",
      "body": "    t == field_mul(field_mul(x, y), field_inv(z))\n}\n\n/// Returns the abstract affine coordinates (x, y) of this point.\npub open spec fn affine_coords(point: crate::edwards::EdwardsPoint) -> (nat, nat) {\n    let x_abs = field_element(&point.X);\n    let y_abs = field_element(&point.Y);\n    let z_abs = field_element(&point.Z);\n    let z_inv = field_inv(z_abs);\n    (field_mul(x_abs, z_inv), field_mul(y_abs, z_inv))\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/get_selected_backend().",
      "display_name": "get_selected_backend",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/get_selected_backend().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/mod.rs",
      "relative_path": "src/backend/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "backend",
      "body": "fn get_selected_backend() -> BackendKind {\n    // #[cfg(all(curve25519_dalek_backend = \"simd\", nightly))]\n    // {\n    //     cpufeatures::new!(cpuid_avx512, \"avx512ifma\", \"avx512vl\");\n    //     let token_avx512: cpuid_avx512::InitToken = cpuid_avx512::init();\n    //     if token_avx512.get() {\n    //         return BackendKind::Avx512;\n    //     }\n    // }\n\n    // #[cfg(curve25519_dalek_backend = \"simd\")]\n    // {\n    //     cpufeatures::new!(cpuid_avx2, \"avx2\");\n    //     let token_avx2: cpuid_avx2::InitToken = cpuid_avx2::init();\n    //     if token_avx2.get() {\n    //         return BackendKind::Avx2;\n    //     }\n    // }\n\n    BackendKind::Serial\n}",
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_ver_div_mod().",
      "display_name": "load8_plus_ver_div_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_ver_div_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn load8_plus_ver_div_mod(input: &[u8], i: usize, k: nat, s: nat)\n    requires\n        i + 7 < input.len(),\n        0 < k <= 7,\n        s < 64,\n    ensures\n        load8_at_plus_version_rec(input, i, k) / (pow2(s) as u64) == load8_at_plus_version_rec(\n            input,\n            i,\n            (k - 1) as nat,\n        ) / (pow2(s) as u64) + (pow2(k * 8) * input[i + k]) as u64 / (pow2(s) as u64),\n        load8_at_plus_version_rec(input, i, k) % (pow2(s) as u64) == load8_at_plus_version_rec(\n            input,\n            i,\n            (k - 1) as nat,\n        ) % (pow2(s) as u64) + (pow2(k * 8) * input[i + k]) as u64 % (pow2(s) as u64),\n{\n    assert(pow2(s) <= u64::MAX) by {\n        pow2_le_max64(s);\n    }\n\n    assert(pow2(s) > 0) by {\n        lemma_pow2_pos(s);\n    }\n\n    assert(pow2(k * 8) <= u64::MAX) by {\n        pow2_le_max64(k * 8);\n    }\n\n    let p64 = pow2(s) as u64;\n\n    let xk = load8_at_plus_version_rec(input, i, k);\n    let xk_1 = load8_at_plus_version_rec(input, i, (k - 1) as nat);\n    let v = input[i + k];\n    let v_n = v as nat;\n\n    assert(xk == (xk_1 + ((v as u64) << k * 8)) as u64) by {\n        reveal_with_fuel(load8_at_plus_version_rec, 1);\n    }\n\n    assert(v * pow2(k * 8) <= u64::MAX) by {\n        u8_times_pow2_fits_u64(v, k * 8);\n    }\n\n    assert(((v as u64) << k * 8) == pow2(k * 8) * v) by {\n        lemma_u64_shl_is_mul(v as u64, (k * 8) as u64);\n    }\n\n    assert(xk_1 < pow2(8 * k)) by {\n        load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n    }\n\n    assert((xk_1 + pow2(k * 8) * v) as u64 / p64 == xk_1 / p64 + ((pow2(k * 8) * v) as u64) / p64\n        && (xk_1 + pow2(k * 8) * v) as u64 % p64 == xk_1 % p64 + ((pow2(k * 8) * v) as u64) % p64)\n        by {\n        assert((xk_1 + pow2(k * 8) * v) <= u64::MAX) by {\n            load8_plus_fits_u64(input, i, k);\n        }\n        lemma_bitops_lifted(xk_1, v as u64, (k * 8) as nat, s);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_inverse_field().",
      "display_name": "is_inverse_field",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_inverse_field().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "        ensures\n            field_element_as_nat(&result.0) == pow(\n                field_element_as_nat(self) as int,\n                (pow2(250) - 1) as nat,\n            ) % (p() as int),\n            field_element_as_nat(&result.1) == pow(field_element_as_nat(self) as int, 11) % (\n            p() as int),\n    {\n        // Instead of managing which temporary variables are used\n        // for what, we define as many as we need and leave stack\n        // allocation to the compiler\n        //\n        // Each temporary variable t_i is of the form (self)^e_i.\n        // Squaring t_i corresponds to multiplying e_i by 2,\n        // so the pow2k function shifts e_i left by k places.\n        // Multiplying t_i and t_j corresponds to adding e_i + e_j.\n        //\n        // Temporary t_i                      Nonzero bits of e_i\n        //\n        assume(false);\n        let t0 = self.square();  // 1         e_0 = 2^1\n        let t1 = t0.square().square();  // 3         e_1 = 2^3\n        let t2 = self * &t1;  // 3,0       e_2 = 2^3 + 2^0\n        let t3 = &t0 * &t2;  // 3,1,0\n        let t4 = t3.square();  // 4,2,1\n        let t5 = &t2 * &t4;  // 4,3,2,1,0\n        let t6 = t5.pow2k(5);  // 9,8,7,6,5\n        let t7 = &t6 * &t5;  // 9,8,7,6,5,4,3,2,1,0\n        let t8 = t7.pow2k(10);  // 19..10\n        let t9 = &t8 * &t7;  // 19..0\n        let t10 = t9.pow2k(20);  // 39..20\n        let t11 = &t10 * &t9;  // 39..0\n        let t12 = t11.pow2k(10);  // 49..10\n        let t13 = &t12 * &t7;  // 49..0\n        let t14 = t13.pow2k(50);  // 99..50\n        let t15 = &t14 * &t13;  // 99..0\n        let t16 = t15.pow2k(100);  // 199..100\n        let t17 = &t16 * &t15;  // 199..0\n        let t18 = t17.pow2k(50);  // 249..50\n        let t19 = &t18 * &t13;  // 249..0\n\n        (t19, t3)\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/bytes_match_limbs_packing().",
      "display_name": "bytes_match_limbs_packing",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/bytes_match_limbs_packing().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn bytes_match_limbs_packing(limbs: [u64; 5], bytes: [u8; 32]) -> bool {\n    bytes[0] == limbs[0] as u8 && bytes[1] == (limbs[0] >> 8) as u8 && bytes[2] == (limbs[0]\n        >> 16) as u8 && bytes[3] == (limbs[0] >> 24) as u8 && bytes[4] == (limbs[0] >> 32) as u8\n        && bytes[5] == (limbs[0] >> 40) as u8 && bytes[6] == ((limbs[0] >> 48) | (limbs[1]\n        << 3)) as u8 && bytes[7] == (limbs[1] >> 5) as u8 && bytes[8] == (limbs[1] >> 13) as u8\n        && bytes[9] == (limbs[1] >> 21) as u8 && bytes[10] == (limbs[1] >> 29) as u8 && bytes[11]\n        == (limbs[1] >> 37) as u8 && bytes[12] == ((limbs[1] >> 45) | (limbs[2] << 6)) as u8\n        && bytes[13] == (limbs[2] >> 2) as u8 && bytes[14] == (limbs[2] >> 10) as u8 && bytes[15]\n        == (limbs[2] >> 18) as u8 && bytes[16] == (limbs[2] >> 26) as u8 && bytes[17] == (limbs[2]\n        >> 34) as u8 && bytes[18] == (limbs[2] >> 42) as u8 && bytes[19] == ((limbs[2] >> 50) | (\n    limbs[3] << 1)) as u8 && bytes[20] == (limbs[3] >> 7) as u8 && bytes[21] == (limbs[3]\n        >> 15) as u8 && bytes[22] == (limbs[3] >> 23) as u8 && bytes[23] == (limbs[3] >> 31) as u8\n        && bytes[24] == (limbs[3] >> 39) as u8 && bytes[25] == ((limbs[3] >> 47) | (limbs[4]\n        << 4)) as u8 && bytes[26] == (limbs[4] >> 4) as u8 && bytes[27] == (limbs[4] >> 12) as u8\n        && bytes[28] == (limbs[4] >> 20) as u8 && bytes[29] == (limbs[4] >> 28) as u8 && bytes[30]\n        == (limbs[4] >> 36) as u8 && bytes[31] == (limbs[4] >> 44) as u8\n}",
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/lemma_low_bits_mask_div2().",
      "display_name": "lemma_low_bits_mask_div2",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/lemma_low_bits_mask_div2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/mask_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/mask_lemmas.rs",
      "file_name": "mask_lemmas.rs",
      "parent_folder": "common_verus",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "display_name": "double",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#AddAssign#add_assign().",
      "display_name": "add_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#AddAssign#add_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn add_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) + _rhs;\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_edwards_identity().",
      "display_name": "is_edwards_identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_edwards_identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/curve_specs.rs",
      "relative_path": "src/curve_specs.rs",
      "file_name": "curve_specs.rs",
      "parent_folder": "src",
      "body": "pub open spec fn is_edwards_identity(x: nat, y: nat) -> bool {\n    x % p() == 0 && y % p() == 1\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_sum_bounds().",
      "display_name": "pow2_sum_bounds",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_sum_bounds().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_Mod().",
      "display_name": "pow2_MUL_div_Mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_Mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn pow2_MUL_div_Mod(x: nat, px: nat, k: nat, s: nat, t: nat)\n    requires\n        x < pow2(px),\n        s <= k,\n        k - s <= t,\n    ensures\n        ((x * pow2(k)) / pow2(s)) % pow2(t) == (x % pow2((t - (k - s)) as nat) * pow2(\n            (k - s) as nat,\n        )),\n{\n    let d = (k - s) as nat;\n\n    assert((x * pow2(k)) / pow2(s) == x * pow2(d)) by {\n        pow2_MUL_div(x, k, s);\n    }\n\n    let dd = (t - d) as nat;\n\n    assert((x * pow2(d)) % pow2(t) == (x % pow2(dd)) * pow2(d)) by {\n        mask_pow2(x, d, t);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/bytes_match_limbs_packing_52().",
      "display_name": "bytes_match_limbs_packing_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/bytes_match_limbs_packing_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub open spec fn bytes_match_limbs_packing_52(limbs: [u64; 5], bytes: [u8; 32]) -> bool {\n    bytes[0] == (limbs[0] >> 0) as u8 && bytes[1] == (limbs[0] >> 8) as u8 && bytes[2] == (limbs[0]\n        >> 16) as u8 && bytes[3] == (limbs[0] >> 24) as u8 && bytes[4] == (limbs[0] >> 32) as u8\n        && bytes[5] == (limbs[0] >> 40) as u8 && bytes[6] == ((limbs[0] >> 48) | (limbs[1]\n        << 4)) as u8 && bytes[7] == (limbs[1] >> 4) as u8 && bytes[8] == (limbs[1] >> 12) as u8\n        && bytes[9] == (limbs[1] >> 20) as u8 && bytes[10] == (limbs[1] >> 28) as u8 && bytes[11]\n        == (limbs[1] >> 36) as u8 && bytes[12] == (limbs[1] >> 44) as u8 && bytes[13] == (limbs[2]\n        >> 0) as u8 && bytes[14] == (limbs[2] >> 8) as u8 && bytes[15] == (limbs[2] >> 16) as u8\n        && bytes[16] == (limbs[2] >> 24) as u8 && bytes[17] == (limbs[2] >> 32) as u8 && bytes[18]\n        == (limbs[2] >> 40) as u8 && bytes[19] == ((limbs[2] >> 48) | (limbs[3] << 4)) as u8\n        && bytes[20] == (limbs[3] >> 4) as u8 && bytes[21] == (limbs[3] >> 12) as u8 && bytes[22]\n        == (limbs[3] >> 20) as u8 && bytes[23] == (limbs[3] >> 28) as u8 && bytes[24] == (limbs[3]\n        >> 36) as u8 && bytes[25] == (limbs[3] >> 44) as u8 && bytes[26] == (limbs[4] >> 0) as u8\n        && bytes[27] == (limbs[4] >> 8) as u8 && bytes[28] == (limbs[4] >> 16) as u8 && bytes[29]\n        == (limbs[4] >> 24) as u8 && bytes[30] == (limbs[4] >> 32) as u8 && bytes[31] == (limbs[4]\n        >> 40) as u8\n}",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_add().",
      "display_name": "field_add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/curve_specs.rs",
      "relative_path": "src/curve_specs.rs",
      "file_name": "curve_specs.rs",
      "parent_folder": "src",
      "body": "    z != 0 && x == 0 && y == z\n}\n\n/// Spec: Check if an EdwardsPoint in projective coordinates is valid\n/// An EdwardsPoint (X:Y:Z:T) is valid if:\n/// 1. The affine point (X/Z, Y/Z) lies on the Edwards curve\n/// 2. The extended coordinate satisfies T = X*Y/Z\n/// 3. Z ≠ 0\npub open spec fn is_valid_edwards_point(point: crate::edwards::EdwardsPoint) -> bool {\n    let x = field_element(&point.X);\n    let y = field_element(&point.Y);\n    let z = field_element(&point.Z);\n    let t = field_element(&point.T);\n\n    // Z must be non-zero\n    z != 0 &&\n    // The affine coordinates (X/Z, Y/Z) must be on the curve\n    on_edwards_curve(field_mul(x, field_inv(z)), field_mul(y, field_inv(z)))\n        &&\n    // Extended coordinate must satisfy T = X*Y/Z\n    t == field_mul(field_mul(x, y), field_inv(z))\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/from_le_bytes().",
      "display_name": "from_le_bytes",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/from_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#as_affine().",
      "display_name": "as_affine",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#as_affine().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    pub fn as_affine(&self) -> MontgomeryPoint {\n        let u = &self.U * &self.W.invert();\n        MontgomeryPoint(u.as_bytes())\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_shr_le_u64().",
      "display_name": "lemma_shr_le_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_shr_le_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/reduce_lemmas.rs",
      "file_name": "reduce_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "        assert(pow2(204) * limbs[4] == pow2(204) * b4 + pow2(204) * (pow2(51) * a4)) by {\n            lemma_mul_is_distributive_add(pow2(204) as int, pow2(51) * a4 as int, b4 as int);\n        }",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 DalekBits#Display#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 DalekBits#Display#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {\n        let w_bits = match self {\n            DalekBits::Dalek32 => \"32\",\n            DalekBits::Dalek64 => \"64\",\n        };\n        write!(f, \"{w_bits}\")\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/a4_0_val().",
      "display_name": "a4_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/a4_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
      "file_name": "pow2k_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn a4_0_val(a: [u64; 5]) -> u64 {\n    (c4_val(a) as u64) & mask51\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "display_name": "lemma_to_bytes_reduction",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 Choice#Not#not().",
      "display_name": "not",
      "symbol": "rust-analyzer cargo subtle 2.6.1 Choice#Not#not().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_sub().",
      "display_name": "field_sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/curve_specs.rs",
      "relative_path": "src/curve_specs.rs",
      "file_name": "curve_specs.rs",
      "parent_folder": "src",
      "body": "/// 1. The affine point (X/Z, Y/Z) lies on the Edwards curve\n/// 2. The extended coordinate satisfies T = X*Y/Z\n/// 3. Z ≠ 0\npub open spec fn is_valid_edwards_point(point: crate::edwards::EdwardsPoint) -> bool {\n    let x = field_element(&point.X);\n    let y = field_element(&point.Y);\n    let z = field_element(&point.Z);\n    let t = field_element(&point.T);\n\n    // Z must be non-zero\n    z != 0 &&\n    // The affine coordinates (X/Z, Y/Z) must be on the curve\n    on_edwards_curve(field_mul(x, field_inv(z)), field_mul(y, field_inv(z)))\n        &&\n    // Extended coordinate must satisfy T = X*Y/Z\n    t == field_mul(field_mul(x, y), field_inv(z))\n}",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_mod_div().",
      "display_name": "assemble_mod_div",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_mod_div().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn assemble_mod_div(a: nat, d: nat, b: nat)\n    ensures\n        (a % pow2(d)) * pow2(b) + pow2(b + d) * (a / pow2(d)) == a * pow2(b),\n{\n    let pb = pow2(b);\n    let pd = pow2(d);\n    let pbd = pow2(b + d);\n\n    assert(pbd == pb * pd) by {\n        lemma_pow2_adds(b, d);\n    }\n\n    let amod = a % pd;\n    let adiv = a / pd;\n\n    assert(pbd * adiv == (pd * adiv) * pb) by {\n        lemma_mul_is_associative(pb as int, pd as int, adiv as int);\n        lemma_mul_is_commutative(pb as int, (pd * adiv) as int);\n    }\n\n    assert(amod * pb + (pd * adiv) * pb == (amod + pd * adiv) * pb) by {\n        lemma_mul_is_distributive_add_other_way(pb as int, amod as int, (pd * adiv) as int);\n    }\n\n    assert(amod + pd * adiv == a) by {\n        assert(pd > 0) by {\n            lemma_pow2_pos(d);\n        }\n        lemma_fundamental_div_mod(a as int, pd as int);\n    }\n\n}",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo digest 0.10.7 digest/Digest#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo digest 0.10.7 digest/Digest#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_zero_is_id().",
      "display_name": "shl_zero_is_id",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_zero_is_id().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub broadcast proof fn shl_zero_is_id(v: u64)\n    ensures\n        #![trigger v << 0]\n        v << 0 == v,\n{\n    assert(v << 0 == v) by (bit_vector);\n}",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "display_name": "into",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "display_name": "iter",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/negate_field().",
      "display_name": "negate_field",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/negate_field().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "    ensures choice_is_true(result) == (self.as_bytes()[0] & 1 == 1)\n    - (note after slack call: maybe the first bit of as_bytes() is sufficient as a spec)\n    </VERIFICATION NOTE> */\n\n        ensures\n            choice_is_true(result) == (field_element_as_bytes(self)[0] & 1\n                == 1),\n    // SPEC BYPASS through placeholder field_element_as_bytes\n\n    {\n        let bytes = self.as_bytes();\n        let result = Choice::from(bytes[0] & 1);\n        assume(choice_is_true(result) == (field_element_as_bytes(self)[0] & 1 == 1));\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pow255_gt_19().",
      "display_name": "pow255_gt_19",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pow255_gt_19().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "use core::ops::Neg;\nuse core::ops::{Add, AddAssign};\nuse core::ops::{Mul, MulAssign};",
      "is_libsignal": false,
      "caller_count": 9,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "display_name": "double",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "            });\n        }\n\n        let result = EdwardsPoint { X, Y, Z, T: &X * &Y };\n",
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_sub_mod_noop().",
      "display_name": "lemma_sub_mod_noop",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_sub_mod_noop().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/div_mod_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_verus",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "display_name": "pow2",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 168,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "display_name": "step_2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub(super) fn step_2(\n        repr: &CompressedEdwardsY,\n        mut X: FieldElement,\n        Y: FieldElement,\n        Z: FieldElement,\n    ) -> (result: EdwardsPoint)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            field_element(&result.X)\n                ==\n            // If the sign bit is 1, negate the X field element\n            if (repr.0[31] >> 7) == 1 {\n                field_neg(field_element(&X))\n            } else {\n                field_element(&X)\n            },",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits().",
      "display_name": "determine_curve25519_dalek_bits",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "body": "    pub(super) fn determine_curve25519_dalek_bits(target_arch: &String) -> DalekBits {\n        let target_pointer_width = match std::env::var(\"CARGO_CFG_TARGET_POINTER_WIDTH\") {\n            Ok(pw) => pw,\n            Err(_) => {\n                determine_curve25519_dalek_bits_warning(ERR_MSG_NO_POINTER_WIDTH);\n                return DalekBits::Dalek32;\n            }\n        };\n\n        #[allow(clippy::match_single_binding)]\n        match &target_arch {\n            //Issues: 449 and 456\n            //TODO: When adding arch defaults use proper types not String match\n            //TODO(Arm): Needs tests + benchmarks to back this up\n            //TODO(Wasm32): Needs tests + benchmarks to back this up\n            _ => match target_pointer_width.as_ref() {\n                \"64\" => DalekBits::Dalek64,\n                \"32\" => DalekBits::Dalek32,\n                // Intended default solely for non-32/64 target pointer widths\n                // Otherwise known target platforms only.\n                _ => {\n                    determine_curve25519_dalek_bits_warning(ERR_MSG_UNKNOWN_POINTER_WIDTH);\n                    DalekBits::Dalek32\n                }\n            },\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "display_name": "optional_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "        RistrettoBasepointTable(EdwardsBasepointTable::create(&basepoint.0))\n    }\n\n    /// Get the basepoint for this table as a `RistrettoPoint`.\n    pub fn basepoint(&self) -> RistrettoPoint {\n        RistrettoPoint(self.0.basepoint())\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/read_le_u64_into().",
      "display_name": "read_le_u64_into",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/read_le_u64_into().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "fn read_le_u64_into(src: &[u8], dst: &mut [u64])/* VERIFICATION NOTE:\nPROOF BYPASS\n*/\n\n    requires\n        src.len() == 8 * old(dst).len(),\n    ensures\n        dst.len() == old(dst).len(),\n        forall|i: int|\n            0 <= i < dst.len() ==> {\n                let byte_seq = Seq::new(8, |j: int| src[i * 8 + j] as u8);\n                #[trigger] dst[i] as nat == bytes_seq_to_nat(byte_seq)\n            },",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_basics_4().",
      "display_name": "lemma_mul_basics_4",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_basics_4().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "display_name": "is_canonical_scalar",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//! let one_as_bytes: [u8; 32] = Scalar::ONE.to_bytes();\n//! let a: Option<Scalar> = Scalar::from_canonical_bytes(one_as_bytes).into();\n//!\n//! assert!(a.is_some());\n//! ```\n//!\n//! However, if we give it bytes representing a scalar larger than \\\\( \\ell \\\\)\n//! (in this case, \\\\( \\ell + 2 \\\\)), we'll get `None` back:\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let l_plus_two_bytes: [u8; 32] = [\n//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Option<Scalar> = Scalar::from_canonical_bytes(l_plus_two_bytes).into();\n//!\n//! assert!(a.is_none());\n//! ```\n//!\n//! Another way to create a `Scalar` is by reducing a \\\\(256\\\\)-bit integer mod\n//! \\\\( \\ell \\\\), for which one may use the\n//! [`Scalar::from_bytes_mod_order`](struct.Scalar.html#method.from_bytes_mod_order)\n//! method.  In the case of the second example above, this would reduce the\n//! resultant scalar \\\\( \\mod \\ell \\\\), producing \\\\( 2 \\\\):\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let l_plus_two_bytes: [u8; 32] = [\n//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Scalar = Scalar::from_bytes_mod_order(l_plus_two_bytes);\n//!\n//! let two: Scalar = Scalar::ONE + Scalar::ONE;\n//!\n//! assert!(a == two);\n//! ```\n//!\n//! There is also a constructor that reduces a \\\\(512\\\\)-bit integer,\n//! [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! To construct a `Scalar` as the hash of some input data, use\n//! [`Scalar::hash_from_bytes`], which takes a buffer, or\n//! [`Scalar::from_hash`], which allows an IUF API.\n//!\n#![cfg_attr(feature = \"digest\", doc = \"```\")]\n#![cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n//! # fn main() {\n//! use sha2::{Digest, Sha512};\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! // Hashing a single byte slice\n//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }",
      "is_libsignal": false,
      "caller_count": 14,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_telescoping().",
      "display_name": "lemma_reduction_telescoping",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_telescoping().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_reduction_telescoping(\n    input_limbs: [u64; 5],\n    final_limbs: [u64; 5],\n    q: u64,\n    c0: int,\n    c1: int,\n    c2: int,\n    c3: int,\n    c4: int,\n)\n    requires\n// The carry propagation relationships\n\n        input_limbs[0] as int + 19 * q as int == c0 * pow2(51) as int + final_limbs[0] as int,\n        input_limbs[1] as int + c0 == c1 * pow2(51) as int + final_limbs[1] as int,\n        input_limbs[2] as int + c1 == c2 * pow2(51) as int + final_limbs[2] as int,\n        input_limbs[3] as int + c2 == c3 * pow2(51) as int + final_limbs[3] as int,\n        input_limbs[4] as int + c3 == c4 * pow2(51) as int + final_limbs[4] as int,\n        // final_limbs are bounded by 2^51\n        final_limbs[0] < (1u64 << 51),\n        final_limbs[1] < (1u64 << 51),\n        final_limbs[2] < (1u64 << 51),\n        final_limbs[3] < (1u64 << 51),\n        final_limbs[4] < (1u64 << 51),\n    ensures\n        as_nat(input_limbs) as int + 19 * q as int == as_nat(final_limbs) as int + c4 * pow2(\n            255,\n        ) as int,\n{\n    // Establish power-of-2 relationships\n    lemma_pow2_pos(51);\n    lemma_pow2_adds(51, 51);\n    lemma_pow2_adds(51, 102);\n    lemma_pow2_adds(51, 153);\n    lemma_pow2_adds(51, 204);\n\n    // Expand as_nat(input_limbs) + 19*q\n    let lhs = as_nat(input_limbs) as int + 19 * q as int;\n\n    // Explicitly expand as_nat using its definition\n    assert(as_nat(input_limbs) == (input_limbs[0] as nat) + pow2(51) * (input_limbs[1] as nat)\n        + pow2(102) * (input_limbs[2] as nat) + pow2(153) * (input_limbs[3] as nat) + pow2(204) * (\n    input_limbs[4] as nat));\n\n    // Convert to int with commutativity\n    assert(as_nat(input_limbs) as int == input_limbs[0] as int + input_limbs[1] as int * pow2(\n        51,\n    ) as int + input_limbs[2] as int * pow2(102) as int + input_limbs[3] as int * pow2(153) as int\n        + input_limbs[4] as int * pow2(204) as int) by {\n        lemma_mul_is_commutative(pow2(51) as int, input_limbs[1] as int);\n        lemma_mul_is_commutative(pow2(102) as int, input_limbs[2] as int);\n        lemma_mul_is_commutative(pow2(153) as int, input_limbs[3] as int);\n        lemma_mul_is_commutative(pow2(204) as int, input_limbs[4] as int);\n    }\n\n    assert(lhs == input_limbs[0] as int + input_limbs[1] as int * pow2(51) as int\n        + input_limbs[2] as int * pow2(102) as int + input_limbs[3] as int * pow2(153) as int\n        + input_limbs[4] as int * pow2(204) as int + 19 * q as int);\n\n    // Substitute the division relationships (solve for input_limbs[i])\n\n    // Expand each term using distributivity (same pattern as lemma_radix51_telescoping_direct)\n    assert((c1 * pow2(51) as int + final_limbs[1] as int - c0) * pow2(51) as int == c1 * pow2(\n        102,\n    ) as int + final_limbs[1] as int * pow2(51) as int - c0 * pow2(51) as int) by {\n        lemma_mul_is_distributive_sub_other_way(\n            pow2(51) as int,\n            c1 * pow2(51) as int + final_limbs[1] as int,\n            c0,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(51) as int,\n            c1 * pow2(51) as int,\n            final_limbs[1] as int,\n        );\n        lemma_mul_is_associative(c1, pow2(51) as int, pow2(51) as int);\n    }\n\n    assert((c2 * pow2(51) as int + final_limbs[2] as int - c1) * pow2(102) as int == c2 * pow2(\n        153,\n    ) as int + final_limbs[2] as int * pow2(102) as int - c1 * pow2(102) as int) by {\n        lemma_mul_is_distributive_sub_other_way(\n            pow2(102) as int,\n            c2 * pow2(51) as int + final_limbs[2] as int,\n            c1,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(102) as int,\n            c2 * pow2(51) as int,\n            final_limbs[2] as int,\n        );\n        lemma_mul_is_associative(c2, pow2(51) as int, pow2(102) as int);\n    }\n\n    assert((c3 * pow2(51) as int + final_limbs[3] as int - c2) * pow2(153) as int == c3 * pow2(\n        204,\n    ) as int + final_limbs[3] as int * pow2(153) as int - c2 * pow2(153) as int) by {\n        lemma_mul_is_distributive_sub_other_way(\n            pow2(153) as int,\n            c3 * pow2(51) as int + final_limbs[3] as int,\n            c2,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(153) as int,\n            c3 * pow2(51) as int,\n            final_limbs[3] as int,\n        );\n        lemma_mul_is_associative(c3, pow2(51) as int, pow2(153) as int);\n    }\n\n    assert((c4 * pow2(51) as int + final_limbs[4] as int - c3) * pow2(204) as int == c4 * pow2(\n        255,\n    ) as int + final_limbs[4] as int * pow2(204) as int - c3 * pow2(204) as int) by {\n        lemma_mul_is_distributive_sub_other_way(\n            pow2(204) as int,\n            c4 * pow2(51) as int + final_limbs[4] as int,\n            c3,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(204) as int,\n            c4 * pow2(51) as int,\n            final_limbs[4] as int,\n        );\n        lemma_mul_is_associative(c4, pow2(51) as int, pow2(204) as int);\n    }\n\n    // Now perform the telescoping sum\n    // lhs = input_limbs[0] + input_limbs[1]*2^51 + input_limbs[2]*2^102 + input_limbs[3]*2^153 + input_limbs[4]*2^204 + 19*q\n\n    // Substitute input_limbs[0]:\n    // = (c0*2^51 + final_limbs[0] - 19*q) + input_limbs[1]*2^51 + ... + 19*q\n    // = c0*2^51 + final_limbs[0] + input_limbs[1]*2^51 + ...\n\n    // Substitute input_limbs[1]:\n    // = c0*2^51 + final_limbs[0] + (c1*2^51 + final_limbs[1] - c0)*2^51 + input_limbs[2]*2^102 + ...\n    // = c0*2^51 + final_limbs[0] + c1*2^102 + final_limbs[1]*2^51 - c0*2^51 + input_limbs[2]*2^102 + ...\n    // = final_limbs[0] + final_limbs[1]*2^51 + c1*2^102 + input_limbs[2]*2^102 + ...\n\n    // Continue substituting - the c0*2^51 terms cancel, then c1*2^102 terms cancel, etc.\n\n    // Expand lhs using the substitutions\n    let rhs = final_limbs[0] as int + final_limbs[1] as int * pow2(51) as int\n        + final_limbs[2] as int * pow2(102) as int + final_limbs[3] as int * pow2(153) as int\n        + final_limbs[4] as int * pow2(204) as int + c4 * pow2(255) as int;\n\n    // Show that lhs == rhs through algebraic expansion\n    assert(lhs == (c0 * pow2(51) as int + final_limbs[0] as int - 19 * q as int) + (c1 * pow2(\n        51,\n    ) as int + final_limbs[1] as int - c0) * pow2(51) as int + (c2 * pow2(51) as int\n        + final_limbs[2] as int - c1) * pow2(102) as int + (c3 * pow2(51) as int\n        + final_limbs[3] as int - c2) * pow2(153) as int + (c4 * pow2(51) as int\n        + final_limbs[4] as int - c3) * pow2(204) as int + 19 * q as int);\n\n    // Use the distributivity facts we proved above\n    assert(lhs == (c0 * pow2(51) as int + final_limbs[0] as int - 19 * q as int) + (c1 * pow2(\n        102,\n    ) as int + final_limbs[1] as int * pow2(51) as int - c0 * pow2(51) as int) + (c2 * pow2(\n        153,\n    ) as int + final_limbs[2] as int * pow2(102) as int - c1 * pow2(102) as int) + (c3 * pow2(\n        204,\n    ) as int + final_limbs[3] as int * pow2(153) as int - c2 * pow2(153) as int) + (c4 * pow2(\n        255,\n    ) as int + final_limbs[4] as int * pow2(204) as int - c3 * pow2(204) as int) + 19 * q as int);\n\n    // Group terms: the carries telescope\n    // c0*2^51 - c0*2^51 = 0\n    // c1*2^102 - c1*2^102 = 0\n    // c2*2^153 - c2*2^153 = 0\n    // c3*2^204 - c3*2^204 = 0\n    // -19*q + 19*q = 0\n    // What remains: final_limbs terms + c4*2^255\n\n    assert(lhs == final_limbs[0] as int + final_limbs[1] as int * pow2(51) as int\n        + final_limbs[2] as int * pow2(102) as int + final_limbs[3] as int * pow2(153) as int\n        + final_limbs[4] as int * pow2(204) as int + c4 * pow2(255) as int);\n\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn default() -> CompressedRistretto {\n        CompressedRistretto::identity()\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#ValidityCheck#is_valid().",
      "display_name": "is_valid",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#ValidityCheck#is_valid().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "            field_element(&result.2) == field_element_from_bytes(&repr.0),\n            // The returned Z field element is 1\n            field_element(&result.3) == 1,\n            // The choice is true iff the Y is valid and (X, Y) is on the curve\n            choice_is_true(result.0) <==> is_valid_y_coordinate(field_element(&result.2)),\n            choice_is_true(result.0) ==> on_edwards_curve(\n                field_element(&result.1),\n                field_element(&result.2),\n            ),\n    {\n        let Y = FieldElement::from_bytes(repr.as_bytes());\n        assert(field_element_from_bytes(&repr.0) == field_element(&Y));\n        let Z = FieldElement::ONE;\n        proof {\n            assume(forall|i: int| 0 <= i < 5 ==> Y.limbs[i] < 1u64 << 54);\n        }\n        let YY = Y.square();\n\n        /* <VERIFICATION NOTE>\n        Assume preconditions for field operations with *SpecImpl traits.\n        </VERIFICATION NOTE> */\n        proof {\n            // For Sub (YY - Z): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> YY.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> Z.limbs[i] < (1u64 << 54));\n\n            // For Mul (YY * EDWARDS_D): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> constants::EDWARDS_D.limbs[i] < (1u64 << 54));\n        }\n        let u = &YY - &Z;  // u =  y²-1\n        let yy_times_d = &YY * &constants::EDWARDS_D;\n        proof {\n            // For Add (yy_times_d + Z): requires no overflow\n            assume(forall|i: int|\n                0 <= i < 5 ==> #[trigger] (yy_times_d.limbs[i] + Z.limbs[i]) <= u64::MAX);\n        }\n        let v = &yy_times_d + &Z;  // v = dy²+1\n\n        let (is_valid_y_coord, X) = FieldElement::sqrt_ratio_i(&u, &v);\n\n        proof {\n            // Assume postconditions that depend on sqrt_ratio_i behavior\n            assume(field_element(&Z) == 1);\n            // Note: Using <==> (bi-implication) to match the postcondition exactly\n            assume(choice_is_true(is_valid_y_coord) <==> is_valid_y_coordinate(field_element(&Y)));\n            assume(choice_is_true(is_valid_y_coord) ==> on_edwards_curve(\n                field_element(&X),\n                field_element(&Y),\n            ));\n        }\n        (is_valid_y_coord, X, Y, Z)\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_verus/u64/serial/backend/sum_bounds().",
      "display_name": "sum_bounds",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_verus/u64/serial/backend/sum_bounds().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/sum_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/sum_lemmas.rs",
      "file_name": "sum_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn sum_bounds(coefs: Seq<nat>, k: nat, s: nat)\n    requires\n        k <= coefs.len(),\n        forall|i: nat|\n            0 <= i <= k ==> #[trigger] coefs[i as int] <= pow2((i + 1) * s) - pow2(i * s),\n    ensures\n        seq_sum(coefs, k) <= pow2((k + 1) * s) - 1,\n    decreases k,\n{\n    if (k == 0) {\n        assert(pow2(0) == 1) by {\n            lemma2_to64();\n        }\n    } else {\n        assert(seq_sum(coefs, k) == seq_sum(coefs, (k - 1) as nat) + coefs[k as int]) by {\n            reveal_with_fuel(seq_sum, 1);\n        }\n\n        assert(seq_sum(coefs, (k - 1) as nat) <= pow2(k * s) - 1) by {\n            sum_bounds(coefs, (k - 1) as nat, s);\n        }\n\n        // \"requires\" for i = k\n        assert(coefs[k as int] <= pow2((k + 1) * s) - pow2(k * s));\n\n        assert((pow2((k + 1) * s) - pow2(k * s)) + (pow2(k * s) - 1) == pow2((k + 1) * s) - 1) by {\n            assert(pow2((k + 1) * s) >= pow2(k * s)) by {\n                if (s > 0) {\n                    assert((k + 1) * s == k * s + s) by {\n                        lemma_mul_is_distributive_add_other_way(s as int, k as int, 1);\n                    }\n                    lemma_pow2_strictly_increases(k * s, (k + 1nat) * s);\n                }\n            }\n\n            assert(pow2((k + 1) * s) >= 1) by {\n                assert(1 == pow2(0)) by {\n                    lemma2_to64();\n                }\n                if (s > 0) {\n                    assert(0 < (k + 1) * s) by {\n                        lemma_mul_strictly_positive((k + 1) as int, s as int);\n                    }\n                    lemma_pow2_strictly_increases(0, (k + 1nat) * s);\n                }\n            }\n        }\n    }\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc string/String#AsRef#as_ref().",
      "display_name": "as_ref",
      "symbol": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc string/String#AsRef#as_ref().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_bounded_shr_51().",
      "display_name": "lemma_bounded_shr_51",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_bounded_shr_51().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_bounded_shr_51(x: u64)\n    requires\n        x < 3 * pow2(51),\n    ensures\n        (x >> 51) < 3,\n{\n    lemma_pow2_pos(51);\n    lemma_mul_is_commutative(3, pow2(51) as int);\n\n    let shifted = x >> 51;\n    lemma_u64_shr_is_div(x, 51);\n    lemma_div_strictly_bounded(x as int, pow2(51) as int, 3);\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/pow2_MUL_div_mod_u8_t51_cond().",
      "display_name": "pow2_MUL_div_mod_u8_t51_cond",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/pow2_MUL_div_mod_u8_t51_cond().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn pow2_MUL_div_mod_u8_t51_cond(k: nat, j: nat) -> bool {\n    (k <= j * 8) && (51 <= j * 8 - k)\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#encode_253_bits().",
      "display_name": "encode_253_bits",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#encode_253_bits().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    pub fn encode_253_bits(data: &[u8; 32]) -> Option<RistrettoPoint> {\n        if data.len() != 32 {\n            return None;\n        }\n\n        let fe = FieldElement::from_bytes(data);\n        let p = RistrettoPoint::elligator_ristretto_flavor(&fe);\n        Some(p)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_7_terms().",
      "display_name": "mul_7_terms",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_7_terms().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "    assert(((bytes[6] as nat % pow2(3)) * pow2(6 * 8)) + pow2(51) * (bytes[6] as nat / pow2(3))\n        == bytes[6] * pow2(6 * 8)) by {\n        assemble_mod_div(bytes[6] as nat, 3, 6 * 8);\n    }",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_3_terms().",
      "display_name": "mul_3_terms",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_3_terms().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn mul_3_terms(n: int, x1: int, x2: int, x3: int)\n    ensures\n        n * (x1 + x2 + x3) == (x1 + x2 + x3) * n == n * x1 + n * x2 + n * x3,\n{\n    assert(n * (x1 + x2 + x3) == (x1 + x2 + x3) * n) by {\n        lemma_mul_is_commutative(n, x1 + x2 + x3);\n    }\n\n    assert(n * (x1 + x2 + x3) == n * (x1 + x2) + n * x3) by {\n        lemma_mul_is_distributive_add(n, x1 + x2, x3);\n    }\n\n    assert(n * (x1 + x2) == n * x1 + n * x2) by {\n        lemma_mul_is_distributive_add(n, x1, x2);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_y_coordinate().",
      "display_name": "is_valid_y_coordinate",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_y_coordinate().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/curve_specs.rs",
      "relative_path": "src/curve_specs.rs",
      "file_name": "curve_specs.rs",
      "parent_folder": "src",
      "body": "pub open spec fn is_valid_y_coordinate(y: nat) -> bool {\n    let d = field_element(&crate::backend::serial::u64::constants::EDWARDS_D);\n    let y2 = field_square(y);\n\n    // Compute u = y² - 1\n    let u = field_sub(y2, 1);\n\n    // Compute v = d·y² + 1\n    let v = field_add(field_mul(d, y2), 1);\n\n    if u % p() == 0 {\n        // If u = 0, then y² = 1, so y = ±1, which gives valid points (x=0, y=±1)\n        true\n    } else if v % p() == 0 {\n        // If v = 0 but u ≠ 0, division by zero case - invalid\n        false\n    } else {\n        // Check if there exists r such that r² * v ≡ ±u (mod p)\n        // This is what sqrt_ratio_i determines\n        exists|r: nat|\n            r < p() && (#[trigger] field_mul(field_square(r), v) == u % p() || #[trigger] field_mul(\n                field_square(r),\n                v,\n            ) == field_neg(u))\n    }\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "display_name": "montgomery_reduce",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    }\n}\n\ndefine_sub_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> SubAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    #[allow(clippy::op_ref)]\n    fn sub_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        *self = &*self - _rhs;\n    }\n}",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "display_name": "as_radix_2w",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "pub(crate) fn as_radix_2w(&self, w: usize) -> (result:\n    [i8; 64])\n// VERIFICATION NOTE: PROOF BYPASS\n\n    requires\n        4 <= w <= 8,\n        // For w=4 (radix 16), top bit must be clear\n        w == 4 ==> self.bytes[31] <= 127,\n    ensures\n        ({\n            let digits_count = if w < 8 {\n                (256 + (w as int) - 1) / (w as int)\n            } else {\n                (256 + (w as int) - 1) / (w as int) + 1\n            };\n            // Result digits are in valid range for the given window size\n            is_valid_radix_2w(&result, w as nat, digits_count as nat)\n                &&\n            // Reconstruction property: digits reconstruct the scalar value\n            reconstruct_radix_2w(result@.take(digits_count), w as nat) == scalar_to_nat(self) as int\n        }),",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base().",
      "display_name": "mul_base",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_base(scalar: &Scalar) -> Self {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        {\n            scalar * constants::ED25519_BASEPOINT_POINT\n        }\n\n        #[cfg(feature = \"precomputed-tables\")]\n        {\n            scalar * constants::ED25519_BASEPOINT_TABLE\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_multiscalar_mul().",
      "display_name": "straus_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "impl ConstantTimeEq for CompressedEdwardsY {\n    fn ct_eq(&self, other: &CompressedEdwardsY) -> (result: Choice)\n        ensures\n            choice_is_true(result) == (self.0 == other.0),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function ct_eq_bytes32 instead of direct subtle call to ct_eq for Verus compatibility.\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.as_bytes().ct_eq(other.as_bytes())\n         </ORIGINAL CODE> */\n        ct_eq_bytes32(self.as_bytes(), other.as_bytes())\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo digest 0.10.7 digest/Digest#digest().",
      "display_name": "digest",
      "symbol": "rust-analyzer cargo digest 0.10.7 digest/Digest#digest().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn identity() -> (result:\n        CompressedEdwardsY)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            is_compressed_identity(result),\n    {\n        let result = CompressedEdwardsY(\n            [\n                1,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n            ],\n        );\n\n        proof {\n            // The bytes [1, 0, 0, ..., 0] represent the value 1 in little-endian\n            // byte 31 is 0, so the sign bit (bit 7 of byte 31) is 0\n            assert(result.0[31] == 0);\n            let x = result.0[31];\n            assume(x >> 7 == 0);\n            // field_element_from_bytes([1, 0, ...]) should equal 1\n            // This requires the byte-to-nat conversion to recognize [1,0,0,...] = 1\n            assume(field_element_from_bytes(&result.0) == 1);\n        }\n\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core empty/sources/iter/empty().",
      "display_name": "empty",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core empty/sources/iter/empty().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_square_internal_no_overflow().",
      "display_name": "lemma_square_internal_no_overflow",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_square_internal_no_overflow().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_square_internal_no_overflow()\n    ensures\n        (1u128 << 105) + (1u128 << 105) == (1u128 << 106),\n        (1u128 << 105) + (1u128 << 104) < (1u128 << 106),\n        (1u128 << 104) * 2 == (1u128 << 105),\n        (1u128 << 106) + (1u128 << 104) < (1u128 << 107),\n{\n    assert((1u128 << 105) + (1u128 << 105) == (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 105) + (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 104) * 2 == (1u128 << 105)) by (bit_vector);\n    assert((1u128 << 106) + (1u128 << 104) < (1u128 << 107)) by (bit_vector);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#elligator_ristretto_flavor_inverse().",
      "display_name": "elligator_ristretto_flavor_inverse",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#elligator_ristretto_flavor_inverse().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    pub fn elligator_ristretto_flavor_inverse(&self) -> (u8, [FieldElement; 8]) {\n        // Elligator2 computes a Point from a FieldElement in two steps: first\n        // it computes a (s,t) on the Jacobi quartic and then computes the\n        // corresponding even point on the Edwards curve.\n        //\n        // We invert in three steps.  Any Ristretto point has four representatives\n        // as even Edwards points.  For each of those even Edwards points,\n        // there are two points on the Jacobi quartic that map to it.\n        // Each of those eight points on the Jacobi quartic might have an\n        // Elligator2 preimage.\n        //\n        // Essentially we first loop over the four representatives of our point,\n        // then for each of them consider both points on the Jacobi quartic and\n        // check whether they have an inverse under Elligator2.  We take the\n        // following shortcut though.\n        //\n        // We can compute two Jacobi quartic points for (x,y) and (-x,-y)\n        // at the same time.  The four Jacobi quartic points are two of\n        // such pairs.\n\n        let mut mask: u8 = 0;\n        let jcs = self.to_jacobi_quartic_ristretto();\n        let mut ret = [FieldElement::ONE; 8];\n\n        for i in 0..4 {\n            let (ok, fe) = jcs[i].elligator_inv();\n            let mut tmp: u8 = 0;\n            ret[2 * i] = fe;\n            tmp.conditional_assign(&1, ok);\n            mask |= tmp << (2 * i);\n\n            let jc = jcs[i].dual();\n            let (ok, fe) = jc.elligator_inv();\n            let mut tmp: u8 = 0;\n            ret[2 * i + 1] = fe;\n            tmp.conditional_assign(&1, ok);\n            mask |= tmp << (2 * i + 1);\n        }\n\n        (mask, ret)\n    }",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_twice().",
      "display_name": "lemma_mod_twice",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_twice().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/div_mod_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_verus",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes().",
      "display_name": "from_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//! assert_eq!(a, a2);\n//! # }\n//! ```\n//!\n//! See also `Scalar::hash_from_bytes` and `Scalar::from_hash` that\n//! reduces a \\\\(512\\\\)-bit integer, if the optional `digest` feature\n//! has been enabled.\n\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::{Product, Sum};\nuse core::ops::Index;",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_u8_cast_is_mod_256().",
      "display_name": "lemma_u8_cast_is_mod_256",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_u8_cast_is_mod_256().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "    assert(as_nat_32_u8(&bytes) == limb0_contribution + limb1_contribution + limb2_contribution\n        + limb3_contribution + limb4_contribution);\n\n    // Therefore, the sum equals as_nat(limbs)\n}\n\n/// Helper: A byte formed by simple right shift has a direct arithmetic interpretation\nproof fn lemma_byte_from_limb_shift(limb: u64, shift: u64, byte: u8)\n    requires\n        limb < pow2(51),\n        shift < 64,\n        byte == (limb >> shift) as u8,\n    ensures\n        byte as nat == (limb as nat / pow2(shift as nat)) % 256,\n{\n    // Bitwise shift to arithmetic conversion\n    // When we shift right by `shift` bits and cast to u8, we extract 8 bits starting at position `shift`\n    // In arithmetic terms: (limb / 2^shift) % 256\n    lemma2_to64();\n    lemma_u64_shr_is_div(limb, shift);\n    assert((limb >> shift) as nat == limb as nat / pow2(shift as nat));\n\n    // The u8 cast takes the low 8 bits, which is % 256\n    assert((limb >> shift) as u8 == (limb >> shift) as nat % 256) by {\n        lemma_u8_cast_is_mod_256(limb >> shift);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_stage_division_theorem().",
      "display_name": "lemma_stage_division_theorem",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_stage_division_theorem().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_stage_division_theorem(limb: u64, carry_in: int, carry_out: int) -> (r: int)\n    requires\n        limb < (1u64 << 52),\n        carry_out == (limb as int + carry_in) / pow2(51) as int,\n    ensures\n        (limb as int + carry_in) == carry_out * pow2(51) as int + r,\n        0 <= r < pow2(51) as int,\n{\n    assert(pow2(51) > 0) by {\n        lemma_pow2_pos(51);\n    }\n    lemma_fundamental_div_mod((limb as int + carry_in), pow2(51) as int);\n    let r = (limb as int + carry_in) % pow2(51) as int;\n    lemma_mod_bound((limb as int + carry_in), pow2(51) as int);\n    r\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "display_name": "add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }\n\n    /// Construct a `Scalar` by reducing a 512-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    // VERIFICATION NOTE: VERIFIED\n    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == bytes_wide_to_nat(input) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self(crate::backend::VartimePrecomputedStraus::new(\n            static_points.into_iter().map(|P| P.borrow().0),\n        ))\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_inequality().",
      "display_name": "lemma_mul_inequality",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_inequality().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "display_name": "batch_invert",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn batch_invert(inputs: &mut [Scalar]) -> (result:\n        Scalar)/* <VERIFICATION NOTE>\n     Refactored for Verus: Index loops instead of iterators, manual Vec construction, ..\n    </VERIFICATION NOTE> */\n\n        ensures\n    // Result is the modular inverse of the product of all original inputs\n\n            is_inverse_of_nat(&result, product_of_scalars(old(inputs)@)),\n            // Each input is replaced with its inverse\n            forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ),\n    {\n        // This code is essentially identical to the FieldElement\n        // implementation, and is documented there.  Unfortunately,\n        // it's not easy to write it generically, since here we want\n        // to use `UnpackedScalar`s internally, and `Scalar`s\n        // externally, but there's no corresponding distinction for\n        // field elements.\n        let n = inputs.len();\n        let one_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(limbs_bounded(&one_unpacked));\n        }\n\n        let one: UnpackedScalar = one_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&one));\n        }\n\n        /* <VERIFICATION NOTE>\n         Build vec manually instead of vec![one; n] for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let mut scratch = vec![one; n];\n         </ORIGINAL CODE> */\n        let mut scratch = Vec::new();\n        for _ in 0..n {\n            scratch.push(one);\n        }\n\n        // Keep an accumulator of all of the previous products\n        let acc_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(scratch.len() == n);\n            assume(limbs_bounded(&acc_unpacked));\n        }\n\n        let mut acc = acc_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        /* <VERIFICATION NOTE>\n         Rewritten with index loop instead of .zip() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         for (input, scratch) in inputs.iter_mut().zip(scratch.iter_mut()) {\n             *scratch = acc;\n        //     // Avoid unnecessary Montgomery multiplication in second pass by\n        //     // keeping inputs in Montgomery form\n             let tmp = input.unpack().as_montgomery();\n             *input = tmp.pack();\n             acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n         }\n        </ORIGINAL CODE> */\n        for i in 0..n\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                limbs_bounded(&acc),\n        {\n            scratch[i] = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = input_unpacked.as_montgomery();\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n\n            proof {\n                assume(limbs_bounded(&acc));\n            }\n        }\n\n        proof {\n            // Assert that all scratch elements have bounded limbs\n            assume(forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]));\n        }\n\n        // acc is nonzero iff all inputs are nonzero\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert!(acc.pack() != Scalar::ZERO);\n\n        // Compute the inverse of all products\n        // ORIGINAL CODE: acc = acc.montgomery_invert().from_montgomery();\n        acc = acc.montgomery_invert();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        acc = acc.from_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // We need to return the product of all inverses later\n        let ret = acc.pack();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        /* <VERIFICATION NOTE>\n         Manual reverse loop instead of .rev() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.iter().rev()) {\n             let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n             *input = UnpackedScalar::montgomery_mul(&acc, scratch).pack();\n             acc = tmp;\n         }\n        </ORIGINAL CODE> */\n        let mut i: usize = n;\n        while i > 0\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                i <= n,\n                limbs_bounded(&acc),\n                forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]),\n            decreases i,\n        {\n            i -= 1;\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input_unpacked);\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = UnpackedScalar::montgomery_mul(&acc, &scratch[i]).pack();\n            acc = tmp;\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        #[cfg(not(verus_keep_ghost))]\n        Zeroize::zeroize(&mut scratch);\n\n        proof {\n            // Assume the postconditions\n            assume(is_inverse_of_nat(&ret, product_of_scalars(old(inputs)@)));\n            assume(forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ));\n        }\n\n        ret\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/m().",
      "display_name": "m",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/m().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "fn m(x: u64, y: u64) -> (z: u128)\n    requires\n        x < (1u64 << 52),\n        y < (1u64 << 52),\n    ensures\n        z < (1u128 << 104),\n        z == x * y,\n{\n    proof {\n        lemma_52_52(x, y);\n    }\n    (x as u128) * (y as u128)\n}",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_div_decomposition().",
      "display_name": "sum_div_decomposition",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_div_decomposition().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn sum_div_decomposition(a: nat, b: nat, s: nat, k: nat)\n    requires\n        a < pow2(s),\n    ensures\n        (a + b * pow2(s)) / pow2(k) == a / pow2(k) + (b * pow2(s)) / pow2(k),\n{\n    let ps = pow2(s);\n    let pk = pow2(k);\n    let x = a;\n    let y = b * ps;\n    let z = x + y;\n\n    assert(pk > 0) by {\n        lemma_pow2_pos(k);\n    }\n\n    assert(x == pk * (x / pk) + x % pk) by {\n        lemma_fundamental_div_mod(x as int, pk as int);\n    }\n\n    assert(y == pk * (y / pk) + y % pk) by {\n        lemma_fundamental_div_mod(y as int, pk as int);\n    }\n\n    assert(z % pk == x % pk + y % pk) by {\n        sum_mod_decomposition(a, b, s, k);\n    }\n\n    assert(z == x + y == pk * (x / pk + y / pk) + z % pk) by {\n        lemma_mul_is_distributive_add(pk as int, (x / pk) as int, (y / pk) as int);\n    }\n\n    assert(z == pk * (z / pk) + z % pk) by {\n        lemma_fundamental_div_mod(z as int, pk as int);\n    }\n\n    assert(z / pk == x / pk + y / pk) by {\n        lemma_mul_equality_converse(pk as int, (z / pk) as int, (x / pk + y / pk) as int);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_quad_prod().",
      "display_name": "mul_quad_prod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_quad_prod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn mul_quad_prod(a1: int, b1: int, a2: int, b2: int)\n    ensures\n        (a1 * b1) * (a2 * b2) == (a1 * a2) * (b1 * b2),\n{\n    // commutativity is baked-in\n    // (a1 * b1) * (a2 * b2) =  ((a1 * b1) * a2) * b2\n    lemma_mul_is_associative(a1 * b1, a2, b2);\n    // (a1 * b1) * a2 = a2 * (a1 * b1) = (a2 * a1) * b1\n    lemma_mul_is_associative(a2, a1, b1);\n    // ((a2 * a1) * b1) * b2 = (a2 * a1) * (b1 * b2)\n    lemma_mul_is_associative(a2 * a1, b1, b2);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Neg#neg().",
      "display_name": "neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Neg#neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn neg(self) -> AffineNielsPoint {\n        AffineNielsPoint {\n            y_plus_x: self.y_minus_x,\n            y_minus_x: self.y_plus_x,\n            xy2d: -(&self.xy2d),\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#MulAssign#mul_assign().",
      "display_name": "mul_assign",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#MulAssign#mul_assign().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn mul_assign(&mut self, scalar: &'b Scalar) {\n        let result = (self as &RistrettoPoint) * scalar;\n        *self = result;\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#mul_base().",
      "display_name": "mul_base",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#mul_base().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_base(scalar: &Scalar) -> Self {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_POINT\n        }\n\n        #[cfg(feature = \"precomputed-tables\")]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_TABLE\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/wrapping_sub().",
      "display_name": "wrapping_sub",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/wrapping_sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Sub#sub().",
      "display_name": "sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Sub#sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn sub(self, other: &'b EdwardsPoint) -> EdwardsPoint {\n        (self - &other.as_projective_niels()).as_extended()\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mul_internal_no_overflow().",
      "display_name": "lemma_mul_internal_no_overflow",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mul_internal_no_overflow().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_mul_internal_no_overflow()\n    ensures\n        (1u128 << 104) + (1u128 << 104) == (1u128 << 105),\n        3u128 * (1u128 << 104) < (1u128 << 106),\n        4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104),\n        (1u128 << 2) * (1u128 << 104) == (1u128 << 106),\n        8u128 == (1u128 << 3),\n        (1u128 << 3) * (1u128 << 104) == (1u128 << 107),\n{\n    assert((1u128 << 104) + (1u128 << 104) == (1u128 << 105)) by (bit_vector);\n    assert(3u128 * (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert(4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104)) by (bit_vector);\n    assert((1u128 << 2) * (1u128 << 104) == (1u128 << 106)) by (bit_vector);\n    assert(8u128 == (1u128 << 3)) by (bit_vector);\n    assert((1u128 << 3) * (1u128 << 104) == (1u128 << 107)) by (bit_vector);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mod_cancel().",
      "display_name": "lemma_mod_cancel",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mod_cancel().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_mod_cancel(a: &Scalar52, b: &Scalar52)\n    ensures\n        (group_order() + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int) == (to_nat(\n            &a.limbs,\n        ) - to_nat(&b.limbs)) % (group_order() as int),\n{\n    lemma_mod_add_multiples_vanish(\n        (to_nat(&a.limbs) - to_nat(&b.limbs)) as int,\n        group_order() as int,\n    );\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "display_name": "p",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/curve_specs.rs",
      "relative_path": "src/curve_specs.rs",
      "file_name": "curve_specs.rs",
      "parent_folder": "src",
      "body": "/// where d = -121665/121666 (mod p)\n/// Check if a point (x, y) satisfies the Edwards curve equation\n/// -x² + y² = 1 + d·x²·y²  (mod p)\npub open spec fn on_edwards_curve(x: nat, y: nat) -> bool {\n    let p = p();\n    let d = field_element(&crate::backend::serial::u64::constants::EDWARDS_D);\n    let x2 = field_square(x);\n    let y2 = field_square(y);\n    let x2y2 = field_mul(x2, y2);\n\n    // -x² + y² = 1 + d·x²·y²\n    let lhs = field_sub(y2, x2);  // y² - x²\n    let rhs = field_add(1, field_mul(d, x2y2));  // 1 + d·x²·y²\n\n    lhs == rhs\n}",
      "is_libsignal": false,
      "caller_count": 44,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "display_name": "map",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 14,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_lt().",
      "display_name": "mul_lt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_lt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/reduce_lemmas.rs",
      "file_name": "reduce_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "use super::super::common_verus::div_mod_lemmas::*;\nuse super::super::common_verus::mask_lemmas::*;\nuse super::super::common_verus::mul_lemmas::*;\nuse super::super::common_verus::pow_lemmas::*;\nuse super::super::common_verus::shift_lemmas::*;\nuse super::field_core::*;\nuse super::pow2_51_lemmas::*;\n\nverus! {\n\n// Each component of spec_reduce is bounded.\n// The reason we _don't_ write\n// ensures forall |i: int| 0 <= i < 5 ==> spec_reduce(limbs)[i] < (1u64 << 52)\n// is that the solver treats `spec_reduce`` above as symbolic and does _not_ instantiate e.g.\n// ((limbs[4] & mask51) + (limbs[3] >> 51)) as u64 < (1u64 << 52)\npub proof fn lemma_boundaries(limbs: [u64; 5])\n    ensures\n        ((limbs[0] & mask51) + (limbs[4] >> 51) * 19) < (1u64 << 52),\n        ((limbs[1] & mask51) + (limbs[0] >> 51)) < (1u64 << 52),\n        ((limbs[2] & mask51) + (limbs[1] >> 51)) < (1u64 << 52),\n        ((limbs[3] & mask51) + (limbs[2] >> 51)) < (1u64 << 52),\n        ((limbs[4] & mask51) + (limbs[3] >> 51)) < (1u64 << 52),\n{\n    // \\A i. limbs[i] < 2^13\n    shifted_lt(limbs[0], 51);\n    shifted_lt(limbs[1], 51);\n    shifted_lt(limbs[2], 51);\n    shifted_lt(limbs[3], 51);\n    shifted_lt(limbs[4], 51);\n\n    // \\A i. limbs[i] & mask51 < 2^51\n    masked_lt_51(limbs[0]);\n    masked_lt_51(limbs[1]);\n    masked_lt_51(limbs[2]);\n    masked_lt_51(limbs[3]);\n    masked_lt_51(limbs[4]);\n\n    // Since 19 < 2^5 and (limbs[4] >> 51) < 2^13, their product is less than 2^18\n    assert((limbs[4] >> 51) * 19 < (1u64 << 18) as nat) by {\n        assert(19 < (1u64 << 5)) by (bit_vector);\n        shift_is_pow2(5);\n        shift_is_pow2(13);\n        shift_is_pow2(18);\n        lemma_pow2_adds(13, 5);\n        // If (limbs[4] >> 51) < 2^13 and 19 < 2^5 then their product is less than 2^18\n        mul_lt((limbs[4] >> 51) as nat, (1u64 << 13) as nat, 19nat, (1u64 << 5) as nat);\n    }\n\n    // The final values (limbs[i] += cX) are all bounded by 2^51 + eps, for eps \\in {2^18, 2^13}.\n    assert(((1u64 << 18)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n    assert(((1u64 << 13)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n\n    // In summary, they're all bounded by 2^52\n    // The solver can prove this automatically\n}\n\npub proof fn lemma_reduce(limbs: [u64; 5])\n    ensures\n        forall|i: int| 0 <= i < 5 ==> spec_reduce(limbs)[i] < (1u64 << 52),\n        // Suppose l = (l0, l1, l2, l3, l4) are the input limbs.\n        // They represent a number\n        // e(l) =  l0 + l1 * 2^51 + l2 * 2^102 + l3 * 2^153 + l4 * 2^204\n        // in Z_p, for p = 2^255 - 19\n        // reduce(l) returns v = (v0, v1, v2, v3, v4), such that\n        // v0 = 19 * a4 + b0\n        // v1 =      a0 + b1\n        // v2 =      a1 + b2\n        // v3 =      a2 + b3\n        // v4 =      a3 + b4\n        // where ai = li >> 51 and bi = li & mask51\n        // we can reformulate this as ai = li / 2^51 (flooring division) and bi = li % 2^51\n        // Using the following identity connecting integer division and remainder:\n        // x = y * (x / y) + x % y\n        // we can see that li = ai * 2^51 + bi\n        // Plugging the above identities into the equations for v, we can observe that\n        // e(v) = e(l) - p * (l4 >> 51)\n        // IOW, e(reduce(l)) = e(l) (mod p)\n        // additionally, if all limbs are below 2^51, reduce(l) = l\n        (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (spec_reduce(limbs) =~= limbs),\n        as_nat(spec_reduce(limbs)) == as_nat(limbs) - p() * (limbs[4] >> 51),\n        as_nat(spec_reduce(limbs)) % p() == as_nat(limbs) % p(),\n{\n    // -----\n    // reduce identity for small limbs\n    // Can't seem to reference r within this proof block, we reconstruct it here\n    let rr: [u64; 5] = spec_reduce(limbs);\n\n    assert((forall|i: int| 0 <= i < 5 ==> #[trigger] limbs[i] < (1u64 << 51)) ==> (rr =~= limbs))\n        by {\n        if (forall|i: int| 0 <= i < 5 ==> #[trigger] limbs[i] < (1u64 << 51)) {\n            assert forall|i: int| 0 <= i < 5 implies #[trigger] limbs[i] & mask51 == limbs[i] by {\n                l51_bit_mask_lt();  // mask51 = low_bits_mask(51)\n                shift_is_pow2(51);\n                lemma_u64_low_bits_mask_is_mod(limbs[i], 51);\n                lemma_small_mod(limbs[i] as nat, pow2(51));\n            }\n            assert forall|i: int| 0 <= i < 5 implies #[trigger] limbs[i] >> 51 == 0 by {\n                l51_bit_mask_lt();  // mask51 = low_bits_mask(51)\n                shift_is_pow2(51);\n                lemma_u64_shr_is_div(limbs[i], 51);\n                lemma_basic_div(limbs[i] as int, pow2(51) as int);\n            }\n        }\n    }\n\n    // -- as_nat identity\n\n    // ai = limbs[i] / 2^52\n    let a0 = (limbs[0] >> 51);\n    let a1 = (limbs[1] >> 51);\n    let a2 = (limbs[2] >> 51);\n    let a3 = (limbs[3] >> 51);\n    let a4 = (limbs[4] >> 51);\n\n    // bi = limbs[i] % 2^52\n    let b0 = (limbs[0] & mask51);\n    let b1 = (limbs[1] & mask51);\n    let b2 = (limbs[2] & mask51);\n    let b3 = (limbs[3] & mask51);\n    let b4 = (limbs[4] & mask51);\n\n    lemma_boundaries(limbs);\n\n    // distribute\n    assert(as_nat(rr) == 19 * a4 + b0 + pow2(51) * a0 + pow2(51) * b1 + pow2(102) * a1 + pow2(102)\n        * b2 + pow2(153) * a2 + pow2(153) * b3 + pow2(204) * a3 + pow2(204) * b4) by {\n        lemma_mul_is_distributive_add(pow2(51) as int, a0 as int, b1 as int);\n        lemma_mul_is_distributive_add(pow2(102) as int, a1 as int, b2 as int);\n        lemma_mul_is_distributive_add(pow2(153) as int, a2 as int, b3 as int);\n        lemma_mul_is_distributive_add(pow2(204) as int, a3 as int, b4 as int);\n    }\n\n    // factor out\n    assert(as_nat(rr) == 19 * a4 + b0 + pow2(51) * a0 + pow2(51) * b1 + pow2(51) * (pow2(51) * a1)\n        + pow2(102) * b2 + pow2(102) * (pow2(51) * a2) + pow2(153) * b3 + pow2(153) * (pow2(51)\n        * a3) + pow2(204) * b4) by {\n        lemma_two_factoring_51(51, a1);\n        lemma_two_factoring_51(102, a2);\n        lemma_two_factoring_51(153, a3);\n    }\n\n    // change groupings\n    assert(as_nat(rr) == (b0 + pow2(51) * a0) + pow2(51) * (b1 + pow2(51) * a1) + pow2(102) * (b2\n        + pow2(51) * a2) + pow2(153) * (b3 + pow2(51) * a3) + pow2(204) * b4 + 19 * a4) by {\n        lemma_mul_is_distributive_add(pow2(51) as int, b1 as int, pow2(51) * a1);\n        lemma_mul_is_distributive_add(pow2(102) as int, b2 as int, pow2(51) * a2);\n        lemma_mul_is_distributive_add(pow2(153) as int, b3 as int, pow2(51) * a3);\n    }\n\n    // invoke div/mod identity\n    assert(as_nat(rr) == limbs[0] + pow2(51) * limbs[1] + pow2(102) * limbs[2] + pow2(153)\n        * limbs[3] + pow2(204) * b4 + 19 * a4) by {\n        lemma_div_and_mod_51(a0, b0, limbs[0]);\n        lemma_div_and_mod_51(a1, b1, limbs[1]);\n        lemma_div_and_mod_51(a2, b2, limbs[2]);\n        lemma_div_and_mod_51(a3, b3, limbs[3]);\n    }\n\n    // Add missing limbs[4] parts\n    assert(as_nat(rr) == limbs[0] + pow2(51) * limbs[1] + pow2(102) * limbs[2] + pow2(153)\n        * limbs[3] + pow2(204) * limbs[4] - pow2(204) * (pow2(51) * a4) + 19 * a4) by {\n        lemma_div_and_mod_51(a4, b4, limbs[4]);\n        assert(pow2(204) * limbs[4] == pow2(204) * b4 + pow2(204) * (pow2(51) * a4)) by {\n            lemma_mul_is_distributive_add(pow2(204) as int, pow2(51) * a4 as int, b4 as int);\n        }\n    }\n\n    // The solver can collect components of as_nat(limbs) automatically:\n    // as_nat(rr) == as_nat(limbs) - pow2(204) * (pow2(51) * a4 ) + 19 * a4\n    // ... as well as pull in minus\n    // as_nat(rr) == as_nat(limbs) - (pow2(204) * (pow2(51) * a4 ) - 19 * a4)\n\n    // collect components of p() * a4\n    assert(pow2(204) * (pow2(51) * a4) - 19 * a4 == p() * a4) by {\n        lemma_mul_is_associative(pow2(204) as int, pow2(51) as int, a4 as int);\n        lemma_pow2_adds(204, 51);\n        lemma_mul_is_distributive_sub_other_way(a4 as int, pow2(255) as int, 19);\n        pow255_gt_19();  // we need to prove 2^255 - 19 doesn't underflow\n    }\n\n    pow255_gt_19();\n    lemma_mod_multiples_vanish(\n        (limbs[4] >> 51) as int,\n        as_nat(spec_reduce(limbs)) as int,\n        p() as int,\n    );\n}\n\n/// Proves that reduce() ensures as_nat < 2*p()\n///\n/// This is the key property needed for to_bytes(): after reduce(),\n/// the value is bounded by 2*p = 2^256 - 38, not just by the loose\n/// bound from individual limb sizes.\npub proof fn lemma_reduce_bound_2p(limbs: [u64; 5])\n    ensures\n        as_nat(spec_reduce(limbs)) < 2 * p(),\n{\n    lemma2_to64();\n    pow255_gt_19();\n\n    let r = spec_reduce(limbs);\n\n    assert(1u64 << 51 == pow2(51)) by {\n        shift_is_pow2(51);\n    }\n\n    // For r[i] where i > 0: (limbs[i] & mask51) + (limbs[i-1] >> 51) < 2^51 + 2^13\n    assert forall|i: int| 0 <= i <= 4 implies #[trigger] (limbs[i] & mask51) < pow2(51) by {\n        masked_lt_51(limbs[i]);\n    }\n    // separate foralls, because they trigger on i and i-1\n    assert forall|i: int| 0 <= i <= 4 implies #[trigger] limbs[i] >> 51 < pow2(13) by {\n        assert(limbs[i] >> 51 <= u64::MAX >> 51) by {\n            lemma_shr_le_u64(limbs[i], u64::MAX, 51);\n        }\n        assert(u64::MAX >> 51 < pow2(13)) by {\n            assert(1u64 << 13 == pow2(13)) by {\n                shift_is_pow2(13);\n            }\n            lemma_u64_max_shifting(51);\n        }\n    }\n\n    // For r[0] we have the extra factor of 19:\n    // r[0] = (limbs[0] & mask51) + (limbs[4] >> 51) * 19\n    assert((limbs[4] >> 51) * 19 < pow2(18)) by {\n        assert(19 < pow2(5)) by {\n            lemma2_to64();\n        }\n        assert(pow2(18) == pow2(13) * pow2(5)) by {\n            lemma_pow2_adds(13, 5);\n        }\n        mul_lt((limbs[4] >> 51) as nat, pow2(13), 19, pow2(5));\n    }\n\n    assert forall|i: nat| 1 <= i <= 4 implies #[trigger] pow2(i * 51) * r[i as int] < pow2(i * 51)\n        * pow2(13) + pow2((i + 1) * 51) by {\n        assert(pow2(i * 51) * r[i as int] < pow2(i * 51) * (pow2(51) + pow2(13))) by {\n            lemma_pow2_pos(i * 51);\n            lemma_mul_strict_inequality(\n                r[i as int] as int,\n                (pow2(51) + pow2(13)) as int,\n                pow2(i * 51) as int,\n            );\n            lemma_mul_is_commutative(pow2(i * 51) as int, r[i as int] as int);\n            lemma_mul_is_commutative(pow2(i * 51) as int, (pow2(51) + pow2(13)) as int);\n        }\n\n        assert(pow2(i * 51) * (pow2(51) + pow2(13)) == pow2((i + 1) * 51) + pow2(i * 51) * pow2(13))\n            by {\n            assert(pow2(i * 51) * (pow2(51) + pow2(13)) == pow2(i * 51) * pow2(51) + pow2(i * 51)\n                * pow2(13)) by {\n                lemma_mul_is_distributive_add(\n                    pow2(i * 51) as int,\n                    pow2(51) as int,\n                    pow2(13) as int,\n                );\n            }\n            assert(pow2(i * 51) * pow2(51) == pow2((i + 1) * 51)) by {\n                assert(i * 51 + 51 == (i + 1) * 51) by {\n                    lemma_mul_is_distributive_add_other_way(51, i as int, 1);\n                }\n                lemma_pow2_adds(i * 51, 51);\n            }\n        }\n    }\n\n    // write out i * 51s explicitly to trigger forall match\n    let tail = (pow2(18) + pow2(51) + pow2(64) + pow2(102) + pow2(115) + pow2(153) + pow2(166)\n        + pow2(204) + pow2(217));\n    assert(as_nat(r) == r[0] + pow2(1 * 51) * r[1] + pow2(2 * 51) * r[2] + pow2(3 * 51) * r[3]\n        + pow2(4 * 51) * r[4] < tail + pow2(255)) by {\n        lemma_pow2_adds(51, 13);\n        lemma_pow2_adds(102, 13);\n        lemma_pow2_adds(153, 13);\n        lemma_pow2_adds(204, 13);\n    }\n\n    assert(2 * p() == pow2(255) + pow2(255) - 38) by {\n        lemma_pow2_adds(255, 1);\n        lemma_pow2_plus_one(255);\n    }\n\n    // we'll prove the tail is small\n    assert(tail < pow2(255) - 38) by {\n        assert forall|i: nat| i <= 204 implies #[trigger] pow2(i) < pow2(217) by {\n            lemma_pow2_strictly_increases(i, 217);\n        }\n        assert(tail < 9 * pow2(217) < pow2(221)) by {\n            assert(9 < pow2(4));  // known\n            assert(pow2(217) > 0) by {\n                lemma_pow2_pos(217);\n            }\n            lemma_mul_strict_inequality(9, pow2(4) as int, pow2(217) as int);\n            lemma_pow2_adds(217, 4);\n        }\n\n        assert(pow2(254) < pow2(255) - 38) by {\n            assert(38 < pow2(6));  // known\n            assert(pow2(255) - 38 > pow2(255) - pow2(6) == pow2(254) + pow2(254) - pow2(6)) by {\n                lemma_pow2_plus_one(254);\n            }\n            assert(pow2(254) - pow2(6) > 0) by {\n                lemma_pow2_strictly_increases(6, 254);\n            }\n        }\n\n        assert(pow2(221) < pow2(254)) by {\n            lemma_pow2_strictly_increases(221, 254);\n        }\n    }\n}\n\nfn main() {\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "//!\n//! * `RistrettoPoint::random()`, which generates random points from an\n//! RNG - enabled by `rand_core` feature;\n//!\n//! * `RistrettoPoint::from_hash()` and\n//! `RistrettoPoint::hash_from_bytes()`, which perform hashing to the\n//! group.\n//!\n//! The Elligator map itself is not currently exposed.\n//!\n//! ## Implementation\n//!\n//! The Decaf suggestion is to use a quotient group, such as \\\\(\\mathcal\n//! E / \\mathcal E\\[4\\]\\\\) or \\\\(2 \\mathcal E / \\mathcal E\\[2\\] \\\\), to\n//! implement a prime-order group using a non-prime-order curve.\n//!\n//! This requires only changing\n//!\n//! 1. the function for equality checking (so that two representatives\n//!    of the same coset are considered equal);\n//! 2. the function for encoding (so that two representatives of the\n//!    same coset are encoded as identical bitstrings);\n//! 3. the function for decoding (so that only the canonical encoding of\n//!    a coset is accepted).\n//!\n//! Internally, each coset is represented by a curve point; two points\n//! \\\\( P, Q \\\\) may represent the same coset in the same way that two\n//! points with different \\\\(X,Y,Z\\\\) coordinates may represent the\n//! same point.  The group operations are carried out with no overhead\n//! using Edwards formulas.\n//!\n//! Notes on the details of the encoding can be found in the\n//! [Details][ristretto_notes] section of the Ristretto website.\n//!\n//! [cryptonote]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000898.html\n//! [ed25519_hkd]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000858.html\n//! [ristretto_coffee]:\n//! https://en.wikipedia.org/wiki/Ristretto\n//! [ristretto_notes]:\n//! https://ristretto.group/details/index.html\n//! [why_ristretto]:\n//! https://ristretto.group/why_ristretto.html\n//! [ristretto_main]:\n//! https://ristretto.group/\n\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\n\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_constants/lizard/test_lizard_constants().",
      "display_name": "test_lizard_constants",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_constants/lizard/test_lizard_constants().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_constants.rs",
      "relative_path": "src/lizard/lizard_constants.rs",
      "file_name": "lizard_constants.rs",
      "parent_folder": "lizard",
      "body": "    fn test_lizard_constants() {\n        let (_, sqrt_id) = FieldElement::sqrt_ratio_i(\n            &(&constants::SQRT_M1 * &constants::EDWARDS_D),\n            &FieldElement::ONE,\n        );\n        assert_eq!(sqrt_id, SQRT_ID);\n\n        assert_eq!(\n            &(&constants::EDWARDS_D + &FieldElement::ONE)\n                * &(&constants::EDWARDS_D - &FieldElement::ONE).invert(),\n            DP1_OVER_DM1\n        );\n\n        assert_eq!(\n            MDOUBLE_INVSQRT_A_MINUS_D,\n            -&(&constants::INVSQRT_A_MINUS_D + &constants::INVSQRT_A_MINUS_D)\n        );\n\n        assert_eq!(\n            MIDOUBLE_INVSQRT_A_MINUS_D,\n            &MDOUBLE_INVSQRT_A_MINUS_D * &constants::SQRT_M1\n        );\n\n        let (_, invsqrt_one_plus_d) = (&constants::EDWARDS_D + &FieldElement::ONE).invsqrt();\n        assert_eq!(-&invsqrt_one_plus_d, MINVSQRT_ONE_PLUS_D);\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar52: {:?}\", self.limbs)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_valid_naf().",
      "display_name": "is_valid_naf",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_valid_naf().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "use core::iter::{Product, Sum};\nuse core::ops::Index;",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV().",
      "display_name": "pow2_mul_DIV",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn pow2_mul_DIV(x: nat, k: nat, s: nat)\n    requires\n        k <= s,\n    ensures\n        (x * pow2(k)) / pow2(s) == x / pow2((s - k) as nat),\n{\n    assert(pow2(k) > 0) by {\n        lemma_pow2_pos(k);\n    }\n\n    let d = (s - k) as nat;\n\n    assert(pow2(d) > 0) by {\n        lemma_pow2_pos(d);\n    }\n    assert(pow2(s) == pow2(k) * pow2(d)) by {\n        lemma_pow2_adds(k, d);\n    }\n    assert((x * pow2(k)) / pow2(s) == ((x * pow2(k)) / pow2(k) / pow2(d))) by {\n        lemma_div_denominator((x * pow2(k)) as int, pow2(k) as int, pow2(d) as int)\n    }\n    assert((x * pow2(k)) / pow2(k) == x) by {\n        lemma_div_by_multiple(x as int, pow2(k) as int);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "display_name": "optional_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<RistrettoPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<RistrettoPoint>>,\n    {\n        let extended_points = points.into_iter().map(|opt_P| opt_P.map(|P| P.0));\n\n        EdwardsPoint::optional_multiscalar_mul(scalars, extended_points).map(RistrettoPoint)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/pow2_mul_DIV_MOD_u8_t51_cond().",
      "display_name": "pow2_mul_DIV_MOD_u8_t51_cond",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/pow2_mul_DIV_MOD_u8_t51_cond().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn pow2_mul_DIV_MOD_u8_t51_cond(k: nat, j: nat) -> bool {\n    (j * 8 <= k) && (8 <= 51 + k - 8 * j)\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_5_terms().",
      "display_name": "mul_5_terms",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_5_terms().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs",
      "file_name": "as_nat_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "    assert(s4 * s4 == s8) by { lemma_pow2_adds(204, 204) }\n",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/affine_coords().",
      "display_name": "affine_coords",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/affine_coords().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/curve_specs.rs",
      "relative_path": "src/curve_specs.rs",
      "file_name": "curve_specs.rs",
      "parent_folder": "src",
      "body": "pub open spec fn affine_coords(point: crate::edwards::EdwardsPoint) -> (nat, nat) {\n    let x_abs = field_element(&point.X);\n    let y_abs = field_element(&point.Y);\n    let z_abs = field_element(&point.Z);\n    let z_inv = field_inv(z_abs);\n    (field_mul(x_abs, z_inv), field_mul(y_abs, z_inv))\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#from_slice().",
      "display_name": "from_slice",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#from_slice().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn from_slice(bytes: &[u8]) -> (result: Result<\n        CompressedEdwardsY,\n        TryFromSliceError,\n    >)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            bytes@.len() == 32 ==> matches!(result, Ok(_)),\n            bytes@.len() != 32 ==> matches!(result, Err(_)),\n            match result {\n                Ok(point) => point.0@ == bytes@,\n                Err(_) => true,\n            },",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Sub#sub().",
      "display_name": "sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/Sub#sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn sub(self, other: &'b AffineNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PM = &Y_plus_X * &other.y_minus_x;\n        let MP = &Y_minus_X * &other.y_plus_x;\n        let Txy2d = &self.T * &other.xy2d;\n        let Z2 = &self.Z + &self.Z;\n\n        CompletedPoint {\n            X: &PM - &MP,\n            Y: &PM + &MP,\n            Z: &Z2 - &Txy2d,\n            T: &Z2 + &Txy2d,\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/nine_limbs_to_nat_aux().",
      "display_name": "nine_limbs_to_nat_aux",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/nine_limbs_to_nat_aux().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": ")\n//     requires to_scalar(&x.limbs) != 0\n//    ensures (to_scalar(&x.limbs) * invert_spec(&x.limbs)) % group_order() == 1\n{\n    assume(false);\n\n}",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/Sub#sub().",
      "display_name": "sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/Sub#sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn sub(self, other: &'b RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 - other.0)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "display_name": "lemma_pow2_pos",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 57,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_new().",
      "display_name": "ct_option_new",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "// From a conflict:\n//use rand_core::{CryptoRng, RngCore};\n",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/div_pow2_preserves_decomposition().",
      "display_name": "div_pow2_preserves_decomposition",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/div_pow2_preserves_decomposition().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "\n    let s7_0 = (s6_0 + a7) as u64;\n    let s7 = s7_0 / ps64;\n\n    assert(s7 == s6_0 / ps64 + a7 / ps64) by {\n        lemma_bitops_lifted(s6_0, input[i + 7] as u64, 7 * 8, s);\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "display_name": "sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        *self = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&self.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_unfold().",
      "display_name": "lemma_pow2_unfold",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_unfold().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_verus",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/try_into_32_bytes_array().",
      "display_name": "try_into_32_bytes_array",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/try_into_32_bytes_array().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "//! E = \\mathcal E\\[8\\] \\times \\mathcal E[\\ell]\\\\).  The torsion\n//! subgroup \\\\( \\mathcal E\\[8\\] \\\\) consists of eight points of small\n//! order.  Technically, all of \\\\(\\mathcal E\\\\) is torsion, but we\n//! use the word only to refer to the small \\\\(\\mathcal E\\[8\\]\\\\) part, not\n//! the large prime-order \\\\(\\mathcal E[\\ell]\\\\) part.\n//!\n//! To test if a point is in \\\\( \\mathcal E\\[8\\] \\\\), use\n//! [`EdwardsPoint::is_small_order`].\n//!\n//! To test if a point is in \\\\( \\mathcal E[\\ell] \\\\), use\n//! [`EdwardsPoint::is_torsion_free`].\n//!\n//! To multiply by the cofactor, use [`EdwardsPoint::mul_by_cofactor`].\n//!\n//! To avoid dealing with cofactors entirely, consider using Ristretto.\n//!\n//! ## Scalars\n//!\n//! Scalars are represented by the [`Scalar`] struct. To construct a scalar, see\n//! [`Scalar::from_canonical_bytes`] or [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! ## Scalar Multiplication\n//!\n//! Scalar multiplication on Edwards points is provided by:\n//!\n//! * the `*` operator between a `Scalar` and a `EdwardsPoint`, which\n//! performs constant-time variable-base scalar multiplication;\n//!\n//! * the `*` operator between a `Scalar` and a\n//! `EdwardsBasepointTable`, which performs constant-time fixed-base\n//! scalar multiplication;\n//!\n//! * an implementation of the\n//! [`MultiscalarMul`](../traits/trait.MultiscalarMul.html) trait for\n//! constant-time variable-base multiscalar multiplication;\n//!\n//! * an implementation of the\n//! [`VartimeMultiscalarMul`](../traits/trait.VartimeMultiscalarMul.html)\n//! trait for variable-time variable-base multiscalar multiplication;\n//!\n//! ## Implementation\n//!\n//! The Edwards arithmetic is implemented using the “extended twisted\n//! coordinates” of Hisil, Wong, Carter, and Dawson, and the\n//! corresponding complete formulas.  For more details,\n//! see the [`curve_models` submodule][curve_models]\n//! of the internal documentation.\n//!\n//! ## Validity Checking\n//!\n//! There is no function for checking whether a point is valid.\n//! Instead, the `EdwardsPoint` struct is guaranteed to hold a valid\n//! point on the curve.\n//!\n//! We use the Rust type system to make invalid points\n//! unrepresentable: `EdwardsPoint` objects can only be created via\n//! successful decompression of a compressed point, or else by\n//! operations on other (valid) `EdwardsPoint`s.\n//!\n//! [curve_models]: https://docs.rs/curve25519-dalek/latest/curve25519-dalek/backend/serial/curve_models/index.html\n// We allow non snake_case names because coordinates in projective space are\n// traditionally denoted by the capitalisation of their respective\n// counterparts in affine space.  Yeah, you heard me, rustc, I'm gonna have my\n// affine and projective cakes and eat both of them too.\n#![allow(non_snake_case)]\n\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "display_name": "square",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn square(&self) -> (result: Scalar52)\n        requires\n            limbs_bounded(self),\n        ensures\n            to_nat(&result.limbs) == (to_nat(&self.limbs) * to_nat(&self.limbs)) % group_order(),\n    {\n        assume(false);  // TODO: Add proofs\n        let aa = Scalar52::montgomery_reduce(&Scalar52::square_internal(self));\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&aa, &constants::RR))\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoBasepointTable#create().",
      "display_name": "create",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoBasepointTable#create().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn create(basepoint: &RistrettoPoint) -> RistrettoBasepointTable {\n        RistrettoBasepointTable(EdwardsBasepointTable::create(&basepoint.0))\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_le_max64().",
      "display_name": "pow2_le_max64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_le_max64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "    } else {\n        // k > 0",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_byte_from_limb_shift_52().",
      "display_name": "lemma_byte_from_limb_shift_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_byte_from_limb_shift_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "proof fn lemma_byte_from_limb_shift_52(limb: u64, shift: u64, byte: u8)\n    requires\n        limb < pow2(52),\n        shift < 64,\n        byte == (limb >> shift) as u8,\n    ensures\n        byte as nat == (limb as nat / pow2(shift as nat)) % 256,\n{\n    // Bitwise shift to arithmetic conversion\n    // When we shift right by `shift` bits and cast to u8, we extract 8 bits starting at position `shift`\n    // In arithmetic terms: (limb / 2^shift) % 256\n    lemma2_to64();\n    assert((limb >> shift) as nat == limb as nat / pow2(shift as nat)) by {\n        lemma_u64_shr_is_div(limb, shift);\n    }\n\n    // The u8 cast takes the low 8 bits, which is % 256\n    // Proof: use vstd lemma that & 0xFF = % 256, then bit_vector to show casting = masking\n    let shifted = limb >> shift;\n    assert(shifted & 0xFF == shifted % 256) by {\n        lemma_u64_low_bits_mask_is_mod(shifted, 8);\n    }\n    assert(shifted as u8 == (shifted & 0xFF) as u8) by (bit_vector);\n    // Therefore: (shifted as u8) as nat == shifted % 256\n    assert((limb >> shift) as u8 as nat == ((limb >> shift) as nat) % 256);\n}",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#TryFrom#try_from().",
      "display_name": "try_from",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#TryFrom#try_from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn try_from(slice: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        Self::from_slice(slice)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow_nat_is_nat().",
      "display_name": "lemma_pow_nat_is_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow_nat_is_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_none().",
      "display_name": "ct_option_is_none",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_none().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn ct_option_is_none<T>(opt: &CtOption<T>) -> (c: Choice)\n    ensures\n        choice_is_true(c) == !ct_option_has_value(*opt),\n{\n    opt.is_none()\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/Neg#neg().",
      "display_name": "neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/Neg#neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn neg(self) -> RistrettoPoint {\n        RistrettoPoint(-&self.0)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_inverse_of_nat().",
      "display_name": "is_inverse_of_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_inverse_of_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//!\n//! There is also a constructor that reduces a \\\\(512\\\\)-bit integer,\n//! [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! To construct a `Scalar` as the hash of some input data, use\n//! [`Scalar::hash_from_bytes`], which takes a buffer, or\n//! [`Scalar::from_hash`], which allows an IUF API.\n//!\n#![cfg_attr(feature = \"digest\", doc = \"```\")]\n#![cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n//! # fn main() {\n//! use sha2::{Digest, Sha512};\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! // Hashing a single byte slice\n//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_constants/lizard/field_element().",
      "display_name": "field_element",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_constants/lizard/field_element().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/u64_constants.rs",
      "relative_path": "src/lizard/u64_constants.rs",
      "file_name": "u64_constants.rs",
      "parent_folder": "lizard",
      "body": "const fn field_element(element: [u64; 5]) -> FieldElement51 {\n    FieldElement51 { limbs: element }\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "display_name": "from_bytes_mod_order_wide",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == bytes_wide_to_nat(input) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_and_mod().",
      "display_name": "lemma_div_and_mod",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_and_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "use super::super::common_verus::pow_lemmas::*;\nuse super::super::common_verus::shift_lemmas::*;\n\nuse super::field_core::*;\n\nverus! {\n\n// Specialization for b = 51\npub proof fn lemma_two_factoring_51(k: nat, ai: u64)\n    ensures\n        pow2(k + 51) * ai == pow2(k) * (pow2(51) * ai),\n{\n    lemma_two_factoring(k, 51, ai);\n}\n\npub proof fn lemma_add_then_shift(a: u64, b: u64)\n    requires\n        a < (1u64 << 52),\n        b < (1u64 << 52),\n    ensures\n        (a + b) < (1u64 << 53),\n        ((a + b) as u64 >> 51) < 4,\n{\n    lemma2_to64_rest();\n    assert((a + b) < 1u64 << 53) by {\n        assert((1u64 << 52) + (1u64 << 52) == 1u64 << 53) by (compute);\n    }\n    assert(1u64 << 53 == (1u64 << 51) * 4) by (bit_vector);\n    // 0 < b  /\\ a < b * c => a/b < c\n    lemma_multiply_divide_lt((a + b) as int, (1u64 << 51) as int, 4int);\n    shift_is_pow2(51);\n    shift_is_pow2(53);\n    assert((a + b) as u64 >> 51 == (a + b) as u64 / (pow2(51) as u64)) by {\n        lemma_u64_shr_is_div((a + b) as u64, 51);\n    }\n    assert(pow2(53) / pow2(51) == 4) by {\n        lemma_pow2_subtracts(51, 53);\n    }\n}\n\n// >> preserves [<=]. Unfortunately, these operations are u128 and\n// we need lemma_u128_shr_is_div.\npub proof fn lemma_shr_51_le(a: u128, b: u128)\n    requires\n        a <= b,\n    ensures\n        (a >> 51) <= (b >> 51),\n{\n    lemma_pow2_pos(51);\n    lemma2_to64_rest();  // pow2(51) value\n    lemma_u128_shr_is_div(a, 51);\n    lemma_u128_shr_is_div(b, 51);\n    lemma_div_is_ordered(a as int, b as int, 51);\n}\n\n// Corollary of above, using the identity (a << x) >> x == a for u64::MAX\npub proof fn lemma_shr_51_fits_u64(a: u128)\n    requires\n        a <= (u64::MAX as u128) << 51,\n    ensures\n        (a >> 51) <= (u64::MAX as u128),\n{\n    assert(((u64::MAX as u128) << 51) >> 51 == (u64::MAX as u128)) by (compute);\n    lemma_shr_51_le(a, (u64::MAX as u128) << 51);\n}\n\n// Auxiliary datatype lemma\n// Should work for any k <= 64, but the proofs are convoluted and we can't use BV\n// (x as u64) = x % 2^64, so x = 2^64 * (x / 2^64) + (x as u64). Thus\n// (x as u64) % 2^k = (x as u64) % 2^k, because 2^k | 2^64 * (...) for k <= 64\npub proof fn lemma_cast_then_mod_51(x: u128)\n    ensures\n        (x as u64) % (pow2(51) as u64) == x % (pow2(51) as u128),\n{\n    lemma2_to64_rest();  // pow2(51 | 64)\n    assert((x as u64) % 0x8000000000000 == x % 0x8000000000000) by (bit_vector);\n}\n\npub proof fn lemma_mul_sub(ci: int, cj: int, cj_0: int, k: nat)\n    ensures\n        pow2(k) * (ci - pow2(51) * (cj - cj_0)) == pow2(k) * ci - pow2(k + 51) * cj + pow2(k + 51)\n            * cj_0,\n{\n    // 2^k (ci - X) = 2^k ci - 2^k X\n    lemma_mul_is_distributive_sub(pow2(k) as int, ci, pow2(51) * (cj - cj_0));\n    // 2^k (2^51 * Y) = (2^k * 2^51) * Y\n    lemma_mul_is_associative(pow2(k) as int, pow2(51) as int, cj - cj_0);\n    // 2^k * 2^51 = 2^(k + 51)\n    lemma_pow2_adds(k, 51);\n    // 2^(k + 51) * (cj - cj_0) = 2^(k + 51) * cj - 2^(k + 51) * cj_0\n    lemma_mul_is_distributive_sub(pow2(k + 51) as int, cj, cj_0);\n}\n\n// Masking with low_bits_mask(51) gives a value bounded by 2^51\npub proof fn masked_lt_51(v: u64)\n    ensures\n        v & mask51 < (1u64 << 51),\n{\n    l51_bit_mask_lt();  // mask51 == low_bits_mask(51)\n    masked_lt(v, 51);\n}\n\n// lemma_div_and_mod specialization for k = 51, using mask51 == low_bits_mask(51)\npub proof fn lemma_div_and_mod_51(ai: u64, bi: u64, v: u64)\n    requires\n        ai == v >> 51,\n        bi == v & mask51,\n    ensures\n        ai == v / (pow2(51) as u64),\n        bi == v % (pow2(51) as u64),\n        v == ai * pow2(51) + bi,\n{\n    l51_bit_mask_lt();  // mask51 == low_bits_mask(51)\n    lemma_div_and_mod(ai, bi, v, 51);\n}\n\npub broadcast proof fn lemma_cast_then_mask_51(x: u128)\n    ensures\n        #![trigger (x as u64) & mask51]\n        (x as u64) & mask51 == x & (mask51 as u128),\n{\n    assert((x as u64) & 2251799813685247u64 == x & (2251799813685247u64 as u128)) by (bit_vector);\n}\n\nfn main() {\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/main().",
      "display_name": "main",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/main().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "fn main() {\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_compute_q().",
      "display_name": "lemma_compute_q",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_compute_q().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!\nverus! {\n\nimpl FieldElement51 {\n    pub(crate) const fn from_limbs(limbs: [u64; 5]) -> FieldElement51 {\n        FieldElement51 { limbs }\n    }\n\n    // Modified to use direct struct\n    pub const ZERO: FieldElement51 = FieldElement51 { limbs: [0, 0, 0, 0, 0] };\n\n    pub const ONE: FieldElement51 = FieldElement51 { limbs: [1, 0, 0, 0, 0] };\n\n    pub const MINUS_ONE: FieldElement51 = FieldElement51 {\n        limbs: [\n            2251799813685228,\n            2251799813685247,\n            2251799813685247,\n            2251799813685247,\n            2251799813685247,\n        ],\n    };\n\n    /// Invert the sign of this field element\n    pub fn negate(&mut self)\n        requires\n            forall|i: int| 0 <= i < 5 ==> old(self).limbs[i] < (1u64 << 51),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52),\n            // Assume we start with l = (l0, l1, l2, l3, l4).\n            // Using c0 = 2^51 - 19 and c = 2^51 - 1, we can see that\n            // ( 36028797018963664u64 - l0,\n            //   36028797018963952u64 - l1,\n            //   36028797018963952u64 - l2,\n            //   36028797018963952u64 - l3,\n            //   36028797018963952u64 - l4 )\n            // is just 16 * (c0, c, c, c, c) - l (in vector notation)\n            // Further, as_nat((c0, c, c, c, c)) = p, so\n            // as_nat(16 * (c0, c, c, c, c) - l) is 16p - as_nat(l)\n            // We know as_nat(reduce(v)) = as_nat(v) - p * (v4 >> 51) for any v.\n            // This gives us the identity\n            // as_nat(negate(l)) = as_nat(reduce(16 * (c0, c, c, c, c) - l))\n            //                   = 16p - as_nat(l) - p * ((16c - l4) >> 51)\n            // Note that (16c - l4) >> 51 is either 14 or 15, in either case < 16.\n            as_nat(self.limbs) == 16 * p() - as_nat(old(self).limbs) - p() * ((36028797018963952u64\n                - old(self).limbs[4]) as u64 >> 51),\n            (as_nat(self.limbs) + as_nat(old(self).limbs)) % p() == 0,\n    {\n        proof {\n            lemma_neg_no_underflow(self.limbs);\n            negate_proof(self.limbs);\n        }\n        // See commentary in the Sub impl: (copied below)\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        let neg = FieldElement51::reduce(\n            [\n                36028797018963664u64 - self.limbs[0],\n                36028797018963952u64 - self.limbs[1],\n                36028797018963952u64 - self.limbs[2],\n                36028797018963952u64 - self.limbs[3],\n                36028797018963952u64 - self.limbs[4],\n            ],\n        );\n        self.limbs = neg.limbs;\n    }\n\n    /// Given 64-bit input limbs, reduce to enforce the bound 2^(51 + epsilon).\n    #[inline(always)]\n    fn reduce(mut limbs: [u64; 5]) -> (r: FieldElement51)\n        ensures\n            r.limbs == spec_reduce(limbs),\n            forall|i: int| 0 <= i < 5 ==> r.limbs[i] < (1u64 << 52),\n            (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (r.limbs =~= limbs),\n            as_nat(r.limbs) == as_nat(limbs) - p() * (limbs[4] >> 51),\n            as_nat(r.limbs) % p() == as_nat(limbs) % p(),\n            as_nat(r.limbs) < 2 * p(),\n    {\n        proof {\n            lemma_boundaries(limbs);\n            lemma_reduce(limbs);\n            lemma_reduce_bound_2p(limbs);\n        }\n\n        // Since the input limbs are bounded by 2^64, the biggest\n        // carry-out is bounded by 2^13.\n        //\n        // The biggest carry-in is c4 * 19, resulting in\n        //\n        // 2^51 + 19*2^13 < 2^51.0000000001\n        //\n        // Because we don't need to canonicalize, only to reduce the\n        // limb sizes, it's OK to do a \"weak reduction\", where we\n        // compute the carry-outs in parallel.\n\n        let c0 = limbs[0] >> 51;\n        let c1 = limbs[1] >> 51;\n        let c2 = limbs[2] >> 51;\n        let c3 = limbs[3] >> 51;\n        let c4 = limbs[4] >> 51;\n\n        limbs[0] &= LOW_51_BIT_MASK;\n        limbs[1] &= LOW_51_BIT_MASK;\n        limbs[2] &= LOW_51_BIT_MASK;\n        limbs[3] &= LOW_51_BIT_MASK;\n        limbs[4] &= LOW_51_BIT_MASK;\n\n        limbs[0] += c4 * 19;\n        limbs[1] += c0;\n        limbs[2] += c1;\n        limbs[3] += c2;\n        limbs[4] += c3;\n\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51 { limbs }\n    }\n\n    /// Load a `FieldElement51` from the low 255 bits of a 256-bit\n    /// input.\n    ///\n    /// # Warning\n    ///\n    /// This function does not check that the input used the canonical\n    /// representative.  It masks the high bit, but it will happily\n    /// decode 2^255 - 18 to 1.  Applications that require a canonical\n    /// encoding of every field element should decode, re-encode to\n    /// the canonical encoding, and check that the input was\n    /// canonical.\n    ///\n    ///\n    #[rustfmt::skip]  // keep alignment of bit shifts\n    pub const fn from_bytes(bytes: &[u8; 32]) -> (r: FieldElement51)\n        ensures\n    // last bit is ignored\n\n            as_nat(r.limbs) == as_nat_32_u8(bytes) % pow2(255),\n    {\n        /* MANUALLY moved outside */\n        /*\n        const fn load8_at(input: &[u8], i: usize) -> u64 {\n                (input[i] as u64)\n            | ((input[i + 1] as u64) << 8)\n            | ((input[i + 2] as u64) << 16)\n            | ((input[i + 3] as u64) << 24)\n            | ((input[i + 4] as u64) << 32)\n            | ((input[i + 5] as u64) << 40)\n            | ((input[i + 6] as u64) << 48)\n            | ((input[i + 7] as u64) << 56)\n        }\n        */\n        proof {\n            assert(mask51 == (1u64 << 51) - 1) by (compute);\n\n            let l0 = load8_at_spec(bytes, 0);\n            let l1 = load8_at_spec(bytes, 6);\n            let l2 = load8_at_spec(bytes, 12);\n            let l3 = load8_at_spec(bytes, 19);\n            let l4 = load8_at_spec(bytes, 24);\n\n            assert(l0 <= u64::MAX && l1 <= u64::MAX && l2 <= u64::MAX && l3 <= u64::MAX && l4\n                <= u64::MAX) by {\n                load8_at_spec_fits_u64(bytes, 0);\n                load8_at_spec_fits_u64(bytes, 6);\n                load8_at_spec_fits_u64(bytes, 12);\n                load8_at_spec_fits_u64(bytes, 19);\n                load8_at_spec_fits_u64(bytes, 24);\n            }\n\n            let rr = [\n                l0 as u64 & mask51,\n                (l1 as u64 >> 3) & mask51,\n                (l2 as u64 >> 6) & mask51,\n                (l3 as u64 >> 1) & mask51,\n                (l4 as u64 >> 12) & mask51,\n            ];\n\n            assert(as_nat(rr) == as_nat_32_u8(bytes) % pow2(255)) by {\n                from_bytes_as_nat(bytes);\n                as_nat_32_mod_255(bytes);\n            }\n        }\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51 {\n            limbs:\n            // load bits [  0, 64), no shift\n            [\n                load8_at(bytes, 0)\n                    & low_51_bit_mask\n                // load bits [ 48,112), shift to [ 51,112)\n                ,\n                (load8_at(bytes, 6) >> 3)\n                    & low_51_bit_mask\n                // load bits [ 96,160), shift to [102,160)\n                ,\n                (load8_at(bytes, 12) >> 6)\n                    & low_51_bit_mask\n                // load bits [152,216), shift to [153,216)\n                ,\n                (load8_at(bytes, 19) >> 1)\n                    & low_51_bit_mask\n                // load bits [192,256), shift to [204,112)\n                ,\n                (load8_at(bytes, 24) >> 12) & low_51_bit_mask,\n            ],\n        }\n    }\n\n    /// Serialize this `FieldElement51` to a 32-byte array.  The\n    /// encoding is canonical.\n    #[rustfmt::skip]  // keep alignment of s[*] calculations\n    pub fn as_bytes(self) -> (r: [u8; 32])\n        ensures\n    // canonical encoding, i.e. mod p value\n\n            as_nat_32_u8(&r) == as_nat(self.limbs) % p(),\n    {\n        proof {\n            // No overflows\n            as_bytes_boundaries1(self.limbs);\n            as_bytes_boundaries2(self.limbs);\n\n            // Step 1: Reduce limbs to ensure h < 2*p\n            // The reduce function ensures the limbs are bounded by 2^52\n            lemma_reduce(self.limbs);\n            lemma_reduce_bound_2p(self.limbs);\n            let limbs = spec_reduce(self.limbs);\n\n            let q = compute_q_spec(limbs);\n\n            // Step 2: Prove that q is the correct quotient\n            assert((q == 0 || q == 1) && (as_nat(limbs) >= p() <==> q == 1) && (as_nat(limbs) < p()\n                <==> q == 0)) by {\n                lemma_compute_q(limbs, q);\n            }\n\n            let final_limbs = reduce_with_q_spec(limbs, q);\n\n            // Step 3: Prove that the reduction preserves the value mod p\n            lemma_to_bytes_reduction(limbs, final_limbs, q);\n\n            // Now arrange the bits of the limbs.\n            let s = bit_arrange(final_limbs);\n\n            // Step 4: Prove that packing limbs into bytes preserves the value\n            lemma_limbs_to_bytes(final_limbs, s);\n        }\n\n        // Let h = limbs[0] + limbs[1]*2^51 + ... + limbs[4]*2^204.\n        //\n        // Write h = pq + r with 0 <= r < p.\n        //\n        // We want to compute r = h mod p.\n        //\n        // If h < 2*p = 2^256 - 38,\n        // then q = 0 or 1,\n        //\n        // with q = 0 when h < p\n        //  and q = 1 when h >= p.\n        //\n        // Notice that h >= p <==> h + 19 >= p + 19 <==> h + 19 >= 2^255.\n        // Therefore q can be computed as the carry bit of h + 19.\n        // First, reduce the limbs to ensure h < 2*p.\n        let mut limbs = FieldElement51::reduce(self.limbs).limbs;\n\n        let mut q = (limbs[0] + 19) >> 51;\n        q = (limbs[1] + q) >> 51;\n        q = (limbs[2] + q) >> 51;\n        q = (limbs[3] + q) >> 51;\n        q = (limbs[4] + q) >> 51;\n\n        // Now we can compute r as r = h - pq = r - (2^255-19)q = r + 19q - 2^255q\n\n        limbs[0] += 19 * q;\n\n        // Now carry the result to compute r + 19q ...\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        limbs[1] += limbs[0] >> 51;\n        limbs[0] &= low_51_bit_mask;\n        limbs[2] += limbs[1] >> 51;\n        limbs[1] &= low_51_bit_mask;\n        limbs[3] += limbs[2] >> 51;\n        limbs[2] &= low_51_bit_mask;\n        limbs[4] += limbs[3] >> 51;\n        limbs[3] &= low_51_bit_mask;\n        // ... but instead of carrying (limbs[4] >> 51) = 2^255q\n        // into another limb, discard it, subtracting the value\n        limbs[4] &= low_51_bit_mask;\n\n        // Now arrange the bits of the limbs.\n        let mut s = [0u8;32];\n        s[0] = limbs[0] as u8;\n        s[1] = (limbs[0] >> 8) as u8;\n        s[2] = (limbs[0] >> 16) as u8;\n        s[3] = (limbs[0] >> 24) as u8;\n        s[4] = (limbs[0] >> 32) as u8;\n        s[5] = (limbs[0] >> 40) as u8;\n        s[6] = ((limbs[0] >> 48) | (limbs[1] << 3)) as u8;\n        s[7] = (limbs[1] >> 5) as u8;\n        s[8] = (limbs[1] >> 13) as u8;\n        s[9] = (limbs[1] >> 21) as u8;\n        s[10] = (limbs[1] >> 29) as u8;\n        s[11] = (limbs[1] >> 37) as u8;\n        s[12] = ((limbs[1] >> 45) | (limbs[2] << 6)) as u8;\n        s[13] = (limbs[2] >> 2) as u8;\n        s[14] = (limbs[2] >> 10) as u8;\n        s[15] = (limbs[2] >> 18) as u8;\n        s[16] = (limbs[2] >> 26) as u8;\n        s[17] = (limbs[2] >> 34) as u8;\n        s[18] = (limbs[2] >> 42) as u8;\n        s[19] = ((limbs[2] >> 50) | (limbs[3] << 1)) as u8;\n        s[20] = (limbs[3] >> 7) as u8;\n        s[21] = (limbs[3] >> 15) as u8;\n        s[22] = (limbs[3] >> 23) as u8;\n        s[23] = (limbs[3] >> 31) as u8;\n        s[24] = (limbs[3] >> 39) as u8;\n        s[25] = ((limbs[3] >> 47) | (limbs[4] << 4)) as u8;\n        s[26] = (limbs[4] >> 4) as u8;\n        s[27] = (limbs[4] >> 12) as u8;\n        s[28] = (limbs[4] >> 20) as u8;\n        s[29] = (limbs[4] >> 28) as u8;\n        s[30] = (limbs[4] >> 36) as u8;\n        s[31] = (limbs[4] >> 44) as u8;\n\n        // High bit should be zero.\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert!((s[31] & 0b1000_0000u8) == 0u8);\n\n        s\n    }\n\n    /// Given `k > 0`, return `self^(2^k)`.\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    pub fn pow2k(&self, mut k: u32) -> (r: FieldElement51)\n        requires\n            k > 0,  // debug_assert!( k > 0 );\n            forall|i: int|\n                0 <= i < 5 ==> self.limbs[i] < 1u64 << 54  // 51 + b for b = 3\n            ,\n        ensures\n            forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 54,\n            as_nat(r.limbs) % p() == pow(as_nat(self.limbs) as int, pow2(k as nat)) as nat % p(),\n    {\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert!( k > 0 );\n\n        /// Multiply two 64-bit integers with 128 bits of output.\n        /* VERIFICATION NOTE: manually moved outside */\n        /* #[inline(always)]\n        fn m(x: u64, y: u64) -> u128 {\n            (x as u128) * (y as u128)\n        }\n        */\n        let mut a: [u64; 5] = self.limbs;\n\n        let ghost k0 = k;\n        // pre-loop invariant, i = 0\n        proof {\n            assert(as_nat(a) == pow(as_nat(self.limbs) as int, pow2(0))) by {\n                lemma2_to64();  // pow2(0) = 1\n                lemma_pow1(as_nat(self.limbs) as int);\n            }\n        }\n        loop\n            invariant_except_break\n                forall|j: int| 0 <= j < 5 ==> a[j] < 1u64 << 54,\n                as_nat(a) % p() == pow(as_nat(self.limbs) as int, pow2((k0 - k) as nat)) as nat\n                    % p(),\n                0 < k <= k0,\n            ensures\n                k == 0,\n                forall|j: int| 0 <= j < 5 ==> a[j] < 1u64 << 54,\n                as_nat(a) % p() == pow(as_nat(self.limbs) as int, pow2(k0 as nat)) as nat % p(),\n            decreases k,\n        {\n            proof {\n                let ghost i = (k0 - k) as nat;\n\n                pow255_gt_19();  // p > 0\n                lemma2_to64_rest();  // pow2(51 | 54)\n                shift_is_pow2(54);\n\n                let bound = 1u64 << 54;\n                let bound19 = (19 * bound) as u64;\n                let bound_sq = 1u128 << 108;\n\n                // u64 to u128 conversion forces extra assert\n                assert((1u64 << 54) * ((19 * (1u64 << 54)) as u64) == 19 * (1u128 << 108))\n                    by (bit_vector);\n                assert(((1u64 << 54) as u128) * ((1u64 << 54) as u128) == (1u128 << 108))\n                    by (bit_vector);\n\n                // precond for term_product_bounds\n                assert(19 * bound <= u64::MAX) by {\n                    assert(19 * (1u64 << 54) <= u64::MAX) by (compute);\n                }\n                // If a[i] < 2^54 then a[i] * a[j] < 2^108 and a[i] * (19 * a[j]) < 19 * 2^108\n                term_product_bounds(a, bound);\n\n                // ci_0 < 77 * (1u128 << 108)\n                c_i_0_bounded(a, bound);\n\n                // precond for c_i_shift_bounded\n                assert(77 * (bound * bound) + u64::MAX <= ((u64::MAX as u128) << 51)) by {\n                    assert(77 * (1u128 << 108) + u64::MAX <= ((u64::MAX as u128) << 51))\n                        by (compute);\n                }\n                // ci >> 51 <= u64::MAX\n                c_i_shift_bounded(a, bound);\n\n                // bv arithmetic\n                assert(19 < (1u64 << 5)) by (bit_vector);\n                assert((1u64 << 51) < (1u64 << 52)) by (bit_vector);\n                assert((1u64 << 52) < (1u64 << 54)) by (bit_vector);\n                assert((1u64 << 54) < (1u64 << 59)) by (bit_vector);\n                assert((1u64 << 54) * (1u64 << 5) == (1u64 << 59)) by (bit_vector);\n                assert(((1u64 << 54) as u128) * ((1u64 << 59) as u128) == (1u128 << 113))\n                    by (bit_vector);\n\n                let a3_19 = (19 * a[3]) as u64;\n                let a4_19 = (19 * a[4]) as u64;\n\n                // NOTE: we assert the properties derived from c_i_0_bounded\n                // and c_i_shift_bounded after every variable declaration,\n                // to trigger the solver instantiation\n\n                // ci_0 defs\n\n                let c0_0: u128 = c0_0_val(a);  // a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19\n                assert(c0_0 < 77 * bound_sq);\n\n                let c1_0: u128 = c1_0_val(a);  // a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19\n                assert(c1_0 < 59 * bound_sq);\n\n                let c2_0: u128 = c2_0_val(a);  // a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * a3_19\n                assert(c2_0 < 41 * bound_sq);\n\n                let c3_0: u128 = c3_0_val(a);  // a[4] * a4_19 + 2*( a[0] *  a[3] + a[1] *  a[2]\n                assert(c3_0 < 23 * bound_sq);\n\n                let c4_0: u128 = c4_0_val(a);  // a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3]\n                assert(c4_0 < 5 * bound_sq);\n\n                // ci defs\n\n                let c1 = c1_val(a);  // (c1_0 + ((c0_0 >> 51) as u64) as u128) as u128;\n                assert((c1 >> 51) <= (u64::MAX as u128));\n\n                let c2 = c2_val(a);  // (c2_0 + ((c1 >> 51) as u64) as u128) as u128;\n                assert((c2 >> 51) <= (u64::MAX as u128));\n\n                let c3 = c3_val(a);  // (c3_0 + ((c2 >> 51) as u64) as u128) as u128;\n                assert((c3 >> 51) <= (u64::MAX as u128));\n\n                let c4 = c4_val(a);  // (c4_0 + ((c3 >> 51) as u64) as u128) as u128;\n                assert((c4 >> 51) <= (u64::MAX as u128));\n\n                let a0_0 = (c0_0 as u64) & LOW_51_BIT_MASK;\n                // a0_0 < (1u64 << 51)\n                masked_lt_51(c0_0 as u64);\n\n                let a1_0 = (c1 as u64) & LOW_51_BIT_MASK;\n                // a1_0 < (1u64 << 51)\n                masked_lt_51(c1 as u64);\n\n                let a2 = (c2 as u64) & LOW_51_BIT_MASK;\n                // a2 < (1u64 << 51)\n                masked_lt_51(c2 as u64);\n\n                let a3 = (c3 as u64) & LOW_51_BIT_MASK;\n                // a3 < (1u64 << 51)\n                masked_lt_51(c3 as u64);\n\n                let carry: u64 = (c4 >> 51) as u64;\n                let a4 = (c4 as u64) & LOW_51_BIT_MASK;\n                // a4 < (1u64 << 51)\n                masked_lt_51(c4 as u64);\n\n                assert(c4 <= c4_0 + (u64::MAX as u128));\n                lemma_shr_51_le(c4, (5 * bound_sq + (u64::MAX as u128)) as u128);\n\n                // From the comments below:\n                // c4 < 2^110.33  so that carry < 2^59.33\n                // and\n                // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n\n                // ceil(2^59.33)\n                let pow2_5933 = 724618875532318195u64;\n\n                assert((5 * (1u128 << 108) + (u64::MAX as u128)) as u128 >> 51 < (\n                pow2_5933 as u128)) by (compute);\n                assert(carry < pow2_5933);\n\n                // a[0] += carry * 19 fits in u64\n                assert(a0_0 + carry * 19 <= u64::MAX) by {\n                    assert((1u64 << 51) + 19 * pow2_5933 <= u64::MAX) by (compute);\n                }\n\n                let a0_1 = (a0_0 + carry * 19) as u64;\n\n                lemma_shr_51_le(a0_1 as u128, u64::MAX as u128);\n                assert(((u64::MAX as u128) >> 51) < (1u64 << 13)) by (compute);\n\n                // a1_0 < (1u64 << 51)\n                assert((1u64 << 51) + (1u64 << 13) < (1u64 << 52)) by (compute);\n\n                // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n                assert(a1_0 + (a0_1 >> 51) < (1u64 << 52));\n                let a1_1 = (a1_0 + (a0_1 >> 51)) as u64;\n\n                let a0_2 = a0_1 & LOW_51_BIT_MASK;\n                // a0_2 < (1u64 << 51)\n                masked_lt_51(a0_1 as u64);\n\n                //---- end of no-overflow proof ----\n                // Loop invariant: after i loops we have as_nat(a) % p = as_nat(self.limbs) ^ (2 ^ i) % p\n                let a_hat = [a0_2, a1_1, a2, a3, a4];\n                assert(as_nat(a_hat) % p() == (as_nat(a) * as_nat(a)) % p()) by {\n                    // it suffices to prove as_nat(a_hat) == (as_nat(a))^2 (mod p)\n                    // let s = pow2(51) for brevity\n                    // By definition, as_nat(a_hat) = a0_2 + s * a1_1 + s^2 * a2 + s^3 * a3 + s^4 * a4\n                    // a0_2 + s * a1_1 cancel out terms via the div/mod identity:\n                    assert(as_nat(a_hat) == a0_1 + pow2(51) * a1_0 + pow2(102) * a2 + pow2(153) * a3\n                        + pow2(204) * a4) by {\n                        // a0_2 + s * a1_1 =\n                        // a0_1 % s  + s * (a1_0 + s * (a0_1 / s)) =\n                        // s * a1_0 + [s * (a0_1 / s) + a0_1 % s] = (by the div-mod identity)\n                        // s * a1_0 + a0_1\n                        assert(a0_2 + pow2(51) * a1_1 == a0_1 + pow2(51) * a1_0) by {\n                            lemma_div_and_mod_51((a0_1 >> 51), a0_2, a0_1);\n                        }\n                    }\n\n                    // Next, we replace all _ & LOW_BITS_MASK with (mod s)\n                    assert(as_nat(a_hat) == ((c0_0 as u64) % (pow2(51) as u64)) + 19 * carry + pow2(\n                        51,\n                    ) * ((c1 as u64) % (pow2(51) as u64)) + pow2(102) * ((c2 as u64) % (pow2(\n                        51,\n                    ) as u64)) + pow2(153) * ((c3 as u64) % (pow2(51) as u64)) + pow2(204) * ((\n                    c4 as u64) % (pow2(51) as u64))) by {\n                        l51_bit_mask_lt();\n\n                        assert((pow2(51) as u64) == (pow2(51) as u128));\n\n                        assert(a0_1 == ((c0_0 as u64) % (pow2(51) as u64)) + 19 * carry) by {\n                            lemma_u64_low_bits_mask_is_mod(c0_0 as u64, 51);\n                        }\n\n                        assert(a1_0 == (c1 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c1 as u64, 51);\n                        }\n\n                        assert(a2 == (c2 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c2 as u64, 51);\n                        }\n\n                        assert(a3 == (c3 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c3 as u64, 51);\n                        }\n\n                        assert(a4 == (c4 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c4 as u64, 51);\n                        }\n                    }\n\n                    // We can see all mod operations in u128\n                    assert(as_nat(a_hat) == (c0_0 % (pow2(51) as u128)) + 19 * carry + pow2(51) * (\n                    c1 % (pow2(51) as u128)) + pow2(102) * (c2 % (pow2(51) as u128)) + pow2(153) * (\n                    c3 % (pow2(51) as u128)) + pow2(204) * (c4 % (pow2(51) as u128))) by {\n                        // pow2(51) is the same in u64 and 128\n                        lemma_cast_then_mod_51(c0_0);\n                        lemma_cast_then_mod_51(c1);\n                        lemma_cast_then_mod_51(c2);\n                        lemma_cast_then_mod_51(c3);\n                        lemma_cast_then_mod_51(c4);\n                    }\n\n                    // Next, we categorically replace a % s with a - s * ( a / s )\n                    assert(as_nat(a_hat) == (c0_0 - pow2(51) * (c0_0 / (pow2(51) as u128))) + 19\n                        * carry + pow2(51) * (c1 - pow2(51) * (c1 / (pow2(51) as u128))) + pow2(102)\n                        * (c2 - pow2(51) * (c2 / (pow2(51) as u128))) + pow2(153) * (c3 - pow2(51)\n                        * (c3 / (pow2(51) as u128))) + pow2(204) * (c4 - pow2(51) * (c4 / (pow2(\n                        51,\n                    ) as u128)))) by {\n                        lemma_fundamental_div_mod(c0_0 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c1 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c2 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c3 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c4 as int, pow2(51) as int);\n                    }\n\n                    // Then, we know that\n                    // carry = c4/s\n                    // c4 = c4_0 + c3/s <=> c3/s = c4 - c4_0\n                    // c3 = c3_0 + c2/s <=> c2/s = c3 - c3_0\n                    // c2 = c2_0 + c1/s <=> c1/s = c2 - c2_0\n                    // c1 = c1_0 + c0_0/s <=> c0_0/s = c1 - c1_0\n                    assert(as_nat(a_hat) == (c0_0 - pow2(51) * (c1 - c1_0)) + 19 * carry + pow2(51)\n                        * (c1 - pow2(51) * (c2 - c2_0)) + pow2(102) * (c2 - pow2(51) * (c3 - c3_0))\n                        + pow2(153) * (c3 - pow2(51) * (c4 - c4_0)) + pow2(204) * (c4 - pow2(51)\n                        * carry)) by {\n                        lemma_u128_shr_is_div(c0_0, 51);\n                        lemma_u128_shr_is_div(c1, 51);\n                        lemma_u128_shr_is_div(c2, 51);\n                        lemma_u128_shr_is_div(c3, 51);\n                        lemma_u128_shr_is_div(c4, 51);\n                    }\n\n                    // Now we use distributivity and pow exponent sums, which cancels out any ci terms and leaves only ci_0 terms\n                    // Conveniently, we're left with a difference of c * p\n                    assert(as_nat(a_hat) == c0_0 + pow2(51) * c1_0 + pow2(102) * c2_0 + pow2(153)\n                        * c3_0 + pow2(204) * c4_0 - p() * carry) by {\n                        assert(c0_0 - pow2(51) * (c1 - c1_0) == c0_0 - pow2(51) * c1 + pow2(51)\n                            * c1_0) by {\n                            lemma_mul_is_distributive_sub(pow2(51) as int, c1 as int, c1_0 as int);\n                        }\n\n                        assert(pow2(51) * (c1 - pow2(51) * (c2 - c2_0)) == pow2(51) * c1 - pow2(102)\n                            * c2 + pow2(102) * c2_0) by {\n                            lemma_mul_sub(c1 as int, c2 as int, c2_0 as int, 51);\n                        }\n\n                        assert(pow2(102) * (c2 - pow2(51) * (c3 - c3_0)) == pow2(102) * c2 - pow2(\n                            153,\n                        ) * c3 + pow2(153) * c3_0) by {\n                            lemma_mul_sub(c2 as int, c3 as int, c3_0 as int, 102);\n                        }\n\n                        assert(pow2(153) * (c3 - pow2(51) * (c4 - c4_0)) == pow2(153) * c3 - pow2(\n                            204,\n                        ) * c4 + pow2(204) * c4_0) by {\n                            lemma_mul_sub(c3 as int, c4 as int, c4_0 as int, 153);\n                        }\n\n                        assert(pow2(204) * (c4 - pow2(51) * carry) == pow2(204) * c4 - pow2(255)\n                            * carry) by {\n                            lemma_mul_is_distributive_sub(\n                                pow2(204) as int,\n                                c4 as int,\n                                pow2(51) * carry,\n                            );\n                            lemma_mul_is_associative(\n                                pow2(204) as int,\n                                pow2(51) as int,\n                                carry as int,\n                            );\n                            lemma_pow2_adds(204, 51);\n                        }\n\n                        // carry on the right, get p\n                        assert(c0_0 + pow2(51) * c1_0 + pow2(102) * c2_0 + pow2(153) * c3_0 + pow2(\n                            204,\n                        ) * c4_0 + 19 * carry - pow2(255) * carry == c0_0 + pow2(51) * c1_0 + pow2(\n                            102,\n                        ) * c2_0 + pow2(153) * c3_0 + pow2(204) * c4_0 - p() * carry) by {\n                            pow255_gt_19();\n                            lemma_mul_is_distributive_sub_other_way(\n                                carry as int,\n                                pow2(255) as int,\n                                19,\n                            );\n                        }\n                    }\n\n                    let c_arr_as_nat = (c0_0 + pow2(51) * c1_0 + pow2(102) * c2_0 + pow2(153) * c3_0\n                        + pow2(204) * c4_0);\n\n                    assert(as_nat(a_hat) % p() == c_arr_as_nat as nat % p()) by {\n                        lemma_mod_diff_factor(carry as int, c_arr_as_nat as int, p() as int);\n                    }\n\n                    // We use the as_nat_squared lemma to see what (as_nat(a)^2) evaluates to (mod p)\n\n                    // The nat_squared lemma gives us the following:\n                    // as_nat(a) * as_nat(a) ==\n                    // pow2(8 * 51) * (a[4] * a[4]) +\n                    // pow2(7 * 51) * (2 * (a[3] * a[4])) +\n                    // pow2(6 * 51) * (a[3] * a[3] + 2 * (a[2] * a[4])) +\n                    // pow2(5 * 51) * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])) +\n                    // pow2(4 * 51) * (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])) +\n                    // pow2(3 * 51) * (2 * (a[1] * a[2]) + 2 * (a[0] * a[3])) +\n                    // pow2(2 * 51) * (a[1] * a[1] + 2 * (a[0] * a[2])) +\n                    // pow2(1 * 51) * (2 * (a[0] * a[1])) +\n                    //                (a[0] * a[0])\n                    //\n                    // AND\n                    //\n                    // (as_nat(a) * as_nat(a)) % p() ==\n                    // (\n                    //     pow2(4 * 51) * (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])) +\n                    //     pow2(3 * 51) * (2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])) +\n                    //     pow2(2 * 51) * (a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))) +\n                    //     pow2(1 * 51) * (2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))) +\n                    //                    (a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])))\n                    // ) as nat % p()\n                    as_nat_squared(a);\n\n                    // We're basically done, what remains is to prove that the coefficients next to pow2(i * 51)\n                    // are exactly ci_0s (via distributivity and associativity)\n\n                    // let c0_0: u128 = a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19);\n                    assert(c0_0 == (a[0] * a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4]))))\n                        by {\n                        // The solver does distributivity on its own.\n                        // LHS = a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19);\n                        //     = a[0] *  a[0] + 2*( a[1] * a4_19 ) + 2 * (a[2] * a3_19);\n                        // RHS = a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4]))\n                        //     = a[0] *  a[0] + 19 * (2 * (a[2] * a[3])) + 19 * (2 * (a[1] * a[4]))\n                        // goals\n                        // 1) 2 * (a[1] * a4_19) = 19 * (2 * (a[1] * a[4]))\n                        // 2) 2 * (a[2] * a3_19) = 19 * (2 * (a[2] * a[3]))\n                        assert(2 * (a[1] * a4_19) == 19 * (2 * (a[1] * a[4]))) by {\n                            lemma_reorder_mul(a[1] as int, a[4] as int);\n                        }\n\n                        assert(2 * (a[2] * a3_19) == 19 * (2 * (a[2] * a[3]))) by {\n                            lemma_reorder_mul(a[2] as int, a[3] as int);\n                        }\n                    }\n\n                    // let c1_0: u128 = a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19);\n                    assert(c1_0 == (2 * (a[0] * a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))))\n                        by {\n                        // The solver does distributivity on its own.\n                        // LHS = a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19)\n                        //     = a[3] * a3_19 + 2*( a[0] *  a[1]) + 2 * (a[2] * a4_19)\n                        // RHS = 2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))\n                        //     = 2 * (a[0] *  a[1]) + 19 * (a[3] * a[3]) + 19 * (2 * (a[2] * a[4]))\n                        // goals: 1) a[3] * a3_19 = 19 * (a[3] * a[3])\n                        //        2) 2 * (a[2] * a4_19) = 19 * (2 * (a[2] * a[4]))\n                        assert(a[3] * a3_19 == 19 * (a[3] * a[3])) by {\n                            lemma_mul_is_associative(a[3] as int, a[3] as int, 19);\n                        }\n\n                        assert(2 * (a[2] * a4_19) == 19 * (2 * (a[2] * a[4]))) by {\n                            lemma_reorder_mul(a[2] as int, a[4] as int);\n                        }\n                    }\n\n                    // let c2_0: u128 = a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * a3_19);\n                    assert(c2_0 == (a[1] * a[1] + 2 * (a[0] * a[2]) + 19 * (2 * (a[3] * a[4]))))\n                        by {\n                        // The solver does distributivity on its own.\n                        // LHS = a[1] * a[1] + 2 * (a[0] *  a[2] + a[4] * a3_19)\n                        //     = a[1] * a[1] + 2 * (a[0] *  a[2]) +  2 * (a[4] * a3_19)\n                        // RHS = a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))\n                        // goals: 2 * (a[4] * a3_19) = 19 * (2 * (a[3] * a[4]))\n                        assert(2 * (a[4] * a3_19) == 19 * (2 * (a[3] * a[4]))) by {\n                            lemma_mul_is_associative(a[4] as int, a[3] as int, 19);\n                        }\n                    }\n\n                    // let c3_0: u128 = a[4] * a4_19 + 2*( a[0] *  a[3] + a[1] *  a[2]);\n                    assert(c3_0 == (2 * (a[1] * a[2]) + 2 * (a[0] * a[3]) + 19 * (a[4] * a[4])))\n                        by {\n                        // The solver does distributivity on its own.\n                        // LHS = a[4] * a4_19 + 2 * (a[0] *  a[3] + a[1] *  a[2])\n                        //     = a[4] * a4_19 + 2 * (a[0] *  a[3]) + 2 * (a[1] *  a[2])\n                        // RHS = 2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])\n                        // goals: a[4] * a4_19 = 19 * (a[4] * a[4])\n                        assert(a[4] * a4_19 == 19 * (a[4] * a[4])) by {\n                            lemma_mul_is_associative(a[4] as int, a[4] as int, 19);\n                        }\n                    }\n\n                    // let c4_0: u128 = a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3]);\n                    assert(c4_0 == (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4]))) by {\n                        // The solver does distributivity on its own.\n                        // LHS = a[2] * a[2] + 2 * (a[0] * a[4] + a[1] * a[3])\n                        //     = a[2] * a[2] + 2 * (a[0] * a[4]) + 2 * (a[1] * a[3])\n                        // RHS = a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])\n                        // goals: none\n                    }\n                }\n\n                let a_pow_2i_int = pow(as_nat(self.limbs) as int, pow2(i as nat));\n                assert(a_pow_2i_int >= 0) by {\n                    lemma_pow_nat_is_nat(as_nat(self.limbs), i as nat);\n                }\n                let a_pow_2i: nat = a_pow_2i_int as nat;\n\n                assert(as_nat(a_hat) % p() == ((as_nat(a) % p()) * (as_nat(a) % p())) % p()) by {\n                    lemma_mul_mod_noop(as_nat(a) as int, as_nat(a) as int, p() as int);\n                }\n\n                // (a_pow_2i % p)^2 % p = (a_pow_2i^2) % p\n                lemma_mul_mod_noop(a_pow_2i as int, a_pow_2i as int, p() as int);\n\n                // We know, by the loop inv, that\n                // as_nat(a) % p == a_pow_2i % p\n                // and, by the above\n                // as_nat(a_hat) % p  = (as_nat(a) * as_nat(a)) % p = (a_pow_2i ^ 2)) % p\n                // It suffices to prove that\n                // (v^(2^i))^2 = v^(2^(i + 1))\n                lemma_pow2_square(as_nat(self.limbs) as int, i as nat);\n            }\n\n            // Precondition: assume input limbs a[i] are bounded as\n            //\n            // a[i] < 2^(51 + b)\n            //\n            // where b is a real parameter measuring the \"bit excess\" of the limbs.\n            // Precomputation: 64-bit multiply by 19.\n            //\n            // This fits into a u64 whenever 51 + b + lg(19) < 64.\n            //\n            // Since 51 + b + lg(19) < 51 + 4.25 + b\n            //                       = 55.25 + b,\n            // this fits if b < 8.75.\n            let a3_19 = 19 * a[3];\n            let a4_19 = 19 * a[4];\n\n            // Multiply to get 128-bit coefficients of output.\n            //\n            // The 128-bit multiplications by 2 turn into 1 slr + 1 slrd each,\n            // which doesn't seem any better or worse than doing them as precomputations\n            // on the 64-bit inputs.\n            let c0: u128 = m(a[0], a[0]) + 2 * (m(a[1], a4_19) + m(a[2], a3_19));\n            let mut c1: u128 = m(a[3], a3_19) + 2 * (m(a[0], a[1]) + m(a[2], a4_19));\n            let mut c2: u128 = m(a[1], a[1]) + 2 * (m(a[0], a[2]) + m(a[4], a3_19));\n            let mut c3: u128 = m(a[4], a4_19) + 2 * (m(a[0], a[3]) + m(a[1], a[2]));\n            let mut c4: u128 = m(a[2], a[2]) + 2 * (m(a[0], a[4]) + m(a[1], a[3]));\n\n            // Same bound as in multiply:\n            //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n            //         < 2^(102 + lg(1 + 4*19) + 2*b)\n            //         < 2^(108.27 + 2*b)\n            //\n            // The carry (c[i] >> 51) fits into a u64 when\n            //    108.27 + 2*b - 51 < 64\n            //    2*b < 6.73\n            //    b < 3.365.\n            //\n            // So we require b < 3 to ensure this fits.\n            #[cfg(not(verus_keep_ghost))]\n            {\n                debug_assert!(a[0] < (1 << 54));\n                debug_assert!(a[1] < (1 << 54));\n                debug_assert!(a[2] < (1 << 54));\n                debug_assert!(a[3] < (1 << 54));\n                debug_assert!(a[4] < (1 << 54));\n            }\n\n            // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n\n            // Casting to u64 and back tells the compiler that the carry is bounded by 2^64, so\n            // that the addition is a u128 + u64 rather than u128 + u128.\n            c1 += ((c0 >> 51) as u64) as u128;\n            a[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n            c2 += ((c1 >> 51) as u64) as u128;\n            a[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n            c3 += ((c2 >> 51) as u64) as u128;\n            a[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n            c4 += ((c3 >> 51) as u64) as u128;\n            a[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n            let carry: u64 = (c4 >> 51) as u64;\n            a[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n            // To see that this does not overflow, we need a[0] + carry * 19 < 2^64.\n            //\n            // c4 < a2^2 + 2*a0*a4 + 2*a1*a3 + (carry from c3)\n            //    < 2^(102 + 2*b + lg(5)) + 2^64.\n            //\n            // When b < 3 we get\n            //\n            // c4 < 2^110.33  so that carry < 2^59.33\n            //\n            // so that\n            //\n            // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n            //\n            // and there is no overflow.\n            a[0] += carry * 19;\n\n            // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n            a[1] += a[0] >> 51;\n            a[0] &= LOW_51_BIT_MASK;\n\n            // Now all a[i] < 2^(51 + epsilon) and a = self^(2^k).\n\n            k -= 1;\n            if k == 0 {\n                break ;\n            }\n        }\n\n        FieldElement51 { limbs: a }\n    }\n\n    /// Returns the square of this field element.\n    pub fn square(&self) -> (r: FieldElement51)\n        requires\n    // The precondition in pow2k loop propagates to here\n\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54,\n        ensures\n            as_nat(r.limbs) % p() == pow(as_nat(self.limbs) as int, 2) as nat % p(),\n    {\n        proof {\n            // pow2(1) == 2\n            lemma2_to64();\n        }\n        self.pow2k(1)\n    }\n\n    /// Returns 2 times the square of this field element.\n    pub fn square2(&self) -> (r: FieldElement51)\n        requires\n    // The precondition in pow2k loop propagates to here\n\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54,\n        ensures\n            as_nat(r.limbs) % p() == (2 * pow(as_nat(self.limbs) as int, 2)) as nat % p(),\n    {\n        let mut square = self.pow2k(1);\n\n        // Since square is mut, we save the initial value\n        let ghost old_limbs = square.limbs;\n\n        proof {\n            // forall |i: int| 0 <= i < 5 ==> 2 * old_limbs[i] <= u64::MAX\n            assert forall|i: int| 0 <= i < 5 implies 2 * square.limbs[i] <= u64::MAX by {\n                // if LHS < RHS, then 2 * LHS < 2 * RHS\n                lemma_mul_left_inequality(2, square.limbs[i] as int, (1u64 << 54) as int);\n                assert(2 * (1u64 << 54) <= u64::MAX) by (compute);\n            }\n\n            let ka = [\n                (2 * square.limbs[0]) as u64,\n                (2 * square.limbs[1]) as u64,\n                (2 * square.limbs[2]) as u64,\n                (2 * square.limbs[3]) as u64,\n                (2 * square.limbs[4]) as u64,\n            ];\n\n            // as_nat(ka) == 2 * as_nat(square.limbs)\n            // and\n            // as_nat(ka) % p() == (2 * as_nat(square.limbs)) % p()\n            as_nat_k(square.limbs, 2);\n\n            // By pow2k ensures:\n            // as_nat(square.limbs) % p() == pow(as_nat(self.limbs) as int, pow2(1)) as nat % p()\n            // We just need pow2(1) == 2\n            lemma2_to64();\n\n            // p > 0\n            pow255_gt_19();\n\n            assert(as_nat(ka) % p() == ((2nat % p()) * (as_nat(square.limbs) % p())) % p() == ((2nat\n                % p()) * (pow(as_nat(self.limbs) as int, 2) as nat % p())) % p()) by {\n                lemma_mul_mod_noop(2, as_nat(square.limbs) as int, p() as int);\n            }\n\n            // as_nat(self.limbs)^2 >= 0\n            assert(pow(as_nat(self.limbs) as int, 2) >= 0) by {\n                lemma_pow_nat_is_nat(as_nat(self.limbs), 1);\n            }\n\n            assert(((2nat % p()) * (pow(as_nat(self.limbs) as int, 2) as nat % p())) % p() == (2 * (\n            pow(as_nat(self.limbs) as int, 2))) as nat % p()) by {\n                lemma_mul_mod_noop(2, pow(as_nat(self.limbs) as int, 2) as int, p() as int);\n            }\n\n            assert(as_nat(ka) % p() == (2 * (pow(as_nat(self.limbs) as int, 2))) as nat % p());\n        }\n\n        for i in 0..5\n            invariant\n                forall|j: int| 0 <= j < 5 ==> old_limbs[j] < (1u64 << 54),\n                forall|j: int| 0 <= j < i ==> #[trigger] square.limbs[j] == 2 * old_limbs[j],\n                forall|j: int| i <= j < 5 ==> #[trigger] square.limbs[j] == old_limbs[j],\n        {\n            proof {\n                assert(2 * (1u64 << 54) <= u64::MAX) by (compute);\n                lemma_mul_strict_inequality(square.limbs[i as int] as int, (1u64 << 54) as int, 2);\n            }\n            square.limbs[i] *= 2;\n        }\n\n        square\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb0_byte_contribution().",
      "display_name": "limb0_byte_contribution",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb0_byte_contribution().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "spec fn limb0_byte_contribution(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    bytes[0] as nat * pow2(0 * 8) + bytes[1] as nat * pow2(1 * 8) + bytes[2] as nat * pow2(2 * 8)\n        + bytes[3] as nat * pow2(3 * 8) + bytes[4] as nat * pow2(4 * 8) + bytes[5] as nat * pow2(\n        5 * 8,\n    )\n        +\n    // Byte 6 is a boundary byte - limb 0 contributes only the low 3 bits\n    // These 3 bits represent limbs[0]'s bits 48-50\n    ((limbs[0] as nat / pow2(48)) % 8) * pow2(6 * 8)\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_0_bounded().",
      "display_name": "c_i_0_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_0_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"CompressedRistretto: {:?}\", self.as_bytes())\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "display_name": "lemma_mul_is_distributive_sub_other_way",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_is_binary().",
      "display_name": "lemma_q_is_binary",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_is_binary().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_q_is_binary(limbs: [u64; 5], q: u64)\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 52),\n        as_nat(limbs) < 2 * p(),  // From reduce()'s postcondition\n        q == compute_q_spec(limbs),\n        q < 3,\n    ensures\n        q == 0 || q == 1,\n        q as nat == (as_nat(limbs) + 19) / pow2(255),  // Export for reuse\n{\n    lemma_carry_propagation_is_division(limbs, q);\n\n    // Establish basic facts\n    lemma2_to64();\n    pow255_gt_19();\n    lemma_pow2_adds(255, 1);  // Establish pow2(256) == pow2(255) * 2\n\n    // Simplified reasoning:\n    // Since p() = 2^255 - 19 < 2^255, we have:\n    // as_nat(limbs) < 2*p() < 2*2^255\n    // Therefore: as_nat(limbs) + 19 < 2*2^255\n    assert(p() < pow2(255)) by {\n        pow255_gt_19();\n    }\n\n    // By integer division: if x < 2 * d, then x / d < 2\n    lemma_pow2_pos(255);\n    lemma_div_strictly_bounded((as_nat(limbs) + 19) as int, pow2(255) as int, 2);\n\n    // Since q = (as_nat(limbs) + 19) / 2^255, we have q < 2\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness().",
      "display_name": "lemma_limb4_contribution_correctness",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_limb4_contribution_correctness(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[3] < pow2(51),  // Need limb 3 for boundary byte 25\n        limbs[4] < pow2(51),\n        bytes_match_limbs_packing(limbs, bytes),\n    ensures\n        limb4_byte_contribution(limbs, bytes) == limbs[4] as nat * pow2(204),\n{\n    // Limb 4 stored in bytes 25-31, positioned at 2^204\n    // - Byte 25 (high 4 bits): limbs[4]'s bits 0-3\n    // - Bytes 26-31: limbs[4]'s bits 4-51 (48 bits, but only 47 used)\n    // Total: 4 + 47 = 51 bits (limbs[4] < 2^51)\n    lemma2_to64();\n    lemma_pow2_adds(200, 4);  // 2^204 = 2^200 * 2^4\n\n    // Stabilization placeholders\n    assert(pow2(0) == pow2(0 * 8));\n    assert(pow2(8) == pow2(1 * 8));\n    assert(pow2(16) == pow2(2 * 8));\n    assert(pow2(24) == pow2(3 * 8));\n    assert(pow2(32) == pow2(4 * 8));\n\n    // KEY INSIGHT: From bytes_match_limbs_packing:\n    // bytes[26] = (limbs[4] >> 4) as u8\n    // bytes[27] = (limbs[4] >> 12) as u8\n    // ... and so on\n    //\n    // So limb4_byte_contribution is:\n    //   (limbs[4] % 2^4) * 16 * 2^200 +             // Low 4 bits at position 2^204\n    //   (limbs[4] >> 4 ... >> 44) * positions       // High 47 bits at position 2^208\n    //\n    // This is limbs[4] * 2^204!\n\n    // Step 1: Extract arithmetic values for bytes 26-31\n    // These bytes come from limbs[4] >> 4, 12, 20, 28, 36, 44\n    lemma_byte_from_limb_shift(limbs[4], 4, bytes[26]);\n    assert(bytes[26] as nat == (limbs[4] as nat / pow2(4)) % 256);\n\n    lemma_byte_from_limb_shift(limbs[4], 12, bytes[27]);\n\n    lemma_byte_from_limb_shift(limbs[4], 20, bytes[28]);\n\n    lemma_byte_from_limb_shift(limbs[4], 28, bytes[29]);\n\n    lemma_byte_from_limb_shift(limbs[4], 36, bytes[30]);\n\n    lemma_byte_from_limb_shift(limbs[4], 44, bytes[31]);\n\n    // Step 2: Prove that bytes[26-31] reconstruct (limbs[4] / 2^4) at position 2^208\n    //\n    // From lemma_byte_from_limb_shift, we have:\n    // bytes[26] as nat == (limbs[4] / pow2(4)) % 256\n    // bytes[27] as nat == (limbs[4] / pow2(12)) % 256\n    // bytes[28] as nat == (limbs[4] / pow2(20)) % 256\n    // bytes[29] as nat == (limbs[4] / pow2(28)) % 256\n    // bytes[30] as nat == (limbs[4] / pow2(36)) % 256\n    // bytes[31] as nat == (limbs[4] / pow2(44)) % 256\n    //\n    // The key insight: these bytes extract consecutive 8-bit chunks from (limbs[4] / 2^4)\n\n    // First, rewrite the byte extractions in terms of (limbs[4] / 2^4)\n    // bytes[26] == (limbs[4] / 2^4) / 2^0 % 256\n    lemma_pow2_adds(0, 4);\n    assert(pow2(4) * pow2(0) == pow2(4));\n    lemma_div_denominator(limbs[4] as int, pow2(4) as int, pow2(0) as int);\n\n    // bytes[27] == (limbs[4] / 2^12) % 256 == (limbs[4] / 2^4) / 2^8 % 256\n    lemma_pow2_adds(4, 8);\n    lemma_div_denominator(limbs[4] as int, pow2(4) as int, pow2(8) as int);\n\n    // bytes[28] == (limbs[4] / 2^20) % 256 == (limbs[4] / 2^4) / 2^16 % 256\n    lemma_pow2_adds(4, 16);\n    lemma_div_denominator(limbs[4] as int, pow2(4) as int, pow2(16) as int);\n\n    // bytes[29] == (limbs[4] / 2^28) % 256 == (limbs[4] / 2^4) / 2^24 % 256\n    lemma_pow2_adds(4, 24);\n    lemma_div_denominator(limbs[4] as int, pow2(4) as int, pow2(24) as int);\n\n    // bytes[30] == (limbs[4] / 2^36) % 256 == (limbs[4] / 2^4) / 2^32 % 256\n    lemma_pow2_adds(4, 32);\n    lemma_pow2_pos(32);\n    lemma_div_denominator(limbs[4] as int, pow2(4) as int, pow2(32) as int);\n\n    // bytes[31] == (limbs[4] / 2^44) % 256 == (limbs[4] / 2^4) / 2^40 % 256\n    lemma_pow2_adds(4, 40);\n    lemma_pow2_pos(40);\n    lemma_div_denominator(limbs[4] as int, pow2(4) as int, pow2(40) as int);\n\n    // Since limbs[4] < 2^51, we have limbs[4] / 2^4 < 2^47\n    lemma_div_bound(limbs[4] as nat, 4, 51);\n\n    // The value (limbs[4] / 2^4) is 47 bits, and we have 6 bytes (48 bits capacity)\n    // So we can directly use it without modulo truncation!\n    let high_value = limbs[4] as nat / pow2(4);\n\n    // Prove high_value < 2^48 (we have 2^47, which is less than 2^48)\n    assert(high_value < pow2(47));\n    assert(pow2(47) < pow2(48)) by {\n        lemma_pow2_adds(47, 1);\n        assert(pow2(48) == pow2(47) * 2);\n    }\n\n    // Now apply lemma_6_bytes_reconstruct\n    lemma_6_bytes_reconstruct(\n        high_value,\n        bytes[26],\n        bytes[27],\n        bytes[28],\n        bytes[29],\n        bytes[30],\n        bytes[31],\n    );\n\n    // This gives us:\n    assert(bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat * pow2(16)\n        + bytes[29] as nat * pow2(24) + bytes[30] as nat * pow2(32) + bytes[31] as nat * pow2(40)\n        == high_value);\n\n    // Now multiply both sides by 2^208 to get the bytes at their actual positions\n    lemma_mul_is_distributive_add(\n        pow2(208) as int,\n        (bytes[26] as nat * pow2(0)) as int,\n        (bytes[27] as nat * pow2(8)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(208) as int,\n        (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8)) as int,\n        (bytes[28] as nat * pow2(16)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(208) as int,\n        (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat * pow2(\n            16,\n        )) as int,\n        (bytes[29] as nat * pow2(24)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(208) as int,\n        (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat * pow2(16)\n            + bytes[29] as nat * pow2(24)) as int,\n        (bytes[30] as nat * pow2(32)) as int,\n    );\n    lemma_mul_is_distributive_add(\n        pow2(208) as int,\n        (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat * pow2(16)\n            + bytes[29] as nat * pow2(24) + bytes[30] as nat * pow2(32)) as int,\n        (bytes[31] as nat * pow2(40)) as int,\n    );\n\n    // Distribute the multiplication into each term\n    lemma_mul_is_associative(bytes[26] as int, pow2(0) as int, pow2(208) as int);\n    lemma_mul_is_associative(bytes[27] as int, pow2(8) as int, pow2(208) as int);\n    lemma_mul_is_associative(bytes[28] as int, pow2(16) as int, pow2(208) as int);\n    lemma_mul_is_associative(bytes[29] as int, pow2(24) as int, pow2(208) as int);\n    lemma_mul_is_associative(bytes[30] as int, pow2(32) as int, pow2(208) as int);\n    lemma_mul_is_associative(bytes[31] as int, pow2(40) as int, pow2(208) as int);\n\n    // Simplify using pow2 addition: 2^208 * 2^k = 2^(208+k)\n    lemma_pow2_adds(208, 0);\n\n    lemma_pow2_adds(208, 8);\n\n    lemma_pow2_adds(208, 16);\n\n    lemma_pow2_adds(208, 24);\n\n    lemma_pow2_adds(208, 32);\n\n    lemma_pow2_adds(208, 40);\n\n    // Final result\n    assert(bytes[26] as nat * pow2(26 * 8) + bytes[27] as nat * pow2(27 * 8) + bytes[28] as nat\n        * pow2(28 * 8) + bytes[29] as nat * pow2(29 * 8) + bytes[30] as nat * pow2(30 * 8)\n        + bytes[31] as nat * pow2(31 * 8) == high_value * pow2(208));\n\n    // Step 3: Handle boundary byte\n    // Low 4 bits (byte 25 high part): (limbs[4] % 2^4) * 16 * 2^200 = (limbs[4] % 2^4) * 2^204\n\n    assert(16 * pow2(200) == pow2(204)) by {\n        lemma_pow2_adds(200, 4);\n    }\n\n    // From the proof above, we have:\n    let high_bytes_sum = bytes[26] as nat * pow2(26 * 8) + bytes[27] as nat * pow2(27 * 8)\n        + bytes[28] as nat * pow2(28 * 8) + bytes[29] as nat * pow2(29 * 8) + bytes[30] as nat\n        * pow2(30 * 8) + bytes[31] as nat * pow2(31 * 8);\n\n    let high_value_at_position = (limbs[4] as nat / pow2(4)) * pow2(208);\n\n    // Substitute into contribution\n    let contribution = limb4_byte_contribution(limbs, bytes);\n    assert(contribution == ((limbs[4] as nat % pow2(4)) * 16) * pow2(200) + high_bytes_sum);\n\n    assert(contribution == ((limbs[4] as nat % pow2(4)) * 16) * pow2(200) + high_value_at_position);\n\n    // Step 3: Prove the reconstruction identity for limbs[4]\n    // limbs[4] = (limbs[4] % 2^4) + (limbs[4] / 2^4) * 2^4\n    // This is just the fundamental div-mod property!\n\n    lemma_pow2_pos(4);\n    lemma_fundamental_div_mod(limbs[4] as int, pow2(4) as int);\n    assert(pow2(4) * (limbs[4] as nat / pow2(4)) == (limbs[4] as nat / pow2(4)) * pow2(4)) by {\n        lemma_mul_is_commutative(pow2(4) as int, (limbs[4] as nat / pow2(4)) as int);\n    }\n\n    // Step 4: Now connect the contribution to limbs[4] * 2^204\n    // We have: contribution = ((limbs[4] % 2^4) * 16) * 2^200 + (limbs[4] / 2^4) * 2^208\n\n    // First, simplify the low term: ((limbs[4] % 2^4) * 16) * 2^200 = (limbs[4] % 2^4) * (16 * 2^200) = (limbs[4] % 2^4) * 2^204\n    // We proved earlier that 16 * 2^200 = 2^204\n    let low_part = (limbs[4] as nat % pow2(4));\n    assert(((limbs[4] as nat % pow2(4)) * 16) * pow2(200) == low_part * (16 * pow2(200))) by {\n        lemma_mul_is_associative(low_part as int, 16, pow2(200) as int);\n    }\n\n    // So contribution = (limbs[4] % 2^4) * 2^204 + (limbs[4] / 2^4) * 2^208\n    assert(contribution == low_part * pow2(204) + (limbs[4] as nat / pow2(4)) * pow2(208));\n\n    // Rewrite using 2^208 = 2^204 * 2^4\n    lemma_pow2_adds(204, 4);\n\n    assert(contribution == low_part * pow2(204) + (limbs[4] as nat / pow2(4)) * (pow2(204) * pow2(\n        4,\n    )));\n\n    // Apply associativity to move pow2(204) to the left\n    let high_part = limbs[4] as nat / pow2(4);\n\n    assert(high_part * (pow2(204) * pow2(4)) == (high_part * pow2(204)) * pow2(4)) by {\n        lemma_mul_is_associative(high_part as int, pow2(204) as int, pow2(4) as int);\n    }\n    assert((high_part * pow2(204)) * pow2(4) == pow2(204) * high_part * pow2(4)) by {\n        lemma_mul_is_commutative((high_part * pow2(204)) as int, pow2(4) as int);\n    }\n    assert(pow2(204) * high_part * pow2(4) == pow2(204) * (high_part * pow2(4))) by {\n        lemma_mul_is_associative(pow2(204) as int, high_part as int, pow2(4) as int);\n    }\n\n    // Now factor out pow2(204)\n    assert(contribution == low_part * pow2(204) + pow2(204) * (high_part * pow2(4)));\n\n    // Use distributivity to factor out pow2(204)\n    assert(contribution == pow2(204) * (low_part + high_part * pow2(4))) by {\n        lemma_mul_is_distributive_add(\n            pow2(204) as int,\n            low_part as int,\n            (high_part * pow2(4)) as int,\n        );\n    }\n\n    // The part in parentheses equals limbs[4] by our reconstruction identity!\n    assert(contribution == limbs[4] as nat * pow2(204)) by {\n        lemma_mul_is_commutative(pow2(204) as int, limbs[4] as int);\n    }\n\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 14
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_as_nat_bound_from_51bit_limbs().",
      "display_name": "lemma_as_nat_bound_from_51bit_limbs",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_as_nat_bound_from_51bit_limbs().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_as_nat_bound_from_51bit_limbs(limbs: [u64; 5])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51),\n    ensures\n        as_nat(limbs) < pow2(255),\n{\n    // Strategy: Prove that the maximum value (when all limbs = 2^51 - 1) equals 2^255 - 1\n    // We'll prove this by showing the algebraic identity directly using bit manipulation\n    lemma2_to64_rest();\n    assert((1u64 << 51) as nat == pow2(51)) by (compute);\n\n    // Establish power-of-2 relationships\n    lemma_pow2_adds(51, 51);  // 2^102 = 2^51 * 2^51\n    lemma_pow2_adds(51, 102);  // 2^153 = 2^51 * 2^102\n    lemma_pow2_adds(51, 153);  // 2^204 = 2^51 * 2^153\n    lemma_pow2_adds(51, 204);  // 2^255 = 2^51 * 2^204\n\n    // Expand as_nat definition\n    assert(as_nat(limbs) == limbs[0] as nat + pow2(51) * limbs[1] as nat + pow2(102)\n        * limbs[2] as nat + pow2(153) * limbs[3] as nat + pow2(204) * limbs[4] as nat);\n\n    // Each limb < 2^51, so limbs[i] <= 2^51 - 1\n    lemma_pow2_pos(51);\n    let max_limb = (pow2(51) - 1) as nat;\n\n    // Prove upper bound for each term\n    lemma_mul_upper_bound(pow2(51), limbs[1] as nat, max_limb);\n\n    lemma_mul_upper_bound(pow2(102), limbs[2] as nat, max_limb);\n\n    lemma_mul_upper_bound(pow2(153), limbs[3] as nat, max_limb);\n\n    lemma_mul_upper_bound(pow2(204), limbs[4] as nat, max_limb);\n\n    // Therefore, as_nat(limbs) <= sum of maximum values\n    // as_nat(limbs) <= max_limb + pow2(51)*max_limb + pow2(102)*max_limb + pow2(153)*max_limb + pow2(204)*max_limb\n    //                = max_limb * (1 + pow2(51) + pow2(102) + pow2(153) + pow2(204))\n\n    // Since each term is maximized at max_limb = 2^51 - 1, we have:\n    let max_val = max_limb + pow2(51) * max_limb + pow2(102) * max_limb + pow2(153) * max_limb\n        + pow2(204) * max_limb;\n\n    // Factor out max_limb using distributivity\n    lemma_mul_is_distributive_add(max_limb as int, 1, pow2(51) as int);\n    lemma_mul_is_distributive_add(max_limb as int, (1 + pow2(51)) as int, pow2(102) as int);\n    lemma_mul_is_distributive_add(\n        max_limb as int,\n        (1 + pow2(51) + pow2(102)) as int,\n        pow2(153) as int,\n    );\n    lemma_mul_is_distributive_add(\n        max_limb as int,\n        (1 + pow2(51) + pow2(102) + pow2(153)) as int,\n        pow2(204) as int,\n    );\n\n    // Now use the geometric series identity: (2^51 - 1) * (1 + 2^51 + 2^102 + 2^153 + 2^204) = 2^255 - 1\n    lemma_geometric_sum_5_terms();\n\n    // Since as_nat(limbs) <= max_val = 2^255 - 1 < 2^255, we're done\n    assert(pow2(255) - 1 < pow2(255)) by {\n        lemma_pow2_pos(255);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "display_name": "as_extended",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
      "relative_path": "src/backend/serial/scalar_mul/straus.rs",
      "file_name": "straus.rs",
      "parent_folder": "scalar_mul",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_lt_pow2_8().",
      "display_name": "u8_lt_pow2_8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_lt_pow2_8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "\nuse super::field_core::*;\n\nverus! {\n\npub open spec fn load8_at_or_version_rec(input: &[u8], i: usize, k: nat) -> u64\n    decreases k,\n{\n    if (k == 0) {\n        (input[i as int] as u64)\n    } else {\n        // k > 0\n        load8_at_or_version_rec(input, i, (k - 1) as nat) | ((input[i + k] as u64) << k * 8)\n    }\n}\n\npub proof fn rec_version_is_exec(input: &[u8], i: usize)\n    ensures\n        load8_at_or_version_rec(input, i, 7) == (input[i as int] as u64) | ((input[i + 1] as u64)\n            << 8) | ((input[i + 2] as u64) << 16) | ((input[i + 3] as u64) << 24) | ((input[i\n            + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((input[i + 6] as u64) << 48) | ((\n        input[i + 7] as u64) << 56),\n{\n    assert(load8_at_or_version_rec(input, i, 0) == (input[i as int] as u64));\n\n    assert forall|j: nat| 1 <= j <= 7 implies #[trigger] load8_at_or_version_rec(input, i, j)\n        == load8_at_or_version_rec(input, i, (j - 1) as nat) | ((input[i + j] as u64) << 8 * j) by {\n        reveal_with_fuel(load8_at_or_version_rec, 1);\n    }\n}\n\npub open spec fn load8_at_plus_version_rec(input: &[u8], i: usize, k: nat) -> u64\n    decreases k,\n{\n    if (k == 0) {\n        (input[i as int] as u64)\n    } else {\n        // k > 0\n        (load8_at_plus_version_rec(input, i, (k - 1) as nat) + ((input[i + k] as u64) << k\n            * 8)) as u64\n    }\n}\n\npub proof fn load8_at_plus_version_rec_is_bounded(input: &[u8], i: usize, k: nat)\n    requires\n        k <= 7,\n    ensures\n        load8_at_plus_version_rec(input, i, k) < pow2(8 * (k + 1)),\n    decreases k,\n{\n    assert(u8::MAX < pow2(8)) by {\n        lemma2_to64();\n    }\n\n    if (k == 0) {\n        // just needs the the pre-if assert\n    } else {\n        // k > 0\n        // Let f(k) := load8_at_plus_version_rec(input, i, k)\n        // IH: f(k - 1) < pow2(8 * k)\n        assert(load8_at_plus_version_rec(input, i, (k - 1) as nat) < pow2(8 * k)) by {\n            load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n        }\n\n        let c = (input[i + k] as u64);\n        assert(c < pow2(8));\n\n        // f(k) = f(k - 1) + c * pow2(8 * k)\n        assert(c << (8 * k) == c * pow2(8 * k)) by {\n            assert((input[i + k] as u64) * pow2(8 * k) <= u64::MAX) by {\n                assert(u64::MAX == pow2(64) - 1) by {\n                    lemma2_to64_rest();\n                }\n                assert(c * pow2(8 * k) < pow2(64)) by {\n                    assert(c * pow2(8 * k) < pow2(8) * pow2(8 * k)) by {\n                        lemma_mul_strict_inequality(c as int, pow2(8) as int, pow2(8 * k) as int);\n                    }\n                    assert(pow2(8) * pow2(8 * k) <= pow2(64)) by {\n                        assert(pow2(8 * k) <= pow2(56)) by {\n                            if (k < 7) {\n                                lemma_pow2_strictly_increases(8 * k, 56);\n                            }\n                        }\n                        lemma_pow2_pos(8);\n                        lemma_mul_inequality(pow2(8 * k) as int, pow2(56) as int, pow2(8) as int);\n                        lemma_pow2_adds(8, 56);\n                    }\n                }\n            }\n            lemma_u64_shl_is_mul(c, (8 * k) as u64);\n        }\n\n        // f(k - 1) < 1 * 2^(8k)\n        // c <= 2^8 - 1\n        // f(k -1) + c * 2^8k < 2^8 * 2^8k = 2^(8 * (k + 1))\n\n        assert(load8_at_plus_version_rec(input, i, k) < pow2(8 * k) + c * pow2(8 * k));\n\n        assert(pow2(8 * k) + c * pow2(8 * k) <= pow2(8 * (k + 1))) by {\n            // x + c * x == c ( x + 1 )\n            assert(pow2(8 * k) + c * pow2(8 * k) == pow2(8 * k) * (c + 1)) by {\n                lemma_mul_is_distributive_add(pow2(8 * k) as int, c as int, 1);\n            }\n            assert(c + 1 <= pow2(8));\n\n            assert(pow2(8 * k) * (c + 1) <= pow2(8 * (k + 1))) by {\n                lemma_mul_inequality((c + 1) as int, pow2(8) as int, pow2(8 * k) as int);\n                lemma_pow2_adds(8, 8 * k);\n                lemma_mul_is_distributive_add(8, 1, k as int);\n            }\n        }\n    }\n}\n\npub proof fn plus_version_is_spec_lemma(input: &[u8], i: usize, j: nat)\n    requires\n        1 <= j <= 7,\n    ensures\n        (input[i + j] as u64) << 8 * j == pow2(j * 8) * input[i + j],\n        input[i + j] * pow2(j * 8) <= u64::MAX,\n        pow2(8 * (j + 1)) - 1 <= pow2(64) - 1,\n        pow2(8) * pow2(8 * j) == pow2(8 * (j + 1)),\n{\n    assert(pow2(64) - 1 == u64::MAX) by {\n        lemma2_to64_rest();\n    }\n\n    assert(u8::MAX + 1 == pow2(8)) by {\n        lemma2_to64();\n    }\n\n    assert(pow2(8 * (j + 1)) - 1 <= pow2(64) - 1) by {\n        if (j < 7) {\n            lemma_pow2_strictly_increases(8 * (j + 1), 64);\n        }\n    }\n\n    lemma_pow2_adds(8, j * 8);\n\n    lemma_mul_inequality(input[i + j] as int, u8::MAX as int, pow2(j * 8) as int);\n\n    assert((input[i + j] as u64) * pow2(j * 8) <= u64::MAX) by {\n        assert(u8::MAX * pow2(j * 8) <= pow2(64) - 1) by {\n            assert(u8::MAX * pow2(j * 8) == (pow2(8) - 1) * pow2(j * 8) == pow2(8 * (j + 1)) - pow2(\n                j * 8,\n            )) by {\n                assert(pow2(8) >= 1) by {\n                    lemma2_to64();\n                }\n                lemma_mul_is_distributive_sub(pow2(8) as int, 1, pow2(j * 8) as int);\n            }\n            assert(pow2(j * 8) > 1) by {\n                lemma2_to64();  // pow2(0)\n                lemma_pow2_strictly_increases(0, j * 8)\n            }\n        }\n    }\n    lemma_u64_shl_is_mul((input[i + j] as u64), (j * 8) as u64);\n}\n\npub proof fn plus_version_is_spec(input: &[u8], i: usize)\n    ensures\n        load8_at_plus_version_rec(input, i, 7) == load8_at_spec(input, i),\n{\n    assert(load8_at_plus_version_rec(input, i, 0) == input[i as int] as u64);\n\n    assert(pow2(64) - 1 == u64::MAX) by {\n        lemma2_to64_rest();\n    }\n\n    assert(u8::MAX + 1 == pow2(8)) by {\n        lemma2_to64();\n    }\n\n    assert((input[i as int] as u64) == pow2(0 * 8) * input[i + 0]) by {\n        lemma2_to64();\n    }\n    plus_version_is_spec_lemma(input, i, 1);\n    plus_version_is_spec_lemma(input, i, 2);\n    plus_version_is_spec_lemma(input, i, 3);\n    plus_version_is_spec_lemma(input, i, 4);\n    plus_version_is_spec_lemma(input, i, 5);\n    plus_version_is_spec_lemma(input, i, 6);\n    plus_version_is_spec_lemma(input, i, 7);\n\n    // suffices to prove this, the _lemma results then give the spec formulation for free\n    assert(load8_at_plus_version_rec(input, i, 7) == (input[i as int] as u64) + ((input[i\n        + 1] as u64) << 8) + ((input[i + 2] as u64) << 16) + ((input[i + 3] as u64) << 24) + ((\n    input[i + 4] as u64) << 32) + ((input[i + 5] as u64) << 40) + ((input[i + 6] as u64) << 48) + ((\n    input[i + 7] as u64) << 56)) by {\n        assert forall|j: nat| 1 <= j <= 7 implies #[trigger] load8_at_plus_version_rec(input, i, j)\n            == load8_at_plus_version_rec(input, i, (j - 1) as nat) + ((input[i + j] as u64) << j\n            * 8) by {\n            reveal_with_fuel(load8_at_plus_version_rec, 1);\n\n            assert(load8_at_plus_version_rec(input, i, (j - 1) as nat) + ((input[i + j] as u64) << j\n                * 8) <= u64::MAX) by {\n                assert(load8_at_plus_version_rec(input, i, (j - 1) as nat) <= pow2(8 * j) - 1) by {\n                    load8_at_plus_version_rec_is_bounded(input, i, (j - 1) as nat);\n                }\n\n                assert((input[i + j] as u64) << j * 8 <= u8::MAX * pow2(j * 8)) by {\n                    // input[k] < MAX8 => input[k] * 2^(8j) < MAX8 * 2^(8j)\n                    lemma_mul_inequality(input[i + j] as int, u8::MAX as int, pow2(j * 8) as int);\n                }\n\n                assert(load8_at_plus_version_rec(input, i, (j - 1) as nat) + ((input[i + j] as u64)\n                    << j * 8) <= pow2(8 * (j + 1)) - 1) by {\n                    lemma_mul_is_distributive_add(1, u8::MAX as int, pow2(j * 8) as int);\n                }\n            }\n\n        }\n    }\n}\n\npub proof fn load8_at_versions_equivalent(input: &[u8], i: usize, k: nat)\n    requires\n        k <= 7,\n    ensures\n        load8_at_or_version_rec(input, i, k) == load8_at_plus_version_rec(input, i, k),\n    decreases k,\n{\n    if (k == 0) {\n        // trivial\n    } else {\n        load8_at_versions_equivalent(input, i, (k - 1) as nat);\n        let prev = load8_at_plus_version_rec(input, i, (k - 1) as nat);\n        assert(prev < (1u64 << 8 * k)) by {\n            load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n            shift_is_pow2(8 * k);\n        }\n        let v = input[i + k];\n        assert(v <= (u64::MAX >> ((k * 8) as u64))) by {\n            assert(v <= u8::MAX);\n            assert(u64::MAX >> ((k * 8) as u64) >= u64::MAX >> 56) by {\n                shr_nonincreasing(u64::MAX, k * 8, 56);\n            }\n            assert(u8::MAX <= u64::MAX >> 56) by (compute);\n        }\n        bit_or_is_plus(prev, input[i + k] as u64, (8 * k) as u64);\n    }\n}\n\npub proof fn load8_plus_fits_u64(input: &[u8], i: usize, k: nat)\n    requires\n        i + k < input.len(),\n        0 < k <= 7,\n    ensures\n        load8_at_plus_version_rec(input, i, (k - 1) as nat) + pow2(k * 8) * input[i + k]\n            <= u64::MAX,\n{\n    let xk_1 = load8_at_plus_version_rec(input, i, (k - 1) as nat);\n    let v = input[i + k];\n\n    assert((xk_1 + pow2(k * 8) * v) <= u64::MAX) by {\n        assert(v <= u8::MAX);  // known\n        assert(pow2(8 * k) <= 0x100000000000000) by {\n            if (k < 7) {\n                lemma_pow2_strictly_increases(k * 8, 56);\n            }\n            lemma2_to64_rest();\n        }\n        assert(xk_1 < pow2(8 * k)) by {\n            load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n        }\n        assert(xk_1 <= 0x100000000000000 - 1);\n        assert(pow2(k * 8) * v <= 0x100000000000000 * u8::MAX) by {\n            mul_le(pow2(k * 8), 0x100000000000000, v as nat, u8::MAX as nat);\n        }\n        assert((0x100000000000000 - 1) + (0x100000000000000) * u8::MAX <= u64::MAX) by (compute);\n    }\n}\n\npub proof fn load8_at_spec_fits_u64(input: &[u8], i: usize)\n    requires\n        i + 7 < input.len(),\n    ensures\n        load8_at_spec(input, i) <= u64::MAX,\n{\n    plus_version_is_spec(input, i);\n    load8_plus_fits_u64(input, i, 7);\n}\n\npub proof fn load8_plus_ver_div_mod(input: &[u8], i: usize, k: nat, s: nat)\n    requires\n        i + 7 < input.len(),\n        0 < k <= 7,\n        s < 64,\n    ensures\n        load8_at_plus_version_rec(input, i, k) / (pow2(s) as u64) == load8_at_plus_version_rec(\n            input,\n            i,\n            (k - 1) as nat,\n        ) / (pow2(s) as u64) + (pow2(k * 8) * input[i + k]) as u64 / (pow2(s) as u64),\n        load8_at_plus_version_rec(input, i, k) % (pow2(s) as u64) == load8_at_plus_version_rec(\n            input,\n            i,\n            (k - 1) as nat,\n        ) % (pow2(s) as u64) + (pow2(k * 8) * input[i + k]) as u64 % (pow2(s) as u64),\n{\n    assert(pow2(s) <= u64::MAX) by {\n        pow2_le_max64(s);\n    }\n\n    assert(pow2(s) > 0) by {\n        lemma_pow2_pos(s);\n    }\n\n    assert(pow2(k * 8) <= u64::MAX) by {\n        pow2_le_max64(k * 8);\n    }\n\n    let p64 = pow2(s) as u64;\n\n    let xk = load8_at_plus_version_rec(input, i, k);\n    let xk_1 = load8_at_plus_version_rec(input, i, (k - 1) as nat);\n    let v = input[i + k];\n    let v_n = v as nat;\n\n    assert(xk == (xk_1 + ((v as u64) << k * 8)) as u64) by {\n        reveal_with_fuel(load8_at_plus_version_rec, 1);\n    }\n\n    assert(v * pow2(k * 8) <= u64::MAX) by {\n        u8_times_pow2_fits_u64(v, k * 8);\n    }\n\n    assert(((v as u64) << k * 8) == pow2(k * 8) * v) by {\n        lemma_u64_shl_is_mul(v as u64, (k * 8) as u64);\n    }\n\n    assert(xk_1 < pow2(8 * k)) by {\n        load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n    }\n\n    assert((xk_1 + pow2(k * 8) * v) as u64 / p64 == xk_1 / p64 + ((pow2(k * 8) * v) as u64) / p64\n        && (xk_1 + pow2(k * 8) * v) as u64 % p64 == xk_1 % p64 + ((pow2(k * 8) * v) as u64) % p64)\n        by {\n        assert((xk_1 + pow2(k * 8) * v) <= u64::MAX) by {\n            load8_plus_fits_u64(input, i, k);\n        }\n        lemma_bitops_lifted(xk_1, v as u64, (k * 8) as nat, s);\n    }\n}\n\n// For each 0 <= j <= 7 this lemma helps us show\n// ((s_j + a_{j + 1}) / 2^s) % 2^t == (s_j / 2^s) % 2^t + (a_{j + 1} / 2^s) % 2^t\n// where s_j = s[j]_0 and a_{j+1} = a[j] in the load8_shift_mod body.\n// s_j represents the j-th partial sum (of load8 summands)\n// The myriad of `requires` conditions captures the local scope in load8_shift_mod\npub proof fn load8_shift_mod_lemma(\n    s_jplus1: u64,\n    s_j: u64,\n    a_jplus1: u64,\n    x: u8,\n    j: nat,\n    s: nat,\n    t: nat,\n)\n    requires\n        s_j < pow2(j * 8),\n        s_j + x * pow2(j * 8) <= u64::MAX,\n        a_jplus1 == (x * pow2(j * 8)) as u64,\n        s_jplus1 == s_j + a_jplus1,\n        s_jplus1 / (pow2(s) as u64) == s_j / (pow2(s) as u64) + a_jplus1 / (pow2(s) as u64),\n        0 <= j <= 7,\n        s < 64,\n        t < 64,\n        0 < pow2(s) <= u64::MAX,\n        0 < pow2(t) <= u64::MAX,\n    ensures\n        (s_jplus1 / (pow2(s) as u64)) % (pow2(t) as u64) == (s_j / (pow2(s) as u64)) % (pow2(\n            t,\n        ) as u64) + (a_jplus1 / (pow2(s) as u64)) % (pow2(t) as u64),\n{\n    let ps64 = (pow2(s) as u64);\n    let pt64 = (pow2(t) as u64);\n\n    assert((s_jplus1 / ps64) % pt64 == (s_j / ps64) % pt64 + (a_jplus1 / ps64) % pt64) by {\n        if (s <= j * 8) {\n            assert(pow2(s) <= pow2(j * 8)) by {\n                if (s < j * 8) {\n                    lemma_pow2_strictly_increases(s, j * 8);\n                }\n            }\n            assert(x * pow2(s) <= a_jplus1) by {\n                lemma_mul_inequality(pow2(s) as int, pow2(j * 8) as int, x as int);\n            }\n            assert(s_j + x * pow2(s) <= s_j + a_jplus1 <= u64::MAX);\n\n            let d = (8 * j - s) as nat;\n\n            assert(s_j / ps64 < pow2(d) && a_jplus1 / ps64 == x * pow2(d) && s_j / ps64 + x * pow2(\n                d,\n            ) <= u64::MAX) by {\n                div_pow2_preserves_decomposition(s_j, x as u64, j * 8, s);\n            }\n\n            assert((s_j / ps64 + x * pow2(d)) as u64 % pt64 == (s_j / ps64) % pt64 + (x * pow2(\n                d,\n            )) as u64 % pt64 == (s_j / ps64) % pt64 + (a_jplus1 / ps64) % pt64) by {\n                lemma_bitops_lifted(s_j / ps64, x as u64, d, t);\n            }\n        } else {\n            // s > j * 8\n            assert(pow2(j * 8) < pow2(s)) by {\n                lemma_pow2_strictly_increases(j * 8, s);\n            }\n            assert(s_j / ps64 == 0) by {\n                lemma_basic_div(s_j as int, ps64 as int);\n            }\n\n            assert(0u64 % pt64 == 0) by {\n                lemma_small_mod(0, pow2(t));\n            }\n        }\n    }\n}\n\npub proof fn load8_shift_mod(input: &[u8], i: usize, s64: u64, t: nat)\n    requires\n        i + 7 < input.len(),\n        s64 < 64,\n        t < 64,\n    ensures\n        (load8_at_spec(input, i) as u64 >> s64) & (low_bits_mask(t) as u64) == ((pow2(0 * 8)\n            * input[i + 0]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(1 * 8)\n            * input[i + 1]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(2 * 8)\n            * input[i + 2]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(3 * 8)\n            * input[i + 3]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(4 * 8)\n            * input[i + 4]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(5 * 8)\n            * input[i + 5]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(6 * 8)\n            * input[i + 6]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64) + ((pow2(7 * 8)\n            * input[i + 7]) as u64 / (pow2(s64 as nat) as u64)) % (pow2(t) as u64),\n{\n    let x = load8_at_spec(input, i) as u64;\n    let y = load8_at_plus_version_rec(input, i, 7);\n    let s = s64 as nat;\n    let ps64 = pow2(s) as u64;\n\n    assert(0 < pow2(s) <= u64::MAX) by {\n        lemma_pow2_pos(s);\n        pow2_le_max64(s);\n    }\n\n    assert(x >> s64 == x / ps64) by {\n        lemma_u64_shr_is_div(x, s64);\n    }\n\n    assert(x == y) by {\n        plus_version_is_spec(input, i);\n    }\n\n    assert forall|j: nat| j <= 7 implies #[trigger] pow2(j * 8) * input[i + j] <= u64::MAX by {\n        assert(pow2(j * 8) * input[i + j] == input[i + j] * pow2(j * 8));\n        u8_times_pow2_fits_u64(input[i + j], j * 8);\n    }\n\n    assert(y / ps64 == (pow2(0 * 8) * input[i + 0]) as u64 / ps64 + (pow2(1 * 8) * input[i\n        + 1]) as u64 / ps64 + (pow2(2 * 8) * input[i + 2]) as u64 / ps64 + (pow2(3 * 8) * input[i\n        + 3]) as u64 / ps64 + (pow2(4 * 8) * input[i + 4]) as u64 / ps64 + (pow2(5 * 8) * input[i\n        + 5]) as u64 / ps64 + (pow2(6 * 8) * input[i + 6]) as u64 / ps64 + (pow2(7 * 8) * input[i\n        + 7]) as u64 / ps64) by {\n        load8_plus_ver_div_mod(input, i, 7, s);\n        load8_plus_ver_div_mod(input, i, 6, s);\n        load8_plus_ver_div_mod(input, i, 5, s);\n        load8_plus_ver_div_mod(input, i, 4, s);\n        load8_plus_ver_div_mod(input, i, 3, s);\n        load8_plus_ver_div_mod(input, i, 2, s);\n        load8_plus_ver_div_mod(input, i, 1, s);\n\n        assert(load8_at_plus_version_rec(input, i, 0) == (pow2(0 * 8) * input[i + 0]) as u64) by {\n            assert(load8_at_plus_version_rec(input, i, 0) == (input[i as int] as u64));\n            assert(pow2(0 * 8) == 1) by {\n                lemma2_to64();\n            }\n            assert((pow2(0 * 8) * input[i + 0]) as u64 == (input[i as int] as u64)) by {\n                lemma_mul_basics_4(input[i as int] as int);  // 1 * x = x\n            }\n        }\n    }\n\n    let pt64 = pow2(t) as u64;\n    let z = y / ps64;\n\n    assert(low_bits_mask(t) <= u64::MAX) by {\n        low_bits_masks_fit_u64(t);\n    }\n\n    assert(z & (low_bits_mask(t) as u64) == z % pt64) by {\n        lemma_u64_low_bits_mask_is_mod(z, t);\n    }\n\n    assert forall|j: nat| 0 <= j <= 7 implies #[trigger] pow2(j * 8) > 0 by {\n        lemma_pow2_pos(j * 8);\n    }\n\n    assert forall|j: nat| 0 <= j <= 7 implies #[trigger] (pow2(j * 8) * input[i + j]) <= pow2(\n        (j + 1) * 8,\n    ) - pow2(j * 8) by {\n        assert(j * 8 + 8 == (j + 1) * 8) by {\n            lemma_mul_is_distributive_add_other_way(8, j as int, 1);\n        }\n        pow2_mul_u8(input[i + j], j * 8);\n    }\n\n    // pow2(_) values;\n    lemma2_to64();\n    lemma2_to64_rest();\n    assert(0 < pow2(t) <= u64::MAX) by {\n        lemma_pow2_pos(t);\n        pow2_le_max64(t);\n    }\n\n    // ---- lemmas about X * pow2\n    assert forall|j: nat| 0 <= j <= 7 implies #[trigger] pow2(j * 8) * input[i + j]\n        == #[trigger] input[i + j] * pow2(j * 8) by {\n        lemma_mul_is_commutative(pow2(j * 8) as int, input[i + j] as int);\n    }\n\n    assert forall|j: nat| 0 <= j <= 7 implies #[trigger] (pow2(j * 8) * input[i + j]) <= pow2(\n        (j + 1) * 8,\n    ) - pow2(j * 8) && pow2((j + 1) * 8) > pow2(j * 8) by {\n        assert(j * 8 + 8 == (j + 1) * 8) by {\n            lemma_mul_is_distributive_add_other_way(8, j as int, 1);\n        }\n        pow2_mul_u8(input[i + j], j * 8);\n        assert(pow2((j + 1) * 8) > pow2(j * 8)) by {\n            lemma_pow2_strictly_increases(j * 8, j * 8 + 8);\n        }\n    }\n    // ---- lemmas about X * pow2 <END>\n\n    let a0 = (pow2(0 * 8) * input[i + 0]) as u64;\n    let a1 = (pow2(1 * 8) * input[i + 1]) as u64;\n    let a2 = (pow2(2 * 8) * input[i + 2]) as u64;\n    let a3 = (pow2(3 * 8) * input[i + 3]) as u64;\n    let a4 = (pow2(4 * 8) * input[i + 4]) as u64;\n    let a5 = (pow2(5 * 8) * input[i + 5]) as u64;\n    let a6 = (pow2(6 * 8) * input[i + 6]) as u64;\n    let a7 = (pow2(7 * 8) * input[i + 7]) as u64;\n\n    // Trigger the forall-s\n    assert(a0 == input[i + 0] * pow2(0));\n    assert(a1 == input[i + 1] * pow2(8));\n    assert(a2 == input[i + 2] * pow2(16));\n    assert(a3 == input[i + 3] * pow2(24));\n    assert(a4 == input[i + 4] * pow2(32));\n    assert(a5 == input[i + 5] * pow2(40));\n    assert(a6 == input[i + 6] * pow2(48));\n    assert(a7 == input[i + 7] * pow2(56));\n\n    let s0_0 = a0;\n    let s0 = s0_0 / ps64;\n\n    assert(s0_0 < pow2(1 * 8));\n    assert(s0_0 + a1 <= u64::MAX);\n\n    let s1_0 = (s0_0 + a1) as u64;\n    let s1 = s1_0 / ps64;\n\n    assert(s1_0 < pow2(2 * 8));\n    assert(s1 == s0_0 / ps64 + a1 / ps64) by {\n        lemma_bitops_lifted(s0_0, input[i + 1] as u64, 1 * 8, s);\n    }\n    assert(s1_0 + a2 <= u64::MAX);\n\n    let s2_0 = (s1_0 + a2) as u64;\n    let s2 = s2_0 / ps64;\n\n    assert(s2_0 < pow2(3 * 8));\n    assert(s2 == s1_0 / ps64 + a2 / ps64) by {\n        lemma_bitops_lifted(s1_0, input[i + 2] as u64, 2 * 8, s);\n    }\n    assert(s2_0 + a3 <= u64::MAX);\n\n    let s3_0 = (s2_0 + a3) as u64;\n    let s3 = s3_0 / ps64;\n\n    assert(s3_0 < pow2(4 * 8));\n    assert(s3 == s2_0 / ps64 + a3 / ps64) by {\n        lemma_bitops_lifted(s2_0, input[i + 3] as u64, 3 * 8, s);\n    }\n    assert(s3_0 + a4 <= u64::MAX);\n\n    let s4_0 = (s3_0 + a4) as u64;\n    let s4 = s4_0 / ps64;\n\n    assert(s4_0 < pow2(5 * 8));\n    assert(s4 == s3_0 / ps64 + a4 / ps64) by {\n        lemma_bitops_lifted(s3_0, input[i + 4] as u64, 4 * 8, s);\n    }\n    assert(s4_0 + a5 <= u64::MAX);\n\n    let s5_0 = (s4_0 + a5) as u64;\n    let s5 = s5_0 / ps64;\n\n    assert(s5_0 < pow2(6 * 8));\n    assert(s5 == s4_0 / ps64 + a5 / ps64) by {\n        lemma_bitops_lifted(s4_0, input[i + 5] as u64, 5 * 8, s);\n    }\n    assert(s5_0 + a6 <= u64::MAX);\n\n    let s6_0 = (s5_0 + a6) as u64;\n    let s6 = s6_0 / ps64;\n\n    assert(s6_0 < pow2(7 * 8));\n    assert(s6 == s5_0 / ps64 + a6 / ps64) by {\n        lemma_bitops_lifted(s5_0, input[i + 6] as u64, 6 * 8, s);\n    }\n    assert(s6_0 + a7 <= u64::MAX);\n\n    let s7_0 = (s6_0 + a7) as u64;\n    let s7 = s7_0 / ps64;\n\n    assert(s7 == s6_0 / ps64 + a7 / ps64) by {\n        lemma_bitops_lifted(s6_0, input[i + 7] as u64, 7 * 8, s);\n    }\n\n    assert(s7 == z);\n\n    assert(s6_0 <= pow2(7 * 8) - 1);\n    assert(s5_0 <= pow2(6 * 8) - 1);\n    assert(s4_0 <= pow2(5 * 8) - 1);\n    assert(s3_0 <= pow2(4 * 8) - 1);\n    assert(s2_0 <= pow2(3 * 8) - 1);\n    assert(s1_0 <= pow2(2 * 8) - 1);\n    assert(s0_0 <= pow2(1 * 8) - 1);\n\n    assert(z % pt64 == ((pow2(0 * 8) * input[i + 0]) as u64 / ps64) % pt64 + ((pow2(1 * 8) * input[i\n        + 1]) as u64 / ps64) % pt64 + ((pow2(2 * 8) * input[i + 2]) as u64 / ps64) % pt64 + ((pow2(\n        3 * 8,\n    ) * input[i + 3]) as u64 / ps64) % pt64 + ((pow2(4 * 8) * input[i + 4]) as u64 / ps64) % pt64\n        + ((pow2(5 * 8) * input[i + 5]) as u64 / ps64) % pt64 + ((pow2(6 * 8) * input[i + 6]) as u64\n        / ps64) % pt64 + ((pow2(7 * 8) * input[i + 7]) as u64 / ps64) % pt64) by {\n        load8_shift_mod_lemma(s7_0, s6_0, a7, input[i + 7], 7, s, t);\n        load8_shift_mod_lemma(s6_0, s5_0, a6, input[i + 6], 6, s, t);\n        load8_shift_mod_lemma(s5_0, s4_0, a5, input[i + 5], 5, s, t);\n        load8_shift_mod_lemma(s4_0, s3_0, a4, input[i + 4], 4, s, t);\n        load8_shift_mod_lemma(s3_0, s2_0, a3, input[i + 3], 3, s, t);\n        load8_shift_mod_lemma(s2_0, s1_0, a2, input[i + 2], 2, s, t);\n        load8_shift_mod_lemma(s1_0, s0_0, a1, input[i + 1], 1, s, t);\n    }\n}\n\npub proof fn load8_limb_base(input: &[u8], i: usize, k: u64)\n    requires\n        i + 7 < input.len(),\n        k < 64,\n    ensures\n        0 < pow2(51) <= u64::MAX,\n        load8_at_spec(input, i) <= u64::MAX,\n        ((load8_at_spec(input, i) as u64) >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64)\n            / (pow2(k as nat) as u64)) % (pow2(51) as u64),\n{\n    assert(0 < pow2(51) <= u64::MAX) by {\n        lemma_pow2_pos(51);\n        pow2_le_max64(51);\n    }\n\n    assert(0 < pow2(k as nat) <= u64::MAX) by {\n        lemma_pow2_pos(k as nat);\n        pow2_le_max64(k as nat);\n    }\n\n    let p51 = pow2(51) as u64;\n    let pk = pow2(k as nat) as u64;\n\n    assert(mask51 == low_bits_mask(51)) by {\n        l51_bit_mask_lt();\n    }\n\n    assert(load8_at_spec(input, i) <= u64::MAX) by {\n        load8_at_spec_fits_u64(input, i);\n    }\n\n    assert((load8_at_spec(input, i) as u64 >> k) & (low_bits_mask(51) as u64) == (((input[i + 0]\n        * pow2(0 * 8)) as u64) / pk) % p51 + (((input[i + 1] * pow2(1 * 8)) as u64) / pk) % p51 + ((\n    (input[i + 2] * pow2(2 * 8)) as u64) / pk) % p51 + (((input[i + 3] * pow2(3 * 8)) as u64) / pk)\n        % p51 + (((input[i + 4] * pow2(4 * 8)) as u64) / pk) % p51 + (((input[i + 5] * pow2(\n        5 * 8,\n    )) as u64) / pk) % p51 + (((input[i + 6] * pow2(6 * 8)) as u64) / pk) % p51 + (((input[i + 7]\n        * pow2(7 * 8)) as u64) / pk) % p51) by {\n        load8_shift_mod(input, i, k, 51);\n    }\n\n}\n\npub open spec fn pow2_mul_DIV_MOD_u8_t51_cond(k: nat, j: nat) -> bool {\n    (j * 8 <= k) && (8 <= 51 + k - 8 * j)\n}\n\npub open spec fn pow2_MUL_div_MOD_u8_t51_cond(k: nat, j: nat) -> bool {\n    (k <= j * 8) && (8 + j * 8 - k <= 51)\n}\n\npub open spec fn pow2_MUL_div_Mod_u8_t51_cond(k: nat, j: nat) -> bool {\n    (k <= j * 8) && (j * 8 - k <= 51)\n}\n\npub open spec fn pow2_MUL_div_mod_u8_t51_cond(k: nat, j: nat) -> bool {\n    (k <= j * 8) && (51 <= j * 8 - k)\n}\n\n// Generalized load8_limb theorem. Asserts that\n// - the first few summands are shifted by more than their power exponent and reduce to division\n// - the next few summands are shifted by less than their exponents and are unaffected by masking, due to being small\n// - the next few summands may, depending on the value of the u8 coefficient be either smaller than the mod,\n//   or larger, so in general, the best we can assert is that they reduce to coefficient masking\n// - the last few summands have large enough exponents that masking zeroes them\n// The particular indices where these happen depend on the limb (i.e. the shift value k)\npub proof fn load8_limb_X(input: &[u8], i: usize, k: nat, j_div: nat, j_id: nat, j_shift: nat)\n    requires\n        i + 7 < input.len(),\n        k <= 12,\n        forall|j: nat| 0 <= j < j_div ==> pow2_mul_DIV_MOD_u8_t51_cond(k, j),\n        forall|j: nat| j_div <= j < j_id ==> pow2_MUL_div_MOD_u8_t51_cond(k, j),\n        forall|j: nat| j_id <= j < j_shift ==> pow2_MUL_div_Mod_u8_t51_cond(k, j),\n        forall|j: nat| j_shift <= j < 8 ==> pow2_MUL_div_mod_u8_t51_cond(k, j),\n    ensures\n        forall|j: nat|\n            0 <= j < j_div ==> #[trigger] ((input[(i + j) as int] * pow2(j * 8)) as u64 / (pow2(\n                k,\n            ) as u64)) % (pow2(51) as u64) == (input[(i + j) as int]) as nat / pow2(\n                (k - j * 8) as nat,\n            ),\n        forall|j: nat|\n            j_div <= j < j_id ==> #[trigger] ((input[(i + j) as int] * pow2(j * 8)) as u64 / (pow2(\n                k,\n            ) as u64)) % (pow2(51) as u64) == (input[(i + j) as int]) * pow2((j * 8 - k) as nat),\n        forall|j: nat|\n            j_id <= j < j_shift ==> #[trigger] ((input[(i + j) as int] * pow2(j * 8)) as u64 / (\n            pow2(k) as u64)) % (pow2(51) as u64) == (input[(i + j) as int] as nat % pow2(\n                (51 - (j * 8 - k)) as nat,\n            )) * pow2((j * 8 - k) as nat),\n        forall|j: nat|\n            j_shift <= j < 8 ==> #[trigger] ((input[(i + j) as int] * pow2(j * 8)) as u64 / (pow2(\n                k,\n            ) as u64)) % (pow2(51) as u64) == 0,\n        (load8_at_spec(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (\n        pow2(k as nat) as u64)) % (pow2(51) as u64),\n{\n    let p51 = pow2(51) as u64;\n\n    assert(0 < pow2(k) <= u64::MAX) by {\n        lemma_pow2_pos(k);\n        pow2_le_max64(k);\n    }\n\n    let pk = pow2(k) as u64;\n\n    load8_limb_base(input, i, k as u64);\n\n    // first: all div, no mul\n    assert forall|j: nat| 0 <= j < j_div implies #[trigger] ((input[(i + j) as int] * pow2(\n        j * 8,\n    )) as u64 / pk) % p51 == (input[(i + j) as int]) as nat / pow2((k - j * 8) as nat) by {\n        assert(pow2_mul_DIV_MOD_u8_t51_cond(k, j));  // trigger forall\n        pow2_mul_DIV_MOD_u8(input[(i + j) as int], j * 8, k, 51);\n    }\n\n    // (product >> k) < 2^51\n    assert forall|j: nat| j_div <= j < j_id implies #[trigger] ((input[(i + j) as int] * pow2(\n        j * 8,\n    )) as u64 / pk) % p51 == (input[(i + j) as int]) * pow2((j * 8 - k) as nat) by {\n        assert(pow2_MUL_div_MOD_u8_t51_cond(k, j));  // trigger forall\n        pow2_MUL_div_MOD_u8(input[(i + j) as int], j * 8, k, 51);\n    }\n\n    // partial shift\n    assert forall|j: nat| j_id <= j < j_shift implies #[trigger] ((input[(i + j) as int] * pow2(\n        j * 8,\n    )) as u64 / pk) % p51 == (input[(i + j) as int] as nat % pow2((51 - (j * 8 - k)) as nat))\n        * pow2((j * 8 - k) as nat) by {\n        assert(pow2_MUL_div_Mod_u8_t51_cond(k, j));  // trigger forall\n        pow2_MUL_div_Mod_u8(input[(i + j) as int], j * 8, k, 51);\n    }\n\n    // zero\n    assert forall|j: nat| j_shift <= j < 8 implies #[trigger] ((input[(i + j) as int] * pow2(\n        j * 8,\n    )) as u64 / pk) % p51 == 0 by {\n        assert(pow2_MUL_div_mod_u8_t51_cond(k, j));  // trigger forall\n        pow2_MUL_div_mod_u8(input[(i + j) as int], j * 8, k, 51);\n    }\n}\n\npub proof fn load8_limb0(input: &[u8])\n    requires\n        0 + 7 < input.len(),\n    ensures\n        (load8_at_spec(input, 0) as u64) & mask51 == (input[0] * pow2(0 * 8)) + (input[1] * pow2(\n            1 * 8,\n        )) + (input[2] * pow2(2 * 8)) + (input[3] * pow2(3 * 8)) + (input[4] * pow2(4 * 8)) + (\n        input[5] * pow2(5 * 8)) + ((input[6] as nat % pow2(3)) * pow2(6 * 8)),\n{\n    let i = 0;\n    let k = 0;\n\n    let j_div = 0;\n    let j_id = 6;\n    let j_shift = 7;\n\n    assert(load8_at_spec(input, 0) as u64 == (load8_at_spec(input, 0) as u64 >> 0)) by {\n        shr_zero_is_id(load8_at_spec(input, 0) as u64);\n    }\n\n    load8_limb_X(input, i, k, j_div, j_id, j_shift);\n\n    // Sanity check\n    assert((load8_at_spec(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n        / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n    pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64));\n\n    assert(pow2(0) == 1) by {\n        lemma2_to64();\n    }\n\n    broadcast use lemma_div_basics_2;  // x / 1 = x\n\n}\n\npub proof fn load8_limb1(input: &[u8])\n    requires\n        6 + 7 < input.len(),\n    ensures\n        ((load8_at_spec(input, 6) as u64) >> 3) & mask51 == (input[6] as nat / pow2(3)) + (input[7]\n            * pow2((1 * 8 - 3) as nat)) + (input[8] * pow2((2 * 8 - 3) as nat)) + (input[9] * pow2(\n            (3 * 8 - 3) as nat,\n        )) + (input[10] * pow2((4 * 8 - 3) as nat)) + (input[11] * pow2((5 * 8 - 3) as nat)) + ((\n        input[12] as nat % pow2(6)) * pow2((6 * 8 - 3) as nat)),\n{\n    let i = 6;\n    let k = 3;\n\n    let j_div = 1;\n    let j_id = 6;\n    let j_shift = 7;\n\n    load8_limb_X(input, i, k, j_div, j_id, j_shift);\n\n    // Sanity check\n    assert((load8_at_spec(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n        / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n    pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64));\n}\n\npub proof fn load8_limb2(input: &[u8])\n    requires\n        12 + 7 < input.len(),\n    ensures\n        ((load8_at_spec(input, 12) as u64) >> 6) & mask51 == (input[12] as nat / pow2(6)) + (\n        input[13] * pow2((1 * 8 - 6) as nat)) + (input[14] * pow2((2 * 8 - 6) as nat)) + (input[15]\n            * pow2((3 * 8 - 6) as nat)) + (input[16] * pow2((4 * 8 - 6) as nat)) + (input[17]\n            * pow2((5 * 8 - 6) as nat)) + (input[18] * pow2((6 * 8 - 6) as nat)) + ((\n        input[19] as nat % pow2(1)) * pow2((7 * 8 - 6) as nat)),\n{\n    let i = 12;\n    let k = 6;\n\n    let j_div = 1;\n    let j_id = 7;\n    let j_shift = 8;\n\n    load8_limb_X(input, i, k, j_div, j_id, j_shift);\n\n    // Sanity check\n    assert((load8_at_spec(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n        / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n    pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64));\n}\n\npub proof fn load8_limb3(input: &[u8])\n    requires\n        19 + 7 < input.len(),\n    ensures\n        ((load8_at_spec(input, 19) as u64) >> 1) & mask51 == (input[19] as nat / pow2(1)) + (\n        input[20] * pow2((1 * 8 - 1) as nat)) + (input[21] * pow2((2 * 8 - 1) as nat)) + (input[22]\n            * pow2((3 * 8 - 1) as nat)) + (input[23] * pow2((4 * 8 - 1) as nat)) + (input[24]\n            * pow2((5 * 8 - 1) as nat)) + ((input[25] as nat % pow2(4)) * pow2((6 * 8 - 1) as nat)),\n{\n    let i = 19;\n    let k = 1;\n\n    let j_div = 1;\n    let j_id = 6;\n    let j_shift = 7;\n\n    load8_limb_X(input, i, k, j_div, j_id, j_shift);\n\n    // Sanity check\n    assert((load8_at_spec(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n        / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n    pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64));\n}\n\npub proof fn load8_limb4(input: &[u8])\n    requires\n        24 + 7 < input.len(),\n    ensures\n        ((load8_at_spec(input, 24) as u64) >> 12) & mask51 == (input[25] as nat / pow2(4)) + (\n        input[26] * pow2((2 * 8 - 12) as nat)) + (input[27] * pow2((3 * 8 - 12) as nat)) + (\n        input[28] * pow2((4 * 8 - 12) as nat)) + (input[29] * pow2((5 * 8 - 12) as nat)) + (\n        input[30] * pow2((6 * 8 - 12) as nat)) + ((input[31] as nat % pow2(7)) * pow2(\n            (7 * 8 - 12) as nat,\n        )),\n{\n    let i = 24;\n    let k = 12;\n\n    let j_div = 2;\n    let j_id = 7;\n    let j_shift = 8;\n\n    load8_limb_X(input, i, k, j_div, j_id, j_shift);\n\n    // Sanity check\n    assert((load8_at_spec(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n        / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n    pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64));\n\n    // First term too small, swallowed by div\n    assert(input[24] as nat / pow2(12) == 0) by {\n        assert(input[24] < pow2(8) < pow2(12)) by {\n            assert(input[24] < pow2(8)) by {\n                u8_lt_pow2_8(input[24]);\n            }\n            assert(pow2(8) < pow2(12)) by {\n                lemma_pow2_strictly_increases(8, 12);\n            }\n        }\n\n        lemma_basic_div(input[24] as int, pow2(12) as int);\n    }\n}\n\nfn main() {\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits_warning().",
      "display_name": "determine_curve25519_dalek_bits_warning",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits_warning().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/build.rs",
      "relative_path": "build.rs",
      "file_name": "build.rs",
      "parent_folder": "curve25519-dalek",
      "body": "    fn determine_curve25519_dalek_bits_warning(cause: &str) {\n        println!(\"cargo:warning=\\\"Defaulting to curve25519_dalek_bits=32: {cause}\\\"\");\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "display_name": "from_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "impl Identity for RistrettoPoint {\n    fn identity() -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::identity())\n    }\n}",
      "is_libsignal": false,
      "caller_count": 12,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/reconstruct_radix_16().",
      "display_name": "reconstruct_radix_16",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/reconstruct_radix_16().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "#[allow(unused_imports)]\nuse crate::core_assumes::*;\n\n#[allow(unused_imports)]\nuse crate::scalar_specs::*;\n\n#[cfg(feature = \"digest\")]\n#[allow(unused_imports)]\nuse digest::Digest;\n\nverus! {\n\n/*** <VERIFICATION NOTE> Focus on u64; removed all other backend types </VERIFICATION NOTE> ***/\ntype UnpackedScalar = backend::serial::u64::scalar::Scalar52;\n\n/// The `Scalar` struct holds an element of \\\\(\\mathbb Z / \\ell\\mathbb Z \\\\).\n#[allow(clippy::derived_hash_with_manual_eq)]\n#[derive(Copy, Clone, Hash)]\npub struct Scalar {\n    /// `bytes` is a little-endian byte encoding of an integer representing a scalar modulo the\n    /// group order.\n    ///\n    /// # Invariant #1\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255}\\\\). That is, the most\n    /// significant bit of `bytes[31]` is 0.\n    ///\n    /// This is required for `EdwardsPoint` variable- and fixed-base multiplication, because most\n    /// integers above 2^255 are unrepresentable in our radix-16 NAF (see [`Self::as_radix_16`]).\n    /// The invariant is also required because our `MontgomeryPoint` multiplication assumes the MSB\n    /// is 0 (see `MontgomeryPoint::mul`).\n    ///\n    /// # Invariant #2 (weak)\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255} - 19 \\\\), i.e., it represents\n    /// a canonical representative of an element of \\\\( \\mathbb Z / \\ell\\mathbb Z \\\\). This is\n    /// stronger than invariant #1. It also sometimes has to be broken.\n    ///\n    /// This invariant is deliberately broken in the implementation of `EdwardsPoint::{mul_clamped,\n    /// mul_base_clamped}`, `MontgomeryPoint::{mul_clamped, mul_base_clamped}`, and\n    /// `BasepointTable::mul_base_clamped`. This is not an issue though. As mentioned above,\n    /// scalar-point multiplication is defined for any choice of `bytes` that satisfies invariant\n    /// #1. Since clamping guarantees invariant #1 is satisfied, these operations are well defined.\n    ///\n    /// Note: Scalar-point mult is the _only_ thing you can do safely with an unreduced scalar.\n    /// Scalar-scalar addition and subtraction are NOT correct when using unreduced scalars.\n    /// Multiplication is correct, but this is only due to a quirk of our implementation, and not\n    /// guaranteed to hold in general in the future.\n    ///\n    /// Note: It is not possible to construct an unreduced `Scalar` from the public API unless the\n    /// `legacy_compatibility` is enabled (thus making `Scalar::from_bits` public). Thus, for all\n    /// public non-legacy uses, invariant #2\n    /// always holds.\n    ///\n    /* <VERIFICATION NOTE>\n    Changed from pub(crate) to pub\n    </VERIFICATION NOTE> */\n    pub bytes: [u8; 32],/* <ORIGINAL CODE>\n    pub(crate) bytes: [u8; 32],\n    </ORIGINAL CODE> */\n}\n\n// This is a dummy function that we call from signal\n// to test that verus functions in libsignal know\n// about verus functions in curve-dalek\npub open spec fn is_a_scalar(s: Scalar) -> bool {\n    true\n}\n\nimpl Scalar {\n    /// Construct a `Scalar` by reducing a 256-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    // VERIFICATION NOTE: VERIFIED\n    pub fn from_bytes_mod_order(bytes: [u8; 32]) -> (result: Scalar)\n        ensures\n    // Result is equivalent to input modulo the group order\n\n            bytes_to_nat(&result.bytes) % group_order() == bytes_to_nat(&bytes) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        // Temporarily allow s_unreduced.bytes > 2^255 ...\n        let s_unreduced = Scalar { bytes };\n\n        // Then reduce mod the group order and return the reduced representative.\n        let s = s_unreduced.reduce();\n        /*** <VERIFICATION NOTE> We omit debug asserts from verification  </VERIFICATION NOTE> ***/\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }\n\n    /// Construct a `Scalar` by reducing a 512-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    // VERIFICATION NOTE: VERIFIED\n    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == bytes_wide_to_nat(input) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }\n\n    /// Attempt to construct a `Scalar` from a canonical byte representation.\n    ///\n    /// # Return\n    ///\n    /// - `Some(s)`, where `s` is the `Scalar` corresponding to `bytes`,\n    ///   if `bytes` is a canonical byte representation modulo the group order \\\\( \\ell \\\\);\n    /// - `None` if `bytes` is not a canonical byte representation.\n    /*\n    <VERIFICATION NOTE>\n      - Refactored to use wrapper functions instead of trait functions for ct_eq and ct_option_new\n      - Has proof bypass\n    </VERIFICATION NOTE> */\n    pub fn from_canonical_bytes(bytes: [u8; 32]) -> (result: CtOption<Scalar>)\n        ensures\n            bytes_to_nat(&bytes) < group_order() ==> ct_option_has_value(result),\n            bytes_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result),\n            ct_option_has_value(result) ==> bytes_to_nat(&ct_option_value(result).bytes)\n                % group_order() == bytes_to_nat(&bytes) % group_order(),\n    {\n        /* <ORIGINAL CODE>\n          let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let high_byte_shifted = bytes[31] >> 7;\n        let high_bit_unset = ct_eq_u8(&high_byte_shifted, &0);\n        /* </MODIFIED CODE> */\n\n        let candidate = Scalar { bytes };\n        let is_canonical = candidate.is_canonical();\n\n        /* <ORIGINAL CODE>\n          CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n          </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let condition = choice_and(high_bit_unset, is_canonical);\n        let result = ct_option_new(candidate, condition);\n        /* </MODIFIED CODE> */\n\n        // VERIFICATION NOTE: PROOF BYPASS\n        assume(bytes_to_nat(&bytes) < group_order() ==> ct_option_has_value(result));\n        assume(bytes_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result));\n        assume(ct_option_has_value(result) ==> bytes_to_nat(&ct_option_value(result).bytes)\n            % group_order() == bytes_to_nat(&bytes) % group_order());\n\n        result\n    }\n\n    /// Construct a `Scalar` from the low 255 bits of a 256-bit integer. This breaks the invariant\n    /// that scalars are always reduced. Scalar-scalar arithmetic, i.e., addition, subtraction,\n    /// multiplication, **does not work** on scalars produced from this function. You may only use\n    /// the output of this function for `EdwardsPoint::mul`, `MontgomeryPoint::mul`, and\n    /// `EdwardsPoint::vartime_double_scalar_mul_basepoint`. **Do not use this function** unless\n    /// you absolutely have to.\n    /* <VERIFICATION NOTE>\n        -This is not in default features and not in our current target list ==> spec omitted for now\n    </VERIFICATION NOTE> */\n    #[cfg(feature = \"legacy_compatibility\")]\n    #[deprecated(\n        since = \"4.0.0\",\n        note = \"This constructor outputs scalars with undefined scalar-scalar arithmetic. See docs.\"\n    )]\n    pub const fn from_bits(bytes: [u8; 32]) -> Scalar {\n        let mut s = Scalar { bytes };\n        // Ensure invariant #1 holds. That is, make s < 2^255 by masking the high bit.\n        s.bytes[31] &= 0b0111_1111;\n\n        s\n    }\n}\n\nimpl Eq for Scalar {\n\n}\n\nimpl PartialEq for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS (problem with traits)\n    fn eq(&self, other: &Self) -> (result: bool)\n        ensures\n            result == (&self.bytes == &other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Choice::into\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let result = self.ct_eq(other).into();\n         </ORIGINAL CODE> */\n        let choice = self.ct_eq(other);\n        assert(choice_is_true(choice) == (self.bytes == other.bytes));\n        let result = choice_into(choice);\n        assert(result == choice_is_true(choice));\n        assert(result == (self.bytes == other.bytes));\n\n        // VERIFICATION NOTE: vstd's external trait specification check cannot be satisfied\n        // vstd expects obeys_eq_spec() and eq_spec() from PartialEqSpecImpl trait,\n        // but that trait is not publicly exported, so we bypass with assume(false)\n        // while maintaining our own custom ensures clause above\n        assume(false);\n\n        result\n    }\n}\n\nimpl ConstantTimeEq for Scalar {\n    fn ct_eq(&self, other: &Self) -> (result: Choice)\n        ensures\n            choice_is_true(result) == (self.bytes == other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Verus compatibility instead of direct subtle call\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.bytes.ct_eq(&other.bytes)\n         </ORIGINAL CODE> */\n        ct_eq_bytes32(&self.bytes, &other.bytes)\n    }\n}\n\nimpl Index<usize> for Scalar {\n    type Output = u8;\n\n    /// Index the bytes of the representative for this `Scalar`.  Mutation is not permitted.\n    fn index(&self, _index: usize) -> (result: &u8)\n        requires\n            _index < 32,\n        ensures\n            result == &self.bytes[_index as int],\n    {\n        &(self.bytes[_index])\n    }\n}\n\nimpl Debug for Scalar {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar{{\\n\\tbytes: {:?},\\n}}\", &self.bytes)\n    }\n}\n\nimpl<'a> MulAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    fn mul_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n            is_canonical_scalar(self),\n    {\n        /* <ORIGINAL CODE>\n         *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n        /* <VERIFICATION NOTE>\n         In the modified code, we store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&old(self).bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        *self = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&self.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n    }\n}\n\ndefine_mul_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_mul_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn mul_req(self, rhs: &Scalar) -> bool {\n        true  // No preconditions\n\n    }\n\n    open spec fn mul_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'b> Mul<&'b Scalar> for &Scalar {\n    type Output = Scalar;\n\n    // VERIFICATION NOTE: VERIFIED\n    fn mul(self, _rhs: &'b Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n    {\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n            * bytes_to_nat(&_rhs.bytes)) % group_order());\n        /* </MODIFIED CODE> */\n        /* <ORIGINAL CODE>\n         let result = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n\n        result\n    }\n}\n\ndefine_mul_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_add_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn add_req(self, rhs: &Scalar) -> bool {\n        true  // No preconditions yet\n\n    }\n\n    open spec fn add_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'a> Add<&'a Scalar> for &Scalar {\n    type Output = Scalar;\n\n    /* <VERIFICATION NOTE>\n    PROOF BYPASS; may need to add preconditions to spec\n    </VERIFICATION NOTE> */\n    #[allow(non_snake_case)]\n    fn add(self, _rhs: &'a Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(&_rhs.bytes))\n                % group_order(),\n    {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::add requires inputs < group_order()\n        // By Scalar invariant #2, scalars should be canonical\n        // However, we cannot add requires clauses to trait implementations,\n        // so we assume this property holds\n        proof {\n            assume(to_nat(&self_unpacked.limbs) < group_order());\n            assume(to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::add(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) == (to_nat(&self_unpacked.limbs) + to_nat(\n                &rhs_unpacked.limbs,\n            )) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) == to_nat(&result_unpacked.limbs));\n            assert(bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }\n}\n\ndefine_add_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> AddAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    #[allow(clippy::op_ref)]\n    fn add_assign(&mut self, _rhs: &'a Scalar)\n        ensures\n            bytes_to_nat(&self.bytes) == (bytes_to_nat(&old(self).bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order(),\n    {\n        *self = &*self + _rhs;\n    }\n}\n\ndefine_add_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_sub_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn sub_req(self, rhs: &Scalar) -> bool {\n        is_canonical_scalar(self) && is_canonical_scalar(rhs)\n    }\n\n    open spec fn sub_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'b> Sub<&'b Scalar> for &Scalar {\n    type Output = Scalar;\n\n    // VERIFICATION NOTE: PROOF BYPASS (problems with traits and preconditions)\n    // PRECONDITION is_canonical_scalar(self) && is_canonical_scalar(_rhs)\n    #[allow(non_snake_case)]\n    fn sub(self, _rhs: &'b Scalar) -> (result:\n        Scalar)/* VERIFICATION NOTE: preconditions are added to the SpecImpl above\n    requires\n      is_canonical_scalar(self),\n      is_canonical_scalar(_rhs),\n    */\n\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        /* <ORIGINAL CODE>\n         UnpackedScalar::sub(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::sub requires: -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()\n        proof {\n            assume(-group_order() <= to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs));\n            assume(to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::sub(&self_unpacked, &rhs_unpacked);\n        proof {\n            // Postconditions from sub - need to strengthen, review connections\n            assume(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                - to_nat(&rhs_unpacked.limbs)) % (group_order() as int));\n            assume(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int));\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }\n}\n\ndefine_sub_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> SubAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    #[allow(clippy::op_ref)]\n    fn sub_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        *self = &*self - _rhs;\n    }\n}\n\ndefine_sub_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &Scalar {\n    open spec fn obeys_neg_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn neg_req(self) -> bool {\n        true  // No preconditions - scalars are canonical by invariant\n\n    }\n\n    open spec fn neg_spec(self) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl Neg for &Scalar {\n    type Output = Scalar;\n\n    #[allow(non_snake_case)]\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        /* <ORIGINAL CODE>\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        proof {\n            // Preconditions for mul_internal and sub\n            assume(limbs_bounded(&constants::R));\n            assume(limbs_bounded(&UnpackedScalar::ZERO));\n        }\n\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n\n        proof {\n            assume(limbs_bounded(&self_mod_l));\n            // sub requires: -group_order() <= 0 - to_nat(&self_mod_l.limbs) < group_order()\n            assume(-group_order() <= to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(\n                &self_mod_l.limbs,\n            ));\n            assume(to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(&self_mod_l.limbs) < group_order());\n        }\n\n        let result = UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack();\n        proof {\n            // TODO: Prove that -self + self == 0 (mod group_order)\n            assume((scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0);\n        }\n\n        /* </MODIFIED CODE> */\n        result\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for Scalar {\n    open spec fn obeys_neg_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn neg_req(self) -> bool {\n        true  // No specific preconditions - scalars are canonical by invariant\n\n    }\n\n    open spec fn neg_spec(self) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl Neg for Scalar {\n    type Output = Scalar;\n\n    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        let result = (&self).neg();\n        proof {\n            assume((scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0);\n        }\n        result\n    }/* <ORIGINAL CODE>\n    fn neg(self) -> Scalar {\n        -&self\n    }\n    </ORIGINAL CODE> */\n\n}\n\nimpl ConditionallySelectable for Scalar {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> (Self) {\n        let mut bytes = [0u8;32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            /* <VERIFICATION NOTE>\n            Use wrapper function for Verus compatibility instead of direct subtle call\n            </VERIFICATION NOTE> */\n            /* <ORIGINAL CODE>\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n            </ORIGINAL CODE> */\n            /* <MODIFIED CODE> */\n            bytes[i] = select_u8(&a.bytes[i], &b.bytes[i], choice);\n            /* </MODIFIED CODE> */\n        }\n        Scalar { bytes }\n    }\n}\n\n/* <VERIFICATION NOTE>\n Trait implementations for Product and Sum declared as external_body since they use iterators which are not supported by Verus.\n</VERIFICATION NOTE> */\n\nimpl<T> Product<T> for Scalar where T: Borrow<Scalar> {\n    /* <ORIGINAL CODE>\n    fn product<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ONE, |acc, item| acc * item.borrow())\n    }\n    </ORIGINAL CODE> */\n    /* <VERIFICATION NOTE>\n     Added verifier::external_body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    /* <MODIFIED CODE> - FOR EVENTUAL VERIFICATION*/\n    fn product<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified product_of_slice function\n        Scalar::product_of_slice(&scalars)\n    }  /* </MODIFIED CODE> */\n\n}\n\nimpl<T> Sum<T> for Scalar where T: Borrow<Scalar> {\n    #[verifier::external_body]\n    fn sum<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }/* <MODIFIED CODE> - if needed in for verification in the future\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified sum_of_slice function\n        Scalar::sum_of_slice(&scalars)\n    }\n     </MODIFIED CODE> */\n\n}\n\nimpl Default for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn default() -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == 0 as nat,\n    {\n        let result = Scalar::ZERO;\n        assume(scalar_to_nat(&result) == 0 as nat);\n        result\n    }\n}\n\nimpl From<u8> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn from(x: u8) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        let mut s_bytes = [0u8;32];\n        s_bytes[0] = x;\n\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u16> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u16) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u16_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u32> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u32) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u32_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        let result = Scalar { bytes: s_bytes };\n        /* </MODIFIED CODE> */\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u64> for Scalar {\n    /// Construct a scalar from the given `u64`.\n    ///\n    /// # Inputs\n    ///\n    /// An `u64` to convert to a `Scalar`.\n    ///\n    /// # Returns\n    ///\n    /// A `Scalar` corresponding to the input `u64`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let fourtytwo = Scalar::from(42u64);\n    /// let six = Scalar::from(6u64);\n    /// let seven = Scalar::from(7u64);\n    ///\n    /// assert!(fourtytwo == six * seven);\n    /// ```\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u64) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u64_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u128> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u128) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u128_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for Scalar {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self) {\n        self.bytes.zeroize();\n    }\n}\n\nimpl Scalar {\n    /// The scalar \\\\( 0 \\\\).\n    // pub const ZERO: Self = Self { bytes: [0u8; 32] };\n    /* <VERIFICATION NOTE>\n    Changed to explicit initialization\n    </VERIFICATION NOTE> */\n    /* <ORIGINAL CODE>\n    pub const ZERO: Self = Self { bytes: [0u8; 32] };\n    </ORIGINAL CODE> */\n    pub const ZERO: Scalar = Scalar {\n        bytes: [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n        ],\n    };\n\n    /// The scalar \\\\( 1 \\\\).\n    pub const ONE: Self = Self {\n        bytes: [\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n        ],\n    };\n\n    /* <VERIFICATION NOTE>\n     Verification of random method postponed - requires rand_core feature to be enabled.\n    </VERIFICATION NOTE> */\n    #[cfg(any(test, feature = \"rand_core\"))]\n    /// Return a `Scalar` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `CryptoRngCore`\n    ///   (i.e. `CryptoRng` + `RngCore`) interface.\n    ///\n    /// # Returns\n    ///\n    /// A random scalar within \\\\(\\mathbb{Z} / \\ell\\mathbb{Z}\\\\).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # fn main() {\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// use rand_core::OsRng;\n    ///\n    /// let mut csprng = OsRng;\n    /// let a: Scalar = Scalar::random(&mut csprng);\n    /// # }\n    /* <VERIFICATION NOTE>\n     No verifier::external_body annotation but it is NOT verified\n    </VERIFICATION NOTE> */\n    pub fn random<R: CryptoRngCore + ?Sized>(rng: &mut R) -> (result: Self)\n        ensures\n            is_random_scalar(&result),\n            is_canonical_scalar(&result),\n    {\n        let mut scalar_bytes = [0u8;64];\n        rng.fill_bytes(&mut scalar_bytes);\n        Scalar::from_bytes_mod_order_wide(&scalar_bytes)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Hash a slice of bytes into a scalar using a specified hash function.\n    ///\n    /// This function hashes the input using the specified `Digest` type and then reduces\n    /// the result modulo the group order to produce a scalar.\n    ///\n    /// Convenience wrapper around `from_hash`.\n    ///\n    /// # Example\n    ///\n    #[cfg_attr(feature = \"digest\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// use sha2::Sha512;\n    /// # fn main() {\n    /// let msg = \"To really appreciate architecture, you may even need to commit a murder\";\n    /// let s = Scalar::hash_from_bytes::<Sha512>(msg.as_bytes());\n    /// # }\n    /// ```\n    /* <VERIFICATION NOTE>\n     Marked as external_body due to complexity of Digest trait.\n     For Verus verification, use hash_from_bytes_verus instead.\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    pub fn hash_from_bytes<D>(input: &[u8]) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64> + Default,\n\n        ensures\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        Scalar::from_hash(hash)\n    }\n\n    /// Verus-compatible version of hash_from_bytes that uses SHA-512.\n    ///\n    /// This function is designed for Verus verification and directly computes\n    /// a SHA-512 hash. For regular code with generic hash functions, use `hash_from_bytes` instead.\n    ///\n    /// # Inputs\n    ///\n    /// * `input`: a byte slice to hash\n    ///\n    /// # Returns\n    ///\n    /// A scalar reduced modulo the group order\n    pub fn hash_from_bytes_verus(input: &[u8]) -> (result: Scalar)\n        ensures\n            is_random_bytes(input) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        use crate::core_assumes as assumes;\n        let hash_bytes: [u8; 64] = assumes::sha512_hash_bytes(input);\n        Scalar::from_hash_verus(hash_bytes)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Construct a scalar from a 64-byte (512-bit) hash output.\n    ///\n    /// This reduces the hash output modulo the group order.\n    /// Typically used after calling `finalize()` on a SHA-512 hasher.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// use sha2::{Digest, Sha512};\n    ///\n    /// # fn main() {\n    /// let mut h = Sha512::new();\n    /// h.update(b\"To really appreciate architecture, you may even need to commit a murder.\");\n    /// h.update(b\"While the programs used for The Manhattan Transcripts are of the most extreme\");\n    /// h.update(b\"nature, they also parallel the most common formula plot: the archetype of\");\n    /// h.update(b\"murder. Other phantasms were occasionally used to underline the fact that\");\n    /// h.update(b\"perhaps all architecture, rather than being about functional standards, is\");\n    /// h.update(b\"about love and death.\");\n    ///\n    /// let hash_bytes: [u8; 64] = h.finalize().into();\n    /// let s = Scalar::from_hash(hash_bytes);\n    ///\n    /// println!(\"{:?}\", s.to_bytes());\n    /// assert_eq!(\n    ///     s.to_bytes(),\n    ///     [  21,  88, 208, 252,  63, 122, 210, 152,\n    ///       154,  38,  15,  23,  16, 167,  80, 150,\n    ///       192, 221,  77, 226,  62,  25, 224, 148,\n    ///       239,  48, 176,  10, 185,  69, 168,  11, ],\n    /// );\n    /// # }\n    /// ```\n    /* <VERIFICATION NOTE>\n     Marked as external_body due to GenericArray having private fields.\n     For Verus verification, see from_hash_verus below.\n    </VERIFICATION NOTE> */\n    #[cfg(feature = \"digest\")]\n    #[verifier::external_body]\n    pub fn from_hash<D>(hash: D) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64>,\n\n        ensures\n    //is_random_digest(&hash) ==> is_random_scalar(&result),\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut output = [0u8;64];\n        output.copy_from_slice(hash.finalize().as_slice());\n        Scalar::from_bytes_mod_order_wide(&output)\n    }\n\n    /// Verus-compatible version of from_hash that takes pre-finalized hash bytes.\n    ///\n    /// This function is designed for Verus verification and takes a byte array directly\n    /// instead of a generic Digest type. For regular code, use `from_hash` instead.\n    ///\n    /// # Inputs\n    ///\n    /// * `hash_bytes`: a 64-byte array representing the output of a hash function\n    ///\n    /// # Returns\n    ///\n    /// A scalar reduced modulo the group order\n    pub fn from_hash_verus(hash_bytes: [u8; 64]) -> (result: Scalar)\n        ensures\n            is_random_bytes(&hash_bytes) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        let result = Scalar::from_bytes_mod_order_wide(&hash_bytes);\n        assume(false);\n        result\n    }\n\n    /// Convert this `Scalar` to its underlying sequence of bytes.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.to_bytes() == [0u8; 32]);\n    /// ```\n    pub const fn to_bytes(&self) -> (result: [u8; 32])\n        ensures\n            result == self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        self.bytes\n    }\n\n    /// View the little-endian byte encoding of the integer representing this Scalar.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.as_bytes() == &[0u8; 32]);\n    /// ```\n    pub const fn as_bytes(&self) -> (result: &[u8; 32])\n        ensures\n            result == &self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        &self.bytes\n    }\n}\n\nimpl Scalar {\n    /// Given a nonzero `Scalar`, compute its multiplicative inverse.\n    ///\n    /// # Warning\n    ///\n    /// `self` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Returns\n    ///\n    /// The multiplicative inverse of the this `Scalar`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // x = 2238329342913194256032495932344128051776374960164957527413114840482143558222\n    /// let X: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x4e, 0x5a, 0xb4, 0x34, 0x5d, 0x47, 0x08, 0x84,\n    ///         0x59, 0x13, 0xb4, 0x64, 0x1b, 0xc2, 0x7d, 0x52,\n    ///         0x52, 0xa5, 0x85, 0x10, 0x1b, 0xcc, 0x42, 0x44,\n    ///         0xd4, 0x49, 0xf4, 0xa8, 0x79, 0xd9, 0xf2, 0x04,\n    ///     ]);\n    /// // 1/x = 6859937278830797291664592131120606308688036382723378951768035303146619657244\n    /// let XINV: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x1c, 0xdc, 0x17, 0xfc, 0xe0, 0xe9, 0xa5, 0xbb,\n    ///         0xd9, 0x24, 0x7e, 0x56, 0xbb, 0x01, 0x63, 0x47,\n    ///         0xbb, 0xba, 0x31, 0xed, 0xd5, 0xa9, 0xbb, 0x96,\n    ///         0xd5, 0x0b, 0xcd, 0x7a, 0x3f, 0x96, 0x2a, 0x0f,\n    ///     ]);\n    ///\n    /// let inv_X: Scalar = X.invert();\n    /// assert!(XINV == inv_X);\n    /// let should_be_one: Scalar = &inv_X * &X;\n    /// assert!(should_be_one == Scalar::ONE);\n    /// ```\n    // VERIFICATION NOTE: VERIFIED\n    pub fn invert(&self) -> (result: Scalar)\n        requires\n            is_canonical_scalar(self),\n        ensures\n    // Result is the multiplicative inverse: result * self ≡ 1 (mod group_order)\n\n            (scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1,\n            is_canonical_scalar(\n                &result,\n            ),\n    // VERIFICATION NOTE: is this true and/or necessary?\n    // Result is canonical\n    // scalar_to_nat(&result) < group_order(),\n    // result.bytes[31] <= 127,\n\n    {\n        let unpacked = self.unpack();\n        let inv_unpacked = unpacked.invert();\n        let result = inv_unpacked.pack();\n        assert((scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1);\n        assume(is_canonical_scalar(&result));\n        result\n    }\n\n    /// Given a slice of nonzero (possibly secret) `Scalar`s,\n    /// compute their inverses in a batch.\n    ///\n    /// # Return\n    ///\n    /// Each element of `inputs` is replaced by its inverse.\n    ///\n    /// The product of all inverses is returned.\n    ///\n    /// # Warning\n    ///\n    /// All input `Scalars` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// # fn main() {\n    /// let mut scalars = [\n    ///     Scalar::from(3u64),\n    ///     Scalar::from(5u64),\n    ///     Scalar::from(7u64),\n    ///     Scalar::from(11u64),\n    /// ];\n    ///\n    /// let allinv = Scalar::batch_invert(&mut scalars);\n    ///\n    /// assert_eq!(allinv, Scalar::from(3*5*7*11u64).invert());\n    /// assert_eq!(scalars[0], Scalar::from(3u64).invert());\n    /// assert_eq!(scalars[1], Scalar::from(5u64).invert());\n    /// assert_eq!(scalars[2], Scalar::from(7u64).invert());\n    /// assert_eq!(scalars[3], Scalar::from(11u64).invert());\n    /// # }\n    /// ```\n    #[cfg(feature = \"alloc\")]\n    // Theo: Verus doesn't like the zeroize in this function. I think the long-term\n    // solution is to use assume_specification to tell Verus what zeroize does.\n    // In the short-term, I've just told verus to ignore the body.\n    // (SB update: alternative is to exclude just the zeroize call, as below)\n    pub fn batch_invert(inputs: &mut [Scalar]) -> (result:\n        Scalar)/* <VERIFICATION NOTE>\n     Refactored for Verus: Index loops instead of iterators, manual Vec construction, ..\n    </VERIFICATION NOTE> */\n\n        ensures\n    // Result is the modular inverse of the product of all original inputs\n\n            is_inverse_of_nat(&result, product_of_scalars(old(inputs)@)),\n            // Each input is replaced with its inverse\n            forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ),\n    {\n        // This code is essentially identical to the FieldElement\n        // implementation, and is documented there.  Unfortunately,\n        // it's not easy to write it generically, since here we want\n        // to use `UnpackedScalar`s internally, and `Scalar`s\n        // externally, but there's no corresponding distinction for\n        // field elements.\n        let n = inputs.len();\n        let one_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(limbs_bounded(&one_unpacked));\n        }\n\n        let one: UnpackedScalar = one_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&one));\n        }\n\n        /* <VERIFICATION NOTE>\n         Build vec manually instead of vec![one; n] for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let mut scratch = vec![one; n];\n         </ORIGINAL CODE> */\n        let mut scratch = Vec::new();\n        for _ in 0..n {\n            scratch.push(one);\n        }\n\n        // Keep an accumulator of all of the previous products\n        let acc_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(scratch.len() == n);\n            assume(limbs_bounded(&acc_unpacked));\n        }\n\n        let mut acc = acc_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        /* <VERIFICATION NOTE>\n         Rewritten with index loop instead of .zip() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         for (input, scratch) in inputs.iter_mut().zip(scratch.iter_mut()) {\n             *scratch = acc;\n        //     // Avoid unnecessary Montgomery multiplication in second pass by\n        //     // keeping inputs in Montgomery form\n             let tmp = input.unpack().as_montgomery();\n             *input = tmp.pack();\n             acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n         }\n        </ORIGINAL CODE> */\n        for i in 0..n\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                limbs_bounded(&acc),\n        {\n            scratch[i] = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = input_unpacked.as_montgomery();\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n\n            proof {\n                assume(limbs_bounded(&acc));\n            }\n        }\n\n        proof {\n            // Assert that all scratch elements have bounded limbs\n            assume(forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]));\n        }\n\n        // acc is nonzero iff all inputs are nonzero\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert!(acc.pack() != Scalar::ZERO);\n\n        // Compute the inverse of all products\n        // ORIGINAL CODE: acc = acc.montgomery_invert().from_montgomery();\n        acc = acc.montgomery_invert();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        acc = acc.from_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // We need to return the product of all inverses later\n        let ret = acc.pack();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        /* <VERIFICATION NOTE>\n         Manual reverse loop instead of .rev() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.iter().rev()) {\n             let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n             *input = UnpackedScalar::montgomery_mul(&acc, scratch).pack();\n             acc = tmp;\n         }\n        </ORIGINAL CODE> */\n        let mut i: usize = n;\n        while i > 0\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                i <= n,\n                limbs_bounded(&acc),\n                forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]),\n            decreases i,\n        {\n            i -= 1;\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input_unpacked);\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = UnpackedScalar::montgomery_mul(&acc, &scratch[i]).pack();\n            acc = tmp;\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        #[cfg(not(verus_keep_ghost))]\n        Zeroize::zeroize(&mut scratch);\n\n        proof {\n            // Assume the postconditions\n            assume(is_inverse_of_nat(&ret, product_of_scalars(old(inputs)@)));\n            assume(forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ));\n        }\n\n        ret\n    }\n}\n\n#[cfg(feature = \"serde\")]\nuse serde::de::Visitor;\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[cfg(feature = \"serde\")]\n/// Visitor for deserializing a Scalar from a sequence of 32 bytes.\n///\n/* VERIFICATION NOTE:\n- We don't cover serde feature yet\n- The ScalarVisitor struct is defined at module level rather than inside the\n`Deserialize::deserialize` since Verus doesn't support nested types\n</VERIFICATION NOTE> */\nstruct ScalarVisitor;\n\n#[cfg(feature = \"serde\")]\nimpl<'de> Visitor<'de> for ScalarVisitor {\n    type Value = Scalar;\n\n    #[verifier::external_body]\n    fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        {\n            formatter.write_str(\n                \"a sequence of 32 bytes whose little-endian interpretation is less than the \\\n                        basepoint order ℓ\",\n            )\n        }\n    }\n\n    #[verifier::external_body]\n    fn visit_seq<A>(self, mut seq: A) -> Result<Scalar, A::Error> where\n        A: serde::de::SeqAccess<'de>,\n     {\n        let mut bytes = [0u8;32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            bytes[i] = seq.next_element()?.ok_or_else(\n                || serde::de::Error::invalid_length(i, &\"expected 32 bytes\"),\n            )?;\n        }\n        Option::from(Scalar::from_canonical_bytes(bytes)).ok_or_else(\n            || serde::de::Error::custom(\"scalar was not canonically encoded\"),\n        )\n    }\n}\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl Serialize for Scalar {\n    #[verifier::external_body]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl<'de> Deserialize<'de> for Scalar {\n    #[verifier::external_body]\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error> where D: Deserializer<'de> {\n        /* VERIFICATION NOTE:\n        Originally struct ScalarVisitor defined here, but moved up to the top of the file\n        </VERIFICATION NOTE> */\n        deserializer.deserialize_tuple(32, ScalarVisitor)\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Add#add().",
      "display_name": "add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Add#add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn add(self, other: &'b EdwardsPoint) -> EdwardsPoint {\n        (self + &other.as_projective_niels()).as_extended()\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core array/Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core array/Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV_MOD_u8().",
      "display_name": "pow2_mul_DIV_MOD_u8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV_MOD_u8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "        lemma_mul_is_commutative(pow2(j * 8) as int, input[i + j] as int);\n    }\n\n    assert forall|j: nat| 0 <= j <= 7 implies #[trigger] (pow2(j * 8) * input[i + j]) <= pow2(\n        (j + 1) * 8,\n    ) - pow2(j * 8) && pow2((j + 1) * 8) > pow2(j * 8) by {\n        assert(j * 8 + 8 == (j + 1) * 8) by {\n            lemma_mul_is_distributive_add_other_way(8, j as int, 1);\n        }\n        pow2_mul_u8(input[i + j], j * 8);\n        assert(pow2((j + 1) * 8) > pow2(j * 8)) by {\n            lemma_pow2_strictly_increases(j * 8, j * 8 + 8);\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 8,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/main().",
      "display_name": "main",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/main().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/reduce_lemmas.rs",
      "file_name": "reduce_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "fn main() {\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#part1().",
      "display_name": "part1",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#part1().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    fn part1(sum: u128) -> (res: (u128, u64))\n        ensures\n            ({\n                let carry = res.0;\n                let p = res.1;\n                &&& p < (1u64 << 52)  // VER NOTE: p is bounded by 52 bits\n                // VER NOTE: The sum plus p*L[0] equals carry shifted left by 52 bits (i.e., divisible by 2^52)\n                &&& sum + (p as u128) * (constants::L.limbs[0] as u128) == carry << 52\n            }),",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/main().",
      "display_name": "main",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/main().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/bit_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/bit_lemmas.rs",
      "file_name": "bit_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "fn main() {\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_square_of().",
      "display_name": "is_square_of",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_square_of().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field_specs.rs",
      "relative_path": "src/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "src",
      "body": "pub open spec fn is_square_of(a: &FieldElement51, b: &FieldElement51) -> bool {\n    (field_element_as_nat(b) * field_element_as_nat(b)) % p() == field_element_as_nat(a) % p()\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core array/Hash#hash().",
      "display_name": "hash",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core array/Hash#hash().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#random().",
      "display_name": "random",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#random().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn random<R: CryptoRngCore + ?Sized>(rng: &mut R) -> Self {\n        let mut uniform_bytes = [0u8; 64];\n        rng.fill_bytes(&mut uniform_bytes);\n\n        RistrettoPoint::from_uniform_bytes(&uniform_bytes)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#product_of_slice().",
      "display_name": "product_of_slice",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#product_of_slice().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar_helpers.rs",
      "relative_path": "src/scalar_helpers.rs",
      "file_name": "scalar_helpers.rs",
      "parent_folder": "src",
      "body": "    pub fn product_of_slice(scalars: &[Scalar]) -> (result: Scalar)\n        ensures\n    // Result is a valid scalar (bytes represent a value < group_order)\n\n            scalar_to_nat(&result) < group_order(),\n            // Result represents the product of all scalars in the slice (mod group_order)\n            scalar_congruent_nat(&result, product_of_scalars(scalars@)),\n    {\n        let n = scalars.len();\n        let mut acc = Scalar::ONE;\n\n        proof {\n            // Assume properties of Scalar::ONE\n            assume(scalar_to_nat(&acc) < group_order());\n            assume(scalar_to_nat(&acc) == 1);\n            assume(scalar_congruent_nat(&acc, product_of_scalars(scalars@.subrange(0, 0))));\n        }\n\n        for i in 0..n\n            invariant\n                n == scalars.len(),\n                scalar_to_nat(&acc) < group_order(),\n                // acc represents the product of scalars[0..i]\n                scalar_congruent_nat(&acc, product_of_scalars(scalars@.subrange(0, i as int))),\n        {\n            proof {\n                // Assume preconditions for multiplication are satisfied\n                assume(false);\n            }\n            acc = &acc * &scalars[i];\n\n            proof {\n                // Assume the result maintains the invariant\n                assume(scalar_to_nat(&acc) < group_order());\n                assume(scalar_congruent_nat(\n                    &acc,\n                    product_of_scalars(scalars@.subrange(0, (i + 1) as int)),\n                ));\n            }\n        }\n\n        proof {\n            // At this point, acc is the product of all scalars\n            assert(scalars@.subrange(0, n as int) =~= scalars@);\n        }\n\n        acc\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_old_carry().",
      "display_name": "lemma_old_carry",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_old_carry().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_old_carry(old_carry: u64)\n    requires\n        old_carry < 1u64 << 52,\n    ensures\n        old_carry >> 52 == 0,\n{\n    assert(old_carry >> 52 == 0) by (bit_vector)\n        requires\n            old_carry < 1u64 << 52,\n    ;\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries1().",
      "display_name": "as_bytes_boundaries1",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries1().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "\n#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\n#[allow(unused_imports)]\nuse vstd::arithmetic::div_mod::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::mul::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\n#[allow(unused_imports)]\nuse vstd::bits::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::bit_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::div_mod_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mask_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mul_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::pow_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::shift_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_nat_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::compute_q_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::field_core::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::from_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::limbs_to_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::load8_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::negate_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2_51_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_biconditional().",
      "display_name": "lemma_q_biconditional",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_biconditional().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_q_biconditional(limbs: [u64; 5], q: u64)\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 52),\n        as_nat(limbs) < 2 * p(),  // Tight bound from reduce()\n        q == compute_q_spec(limbs),\n        q as nat == (as_nat(limbs) + 19) / pow2(255),\n        q == 0 || q == 1,\n    ensures\n        as_nat(limbs) >= p() <==> q == 1,\n        as_nat(limbs) < p() <==> q == 0,\n{\n    pow255_gt_19();\n    lemma2_to64();\n    lemma_pow2_pos(255);\n\n    // The key insight: with as_nat(limbs) < 2*p() and p() < 2^255, we have two cases:\n    // Case 1: as_nat(limbs) < p() ⟺ as_nat(limbs) + 19 < 2^255 ⟺ q = 0\n    // Case 2: p() ≤ as_nat(limbs) < 2*p() ⟺ 2^255 ≤ as_nat(limbs) + 19 < 2*2^255 ⟺ q = 1\n\n    // Forward direction: as_nat(limbs) < p() ==> q == 0\n    if as_nat(limbs) < p() {\n        lemma_div_strictly_bounded((as_nat(limbs) + 19) as int, pow2(255) as int, 1);\n    }\n    // Backward direction: q == 0 ==> as_nat(limbs) < p()\n\n    if q == 0 {\n        lemma_fundamental_div_mod((as_nat(limbs) + 19) as int, pow2(255) as int);\n        lemma_mod_bound((as_nat(limbs) + 19) as int, pow2(255) as int);\n    }\n    // Forward direction: as_nat(limbs) >= p() ==> q == 1\n\n    if as_nat(limbs) >= p() {\n        // Since q is 0 or 1, and we know as_nat + 19 >= 2^255, q cannot be 0\n        if q == 0 {\n            lemma_fundamental_div_mod((as_nat(limbs) + 19) as int, pow2(255) as int);\n            lemma_mod_bound((as_nat(limbs) + 19) as int, pow2(255) as int);\n        }\n    }\n    // Backward direction: q == 1 ==> as_nat(limbs) >= p()\n\n    if q == 1 {\n        lemma_fundamental_div_mod((as_nat(limbs) + 19) as int, pow2(255) as int);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_is_ordered().",
      "display_name": "lemma_div_is_ordered",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_is_ordered().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_not().",
      "display_name": "choice_not",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_not().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field.rs",
      "relative_path": "src/field.rs",
      "file_name": "field.rs",
      "parent_folder": "src",
      "body": "     - Use wrapper functions for ConstantTimeEq and CtOption\n    </VERIFICATION NOTE> */\n\n        ensures\n            choice_is_true(result) == (field_element_as_bytes(self) == field_element_as_bytes(\n                other,\n            )),\n    // SPEC BYPASS through placeholder field_element_as_bytes\n\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Verus compatibility instead of direct subtle call\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.as_bytes().ct_eq(&other.as_bytes())\n         </ORIGINAL CODE> */\n        let result = ct_eq_bytes32(&self.as_bytes(), &other.as_bytes());\n        assume(choice_is_true(result) == (field_element_as_bytes(self) == field_element_as_bytes(\n            other,\n        )));\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_verus/u64/serial/backend/add().",
      "display_name": "add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_verus/u64/serial/backend/add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/sum_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/sum_lemmas.rs",
      "file_name": "sum_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub open spec fn add(a: nat, b: nat) -> nat {\n    a + b\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "display_name": "elligator_inv",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    /// Encode 16 bytes of data to a RistrettoPoint, using the Lizard method\n    pub fn lizard_encode<D: Digest>(data: &[u8; 16]) -> RistrettoPoint\n    where\n        D: Digest<OutputSize = U32>,\n    {\n        let mut fe_bytes: [u8; 32] = Default::default();\n\n        let digest = D::digest(data);\n        fe_bytes[0..32].copy_from_slice(digest.as_slice());\n        fe_bytes[8..24].copy_from_slice(data);\n        fe_bytes[0] &= 254; // make positive since Elligator on r and -r is the same\n        fe_bytes[31] &= 63;\n        let fe = FieldElement::from_bytes(&fe_bytes);\n        RistrettoPoint::elligator_ristretto_flavor(&fe)\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/left_right_shift().",
      "display_name": "left_right_shift",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/left_right_shift().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn left_right_shift(v: u64, sl: u64, sr: u64)\n    requires\n        sr <= sl < 64,\n        v * pow2(sl as nat) <= u64::MAX,\n    ensures\n        (v << sl) >> sr == v << (sl - sr),\n{\n    let d = (sl - sr) as nat;\n\n    assert(v << sl == v * pow2(sl as nat)) by {\n        lemma_u64_shl_is_mul(v, sl);\n    }\n\n    assert(pow2(sl as nat) == pow2(d) * pow2(sr as nat)) by {\n        lemma_pow2_adds(d, sr as nat);\n    }\n\n    let w = (v * pow2(sl as nat)) as nat;\n\n    assert(w as u64 >> sr == w / pow2(sr as nat)) by {\n        lemma_u64_shr_is_div(w as u64, sr);\n    }\n\n    assert(w == pow2(sr as nat) * (v * pow2(d))) by {\n        lemma_mul_is_associative(v as int, pow2(d) as int, pow2(sr as nat) as int);\n    }\n\n    assert(pow2(sr as nat) > 0) by {\n        lemma_pow2_pos(sr as nat);\n    }\n\n    assert(w / pow2(sr as nat) == v * pow2(d)) by {\n        lemma_div_multiples_vanish((v * pow2(d)) as int, pow2(sr as nat) as int);\n    }\n\n    assert(v * pow2(d) == v << (d as u64)) by {\n        lemma_u64_shl_is_mul(v, d as u64);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/low_bits_mask_increases().",
      "display_name": "low_bits_mask_increases",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/low_bits_mask_increases().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/mask_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/mask_lemmas.rs",
      "file_name": "mask_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn low_bits_mask_increases(a: nat, b: nat)\n    requires\n        a < b,\n    ensures\n        low_bits_mask(a) < low_bits_mask(b),\n    decreases a + b,\n{\n    if (a == 0) {\n        // lbm(0) = 0\n        lemma_low_bits_mask_values();\n        // lbm(b) = 2 * lbm(b - 1) + 1, in particular, > 0\n        lemma_low_bits_mask_unfold(b);\n    } else {\n        // lbm(b) / 2 = lbm(b - 1)\n        lemma_low_bits_mask_div2(b);\n        // lbm(a) / 2 = lbm(a - 1)\n        lemma_low_bits_mask_div2(a);\n        // lbm(a - 1) < lbm(b - 1)\n        low_bits_mask_increases((a - 1) as nat, (b - 1) as nat);\n    }\n\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn identity() -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::ONE,\n            W: FieldElement::ZERO,\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#zip().",
      "display_name": "zip",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#zip().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_geometric_sum_5_terms().",
      "display_name": "lemma_geometric_sum_5_terms",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_geometric_sum_5_terms().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_geometric_sum_5_terms()\n    ensures\n        (pow2(51) - 1) * (1 + pow2(51) + pow2(102) + pow2(153) + pow2(204)) == pow2(255) - 1,\n{\n    // Establish power-of-2 relationships\n    lemma_pow2_adds(51, 51);  // 2^102 = 2^51 * 2^51\n    lemma_pow2_adds(51, 102);  // 2^153 = 2^51 * 2^102\n    lemma_pow2_adds(51, 153);  // 2^204 = 2^51 * 2^153\n    lemma_pow2_adds(51, 204);  // 2^255 = 2^51 * 2^204\n\n    // Geometric series formula: For r^n with n terms starting at r^0:\n    // (r - 1) * (1 + r + r^2 + ... + r^(n-1)) = r^n - 1\n    // Here: r = 2^51, n = 5, so (2^51 - 1) * (sum of 5 terms) = 2^255 - 1\n\n    // We'll prove this by expanding the left-hand side and showing it equals the right\n    // LHS = (2^51 - 1) * (1 + 2^51 + 2^102 + 2^153 + 2^204)\n    //     = 2^51*(1 + 2^51 + 2^102 + 2^153 + 2^204) - 1*(1 + 2^51 + 2^102 + 2^153 + 2^204)\n    //     = (2^51 + 2^102 + 2^153 + 2^204 + 2^255) - (1 + 2^51 + 2^102 + 2^153 + 2^204)\n    //     = 2^255 - 1  [all middle terms cancel]\n\n    let sum = 1 + pow2(51) + pow2(102) + pow2(153) + pow2(204);\n    let lhs = (pow2(51) - 1) * sum;\n\n    // Expand (a - 1) * b = a * b - b\n    assert(lhs == pow2(51) * sum - 1 * sum) by {\n        lemma_mul_is_distributive_sub(sum as int, pow2(51) as int, 1);\n    }\n\n    // Expand pow2(51) * sum using distributivity\n    assert(pow2(51) * sum == pow2(51) * 1 + pow2(51) * pow2(51) + pow2(51) * pow2(102) + pow2(51)\n        * pow2(153) + pow2(51) * pow2(204)) by {\n        lemma_mul_is_distributive_add(pow2(51) as int, 1, pow2(51) as int);\n        lemma_mul_is_distributive_add(pow2(51) as int, 1 + pow2(51) as int, pow2(102) as int);\n        lemma_mul_is_distributive_add(\n            pow2(51) as int,\n            1 + pow2(51) + pow2(102) as int,\n            pow2(153) as int,\n        );\n        lemma_mul_is_distributive_add(\n            pow2(51) as int,\n            1 + pow2(51) + pow2(102) + pow2(153) as int,\n            pow2(204) as int,\n        );\n    }\n\n    // Simplify using power-of-2 addition properties\n    assert(pow2(51) * pow2(153) == pow2(204));\n    assert(pow2(51) * pow2(204) == pow2(255));\n\n    // Now compute lhs = (pow2(51) + pow2(102) + pow2(153) + pow2(204) + pow2(255)) - sum\n    //                 = (pow2(51) + pow2(102) + pow2(153) + pow2(204) + pow2(255))\n    //                   - (1 + pow2(51) + pow2(102) + pow2(153) + pow2(204))\n\n    // The middle terms cancel, leaving: pow2(255) - 1\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#select().",
      "display_name": "select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    pub fn select(&self, x: usize) -> T {\n        debug_assert_eq!(x & 1, 1);\n        debug_assert!(x < 16);\n\n        self.0[x / 2]\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimeMultiscalarMul#vartime_multiscalar_mul().",
      "display_name": "vartime_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimeMultiscalarMul#vartime_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn vartime_multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>,\n        Self::Point: Clone,\n    {\n        Self::optional_multiscalar_mul(\n            scalars,\n            points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/pippenger_optional_multiscalar_mul().",
      "display_name": "pippenger_optional_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/pippenger_optional_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "//!\n//! There is no function for checking whether a point is valid.\n//! Instead, the `EdwardsPoint` struct is guaranteed to hold a valid\n//! point on the curve.\n//!\n//! We use the Rust type system to make invalid points\n//! unrepresentable: `EdwardsPoint` objects can only be created via\n//! successful decompression of a compressed point, or else by\n//! operations on other (valid) `EdwardsPoint`s.\n//!\n//! [curve_models]: https://docs.rs/curve25519-dalek/latest/curve25519-dalek/backend/serial/curve_models/index.html\n// We allow non snake_case names because coordinates in projective space are\n// traditionally denoted by the capitalisation of their respective\n// counterparts in affine space.  Yeah, you heard me, rustc, I'm gonna have my\n// affine and projective cakes and eat both of them too.\n#![allow(non_snake_case)]\n\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "display_name": "lemma_bitops_lifted",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "            * 8)) as u64\n    }\n}\n\npub proof fn load8_at_plus_version_rec_is_bounded(input: &[u8], i: usize, k: nat)\n    requires\n        k <= 7,\n    ensures\n        load8_at_plus_version_rec(input, i, k) < pow2(8 * (k + 1)),\n    decreases k,\n{\n    assert(u8::MAX < pow2(8)) by {\n        lemma2_to64();\n    }\n\n    if (k == 0) {\n        // just needs the the pre-if assert\n    } else {\n        // k > 0\n        // Let f(k) := load8_at_plus_version_rec(input, i, k)\n        // IH: f(k - 1) < pow2(8 * k)\n        assert(load8_at_plus_version_rec(input, i, (k - 1) as nat) < pow2(8 * k)) by {\n            load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n        }\n\n        let c = (input[i + k] as u64);\n        assert(c < pow2(8));\n\n        // f(k) = f(k - 1) + c * pow2(8 * k)\n        assert(c << (8 * k) == c * pow2(8 * k)) by {\n            assert((input[i + k] as u64) * pow2(8 * k) <= u64::MAX) by {\n                assert(u64::MAX == pow2(64) - 1) by {\n                    lemma2_to64_rest();\n                }\n                assert(c * pow2(8 * k) < pow2(64)) by {\n                    assert(c * pow2(8 * k) < pow2(8) * pow2(8 * k)) by {\n                        lemma_mul_strict_inequality(c as int, pow2(8) as int, pow2(8 * k) as int);\n                    }\n                    assert(pow2(8) * pow2(8 * k) <= pow2(64)) by {\n                        assert(pow2(8 * k) <= pow2(56)) by {\n                            if (k < 7) {\n                                lemma_pow2_strictly_increases(8 * k, 56);\n                            }\n                        }\n                        lemma_pow2_pos(8);\n                        lemma_mul_inequality(pow2(8 * k) as int, pow2(56) as int, pow2(8) as int);\n                        lemma_pow2_adds(8, 56);\n                    }\n                }\n            }\n            lemma_u64_shl_is_mul(c, (8 * k) as u64);\n        }\n\n        // f(k - 1) < 1 * 2^(8k)\n        // c <= 2^8 - 1\n        // f(k -1) + c * 2^8k < 2^8 * 2^8k = 2^(8 * (k + 1))\n\n        assert(load8_at_plus_version_rec(input, i, k) < pow2(8 * k) + c * pow2(8 * k));\n\n        assert(pow2(8 * k) + c * pow2(8 * k) <= pow2(8 * (k + 1))) by {\n            // x + c * x == c ( x + 1 )\n            assert(pow2(8 * k) + c * pow2(8 * k) == pow2(8 * k) * (c + 1)) by {\n                lemma_mul_is_distributive_add(pow2(8 * k) as int, c as int, 1);\n            }\n            assert(c + 1 <= pow2(8));\n\n            assert(pow2(8 * k) * (c + 1) <= pow2(8 * (k + 1))) by {\n                lemma_mul_inequality((c + 1) as int, pow2(8) as int, pow2(8 * k) as int);\n                lemma_pow2_adds(8, 8 * k);\n                lemma_mul_is_distributive_add(8, 1, k as int);\n            }\n        }\n    }\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 21
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_k().",
      "display_name": "as_nat_k",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_k().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_mod_sum_factor().",
      "display_name": "lemma_mod_sum_factor",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_mod_sum_factor().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs",
      "file_name": "as_nat_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "        lemma_mul_is_distributive_sub(pow2(4 * 51) as int, a[4] as int, b[4] as int);\n    }\n}\n\n// Explicit and mod-p identities for squaring as_nat conversion\npub proof fn as_nat_squared(v: [u64; 5])\n    ensures\n        as_nat(v) * as_nat(v) == pow2(8 * 51) * (v[4] * v[4]) + pow2(7 * 51) * (2 * (v[3] * v[4]))\n            + pow2(6 * 51) * (v[3] * v[3] + 2 * (v[2] * v[4])) + pow2(5 * 51) * (2 * (v[2] * v[3])\n            + 2 * (v[1] * v[4])) + pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0]\n            * v[4])) + pow2(3 * 51) * (2 * (v[1] * v[2]) + 2 * (v[0] * v[3])) + pow2(2 * 51) * (v[1]\n            * v[1] + 2 * (v[0] * v[2])) + pow2(1 * 51) * (2 * (v[0] * v[1])) + (v[0] * v[0]),\n        // and the mod equality\n        (as_nat(v) * as_nat(v)) % p() == (pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (\n        v[0] * v[4])) + pow2(3 * 51) * (2 * (v[1] * v[2]) + 2 * (v[0] * v[3]) + 19 * (v[4] * v[4]))\n            + pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] * v[2]) + 19 * (2 * (v[3] * v[4]))) + pow2(\n            1 * 51,\n        ) * (2 * (v[0] * v[1]) + 19 * (v[3] * v[3] + 2 * (v[2] * v[4]))) + (v[0] * v[0] + 19 * (2\n            * (v[2] * v[3]) + 2 * (v[1] * v[4])))) as nat % p(),\n{\n    let v0 = v[0];\n    let v1 = v[1];\n    let v2 = v[2];\n    let v3 = v[3];\n    let v4 = v[4];\n\n    let s1 = pow2(1 * 51);\n    let s2 = pow2(2 * 51);\n    let s3 = pow2(3 * 51);\n    let s4 = pow2(4 * 51);\n    let s5 = pow2(5 * 51);\n    let s6 = pow2(6 * 51);\n    let s7 = pow2(7 * 51);\n    let s8 = pow2(8 * 51);\n\n    assert(s1 * s1 == s2) by { lemma_pow2_adds(51, 51) }\n    assert(s1 * s2 == s2 * s1 == s3) by { lemma_pow2_adds(51, 102) }\n    assert(s1 * s3 == s3 * s1 == s4) by { lemma_pow2_adds(51, 153) }\n    assert(s1 * s4 == s4 * s1 == s5) by { lemma_pow2_adds(51, 204) }\n    assert(s2 * s2 == s4) by { lemma_pow2_adds(102, 102) }\n    assert(s2 * s3 == s3 * s2 == s5) by { lemma_pow2_adds(102, 153) }\n    assert(s2 * s4 == s4 * s2 == s6) by { lemma_pow2_adds(102, 204) }\n    assert(s3 * s3 == s6) by { lemma_pow2_adds(153, 153) }\n    assert(s3 * s4 == s4 * s3 == s7) by { lemma_pow2_adds(153, 204) }\n    assert(s4 * s4 == s8) by { lemma_pow2_adds(204, 204) }\n\n    assert(as_nat(v) * as_nat(v) == v0 * as_nat(v) + (s1 * v1) * as_nat(v) + (s2 * v2) * as_nat(v)\n        + (s3 * v3) * as_nat(v) + (s4 * v4) * as_nat(v)) by {\n        // (x1 + x2 + x3 + x4 + x5) * n == x1 * n + x2 * n + x3 * n + x4 * n + x5 * n\n        mul_5_terms(as_nat(v) as int, v0 as int, s1 * v1, s2 * v2, s3 * v3, s4 * v4);\n    }\n\n    // because of the sheer number of possible associativity/distributivity groupings we have\n    // to help the solver along by intermittently asserting chunks\n    assert(v0 * as_nat(v) == s4 * (v0 * v4) + s3 * (v0 * v3) + s2 * (v0 * v2) + s1 * (v0 * v1) + v0\n        * v0) by {\n        mul_v0_and_reorder(\n            v0 as int,\n            s1 as int,\n            v1 as int,\n            s2 as int,\n            v2 as int,\n            s3 as int,\n            v3 as int,\n            s4 as int,\n            v4 as int,\n        );\n    }\n\n    assert((s1 * v1) * as_nat(v) == s5 * (v1 * v4) + s4 * (v1 * v3) + s3 * (v1 * v2) + s2 * (v1\n        * v1) + s1 * (v0 * v1)) by {\n        mul_si_vi_and_reorder(\n            s1 as int,\n            v1 as int,\n            v0 as int,\n            s1 as int,\n            v1 as int,\n            s2 as int,\n            v2 as int,\n            s3 as int,\n            v3 as int,\n            s4 as int,\n            v4 as int,\n        )\n    }\n\n    assert((s2 * v2) * as_nat(v) == s6 * (v2 * v4) + s5 * (v2 * v3) + s4 * (v2 * v2) + s3 * (v1\n        * v2) + s2 * (v0 * v2)) by {\n        mul_si_vi_and_reorder(\n            s2 as int,\n            v2 as int,\n            v0 as int,\n            s1 as int,\n            v1 as int,\n            s2 as int,\n            v2 as int,\n            s3 as int,\n            v3 as int,\n            s4 as int,\n            v4 as int,\n        )\n    }\n\n    assert((s3 * v3) * as_nat(v) == s7 * (v3 * v4) + s6 * (v3 * v3) + s5 * (v2 * v3) + s4 * (v1\n        * v3) + s3 * (v0 * v3)) by {\n        mul_si_vi_and_reorder(\n            s3 as int,\n            v3 as int,\n            v0 as int,\n            s1 as int,\n            v1 as int,\n            s2 as int,\n            v2 as int,\n            s3 as int,\n            v3 as int,\n            s4 as int,\n            v4 as int,\n        )\n    }\n\n    assert((s4 * v4) * as_nat(v) == s8 * (v4 * v4) + s7 * (v3 * v4) + s6 * (v2 * v4) + s5 * (v1\n        * v4) + s4 * (v0 * v4)) by {\n        mul_si_vi_and_reorder(\n            s4 as int,\n            v4 as int,\n            v0 as int,\n            s1 as int,\n            v1 as int,\n            s2 as int,\n            v2 as int,\n            s3 as int,\n            v3 as int,\n            s4 as int,\n            v4 as int,\n        )\n    }\n\n    // we now mash them all together\n    assert(as_nat(v) * as_nat(v) == s8 * (v4 * v4) + s7 * (2 * (v3 * v4)) + s6 * (v3 * v3 + 2 * (v2\n        * v4)) + s5 * (2 * (v2 * v3) + 2 * (v1 * v4)) + s4 * (v2 * v2 + 2 * (v1 * v3) + 2 * (v0\n        * v4)) + s3 * (2 * (v1 * v2) + 2 * (v0 * v3)) + s2 * (v1 * v1 + 2 * (v0 * v2)) + s1 * (2 * (\n    v0 * v1)) + (v0 * v0)) by {\n        // These assert(a + a = 2a) statements aren't strictly necessary, but they improve the solve time\n        // s1 terms\n        assert(s1 * (v0 * v1) + s1 * (v0 * v1) == s1 * (2 * (v0 * v1))) by {\n            assert(v0 * v1 + v0 * v1 == 2 * (v0 * v1));\n            lemma_mul_is_distributive_add(s1 as int, v0 * v1, v0 * v1);\n        }\n\n        // s2 terms\n        assert(s2 * (v0 * v2) + s2 * (v1 * v1) + s2 * (v0 * v2) == s2 * (v1 * v1 + 2 * (v0 * v2)))\n            by {\n            assert(v0 * v2 + v0 * v2 == 2 * (v0 * v2));\n            lemma_mul_is_distributive_add(s2 as int, v0 * v2, v0 * v2);\n            lemma_mul_is_distributive_add(s2 as int, 2 * (v0 * v2), v1 * v1);\n        }\n\n        // s3 terms\n        assert(s3 * (v0 * v3) + s3 * (v1 * v2) + s3 * (v1 * v2) + s3 * (v0 * v3) == s3 * (2 * (v1\n            * v2) + 2 * (v0 * v3))) by {\n            assert(v1 * v2 + v1 * v2 == 2 * (v1 * v2));\n            assert(v0 * v3 + v0 * v3 == 2 * (v0 * v3));\n            lemma_mul_is_distributive_add(s3 as int, v1 * v2, v1 * v2);\n            lemma_mul_is_distributive_add(s3 as int, v0 * v3, v0 * v3);\n            lemma_mul_is_distributive_add(s3 as int, 2 * (v1 * v2), 2 * (v0 * v3));\n        }\n\n        // s4 terms\n        assert(s4 * (v0 * v4) + s4 * (v1 * v3) + s4 * (v2 * v2) + s4 * (v1 * v3) + s4 * (v0 * v4)\n            == s4 * (v2 * v2 + 2 * (v1 * v3) + 2 * (v0 * v4))) by {\n            assert(v0 * v4 + v0 * v4 == 2 * (v0 * v4));\n            assert(v1 * v3 + v1 * v3 == 2 * (v1 * v3));\n            lemma_mul_is_distributive_add(s4 as int, v0 * v4, v0 * v4);\n            lemma_mul_is_distributive_add(s4 as int, v1 * v3, v1 * v3);\n            lemma_mul_is_distributive_add(s4 as int, v2 * v2, 2 * (v1 * v3));\n            lemma_mul_is_distributive_add(s4 as int, v2 * v2 + 2 * (v1 * v3), 2 * (v0 * v4));\n        }\n\n        // s5 terms\n        assert(s5 * (v1 * v4) + s5 * (v2 * v3) + s5 * (v2 * v3) + s5 * (v1 * v4) == s5 * (2 * (v2\n            * v3) + 2 * (v1 * v4))) by {\n            assert(v1 * v4 + v1 * v4 == 2 * (v1 * v4));\n            assert(v2 * v3 + v2 * v3 == 2 * (v2 * v3));\n            lemma_mul_is_distributive_add(s5 as int, v1 * v4, v1 * v4);\n            lemma_mul_is_distributive_add(s5 as int, v2 * v3, v2 * v3);\n            lemma_mul_is_distributive_add(s5 as int, 2 * (v1 * v4), 2 * (v2 * v3));\n        }\n\n        // s6 terms\n        assert(s6 * (v2 * v4) + s6 * (v3 * v3) + s6 * (v2 * v4) == s6 * (v3 * v3 + 2 * (v2 * v4)))\n            by {\n            assert(v2 * v4 + v2 * v4 == 2 * (v2 * v4));\n            lemma_mul_is_distributive_add(s6 as int, v2 * v4, v2 * v4);\n            lemma_mul_is_distributive_add(s6 as int, 2 * (v2 * v4), v3 * v3);\n        }\n\n        // s7 terms\n        assert(s7 * (v3 * v4) + s7 * (v3 * v4) == s7 * (2 * (v3 * v4))) by {\n            assert(v3 * v4 + v3 * v4 == 2 * (v3 * v4));\n            lemma_mul_is_distributive_add(s7 as int, v3 * v4, v3 * v4);\n        }\n    }\n\n    // This is the explicit version, now we can take everything mod p\n\n    // p well defined\n    pow255_gt_19();\n\n    // By definition, p = s^5 - 19\n    // equivalently,\n    // s^5 = (p + 19)\n    // s^6 = s * (p + 19)\n    // s^7 = s^2 * (p + 19)\n    // s^8 = s^3 * (p + 19)\n    assert(s5 == (p() + 19));\n\n    // we pack together terms to slim down expressions;\n\n    let c0_base = v0 * v0;\n    let c0_x19 = 2 * (v2 * v3) + 2 * (v1 * v4);\n    let c0 = c0_base + 19 * c0_x19;\n\n    let c1_base = 2 * (v0 * v1);\n    let c1_x19 = v3 * v3 + 2 * (v2 * v4);\n    let c1 = c1_base + 19 * c1_x19;\n\n    let c2_base = v1 * v1 + 2 * (v0 * v2);\n    let c2_x19 = 2 * (v3 * v4);\n    let c2 = c2_base + 19 * c2_x19;\n\n    let c3_base = 2 * (v1 * v2) + 2 * (v0 * v3);\n    let c3_x19 = v4 * v4;\n    let c3 = c3_base + 19 * c3_x19;\n\n    let c4 = v2 * v2 + 2 * (v1 * v3) + 2 * (v0 * v4);\n\n    // group in preparation for the substitution\n    assert(as_nat(v) * as_nat(v) == s4 * c4 + s3 * (s5 * c3_x19 + c3_base) + s2 * (s5 * c2_x19\n        + c2_base) + s1 * (s5 * c1_x19 + c1_base) + (s5 * c0_x19 + c0_base)) by {\n        // s3 terms\n        assert(s8 * c3_x19 + s3 * c3_base == s3 * (s5 * c3_x19 + c3_base)) by {\n            assert(s8 == (s3 * s5)) by {\n                lemma_pow2_adds(3 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s3 as int, s5 as int, c3_x19);\n            lemma_mul_is_distributive_add(s3 as int, s5 * c3_x19, c3_base)\n        }\n\n        // s2 terms\n        assert(s7 * c2_x19 + s2 * c2_base == s2 * (s5 * c2_x19 + c2_base)) by {\n            assert(s7 == (s2 * s5)) by {\n                lemma_pow2_adds(2 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s2 as int, s5 as int, c2_x19);\n            lemma_mul_is_distributive_add(s2 as int, s5 * c2_x19, c2_base)\n        }\n\n        // s1 terms\n        assert(s6 * c1_x19 + s1 * c1_base == s1 * (s5 * c1_x19 + c1_base)) by {\n            assert(s6 == (s1 * s5)) by {\n                lemma_pow2_adds(1 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s1 as int, s5 as int, c1_x19);\n            lemma_mul_is_distributive_add(s1 as int, s5 * c1_x19, c1_base)\n        }\n    }\n\n    // Next we use the identity s5 = p + 19\n    assert(s5 * c3_x19 + c3_base == p() * c3_x19 + c3) by {\n        lemma_mul_is_distributive_add(c3_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c2_x19 + c2_base == p() * c2_x19 + c2) by {\n        lemma_mul_is_distributive_add(c2_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c1_x19 + c1_base == p() * c1_x19 + c1) by {\n        lemma_mul_is_distributive_add(c1_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c0_x19 + c0_base == p() * c0_x19 + c0) by {\n        lemma_mul_is_distributive_add(c0_x19 as int, p() as int, 19);\n    }\n\n    // in summary, we can reorder and regroup terms to get X * p() + Y\n    assert(as_nat(v) * as_nat(v) == p() * (s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19) + (s4\n        * c4 + s3 * c3 + s2 * c2 + s1 * c1 + c0)) by {\n        lemma_mul_is_distributive_add(s3 as int, p() * c3_x19, c3 as int);\n        lemma_mul_is_distributive_add(s2 as int, p() * c2_x19, c2 as int);\n        lemma_mul_is_distributive_add(s1 as int, p() * c1_x19, c1 as int);\n\n        assert(s3 * (p() * c3_x19) + s2 * (p() * c2_x19) + s1 * (p() * c1_x19) + p() * c0_x19 == p()\n            * (s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19)) by {\n            lemma_mul_is_associative(s3 as int, c3_x19 as int, p() as int);\n            lemma_mul_is_associative(s2 as int, c2_x19 as int, p() as int);\n            lemma_mul_is_associative(s1 as int, c1_x19 as int, p() as int);\n\n            lemma_mul_is_distributive_add(p() as int, s3 * c3_x19, s2 * c2_x19);\n            lemma_mul_is_distributive_add(p() as int, s3 * c3_x19 + s2 * c2_x19, s1 * c1_x19);\n            lemma_mul_is_distributive_add(\n                p() as int,\n                s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19,\n                c0_x19 as int,\n            );\n        }\n    }\n\n    let k = (s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19);\n    let sum = (s4 * c4 + s3 * c3 + s2 * c2 + s1 * c1 + c0);\n\n    assert(as_nat(v) * as_nat(v) == k * p() + sum);\n    assert(k * p() + sum == (k as nat) * p() + (sum as nat));\n\n    // Now, we simply move to mod p\n\n    assert((as_nat(v) * as_nat(v)) % p() == ((k as nat) * p() + (sum as nat)) % p());\n    assert(((k as nat) * p() + (sum as nat)) % p() == (sum as nat) % p()) by {\n        lemma_mod_sum_factor(k as int, sum as int, p() as int);\n    }\n\n    // sanity check\n    assert(s4 * c4 == pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])));\n    assert(s3 * c3 == pow2(3 * 51) * (2 * (v[1] * v[2]) + 2 * (v[0] * v[3]) + 19 * (v[4] * v[4])));\n    assert(s2 * c2 == pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] * v[2]) + 19 * (2 * (v[3] * v[4]))));\n    assert(s1 * c1 == pow2(1 * 51) * (2 * (v[0] * v[1]) + 19 * (v[3] * v[3] + 2 * (v[2] * v[4]))));\n    assert(c0 == (v[0] * v[0] + 19 * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4]))));\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#bits_le().",
      "display_name": "bits_le",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#bits_le().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub(crate) fn bits_le(&self) -> impl DoubleEndedIterator<Item = bool> + '_ {\n        /* <VERIFICATION NOTE>\n        - Opaque types like Iterator not supported in Verus yet\n        - see bits_le_verus below for a Verus-compatible version\n        </VERIFICATION NOTE> */\n        (0..256).map(|i| {\n            // As i runs from 0..256, the bottom 3 bits index the bit, while the upper bits index\n            // the byte. Since self.bytes is little-endian at the byte level, this iterator is\n            // little-endian on the bit level\n            ((self.bytes[i >> 3] >> (i & 7)) & 1u8) == 1\n        })\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#to_bytes().",
      "display_name": "to_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#to_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#From#from().",
      "display_name": "from",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#From#from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/window.rs",
      "relative_path": "src/window.rs",
      "file_name": "window.rs",
      "parent_folder": "src",
      "body": "    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_affine_niels(); 8];\n        let A2 = A.double();\n        for i in 0..7 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n        NafLookupTable5(Ai)\n    }",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_sum_simplify().",
      "display_name": "lemma_add_sum_simplify",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_sum_simplify().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_add_sum_simplify(a: &Scalar52, b: &Scalar52, sum: &Scalar52, carry: u64)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        to_nat(&a.limbs) < group_order(),\n        to_nat(&b.limbs) < group_order(),\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n        (carry >> 52) < 2,\n        seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) + (carry >> 52) as nat * pow2(\n            (52 * (5) as nat),\n        ),\n    ensures\n        to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs),\n{\n    // First establish the relationship between the different representations\n    assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs)) by {\n        assert(a.limbs@ == a.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(a.limbs@) == to_nat(&a.limbs));\n    }\n    assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs)) by {\n        assert(b.limbs@ == b.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(b.limbs@) == to_nat(&b.limbs));\n    }\n    assert(seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) == to_nat(&sum.limbs)) by {\n        assert(sum.limbs@ == sum.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(sum.limbs@) == to_nat(&sum.limbs));\n    }\n\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs) + (carry >> 52) * pow2(\n        (52 * (5) as nat),\n    ));\n\n    // From the loop invariant, we have: a + b == sum + (carry >> 52) * 2^260\n    assert(52 * 5 == 260) by (compute);\n    assert(pow2((52 * 5) as nat) == pow2(260));\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(\n        260,\n    ));\n\n    // Since a < group_order() and b < group_order(), we have a + b < 2 * group_order()\n    // This is just basic arithmetic: if x < A and y < A, then x + y < A + A = 2*A\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) < group_order() + group_order());\n    assert(group_order() + group_order() == 2 * group_order());\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) < 2 * group_order());\n\n    // Therefore: sum + (carry >> 52) * 2^260 < 2 * group_order()\n    assert(to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260) < 2 * group_order());\n\n    // Prove a contradiction if carry is nonzero\n    assert((carry >> 52) as nat * pow2(260) < 2 * group_order());\n    if carry >> 52 == 1 {\n        lemma_pow2_260_greater_than_2_group_order();\n        assert(1 as nat * pow2(260) < 2 * group_order());\n        assert(false);\n    }\n    assert(carry >> 52 == 0);\n\n    // Since carry >> 52 >= 0 and pow2(260) > 0, we have (carry >> 52) * pow2(260) >= 0\n    // Therefore sum < sum + (carry >> 52) * pow2(260) < 2 * group_order()\n    lemma_pow2_pos(260);\n    assert(pow2(260) > 0);\n    assert((carry >> 52) as nat * pow2(260) >= 0);\n    assert(to_nat(&sum.limbs) <= to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260));\n    assert(to_nat(&sum.limbs) < 2 * group_order());\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_mul_upper_bound().",
      "display_name": "lemma_mul_upper_bound",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_mul_upper_bound().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "proof fn lemma_mul_upper_bound(a: nat, x: nat, b: nat)\n    requires\n        x <= b,\n    ensures\n        a * x <= a * b,\n{\n    // This follows from the monotonicity of multiplication for non-negative numbers\n    // If x <= b, then a * x <= a * b for any a >= 0\n    // Verus's SMT solver should handle this automatically with integer arithmetic\n    if a == 0 {\n    } else {\n        // For a > 0: x <= b implies a*x <= a*b\n        // This is a basic property of multiplication that the SMT solver understands\n        lemma_mul_inequality(x as int, b as int, a as int);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "display_name": "lemma_limb3_contribution_correctness_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub proof fn lemma_limb3_contribution_correctness_52(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[2] < (1u64 << 52),  // Need limb 2 for boundary byte 19\n        limbs[3] < (1u64 << 52),\n        bytes_match_limbs_packing_52(limbs, bytes),\n    ensures\n        limb3_byte_contribution_52(limbs, bytes) == (limbs[3] as nat) * pow2(156),\n{\n    // Proof following docs_22_oct/lemma_limb3_contribution_52_proof.md\n    lemma2_to64();\n    shift_is_pow2(52);\n\n    // === STEP 1: Define the Split ===\n    let l3_low = limbs[3] as nat % pow2(4);  // Low 4 bits in byte 19\n    let l3_high = limbs[3] as nat / pow2(4);  // High 48 bits in bytes 20-25\n\n    // === STEP 2: Bound the High Part ===\n    lemma_div_bound(limbs[3] as nat, 4, 52);\n    assert(l3_high < pow2(48));\n\n    // === STEP 3: Reconstruction Identity ===\n    lemma_pow2_pos(4);\n    lemma_fundamental_div_mod(limbs[3] as int, pow2(4) as int);\n    assert(pow2(4) * l3_high == l3_high * pow2(4)) by {\n        lemma_mul_is_commutative(pow2(4) as int, l3_high as int);\n    }\n    assert(limbs[3] as nat == l3_low + l3_high * pow2(4));\n\n    // === STEP 4: Byte Reconstruction for High 48 Bits ===\n    lemma_byte_from_limb_shift_52(limbs[3], 4, bytes[20]);\n    lemma_byte_from_limb_shift_52(limbs[3], 12, bytes[21]);\n    lemma_byte_from_limb_shift_52(limbs[3], 20, bytes[22]);\n    lemma_byte_from_limb_shift_52(limbs[3], 28, bytes[23]);\n    lemma_byte_from_limb_shift_52(limbs[3], 36, bytes[24]);\n    lemma_byte_from_limb_shift_52(limbs[3], 44, bytes[25]);\n\n    // Rewrite byte extractions in terms of l3_high = limbs[3] / 2^4\n    lemma_pow2_adds(4, 0);\n    lemma_pow2_pos(0);\n    lemma_div_denominator(limbs[3] as int, pow2(4) as int, pow2(0) as int);\n    assert(bytes[20] as nat == l3_high / pow2(0) % 256);\n\n    lemma_pow2_adds(4, 8);\n    lemma_pow2_pos(8);\n    lemma_div_denominator(limbs[3] as int, pow2(4) as int, pow2(8) as int);\n    assert(bytes[21] as nat == l3_high / pow2(8) % 256);\n\n    lemma_pow2_adds(4, 16);\n    lemma_pow2_pos(16);\n    lemma_div_denominator(limbs[3] as int, pow2(4) as int, pow2(16) as int);\n    assert(bytes[22] as nat == l3_high / pow2(16) % 256);\n\n    lemma_pow2_adds(4, 24);\n    lemma_pow2_pos(24);\n    lemma_div_denominator(limbs[3] as int, pow2(4) as int, pow2(24) as int);\n    assert(bytes[23] as nat == l3_high / pow2(24) % 256);\n\n    lemma_pow2_adds(4, 32);\n    lemma_pow2_pos(32);\n    lemma_div_denominator(limbs[3] as int, pow2(4) as int, pow2(32) as int);\n    assert(bytes[24] as nat == l3_high / pow2(32) % 256);\n\n    lemma_pow2_adds(4, 40);\n    lemma_pow2_pos(40);\n    lemma_div_denominator(limbs[3] as int, pow2(4) as int, pow2(40) as int);\n    assert(bytes[25] as nat == l3_high / pow2(40) % 256);\n\n    // 6-byte reconstruction lemma\n    lemma_6_bytes_reconstruct(\n        l3_high,\n        bytes[20],\n        bytes[21],\n        bytes[22],\n        bytes[23],\n        bytes[24],\n        bytes[25],\n    );\n\n    let bytes_at_offset_0 = bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8)\n        + bytes[22] as nat * pow2(16) + bytes[23] as nat * pow2(24) + bytes[24] as nat * pow2(32)\n        + bytes[25] as nat * pow2(40);\n\n    assert(bytes_at_offset_0 == l3_high);\n\n    // === STEP 5: Position Adjustment ===\n    //assert(19 * 8 == 152);\n\n    // Multiply reconstruction identity by pow2(156)\n    assert((l3_low + l3_high * pow2(4)) * pow2(156) == limbs[3] as nat * pow2(156));\n\n    // Distribute\n    assert((l3_low + l3_high * pow2(4)) * pow2(156) == l3_low * pow2(156) + (l3_high * pow2(4))\n        * pow2(156)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(156) as int,\n            l3_low as int,\n            (l3_high * pow2(4)) as int,\n        );\n    }\n\n    // Simplify high term\n    lemma_pow2_adds(4, 156);\n    assert((l3_high * pow2(4)) * pow2(156) == l3_high * pow2(160)) by {\n        lemma_mul_is_associative(l3_high as int, pow2(4) as int, pow2(156) as int);\n    }\n\n    // Now we have: limbs[3] * 2^156 = l3_low * 2^156 + l3_high * 2^160\n\n    // === STEP 6: Express Low Part in Contribution Form ===\n    // l3_low * 2^156 = l3_low * 2^152 * 2^4 = (l3_low * 16) * 2^152\n    lemma_pow2_adds(152, 4);\n    assert(pow2(156) == pow2(152) * pow2(4));\n    assert(pow2(4) == 16) by {\n        assert(pow2(2) == 4);\n        assert(pow2(4) == pow2(2) * pow2(2)) by {\n            lemma_pow2_adds(2, 2);\n        }\n    }\n\n    assert(l3_low * pow2(156) == l3_low * (pow2(152) * pow2(4))) by {\n        // pow2(156) = pow2(152) * pow2(4) proven above\n    }\n    assert(l3_low * (pow2(152) * pow2(4)) == (l3_low * pow2(152)) * pow2(4)) by {\n        lemma_mul_is_associative(l3_low as int, pow2(152) as int, pow2(4) as int);\n    }\n    assert((l3_low * pow2(152)) * pow2(4) == pow2(152) * l3_low * pow2(4)) by {\n        lemma_mul_is_commutative((l3_low * pow2(152)) as int, pow2(4) as int);\n    }\n    assert(pow2(152) * l3_low * pow2(4) == pow2(152) * (l3_low * pow2(4))) by {\n        lemma_mul_is_associative(pow2(152) as int, l3_low as int, pow2(4) as int);\n    }\n    assert(l3_low * pow2(156) == (l3_low * 16) * pow2(152));\n\n    // === STEP 7: Expand the High Part ===\n    // Multiply bytes_at_offset_0 by pow2(160)\n    assert(bytes_at_offset_0 * pow2(160) == l3_high * pow2(160));\n\n    // Distribute pow2(160) into each byte term\n    assert(bytes_at_offset_0 * pow2(160) == bytes[20] as nat * pow2(0) * pow2(160)\n        + bytes[21] as nat * pow2(8) * pow2(160) + bytes[22] as nat * pow2(16) * pow2(160)\n        + bytes[23] as nat * pow2(24) * pow2(160) + bytes[24] as nat * pow2(32) * pow2(160)\n        + bytes[25] as nat * pow2(40) * pow2(160)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(160) as int,\n            (bytes[20] as nat * pow2(0)) as int,\n            (bytes[21] as nat * pow2(8)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(160) as int,\n            (bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8)) as int,\n            (bytes[22] as nat * pow2(16)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(160) as int,\n            (bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8) + bytes[22] as nat * pow2(\n                16,\n            )) as int,\n            (bytes[23] as nat * pow2(24)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(160) as int,\n            (bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8) + bytes[22] as nat * pow2(16)\n                + bytes[23] as nat * pow2(24)) as int,\n            (bytes[24] as nat * pow2(32)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(160) as int,\n            (bytes[20] as nat * pow2(0) + bytes[21] as nat * pow2(8) + bytes[22] as nat * pow2(16)\n                + bytes[23] as nat * pow2(24) + bytes[24] as nat * pow2(32)) as int,\n            (bytes[25] as nat * pow2(40)) as int,\n        );\n\n        // Apply associativity: (byte * pow2(k)) * pow2(160) = byte * (pow2(k) * pow2(160))\n        lemma_mul_is_associative(bytes[20] as int, pow2(0) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[21] as int, pow2(8) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[22] as int, pow2(16) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[23] as int, pow2(24) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[24] as int, pow2(32) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[25] as int, pow2(40) as int, pow2(160) as int);\n    }\n\n    // Apply power addition and connect to final positions\n    assert(bytes_at_offset_0 * pow2(160) == bytes[20] as nat * pow2(160) + bytes[21] as nat * pow2(\n        168,\n    ) + bytes[22] as nat * pow2(176) + bytes[23] as nat * pow2(184) + bytes[24] as nat * pow2(192)\n        + bytes[25] as nat * pow2(200)) by {\n        lemma_mul_is_associative(bytes[20] as int, pow2(0) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[21] as int, pow2(8) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[22] as int, pow2(16) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[23] as int, pow2(24) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[24] as int, pow2(32) as int, pow2(160) as int);\n        lemma_mul_is_associative(bytes[25] as int, pow2(40) as int, pow2(160) as int);\n        lemma_pow2_adds(0, 160);\n        lemma_pow2_adds(8, 160);\n        lemma_pow2_adds(16, 160);\n        lemma_pow2_adds(24, 160);\n        lemma_pow2_adds(32, 160);\n        lemma_pow2_adds(40, 160);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes_verus().",
      "display_name": "hash_from_bytes_verus",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes_verus().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn hash_from_bytes_verus(input: &[u8]) -> (result: Scalar)\n        ensures\n            is_random_bytes(input) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        use crate::core_assumes as assumes;\n        let hash_bytes: [u8; 64] = assumes::sha512_hash_bytes(input);\n        Scalar::from_hash_verus(hash_bytes)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#coset4().",
      "display_name": "coset4",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#coset4().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn coset4(&self) -> [EdwardsPoint; 4] {\n        [\n            self.0,\n            self.0 + constants::EIGHT_TORSION[2],\n            self.0 + constants::EIGHT_TORSION[4],\n            self.0 + constants::EIGHT_TORSION[6],\n        ]\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
      "relative_path": "src/backend/serial/scalar_mul/straus.rs",
      "file_name": "straus.rs",
      "parent_folder": "scalar_mul",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "display_name": "lemma_pow2_adds",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 59,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/term_product_bounds().",
      "display_name": "term_product_bounds",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/term_product_bounds().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "#[allow(unused_imports)]\nuse vstd::arithmetic::div_mod::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::mul::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\n#[allow(unused_imports)]\nuse vstd::bits::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::bit_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::div_mod_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mask_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mul_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::pow_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::shift_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_nat_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::compute_q_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::field_core::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::from_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::limbs_to_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::load8_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::negate_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2_51_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#From#from().",
      "display_name": "from",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#From#from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn from(x: u128) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u128_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo zeroize 1.8.2 Vec#Zeroize#zeroize().",
      "display_name": "zeroize",
      "symbol": "rust-analyzer cargo zeroize 1.8.2 Vec#Zeroize#zeroize().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/MultiscalarMul#multiscalar_mul().",
      "display_name": "multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/MultiscalarMul#multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>;\n}\n\n/// A trait for variable-time multiscalar multiplication without precomputation.\npub trait VartimeMultiscalarMul {\n    /// The type of point being multiplied, e.g., `RistrettoPoint`.\n    type Point;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// `Option`s of points, compute either `Some(Q)`, where\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// if all points were `Some(P_i)`, or else return `None`.\n    ///\n    /// This function is particularly useful when verifying statements\n    /// involving compressed points.  Accepting `Option<Point>` allows\n    /// inlining point decompression into the multiscalar call,\n    /// avoiding the need for temporary buffers.\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    /// let abc = [a,b,c];\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    /// let PQR = [P, Q, R];\n    ///\n    /// let compressed = [P.compress(), Q.compress(), R.compress()];\n    ///\n    /// // Now we can compute A1 = a*P + b*Q + c*R using P, Q, R:\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &PQR);\n    ///\n    /// // Or using the compressed points:\n    /// let A2 = RistrettoPoint::optional_multiscalar_mul(\n    ///     &abc,\n    ///     compressed.iter().map(|pt| pt.decompress()),\n    /// );\n    ///\n    /// assert_eq!(A2, Some(A1));\n    ///\n    /// // It's also possible to mix compressed and uncompressed points:\n    /// let A3 = RistrettoPoint::optional_multiscalar_mul(\n    ///     abc.iter()\n    ///         .chain(abc.iter()),\n    ///     compressed.iter().map(|pt| pt.decompress())\n    ///         .chain(PQR.iter().map(|&pt| Some(pt))),\n    /// );\n    ///\n    /// assert_eq!(A3, Some(A1+A1));\n    /// # }\n    /// ```\n    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<Self::Point>>;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// public points, compute\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// using variable-time operations.\n    ///\n    /// It is an error to call this function with two iterators of different lengths.\n    ///\n    /// # Examples\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    ///\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    ///\n    /// // A1 = a*P + b*Q + c*R\n    /// let abc = [a,b,c];\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &[P,Q,R]);\n    /// // Note: (&abc).into_iter(): Iterator<Item=&Scalar>\n    ///\n    /// // A2 = (-a)*P + (-b)*Q + (-c)*R\n    /// let minus_abc = abc.iter().map(|x| -x);\n    /// let A2 = RistrettoPoint::vartime_multiscalar_mul(minus_abc, &[P,Q,R]);\n    /// // Note: minus_abc.into_iter(): Iterator<Item=Scalar>\n    ///\n    /// assert_eq!(A1.compress(), (-A2).compress());\n    /// # }\n    /// ```\n    fn vartime_multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>,\n        Self::Point: Clone,\n    {\n        Self::optional_multiscalar_mul(\n            scalars,\n            points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#vartime_double_scalar_mul_basepoint().",
      "display_name": "vartime_double_scalar_mul_basepoint",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#vartime_double_scalar_mul_basepoint().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn vartime_double_scalar_mul_basepoint(\n        a: &Scalar,\n        A: &RistrettoPoint,\n        b: &Scalar,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::vartime_double_scalar_mul_basepoint(\n            a, &A.0, b,\n        ))\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "display_name": "as_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "\nimpl<'b> SubAssign<&'b RistrettoPoint> for RistrettoPoint {\n    fn sub_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) - _rhs;\n    }\n}",
      "is_libsignal": false,
      "caller_count": 14,
      "callee_count": 15
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "display_name": "sub",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn sub(self, _rhs: &'b Scalar) -> (result:\n        Scalar)/* VERIFICATION NOTE: preconditions are added to the SpecImpl above\n    requires\n      is_canonical_scalar(self),\n      is_canonical_scalar(_rhs),\n    */\n\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        /* <ORIGINAL CODE>\n         UnpackedScalar::sub(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::sub requires: -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()\n        proof {\n            assume(-group_order() <= to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs));\n            assume(to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::sub(&self_unpacked, &rhs_unpacked);\n        proof {\n            // Postconditions from sub - need to strengthen, review connections\n            assume(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                - to_nat(&rhs_unpacked.limbs)) % (group_order() as int));\n            assume(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int));\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_borrow_and_mask_bounded().",
      "display_name": "lemma_borrow_and_mask_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_borrow_and_mask_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_borrow_and_mask_bounded(borrow: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        (borrow & mask) < (1u64 << 52),\n{\n    assert((borrow & mask) <= mask) by (bit_vector);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_to_nat().",
      "display_name": "seq_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "#[allow(unused_imports)]\nuse super::scalar_specs::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::div_mod::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::mul::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\n#[allow(unused_imports)]\nuse vstd::bits::*;\n#[allow(unused_imports)]\nuse vstd::calc;\nuse vstd::prelude::*;\n\n#[allow(unused_imports)]\nuse super::common_verus::shift_lemmas::*;\n\nverus! {\n\n/// Verification: scalar * scalar.invert() ≡ 1 mod L\nproof fn verify_invert_correct(\n    x: Scalar52,\n)\n//     requires to_scalar(&x.limbs) != 0\n//    ensures (to_scalar(&x.limbs) * invert_spec(&x.limbs)) % group_order() == 1\n{\n    assume(false);\n\n}\n\npub proof fn lemma_52_52(x: u64, y: u64)\n    requires\n        x < (1u64 << 52),\n        y < (1u64 << 52),\n    ensures\n        (x as u128) * (y as u128) < (1u128 << 104),\n{\n    assert(1u128 << 52 == 1u64 << 52) by (bit_vector);\n    calc! {\n        (<)\n        (x as u128) * (y as u128); (<=) {\n            if x > 0 {\n                lemma_mul_strict_inequality(y as int, (1u128 << 52) as int, x as int);\n                assert(x * y < x * (1u128 << 52));\n            } else {\n                assert((0 as u128) * (y as u128) == 0);\n            }\n        }\n        (x as u128) * (1u128 << 52); (<) {\n            lemma_mul_strict_inequality(x as int, (1u128 << 52) as int, (1u128 << 52) as int);\n        }\n        (1u128 << 52) * (1u128 << 52);\n    }\n    assert((1u128 << 52) * (1u128 << 52) == (1u128 << 104)) by (compute);\n}\n\npub proof fn lemma_square_internal_no_overflow()\n    ensures\n        (1u128 << 105) + (1u128 << 105) == (1u128 << 106),\n        (1u128 << 105) + (1u128 << 104) < (1u128 << 106),\n        (1u128 << 104) * 2 == (1u128 << 105),\n        (1u128 << 106) + (1u128 << 104) < (1u128 << 107),\n{\n    assert((1u128 << 105) + (1u128 << 105) == (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 105) + (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 104) * 2 == (1u128 << 105)) by (bit_vector);\n    assert((1u128 << 106) + (1u128 << 104) < (1u128 << 107)) by (bit_vector);\n}\n\npub proof fn lemma_square_internal_correct(a: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        z[0] == (a[0] * a[0]),\n        z[1] == (a[0] * a[1]) * 2,\n        z[2] == (a[0] * a[2]) * 2 + (a[1] * a[1]),\n        z[3] == (a[0] * a[3]) * 2 + (a[1] * a[2]) * 2,\n        z[4] == (a[0] * a[4]) * 2 + (a[1] * a[3]) * 2 + (a[2] * a[2]),\n        z[5] == (a[1] * a[4]) * 2 + (a[2] * a[3]) * 2,\n        z[6] == (a[2] * a[4]) * 2 + (a[3] * a[3]),\n        z[7] == (a[3] * a[4]) * 2,\n        z[8] == (a[4] * a[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(a),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*a) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n}\n\npub proof fn lemma_mul_internal_no_overflow()\n    ensures\n        (1u128 << 104) + (1u128 << 104) == (1u128 << 105),\n        3u128 * (1u128 << 104) < (1u128 << 106),\n        4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104),\n        (1u128 << 2) * (1u128 << 104) == (1u128 << 106),\n        8u128 == (1u128 << 3),\n        (1u128 << 3) * (1u128 << 104) == (1u128 << 107),\n{\n    assert((1u128 << 104) + (1u128 << 104) == (1u128 << 105)) by (bit_vector);\n    assert(3u128 * (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert(4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104)) by (bit_vector);\n    assert((1u128 << 2) * (1u128 << 104) == (1u128 << 106)) by (bit_vector);\n    assert(8u128 == (1u128 << 3)) by (bit_vector);\n    assert((1u128 << 3) * (1u128 << 104) == (1u128 << 107)) by (bit_vector);\n}\n\npub proof fn lemma_mul_internal_correct(a: &[u64; 5], b: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        forall|i: int| 0 <= i < 5 ==> b[i] < (1u64 << 52),\n        z[0] == (a[0] * b[0]),\n        z[1] == (a[0] * b[1]) + (a[1] * b[0]),\n        z[2] == (a[0] * b[2]) + (a[1] * b[1]) + (a[2] * b[0]),\n        z[3] == (a[0] * b[3]) + (a[1] * b[2]) + (a[2] * b[1]) + (a[3] * b[0]),\n        z[4] == (a[0] * b[4]) + (a[1] * b[3]) + (a[2] * b[2]) + (a[3] * b[1]) + (a[4] * b[0]),\n        z[5] == (a[1] * b[4]) + (a[2] * b[3]) + (a[3] * b[2]) + (a[4] * b[1]),\n        z[6] == (a[2] * b[4]) + (a[3] * b[3]) + (a[4] * b[2]),\n        z[7] == (a[3] * b[4]) + (a[4] * b[3]),\n        z[8] == (a[4] * b[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(b),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*b) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n    lemma_five_limbs_equals_to_nat(&b);\n}\n\npub proof fn lemma_nine_limbs_equals_slice128_to_nat(limbs: &[u128; 9])\n    ensures\n        nine_limbs_to_nat_aux(limbs) == slice128_to_nat(limbs),\n{\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        slice128_to_nat(limbs); {}\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 10);\n        }\n        (limbs[0] as nat) + ((limbs[1] as nat) + ((limbs[2] as nat) + ((limbs[3] as nat) + ((\n        limbs[4] as nat) + ((limbs[5] as nat) + ((limbs[6] as nat) + ((limbs[7] as nat) + (\n        limbs[8] as nat) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52))\n            * pow2(52)) * pow2(52); {\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(104, 52);\n            lemma_pow2_adds(156, 52);\n            lemma_pow2_adds(208, 52);\n            lemma_pow2_adds(260, 52);\n            lemma_pow2_adds(312, 52);\n            lemma_pow2_adds(364, 52);\n            broadcast use group_mul_is_distributive;\n            broadcast use lemma_mul_is_associative;\n\n        }\n        nine_limbs_to_nat_aux(limbs);\n    }\n}\n\npub proof fn lemma_five_limbs_equals_to_nat(limbs: &[u64; 5])\n    ensures\n        five_limbs_to_nat_aux(*limbs) == to_nat(limbs),\n{\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        to_nat(limbs); {}\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 6);\n        }\n        (limbs[0] as nat) + ((limbs[1] as nat) + ((limbs[2] as nat) + ((limbs[3] as nat) + (\n        limbs[4] as nat) * pow2(52)) * pow2(52)) * pow2(52)) * pow2(52); {\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(104, 52);\n            lemma_pow2_adds(156, 52);\n            broadcast use group_mul_is_distributive;\n            broadcast use lemma_mul_is_associative;\n\n        }\n        (limbs[0] as nat) + pow2(52) * (limbs[1] as nat) + pow2(104) * (limbs[2] as nat) + pow2(156)\n            * (limbs[3] as nat) + pow2(208) * (limbs[4] as nat); {}\n        five_limbs_to_nat_aux(*limbs);\n    }\n}\n\npub proof fn lemma_bytes_to_nat_rec_equals_bytes_to_nat(bytes: &[u8; 32])\n    ensures\n        bytes_to_nat(bytes) == as_nat_32_u8(bytes),\n{\n    // Strategy: Unfold the recursive definition and show it matches the explicit sum\n    // The recursive definition bytes_to_nat_rec(bytes, 0) computes:\n    // bytes[0] * 2^0 + bytes[1] * 2^8 + ... + bytes[31] * 2^248\n    // First, reveal the recursive structure by showing a few key steps\n    reveal_with_fuel(bytes_to_nat_rec, 33);\n\n    // Now we need to show that the recursive unfolding equals the explicit sum\n    // The key is that pow2(0) == 1, so bytes[0] * pow2(0) == bytes[0]\n    assert(pow2(0) == 1) by {\n        lemma2_to64();\n    };\n\n    // Use calc block to show the transformation step by step\n    calc! {\n        (==)\n        bytes_to_nat(bytes); {}\n        bytes_to_nat_rec(bytes, 0); {\n            // Unfold recursively - Verus should be able to see this with fuel\n        }\n        (bytes[0] as nat) * pow2(0) + (bytes[1] as nat) * pow2(8) + (bytes[2] as nat) * pow2(16) + (\n        bytes[3] as nat) * pow2(24) + (bytes[4] as nat) * pow2(32) + (bytes[5] as nat) * pow2(40)\n            + (bytes[6] as nat) * pow2(48) + (bytes[7] as nat) * pow2(56) + (bytes[8] as nat)\n            * pow2(64) + (bytes[9] as nat) * pow2(72) + (bytes[10] as nat) * pow2(80) + (\n        bytes[11] as nat) * pow2(88) + (bytes[12] as nat) * pow2(96) + (bytes[13] as nat) * pow2(\n            104,\n        ) + (bytes[14] as nat) * pow2(112) + (bytes[15] as nat) * pow2(120) + (bytes[16] as nat)\n            * pow2(128) + (bytes[17] as nat) * pow2(136) + (bytes[18] as nat) * pow2(144) + (\n        bytes[19] as nat) * pow2(152) + (bytes[20] as nat) * pow2(160) + (bytes[21] as nat) * pow2(\n            168,\n        ) + (bytes[22] as nat) * pow2(176) + (bytes[23] as nat) * pow2(184) + (bytes[24] as nat)\n            * pow2(192) + (bytes[25] as nat) * pow2(200) + (bytes[26] as nat) * pow2(208) + (\n        bytes[27] as nat) * pow2(216) + (bytes[28] as nat) * pow2(224) + (bytes[29] as nat) * pow2(\n            232,\n        ) + (bytes[30] as nat) * pow2(240) + (bytes[31] as nat) * pow2(248); {\n            // Simplify bytes[0] * pow2(0) to bytes[0]\n            // Since pow2(0) == 1, we have x * 1 == x\n            assert((bytes[0] as nat) * pow2(0) == (bytes[0] as nat)) by {\n                assert(pow2(0) == 1);\n            };\n        }\n        (bytes[0] as nat) + (bytes[1] as nat) * pow2(8) + (bytes[2] as nat) * pow2(16) + (\n        bytes[3] as nat) * pow2(24) + (bytes[4] as nat) * pow2(32) + (bytes[5] as nat) * pow2(40)\n            + (bytes[6] as nat) * pow2(48) + (bytes[7] as nat) * pow2(56) + (bytes[8] as nat)\n            * pow2(64) + (bytes[9] as nat) * pow2(72) + (bytes[10] as nat) * pow2(80) + (\n        bytes[11] as nat) * pow2(88) + (bytes[12] as nat) * pow2(96) + (bytes[13] as nat) * pow2(\n            104,\n        ) + (bytes[14] as nat) * pow2(112) + (bytes[15] as nat) * pow2(120) + (bytes[16] as nat)\n            * pow2(128) + (bytes[17] as nat) * pow2(136) + (bytes[18] as nat) * pow2(144) + (\n        bytes[19] as nat) * pow2(152) + (bytes[20] as nat) * pow2(160) + (bytes[21] as nat) * pow2(\n            168,\n        ) + (bytes[22] as nat) * pow2(176) + (bytes[23] as nat) * pow2(184) + (bytes[24] as nat)\n            * pow2(192) + (bytes[25] as nat) * pow2(200) + (bytes[26] as nat) * pow2(208) + (\n        bytes[27] as nat) * pow2(216) + (bytes[28] as nat) * pow2(224) + (bytes[29] as nat) * pow2(\n            232,\n        ) + (bytes[30] as nat) * pow2(240) + (bytes[31] as nat) * pow2(248); {}\n        as_nat_32_u8(bytes);\n    }\n}\n\npub proof fn lemma_scalar_subtract_no_overflow(\n    carry: u64,\n    difference_limb: u64,\n    addend: u64,\n    i: u32,\n    l_value: &Scalar52,\n)\n    requires\n        i < 5,\n        difference_limb < (1u64 << 52),\n        addend == 0 || addend == l_value.limbs[i as int],\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n    ensures\n        (carry >> 52) + difference_limb + addend < (1u64 << 53),\n{\n    if i == 0 {\n        assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    } else if i == 1 {\n        assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n    } else if i == 2 {\n        assert(0x000000000014def9 < (1u64 << 52)) by (bit_vector);\n    } else if i == 3 {\n    } else {\n        assert(0x0000100000000000 < (1u64 << 52)) by (bit_vector);\n    }\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert(2 * (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}\n\npub proof fn lemma_borrow_and_mask_bounded(borrow: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        (borrow & mask) < (1u64 << 52),\n{\n    assert((borrow & mask) <= mask) by (bit_vector);\n}\n\npub proof fn lemma_carry_bounded_after_mask(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) <= 1,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}\n\npub proof fn lemma_add_loop_bounds(i: int, carry: u64, a_limb: u64, b_limb: u64)\n    requires\n        0 <= i < 5,\n        a_limb < (1u64 << 52),\n        b_limb < (1u64 << 52),\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n    ensures\n        (carry >> 52) + a_limb + b_limb < (1u64 << 53),\n{\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert((1u64 << 52) + (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}\n\npub proof fn lemma_add_carry_and_sum_bounds(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) < 2,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}\n\npub proof fn lemma_l_value_properties(l_value: &Scalar52, sum: &Scalar52)\n    requires\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n    ensures\n        forall|j: int| 0 <= j < 5 ==> l_value.limbs[j] < (1u64 << 52),\n{\n    assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n}\n\npub proof fn lemma_from_montgomery_limbs_conversion(limbs: &[u128; 9], self_limbs: &[u64; 5])\n    requires\n        forall|j: int| #![auto] 0 <= j < 5 ==> limbs[j] == self_limbs[j] as u128,\n        forall|j: int| 5 <= j < 9 ==> limbs[j] == 0,\n    ensures\n        slice128_to_nat(limbs) == to_nat(self_limbs),\n{\n    lemma_nine_limbs_equals_slice128_to_nat(limbs);\n    lemma_five_limbs_equals_to_nat(self_limbs);\n    assert(limbs[0] == self_limbs[0] as u128);\n    assert(nine_limbs_to_nat_aux(limbs) == (self_limbs[0] as nat) + (self_limbs[1] as nat) * pow2(\n        52,\n    ) + (self_limbs[2] as nat) * pow2(104) + (self_limbs[3] as nat) * pow2(156) + (\n    self_limbs[4] as nat) * pow2(208) + 0 * pow2(260) + 0 * pow2(312) + 0 * pow2(364) + 0 * pow2(\n        416,\n    ));\n}\n\npub proof fn lemma_rr_limbs_bounded()\n    ensures\n        0x000d63c715bea69fu64 < (1u64 << 52),\n{\n    // Verus can figure that out the other 4 limbs are bounded\n    assert(0x000d63c715bea69fu64 < (1u64 << 52)) by (bit_vector);\n}\n\n/// Need to use induction because the postcondition expands\n/// seq_u64_to_nat in the opposite way from how it's defined.\n/// The base case is straightforward, but it takes a few steps\n/// to get Verus to prove it.\n/// Induction case: Take off the first element using definition of\n/// seq_u64_to_nat, apply induction hypothesis to the remaining sequence,\n/// then put the first element back on and simplify all the powers.\npub proof fn lemma_seq_u64_to_nat_subrange_extend(seq: Seq<u64>, i: int)\n    requires\n        0 <= i < seq.len(),\n    ensures\n        seq_u64_to_nat(seq.subrange(0, i + 1)) == seq_u64_to_nat(seq.subrange(0, i)) + seq[i]\n            * pow2(52 * i as nat),\n    decreases i,\n{\n    if i == 0 {\n        reveal_with_fuel(seq_to_nat, 3);\n        assert(seq.len() > 0);\n        assert(seq.subrange(0, 1) == seq![seq[0]]);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, 0 + 1 as int)); {\n                assert(seq.subrange(0, 1) == seq![seq[0]]);\n            }\n            seq_u64_to_nat(seq![seq[0]]); {\n                let single_elem = seq![seq[0]];\n                let nat_single = single_elem.map(|idx, x| x as nat);\n                assert(nat_single == seq![seq[0] as nat]);\n                assert(seq_u64_to_nat(single_elem) == seq_to_nat(nat_single));\n                assert(nat_single.len() == 1);\n                assert(seq_to_nat(nat_single) == nat_single[0] + seq_to_nat(\n                    nat_single.subrange(1, 1),\n                ) * pow2(52));\n                assert(nat_single.subrange(1, 1).len() == 0);\n                assert(seq_to_nat(nat_single.subrange(1, 1)) == 0);\n                assert(seq_to_nat(nat_single) == nat_single[0]);\n                assert(nat_single[0] == seq[0] as nat);\n            }\n            seq[0] as nat; {\n                assert(pow2(0) == 1) by {\n                    lemma2_to64();\n                }\n                assert(52 * 0 == 0);\n                assert(pow2(52 * 0 as nat) == pow2(0));\n                assert((seq[0] * pow2(0)) as nat == (seq[0] * 1) as nat);\n                assert((seq[0] * 1) as nat == seq[0] as nat);\n            }\n            (seq[0] * pow2(52 * 0 as nat)) as nat; {\n                lemma_empty_seq_as_nat(seq);\n            }\n            (seq_u64_to_nat(seq.subrange(0, 0)) + seq[0] * pow2(52 * 0 as nat)) as nat;\n        }\n        return ;\n    } else {\n        let limbs1 = seq.subrange(0, i + 1).map(|i, x| x as nat);\n        let limbs2 = seq.subrange(0, i).map(|i, x| x as nat);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, i + 1)); {\n                assert(seq_to_nat(limbs1) == limbs1[0] + seq_to_nat(\n                    limbs1.subrange(1, limbs1.len() as int),\n                ) * pow2(52));\n            }\n            limbs1[0] + seq_to_nat(limbs1.subrange(1, limbs1.len() as int)) * pow2(52); {\n                assert(seq.subrange(1, i + 1).map(|i, x| x as nat) == limbs1.subrange(\n                    1,\n                    limbs1.len() as int,\n                ));\n            }\n            limbs1[0] + seq_u64_to_nat(seq.subrange(1, i + 1)) * pow2(52); {\n                let tail = seq.subrange(1, i + 1);\n                assert(i >= 1);\n                assert(0 <= i - 1 < tail.len());\n                lemma_seq_u64_to_nat_subrange_extend(tail, i - 1);\n                assert(seq_u64_to_nat(tail.subrange(0, i)) == seq_u64_to_nat(\n                    tail.subrange(0, i - 1),\n                ) + tail[i - 1] * pow2(52 * (i - 1) as nat));\n                assert(tail.subrange(0, i) == seq.subrange(1, i + 1));\n                assert(tail.subrange(0, i - 1) == seq.subrange(1, i));\n                assert(seq_u64_to_nat(seq.subrange(1, i + 1)) == seq_u64_to_nat(seq.subrange(1, i))\n                    + seq[i] * pow2(52 * (i - 1) as nat));\n            }\n            limbs1[0] + ((seq_u64_to_nat(seq.subrange(1, i)) + seq[i] * pow2(52 * (i - 1) as nat))\n                * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i)) * pow2(52) + seq[i] * pow2(\n                52 * (i - 1) as nat,\n            ) * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_associative;\n\n                lemma_pow2_adds(52 * (i - 1) as nat, 52);\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i)) * pow2(52) + seq[i] * pow2(\n                52 * i as nat,\n            )) as nat; {\n                assert(seq.subrange(1, i).map(|i, x| x as nat) == limbs2.subrange(\n                    1,\n                    limbs2.len() as int,\n                ));\n            }\n            (limbs2[0] + seq_to_nat(limbs2.subrange(1, limbs2.len() as int)) * pow2(52) + seq[i]\n                * pow2(52 * i as nat)) as nat; {\n                assert(seq_to_nat(limbs2) == limbs2[0] + seq_to_nat(\n                    limbs2.subrange(1, limbs2.len() as int),\n                ) * pow2(52));\n            }\n            (seq_to_nat(limbs2) + seq[i] * pow2(52 * i as nat)) as nat; {}\n            (seq_u64_to_nat(seq.subrange(0, i)) + seq[i] * pow2(52 * i as nat)) as nat;\n        }\n    }\n}\n\n/// Verus times out when this assertion is inside\n/// lemma_seq_u64_to_nat_subrange_extend\npub proof fn lemma_empty_seq_as_nat(a: Seq<u64>)\n    ensures\n        seq_u64_to_nat(a.subrange(0, 0)) == 0,\n{\n    assert(seq_u64_to_nat(a.subrange(0, 0)) == 0);\n}\n\n/// Using lemma_mod_add_multiples_vanish in a big proof made the proof hang\npub proof fn lemma_mod_cancel(a: &Scalar52, b: &Scalar52)\n    ensures\n        (group_order() + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int) == (to_nat(\n            &a.limbs,\n        ) - to_nat(&b.limbs)) % (group_order() as int),\n{\n    lemma_mod_add_multiples_vanish(\n        (to_nat(&a.limbs) - to_nat(&b.limbs)) as int,\n        group_order() as int,\n    );\n}\n\n/// The corollary of limbs_bounded(a)\npub proof fn lemma_bound_scalar(a: &Scalar52)\n    requires\n        limbs_bounded(a),\n    ensures\n        to_nat(&a.limbs) < pow2((52 * (5) as nat)),\n{\n    lemma_general_bound(a.limbs@);\n}\n\n/// The general case of lemma_bound_scalar so we\n/// can prove via straightforward induction.\npub proof fn lemma_general_bound(a: Seq<u64>)\n    requires\n        forall|i: int| 0 <= i < a.len() ==> a[i] < (1u64 << 52),\n    ensures\n        seq_u64_to_nat(a) < pow2((52 * a.len() as nat)),\n    decreases a.len(),\n{\n    if a.len() == 0 {\n        assert(seq_u64_to_nat(a) == 0);\n        lemma2_to64();  // Gives us pow2(0) == 1 among other facts\n        assert(pow2(0) == 1);\n    } else {\n        // Inductive case\n        let tail = a.subrange(1, a.len() as int);\n\n        // Apply induction hypothesis on tail\n        assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] < (1u64 << 52)) by {\n            assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] == a[i + 1]);\n        };\n\n        assert(tail.len() == a.len() - 1);\n\n        // Apply induction hypothesis\n        lemma_general_bound(tail);\n        assert(seq_u64_to_nat(tail) < pow2((52 * tail.len() as nat)));\n\n        // Now prove for the full sequence\n        assert(seq_u64_to_nat(a) == seq_to_nat(a.map(|i, x| x as nat)));\n        assert(a.map(|i, x| x as nat).len() == a.len());\n        assert(a.map(|i, x| x as nat)[0] == a[0] as nat);\n        assert(a.map(|i, x| x as nat).subrange(1, a.len() as int) == a.subrange(\n            1,\n            a.len() as int,\n        ).map(|i, x| x as nat));\n        // Therefore:\n        assert(seq_u64_to_nat(a) == a[0] as nat + seq_u64_to_nat(a.subrange(1, a.len() as int))\n            * pow2(52));\n\n        assert(a.subrange(1, a.len() as int) == tail);\n\n        // From precondition\n        assert(a[0] < (1u64 << 52));\n        lemma2_to64_rest();\n        assert(0x10000000000000 == 1u64 << 52) by (compute_only);\n        assert(0x10000000000000 == pow2(52));\n        assert((1u64 << 52) == pow2(52));\n\n        // We have seq_u64_to_nat(a) == a[0] + seq_u64_to_nat(tail) * pow2(52)\n        // We know a[0] < pow2(52) and seq_u64_to_nat(tail) < pow2(52 * (a.len() - 1))\n\n        assert(a[0] as nat <= pow2(52) - 1);\n        assert(seq_u64_to_nat(tail) <= pow2(52 * (a.len() - 1) as nat) - 1);\n\n        assert(seq_u64_to_nat(a) <= (pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(\n            52,\n        )) by {\n            lemma_mul_inequality(\n                (pow2(52 * (a.len() - 1) as nat) - 1) as int,\n                pow2(52 * (a.len() - 1) as nat) as int,\n                pow2(52) as int,\n            );\n        };\n\n        // Expand the right side\n        assert((pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(52) == pow2(52) - 1\n            + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52)) by {\n            broadcast use lemma_mul_is_distributive_sub;\n\n        };\n\n        assert(pow2(52) - 1 + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52) == pow2(\n            52 * (a.len() - 1) as nat,\n        ) * pow2(52) - 1);\n\n        lemma_pow2_adds(52 * (a.len() - 1) as nat, 52);\n        assert(pow2(52 * (a.len() - 1) as nat) * pow2(52) == pow2(52 * (a.len() - 1) as nat + 52));\n        assert(52 * (a.len() - 1) as nat + 52 == 52 * a.len() as nat);\n\n        assert(seq_u64_to_nat(a) <= pow2(52 * a.len() as nat) - 1);\n        assert(seq_u64_to_nat(a) < pow2(52 * a.len() as nat));\n    }\n}\n\n/// Claude wrote this proof. Could the proof be shorter?\n/// Moved this to a lemma to get under rlimit.\npub proof fn lemma_decompose(a: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        a == (a >> 52) * pow2(52) + (a & mask),\n{\n    // First, establish that bit shifting is division by pow2(52)\n    broadcast use lemma_u64_shr_is_div;\n\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    lemma2_to64_rest();  // Establishes pow2(52) == 0x10000000000000\n    assert((1u64 << 52) == 0x10000000000000) by (bit_vector);\n    assert(pow2(52) == 0x10000000000000);\n    assert((1u64 << 52) as nat == pow2(52));\n\n    assert(a >> 52 == a / (1u64 << 52));\n\n    // Apply fundamental division theorem: a = q * d + r\n    lemma_fundamental_div_mod(a as int, pow2(52) as int);\n    let q = a as nat / pow2(52);\n    let r = a as nat % pow2(52);\n    assert(a as nat == q * pow2(52) + r);\n    assert(0 <= r < pow2(52));\n\n    // Now prove that (a & mask) == r\n    // mask is all 1s in the lower 52 bits\n    assert(mask == (1u64 << 52) - 1);\n\n    // Key insight: a & mask gives us the lower 52 bits, which is exactly a % pow2(52)\n    lemma_u64_low_bits_mask_is_mod(a, 52);\n    assert(a & mask == a % (1u64 << 52));\n    assert((a % (1u64 << 52)) as nat == a as nat % pow2(52));\n    assert((a & mask) as nat == r);\n\n    // Now show that a >> 52 == q\n    assert((a >> 52) as nat == a as nat / pow2(52));\n    assert((a >> 52) as nat == q);\n\n    // Combine everything\n    assert(a as nat == (a >> 52) as nat * pow2(52) + (a & mask) as nat);\n}\n\n/// The loop invariant says that subtraction is correct if we only subtract\n/// the first i items of each array, plus there's a borrow term.\n/// The first parts of the calc statement expand using the previous invariant.\n/// Then we have cases depending if the wrapping_sub wrapped.\n/// If it didn't wrap, we show that borrow must be small, and borrow >> 52 == 0.\n/// If it did wrap, we show that borrow is so large that its bit-shifts are all\n/// the maximum amount.\n/// Either way, we then use the preconditions about what was mutated,\n/// and shuffle around the powers of 52.\npub proof fn lemma_sub_loop1_invariant(\n    difference: Scalar52,\n    borrow: u64,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    old_borrow: u64,\n    mask: u64,\n    difference_loop1_start: Scalar52,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> difference.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) == seq_u64_to_nat(difference_loop1_start.limbs@.subrange(0, i as int)) - (old_borrow\n            >> 63) * pow2((52 * (i) as nat)),\n        difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(\n            0,\n            i as int,\n        ),\n        difference.limbs[i as int] == borrow & mask,\n        borrow == a.limbs[i as int].wrapping_sub((b.limbs[i as int] + (old_borrow >> 63)) as u64),\n    ensures\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n            (52 * (i + 1) as nat),\n        ) == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i + 1),\n        ),\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] * pow2(52 * i as nat) - (\n        seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] * pow2(52 * i as nat)); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) + (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            assert(difference_loop1_start.limbs@.subrange(0, i as int)\n                == difference.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) - (old_borrow >> 63) * pow2(\n            52 * i as nat,\n        ) + (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n            - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n            assert(borrow == a.limbs[i as int].wrapping_sub(\n                (b.limbs[i as int] + (old_borrow >> 63)) as u64,\n            ));\n            assert(difference.limbs[i as int] == borrow & mask);\n            // Expand wrapping sub\n            if a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) < 0 {\n                assert(borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52)) by {\n                    assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    assert(b.limbs[i as int] <= (1u64 << 52) - 1);\n                    assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                        >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                    assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 <= 1u64 << 52);\n                    assert(borrow >= (a.limbs[i as int] - (1u64 << 52)\n                        + 0x1_0000_0000_0000_0000) as u64);\n                };\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n                        - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                            >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow\n                        - 0x1_0000_0000_0000_0000) * pow2(52 * i as nat); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((borrow >> 52)\n                        * pow2(52) + difference.limbs[i as int] - 0x1_0000_0000_0000_0000) * pow2(\n                        52 * i as nat,\n                    ); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                            broadcast use lemma_pow2_adds;\n\n                        };\n                        assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n                        broadcast use lemma_mul_is_distributive_sub_other_way;\n\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow\n                            >> 52) as nat * pow2(52 * (i + 1) as nat)) by {\n                            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                            lemma_mul_is_associative(\n                                (borrow >> 52) as int,\n                                pow2(52) as int,\n                                pow2(52 * i as nat) as int,\n                            );\n                        };\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) + difference.limbs[i as int] * pow2(52 * i as nat) - 0x1_0000_0000_0000_0000\n                        * pow2(52 * i as nat); {\n                        lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) - 0x1_0000_0000_0000_0000 * pow2(52 * i as nat); {\n                        assert(borrow >> 52 == (1u64 << 12) - 1) by (bit_vector)\n                            requires\n                                borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52),\n                        ;\n                        assert(0x1_0000_0000_0000_0000 * pow2(52 * i as nat) == (1u64 << 12) * pow2(\n                            52 * (i + 1) as nat,\n                        )) by {\n                            lemma2_to64();\n                            assert(0x1_0000_0000_0000_0000 == pow2(64));\n                            assert(1u64 << 12 == pow2(12)) by (compute);\n                            lemma_pow2_adds(64, 52 * i as nat);\n                            lemma_pow2_adds(12, 52 * (i + 1) as nat);\n                            assert(64 + 52 * i as nat == 12 + 52 * (i + 1) as nat);\n                        }\n                        lemma_mul_is_distributive_sub_other_way(\n                            pow2(52 * (i + 1) as nat) as int,\n                            (1u64 << 12) - 1,\n                            (1u64 << 12) as int,\n                        );\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (-1) * pow2(\n                        52 * (i + 1) as nat,\n                    ); {\n                        assert(borrow >> 63 == 1) by (bit_vector)\n                            requires\n                                borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52),\n                        ;\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n                        (52 * (i + 1) as nat),\n                    );\n                }\n            } else {\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n                        - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                            >> 63)) as u64)) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow) * pow2(\n                        52 * i as nat,\n                    ); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((borrow >> 52)\n                        * pow2(52) + difference.limbs[i as int]) * pow2(52 * i as nat); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                            broadcast use lemma_pow2_adds;\n\n                        };\n                        assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow\n                            >> 52) as nat * pow2(52 * (i + 1) as nat)) by {\n                            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                            lemma_mul_is_associative(\n                                (borrow >> 52) as int,\n                                pow2(52) as int,\n                                pow2(52 * i as nat) as int,\n                            );\n                        };\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) + difference.limbs[i as int] * pow2(52 * i as nat); {\n                        lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                        assert(borrow < 1u64 << 52) by {\n                            assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                                >> 63)) as u64)) as u64);\n                            assert(a.limbs[i as int] < (1u64 << 52));\n                            assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 >= 0);\n                        }\n                        assert(borrow >> 52 == 0) by (bit_vector)\n                            requires\n                                borrow < 1u64 << 52,\n                        ;\n                        assert(borrow >> 63 == 0) by (bit_vector)\n                            requires\n                                borrow < 1u64 << 52,\n                        ;\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n                        (52 * (i + 1) as nat),\n                    );\n                }\n            }\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n            (52 * (i + 1) as nat),\n        );\n    }\n}\n\n/// Just a proof by computation\npub(crate) proof fn lemma_l_equals_group_order()\n    ensures\n        to_nat(&constants::L.limbs) == group_order(),\n        seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order(),\n{\n    // First show that the subrange equals the full array\n    assert(constants::L.limbs@ == constants::L.limbs@.subrange(0, 5 as int));\n    assert(seq_u64_to_nat(constants::L.limbs@) == seq_u64_to_nat(\n        constants::L.limbs@.subrange(0, 5 as int),\n    ));\n    assert(to_nat(&constants::L.limbs) == seq_u64_to_nat(constants::L.limbs@));\n\n    assert(pow2(52) == 0x10000000000000) by {\n        lemma2_to64_rest();\n    };\n    lemma_pow2_adds(52, 52);\n    assert(pow2(104) == 0x100000000000000000000000000);\n    lemma_pow2_adds(104, 104);\n    assert(pow2(208) == 0x10000000000000000000000000000000000000000000000000000);\n    lemma_pow252();\n    lemma_five_limbs_equals_to_nat(&constants::L.limbs);\n    assert(five_limbs_to_nat_aux(constants::L.limbs) == group_order()) by (compute);\n}\n\npub proof fn lemma_pow252()\n    ensures\n        pow2(252) == 0x1000000000000000000000000000000000000000000000000000000000000000,\n{\n    assert(pow2(63) == 0x8000000000000000) by {\n        lemma2_to64_rest();\n    }\n    lemma_pow2_adds(63, 63);\n    assert(pow2(126) == 0x40000000000000000000000000000000);\n    lemma_pow2_adds(126, 126);\n}\n\npub proof fn lemma_pow2_260_greater_than_2_group_order()\n    ensures\n        pow2(260) > 2 * group_order(),\n{\n    // The group order is approximately 2^252, so 2 * group_order ≈ 2^253\n    // And 2^260 >> 2^253\n    assert(pow2(260) == pow2(252) * pow2(8)) by {\n        lemma_pow2_adds(252, 8);\n    };\n    assert(pow2(8) == 256) by {\n        lemma2_to64();\n    };\n    lemma_pow252();\n    // Now Verus knows what the powers of 2 mean, so it can figure out the rest\n}\n\n/// If borrow >> 63 == 0, we apply\n/// (1) `-group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()`,\n/// and that's enough to show that to_nat(&difference.limbs) is between\n/// 0 and group order.\n/// If borrow >> 63 == 1, we apply (1) to show that carry >> 52 can't be 0.\n/// This makes the excess terms in the borrow >> 63 == 1 precondition disappear\npub(crate) proof fn lemma_sub_correct_after_loops(\n    difference: Scalar52,\n    carry: u64,\n    a: &Scalar52,\n    b: &Scalar52,\n    difference_after_loop1: Scalar52,\n    borrow: u64,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        limbs_bounded(&difference),\n        limbs_bounded(&difference_after_loop1),\n        (carry >> 52) < 2,\n        -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order(),\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n            + seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ) + (carry >> 52) * pow2(52 * 5 as nat),\n        seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) - (borrow >> 63)\n            * pow2((52 * (5) as nat)),\n    ensures\n        to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int),\n{\n    assert(borrow >> 63 == 1 || borrow >> 63 == 0) by (bit_vector);\n    assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(&difference.limbs))\n        by {\n        assert(seq_u64_to_nat(difference.limbs@) == to_nat(&difference.limbs));\n        assert(difference.limbs@ == difference.limbs@.subrange(0, 5 as int));\n    }\n    assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs)) by {\n        assert(seq_u64_to_nat(b.limbs@) == to_nat(&b.limbs));\n        assert(b.limbs@ == b.limbs@.subrange(0, 5 as int));\n    }\n    assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs)) by {\n        assert(seq_u64_to_nat(a.limbs@) == to_nat(&a.limbs));\n        assert(a.limbs@ == a.limbs@.subrange(0, 5 as int));\n    }\n    if borrow >> 63 == 0 {\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) - (borrow >> 63) * pow2(\n            (52 * (5) as nat),\n        ));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)));\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) == to_nat(&difference.limbs));\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) >= 0);\n        assert(to_nat(&a.limbs) - to_nat(&b.limbs) < group_order());\n        lemma_small_mod((to_nat(&a.limbs) - to_nat(&b.limbs)) as nat, group_order());\n        assert(to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (\n        group_order() as int));\n    }\n    if borrow >> 63 == 1 {\n        assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            constants::L.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ));\n        assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n            == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ) - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) - pow2(\n            (52 * (5) as nat),\n        ));\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(\n            52 * 5 as nat,\n        ) - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) - pow2((52 * (5) as nat)));\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            a.limbs@.subrange(0, 5 as int),\n        ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ) + (carry >> 52) * pow2(52 * 5 as nat) - pow2((52 * (5) as nat)));\n        if carry >> 52 == 0 {\n            // Get a contradiction because the sides in the above equation have different signs\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n                a.limbs@.subrange(0, 5 as int),\n            ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) >= 0) by {\n                assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) >= group_order())\n                    by {\n                    lemma_l_equals_group_order();\n                };\n                assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs));\n                assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs));\n            };\n            assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) < pow2(\n                (52 * (5) as nat),\n            )) by {\n                assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(\n                    &difference.limbs,\n                ));\n                lemma_bound_scalar(&difference);\n            };\n            assert((carry >> 52) * pow2(52 * 5 as nat) == 0);\n            assert(false);\n        }\n        assert(carry >> 52 == 1);\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            a.limbs@.subrange(0, 5 as int),\n        ) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, 5 as int),\n        ));\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) + to_nat(&a.limbs)\n            - to_nat(&b.limbs) == to_nat(&difference.limbs));\n        assert(to_nat(&constants::L.limbs) == group_order()) by {\n            lemma_l_equals_group_order();\n        };\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order()) by {\n            lemma_l_equals_group_order();\n        };\n        assert(group_order() > 0);\n        calc! {\n            (==)\n            to_nat(&difference.limbs) as int; {}\n            group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs); {\n                assert(group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs) < group_order())\n                    by {\n                    assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int))\n                        == to_nat(&difference_after_loop1.limbs)) by {\n                        assert(seq_u64_to_nat(difference_after_loop1.limbs@) == to_nat(\n                            &difference_after_loop1.limbs,\n                        ));\n                        assert(difference_after_loop1.limbs@\n                            == difference_after_loop1.limbs@.subrange(0, 5 as int));\n                    }\n                    assert(to_nat(&a.limbs) - to_nat(&b.limbs) == to_nat(\n                        &difference_after_loop1.limbs,\n                    ) - pow2((52 * (5) as nat)));\n                    lemma_bound_scalar(&difference_after_loop1);\n                };\n                lemma_small_mod(\n                    (group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) as nat,\n                    group_order(),\n                );\n            }\n            (group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int); {\n                lemma_mod_cancel(a, b);\n            }\n            (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int);\n        }\n    }\n}\n\n/// Moving this out to get under rlimit\npub proof fn lemma_old_carry(old_carry: u64)\n    requires\n        old_carry < 1u64 << 52,\n    ensures\n        old_carry >> 52 == 0,\n{\n    assert(old_carry >> 52 == 0) by (bit_vector)\n        requires\n            old_carry < 1u64 << 52,\n    ;\n}\n\n/// If borrow >> 63 == 0, we just prove that the loop step has no effect.\n/// If borrow >> 63 == 1, we substitute in the loop's updates\n/// like `difference.limbs[i as int] == carry & mask`.\n/// In that case we're proving that subtraction is correct if we only\n/// consider the first i items of each array, except there's also a\n/// `(carry >> 52) * pow2(52 * (i+1) as nat)` term that doesn't go away.\npub(crate) proof fn lemma_sub_loop2_invariant(\n    difference: Scalar52,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    mask: u64,\n    difference_after_loop1: Scalar52,\n    difference_loop2_start: Scalar52,\n    carry: u64,\n    old_carry: u64,\n    addend: u64,\n    borrow: u64,\n)\n    requires\n        0 <= i < 5,\n        mask == (1u64 << 52) - 1,\n        forall|j: int| 0 <= j < 5 ==> difference_loop2_start.limbs[j] < (1u64 << 52),\n        forall|j: int|\n            i <= j < 5 ==> difference_loop2_start.limbs[j] == difference_after_loop1.limbs[j],\n        forall|j: int|\n            (0 <= j < 5 && j != i) ==> difference_loop2_start.limbs[j] == difference.limbs[j],\n        mask == (1u64 << 52) - 1,\n        i == 0 ==> old_carry == 0,\n        i >= 1 ==> (old_carry >> 52) < 2,\n        (i >= 1 && borrow >> 63 == 0) ==> old_carry == difference_loop2_start.limbs[i - 1],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference_loop2_start,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int))\n            + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) == seq_u64_to_nat(\n            difference_loop2_start.limbs@.subrange(0, i as int),\n        ) + (old_carry >> 52) * pow2(52 * i as nat),\n        difference.limbs[i as int] == carry & mask,\n        difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(\n            0,\n            i as int,\n        ),\n        borrow >> 63 == 0 ==> addend == 0,\n        borrow >> 63 == 1 ==> addend == constants::L.limbs[i as int],\n        carry == (old_carry >> 52) + difference_loop2_start.limbs[i as int] + addend,\n    ensures\n        (i + 1 >= 1 && borrow >> 63 == 0) ==> carry == difference.limbs[i as int],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==> seq_u64_to_nat(\n            difference_after_loop1.limbs@.subrange(0, i + 1 as int),\n        ) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i + 1 as int)) == seq_u64_to_nat(\n            difference.limbs@.subrange(0, i + 1 as int),\n        ) + (carry >> 52) * pow2(52 * (i + 1) as nat),\n{\n    if borrow >> 63 == 0 {\n        lemma_old_carry(old_carry);\n        assert(addend == 0);\n        assert(carry == difference_loop2_start.limbs[i as int]);\n        assert(carry & mask == carry) by (bit_vector)\n            requires\n                carry < 1u64 << 52,\n                mask == (1u64 << 52) - 1,\n        ;\n        assert(difference_after_loop1.limbs[i as int] == difference.limbs[i as int]);\n        assert(forall|j: int|\n            0 <= j < 5 ==> difference_after_loop1.limbs[j] == difference.limbs[j]);\n        assert(difference_after_loop1.limbs == difference.limbs);\n    }\n    if borrow >> 63 == 1 {\n        // When underflow, addend = L.limbs[i]\n        assert(addend == constants::L.limbs[i as int]);\n        // carry = (old_carry >> 52) + difference_after_loop1.limbs[i] + L.limbs[i]\n        // difference.limbs[i] = carry & mask\n        calc! {\n            (==)\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(\n                constants::L.limbs@.subrange(0, i + 1),\n            ); {\n                lemma_seq_u64_to_nat_subrange_extend(difference_after_loop1.limbs@, i as int);\n                lemma_seq_u64_to_nat_subrange_extend(constants::L.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int))\n                + difference_after_loop1.limbs[i as int] as nat * pow2(52 * i as nat)\n                + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int))\n                + constants::L.limbs[i as int] as nat * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n                constants::L.limbs@.subrange(0, i as int),\n            ) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                // Use invariant\n            }\n            seq_u64_to_nat(difference_loop2_start.limbs@.subrange(0, i as int)) + (old_carry\n                >> 52) as nat * pow2(52 * i as nat) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(difference_loop2_start.limbs@.subrange(0, i as int)\n                    == difference.limbs@.subrange(0, i as int));\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat\n                * pow2(52 * i as nat) + (difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((old_carry >> 52) as nat\n                + difference_after_loop1.limbs[i as int] as nat\n                + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(carry == (old_carry >> 52) + difference_after_loop1.limbs[i as int]\n                    + constants::L.limbs[i as int]);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + carry as nat * pow2(\n                52 * i as nat,\n            ); {\n                assert(carry == (carry >> 52) * (1u64 << 52) + (carry & mask)) by (bit_vector)\n                    requires\n                        mask == (1u64 << 52) - 1,\n                ;\n                assert(carry == (carry >> 52) * pow2(52) + difference.limbs[i as int]) by {\n                    lemma2_to64_rest();\n                    assert(0x10000000000000 == 1u64 << 52) by (compute_only);\n                };\n                assert(difference.limbs[i as int] == carry & mask);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((carry >> 52) as nat * pow2(\n                52,\n            ) + difference.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n                52,\n            ) * pow2(52 * i as nat) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                    broadcast use lemma_pow2_adds;\n\n                };\n                assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat\n                    * pow2(52 * (i + 1) as nat)) by {\n                    assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                    lemma_mul_is_associative(\n                        (carry >> 52) as int,\n                        pow2(52) as int,\n                        pow2(52 * i as nat) as int,\n                    );\n                };\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n                52 * (i + 1) as nat,\n            ) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (carry >> 52) as nat * pow2(\n                52 * (i + 1) as nat,\n            );\n        }\n    }\n}\n\n/// Proves that the addition loop maintains its invariant:\n/// a[0..i+1] + b[0..i+1] == sum[0..i+1] + (carry >> 52) * 2^(52*(i+1))\n/// See lemma_sub_loop1_invariant for more comments\npub proof fn lemma_add_loop_invariant(\n    sum: Scalar52,\n    carry: u64,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    old_carry: u64,\n    mask: u64,\n    sum_loop_start: Scalar52,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> sum.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) == seq_u64_to_nat(sum_loop_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) * pow2(\n            (52 * (i) as nat),\n        ),\n        sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int),\n        sum.limbs[i as int] == carry & mask,\n        carry == a.limbs[i as int] + b.limbs[i as int] + (old_carry >> 52),\n    ensures\n        seq_u64_to_nat(sum.limbs@.subrange(0, i + 1)) + (carry >> 52) * pow2((52 * (i + 1) as nat))\n            == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i + 1),\n        ),\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] as nat * pow2(\n            52 * i as nat,\n        ) + seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] as nat * pow2(\n            52 * i as nat,\n        ); {\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                a.limbs[i as int] as int,\n                b.limbs[i as int] as int,\n            );\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) + (a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(\n            52 * i as nat,\n        ) + (a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                (old_carry >> 52) as int,\n                (a.limbs[i as int] as nat + b.limbs[i as int] as nat) as int,\n            );\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + ((old_carry >> 52) as nat\n            + a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(carry == a.limbs[i as int] + b.limbs[i as int] + (old_carry >> 52));\n            assert(sum.limbs[i as int] == carry & mask);\n            // Decompose carry using the mask\n            lemma_decompose(carry, mask);\n            assert(carry == (carry >> 52) * pow2(52) + sum.limbs[i as int]);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + ((carry >> 52) as nat * pow2(52)\n            + sum.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                lemma_pow2_adds(52, 52 * i as nat);\n            };\n            assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                (carry >> 52) as nat * pow2(52) as int,\n                sum.limbs[i as int] as int,\n            );\n            assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat\n                * pow2(52 * (i + 1) as nat)) by {\n                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                lemma_mul_is_associative(\n                    (carry >> 52) as int,\n                    pow2(52) as int,\n                    pow2(52 * i as nat) as int,\n                );\n            };\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n            52 * (i + 1) as nat,\n        ) + sum.limbs[i as int] as nat * pow2(52 * i as nat); {\n            lemma_seq_u64_to_nat_subrange_extend(sum.limbs@, i as int);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i + 1)) + (carry >> 52) as nat * pow2(\n            (52 * (i + 1) as nat),\n        );\n    }\n}\n\n/// Get rid of the subranges from the invariant statement.\n/// Since a and b are less than group order, we can show that carry >> 52\n/// has to be 0, else the RHS is too large\npub proof fn lemma_add_sum_simplify(a: &Scalar52, b: &Scalar52, sum: &Scalar52, carry: u64)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        to_nat(&a.limbs) < group_order(),\n        to_nat(&b.limbs) < group_order(),\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n        (carry >> 52) < 2,\n        seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, 5 as int),\n        ) == seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) + (carry >> 52) as nat * pow2(\n            (52 * (5) as nat),\n        ),\n    ensures\n        to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs),\n{\n    // First establish the relationship between the different representations\n    assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs)) by {\n        assert(a.limbs@ == a.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(a.limbs@) == to_nat(&a.limbs));\n    }\n    assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs)) by {\n        assert(b.limbs@ == b.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(b.limbs@) == to_nat(&b.limbs));\n    }\n    assert(seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) == to_nat(&sum.limbs)) by {\n        assert(sum.limbs@ == sum.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(sum.limbs@) == to_nat(&sum.limbs));\n    }\n\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs) + (carry >> 52) * pow2(\n        (52 * (5) as nat),\n    ));\n\n    // From the loop invariant, we have: a + b == sum + (carry >> 52) * 2^260\n    assert(52 * 5 == 260) by (compute);\n    assert(pow2((52 * 5) as nat) == pow2(260));\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(\n        260,\n    ));\n\n    // Since a < group_order() and b < group_order(), we have a + b < 2 * group_order()\n    // This is just basic arithmetic: if x < A and y < A, then x + y < A + A = 2*A\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) < group_order() + group_order());\n    assert(group_order() + group_order() == 2 * group_order());\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) < 2 * group_order());\n\n    // Therefore: sum + (carry >> 52) * 2^260 < 2 * group_order()\n    assert(to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260) < 2 * group_order());\n\n    // Prove a contradiction if carry is nonzero\n    assert((carry >> 52) as nat * pow2(260) < 2 * group_order());\n    if carry >> 52 == 1 {\n        lemma_pow2_260_greater_than_2_group_order();\n        assert(1 as nat * pow2(260) < 2 * group_order());\n        assert(false);\n    }\n    assert(carry >> 52 == 0);\n\n    // Since carry >> 52 >= 0 and pow2(260) > 0, we have (carry >> 52) * pow2(260) >= 0\n    // Therefore sum < sum + (carry >> 52) * pow2(260) < 2 * group_order()\n    lemma_pow2_pos(260);\n    assert(pow2(260) > 0);\n    assert((carry >> 52) as nat * pow2(260) >= 0);\n    assert(to_nat(&sum.limbs) <= to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260));\n    assert(to_nat(&sum.limbs) < 2 * group_order());\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_mod_diff_factor().",
      "display_name": "lemma_mod_diff_factor",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_mod_diff_factor().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "use crate::backend::serial::u64::field_lemmas::compute_q_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::field_core::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::from_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::limbs_to_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::load8_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::negate_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2_51_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "display_name": "group_order",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar_helpers.rs",
      "relative_path": "src/scalar_helpers.rs",
      "file_name": "scalar_helpers.rs",
      "parent_folder": "src",
      "body": "                n == scalars.len(),\n                scalar_to_nat(&acc) < group_order(),\n                // acc represents the sum of scalars[0..i]\n                scalar_congruent_nat(&acc, sum_of_scalars(scalars@.subrange(0, i as int))),\n        {\n            proof {\n                // Assume preconditions for addition are satisfied\n                assume(false);\n            }\n            acc = &acc + &scalars[i];\n\n            proof {\n                // Assume the result maintains the invariant\n                assume(scalar_to_nat(&acc) < group_order());\n                assume(scalar_congruent_nat(\n                    &acc,\n                    sum_of_scalars(scalars@.subrange(0, (i + 1) as int)),\n                ));\n            }\n        }",
      "is_libsignal": false,
      "caller_count": 45,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_times_pow2_fits_u64().",
      "display_name": "u8_times_pow2_fits_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_times_pow2_fits_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "        assert(pow2(8 * k) <= 0x100000000000000) by {\n            if (k < 7) {\n                lemma_pow2_strictly_increases(k * 8, 56);\n            }\n            lemma2_to64_rest();\n        }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb2_byte_contribution().",
      "display_name": "limb2_byte_contribution",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb2_byte_contribution().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/limbs_to_bytes_lemmas.rs",
      "file_name": "limbs_to_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "spec fn limb2_byte_contribution(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    // Byte 12 high 2 bits (limbs[2]'s bits 0-1)\n    ((limbs[2] as nat % pow2(2)) * pow2(6)) * pow2(12 * 8) + bytes[13] as nat * pow2(13 * 8)\n        + bytes[14] as nat * pow2(14 * 8) + bytes[15] as nat * pow2(15 * 8) + bytes[16] as nat\n        * pow2(16 * 8) + bytes[17] as nat * pow2(17 * 8) + bytes[18] as nat * pow2(18 * 8)\n        +\n    // Byte 19 low 1 bit (limbs[2]'s bit 50)\n    ((limbs[2] as nat / pow2(50)) % 2) * pow2(19 * 8)\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness_52().",
      "display_name": "lemma_limb4_contribution_correctness_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub proof fn lemma_limb4_contribution_correctness_52(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[4] < (1u64 << 52),\n        bytes_match_limbs_packing_52(limbs, bytes),\n    ensures\n        limb4_byte_contribution_52(limbs, bytes) == (limbs[4] as nat) * pow2(208),\n{\n    // Paper proof:\n    // Limb 4 occupies bytes 26-31 (no boundary!) at position 2^208\n    // From the packing predicate: bytes[26..31] = limbs[4] >> 0, 8, 16, 24, 32, 40\n    // Therefore: bytes reconstruct limbs[4]\n    // And: limb4_contribution = Σ bytes[i] * 2^(i*8) = limbs[4] * 2^208\n    lemma2_to64();\n    shift_is_pow2(52);\n\n    // Step 1: Show bytes 26-31 encode limbs[4] using byte-shift arithmetic\n    shr_zero_is_id(limbs[4]);\n    lemma_byte_from_limb_shift_52(limbs[4], 0, bytes[26]);\n    lemma_byte_from_limb_shift_52(limbs[4], 8, bytes[27]);\n    lemma_byte_from_limb_shift_52(limbs[4], 16, bytes[28]);\n    lemma_byte_from_limb_shift_52(limbs[4], 24, bytes[29]);\n    lemma_byte_from_limb_shift_52(limbs[4], 32, bytes[30]);\n    lemma_byte_from_limb_shift_52(limbs[4], 40, bytes[31]);\n\n    // TODO: Prove limbs[4] < 2^48\n    //\n    // This bound is required because 6 bytes can only represent 48 bits.\n    // The structural constraint for 256-bit scalars is that limb 4 occupies\n    // only 48 bits (256 - 4*52 = 48), not the full 52 bits.\n    //\n    // However, scalar arithmetic operations use a 52-bit mask for all limbs,\n    // so this bound is not maintained by the implementation.\n    // See docs_22_oct/scalar_limb4_bound_issue.md for details.\n    //\n    // This assume is sound because:\n    // - The packing predicate guarantees bytes 26-31 encode limbs[4]\n    // - 6 bytes can only represent values < 2^48\n    // - Therefore limbs[4] must be < 2^48\n    // But we cannot formally derive this from the current preconditions.\n    assume(limbs[4] < pow2(48));\n\n    // Apply 6-byte reconstruction: bytes[26..31] = limbs[4]\n    lemma_6_bytes_reconstruct(\n        limbs[4] as nat,\n        bytes[26],\n        bytes[27],\n        bytes[28],\n        bytes[29],\n        bytes[30],\n        bytes[31],\n    );\n    let bytes_sum = bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat\n        * pow2(16) + bytes[29] as nat * pow2(24) + bytes[30] as nat * pow2(32) + bytes[31] as nat\n        * pow2(40);\n\n    assert(bytes_sum * pow2(208) == limbs[4] as nat * pow2(208));\n\n    assert(bytes_sum * pow2(208) == (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8)\n        + bytes[28] as nat * pow2(16) + bytes[29] as nat * pow2(24) + bytes[30] as nat * pow2(32)\n        + bytes[31] as nat * pow2(40)) * pow2(208));\n\n    assert((bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat * pow2(16)\n        + bytes[29] as nat * pow2(24) + bytes[30] as nat * pow2(32) + bytes[31] as nat * pow2(40))\n        * pow2(208) == (bytes[26] as nat * pow2(0) * pow2(208) + bytes[27] as nat * pow2(8) * pow2(\n        208,\n    ) + bytes[28] as nat * pow2(16) * pow2(208) + bytes[29] as nat * pow2(24) * pow2(208)\n        + bytes[30] as nat * pow2(32) * pow2(208) + bytes[31] as nat * pow2(40) * pow2(208))) by {\n        // Distribute pow2(208) across the sum using repeated application of distributivity\n        lemma_mul_is_distributive_add(\n            pow2(208) as int,\n            (bytes[26] as nat * pow2(0)) as int,\n            (bytes[27] as nat * pow2(8)) as int,\n        );\n        lemma_mul_is_distributive_add(\n            pow2(208) as int,\n            (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8)) as int,\n            (bytes[28] as nat * pow2(16)) as int,\n        );\n        lemma_mul_is_distributive_add(\n            pow2(208) as int,\n            (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat * pow2(\n                16,\n            )) as int,\n            (bytes[29] as nat * pow2(24)) as int,\n        );\n        lemma_mul_is_distributive_add(\n            pow2(208) as int,\n            (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat * pow2(16)\n                + bytes[29] as nat * pow2(24)) as int,\n            (bytes[30] as nat * pow2(32)) as int,\n        );\n        lemma_mul_is_distributive_add(\n            pow2(208) as int,\n            (bytes[26] as nat * pow2(0) + bytes[27] as nat * pow2(8) + bytes[28] as nat * pow2(16)\n                + bytes[29] as nat * pow2(24) + bytes[30] as nat * pow2(32)) as int,\n            (bytes[31] as nat * pow2(40)) as int,\n        );\n    };\n\n    assert((bytes[26] as nat * pow2(0) * pow2(208) + bytes[27] as nat * pow2(8) * pow2(208)\n        + bytes[28] as nat * pow2(16) * pow2(208) + bytes[29] as nat * pow2(24) * pow2(208)\n        + bytes[30] as nat * pow2(32) * pow2(208) + bytes[31] as nat * pow2(40) * pow2(208)) == (\n    bytes[26] as nat * pow2(208) + bytes[27] as nat * pow2(216) + bytes[28] as nat * pow2(224)\n        + bytes[29] as nat * pow2(232) + bytes[30] as nat * pow2(240) + bytes[31] as nat * pow2(\n        248,\n    ))) by {\n        lemma_mul_is_associative(bytes[26] as int, pow2(0) as int, pow2(208) as int);\n        lemma_mul_is_associative(bytes[27] as int, pow2(8) as int, pow2(208) as int);\n        lemma_mul_is_associative(bytes[28] as int, pow2(16) as int, pow2(208) as int);\n        lemma_mul_is_associative(bytes[29] as int, pow2(24) as int, pow2(208) as int);\n        lemma_mul_is_associative(bytes[30] as int, pow2(32) as int, pow2(208) as int);\n        lemma_mul_is_associative(bytes[31] as int, pow2(40) as int, pow2(208) as int);\n\n        lemma_pow2_adds(0, 208);  // pow2(0) * pow2(208) = pow2(208)\n        lemma_pow2_adds(8, 208);  // pow2(8) * pow2(208) = pow2(216)\n        lemma_pow2_adds(16, 208);  // pow2(16) * pow2(208) = pow2(224)\n        lemma_pow2_adds(24, 208);  // pow2(24) * pow2(208) = pow2(232)\n        lemma_pow2_adds(32, 208);  // pow2(32) * pow2(208) = pow2(240)\n        lemma_pow2_adds(40, 208);\n    };\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_identity().",
      "display_name": "is_identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/curve_specs.rs",
      "relative_path": "src/curve_specs.rs",
      "file_name": "curve_specs.rs",
      "parent_folder": "src",
      "body": "pub open spec fn is_identity(point: crate::edwards::EdwardsPoint) -> bool {\n    let x = field_element(&point.X);\n    let y = field_element(&point.Y);\n    let z = field_element(&point.Z);\n\n    z != 0 && x == 0 && y == z\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#map().",
      "display_name": "map",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#map().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#create().",
      "display_name": "create",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#create().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_loop_invariant().",
      "display_name": "lemma_add_loop_invariant",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_loop_invariant().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_add_loop_invariant(\n    sum: Scalar52,\n    carry: u64,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    old_carry: u64,\n    mask: u64,\n    sum_loop_start: Scalar52,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> sum.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) == seq_u64_to_nat(sum_loop_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) * pow2(\n            (52 * (i) as nat),\n        ),\n        sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int),\n        sum.limbs[i as int] == carry & mask,\n        carry == a.limbs[i as int] + b.limbs[i as int] + (old_carry >> 52),\n    ensures\n        seq_u64_to_nat(sum.limbs@.subrange(0, i + 1)) + (carry >> 52) * pow2((52 * (i + 1) as nat))\n            == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i + 1),\n        ),\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] as nat * pow2(\n            52 * i as nat,\n        ) + seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] as nat * pow2(\n            52 * i as nat,\n        ); {\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                a.limbs[i as int] as int,\n                b.limbs[i as int] as int,\n            );\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) + (a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(\n            52 * i as nat,\n        ) + (a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                (old_carry >> 52) as int,\n                (a.limbs[i as int] as nat + b.limbs[i as int] as nat) as int,\n            );\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + ((old_carry >> 52) as nat\n            + a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(carry == a.limbs[i as int] + b.limbs[i as int] + (old_carry >> 52));\n            assert(sum.limbs[i as int] == carry & mask);\n            // Decompose carry using the mask\n            lemma_decompose(carry, mask);\n            assert(carry == (carry >> 52) * pow2(52) + sum.limbs[i as int]);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + ((carry >> 52) as nat * pow2(52)\n            + sum.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                lemma_pow2_adds(52, 52 * i as nat);\n            };\n            assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n            lemma_mul_is_distributive_add_other_way(\n                pow2(52 * i as nat) as int,\n                (carry >> 52) as nat * pow2(52) as int,\n                sum.limbs[i as int] as int,\n            );\n            assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat\n                * pow2(52 * (i + 1) as nat)) by {\n                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                lemma_mul_is_associative(\n                    (carry >> 52) as int,\n                    pow2(52) as int,\n                    pow2(52 * i as nat) as int,\n                );\n            };\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(\n            52 * (i + 1) as nat,\n        ) + sum.limbs[i as int] as nat * pow2(52 * i as nat); {\n            lemma_seq_u64_to_nat_subrange_extend(sum.limbs@, i as int);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i + 1)) + (carry >> 52) as nat * pow2(\n            (52 * (i + 1) as nat),\n        );\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_q_spec().",
      "display_name": "compute_q_spec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_q_spec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_general().",
      "display_name": "pow2_mul_general",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_general().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "    //   + q2*2^51*2^102 + r2*2^102 - q1*2^102\n    //   + q3*2^51*2^153 + r3*2^153 - q2*2^153\n    //   + q4*2^51*2^204 + r4*2^204 - q3*2^204\n    //   + 19\n\n    // Use the power relationships to simplify products\n    assert(q1 * pow2(51) as int * pow2(51) as int == q1 * pow2(102) as int) by {\n        lemma_mul_is_associative(q1, pow2(51) as int, pow2(51) as int);\n    }",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/bits_to_nat_rec().",
      "display_name": "bits_to_nat_rec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/bits_to_nat_rec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar_specs.rs",
      "relative_path": "src/scalar_specs.rs",
      "file_name": "scalar_specs.rs",
      "parent_folder": "src",
      "body": "pub open spec fn bits_to_nat_rec(bits: &[bool; 256], index: int) -> nat\n    decreases 256 - index,\n{\n    if index >= 256 {\n        0\n    } else {\n        let bit_value = if bits[index] {\n            1nat\n        } else {\n            0nat\n        };\n        bit_value * pow2(index as nat) + bits_to_nat_rec(bits, index + 1)\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_basic_div().",
      "display_name": "lemma_basic_div",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_basic_div().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "display_name": "square",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "//             CompressedRistretto([\n//                 208, 120, 140, 129, 177, 179, 237, 159, 252, 160, 28, 13, 206, 5, 211, 241, 192,\n//                 218, 1, 97, 130, 241, 20, 169, 119, 46, 246, 29, 79, 80, 77, 84,\n//             ]),\n//             CompressedRistretto([\n//                 202, 11, 236, 145, 58, 12, 181, 157, 209, 6, 213, 88, 75, 147, 11, 119, 191, 139,\n//                 47, 142, 33, 36, 153, 193, 223, 183, 178, 8, 205, 120, 248, 110,\n//             ]),\n//             CompressedRistretto([\n//                 26, 66, 231, 67, 203, 175, 116, 130, 32, 136, 62, 253, 215, 46, 5, 214, 166, 248,\n//                 108, 237, 216, 71, 244, 173, 72, 133, 82, 6, 143, 240, 104, 41,\n//             ]),\n//             CompressedRistretto([\n//                 40, 157, 102, 96, 201, 223, 200, 197, 150, 181, 106, 83, 103, 126, 143, 33, 145,\n//                 230, 78, 6, 171, 146, 210, 143, 112, 5, 245, 23, 183, 138, 18, 120,\n//             ]),\n//             CompressedRistretto([\n//                 220, 37, 27, 203, 239, 196, 176, 131, 37, 66, 188, 243, 185, 250, 113, 23, 167,\n//                 211, 154, 243, 168, 215, 54, 171, 159, 36, 195, 81, 13, 150, 43, 43,\n//             ]),\n//             CompressedRistretto([\n//                 232, 121, 176, 222, 183, 196, 159, 90, 238, 193, 105, 52, 101, 167, 244, 170, 121,\n//                 114, 196, 6, 67, 152, 80, 185, 221, 7, 83, 105, 176, 208, 224, 121,\n//             ]),\n//             CompressedRistretto([\n//                 226, 181, 183, 52, 241, 163, 61, 179, 221, 207, 220, 73, 245, 242, 25, 236, 67, 84,\n//                 179, 222, 167, 62, 167, 182, 32, 9, 92, 30, 165, 127, 204, 68,\n//             ]),\n//             CompressedRistretto([\n//                 226, 119, 16, 242, 200, 139, 240, 87, 11, 222, 92, 146, 156, 243, 46, 119, 65, 59,\n//                 1, 248, 92, 183, 50, 175, 87, 40, 206, 53, 208, 220, 148, 13,\n//             ]),\n//             CompressedRistretto([\n//                 70, 240, 79, 112, 54, 157, 228, 146, 74, 122, 216, 88, 232, 62, 158, 13, 14, 146,\n//                 115, 117, 176, 222, 90, 225, 244, 23, 94, 190, 150, 7, 136, 96,\n//             ]),\n//             CompressedRistretto([\n//                 22, 71, 241, 103, 45, 193, 195, 144, 183, 101, 154, 50, 39, 68, 49, 110, 51, 44,\n//                 62, 0, 229, 113, 72, 81, 168, 29, 73, 106, 102, 40, 132, 24,\n//             ]),\n//             CompressedRistretto([\n//                 196, 133, 107, 11, 130, 105, 74, 33, 204, 171, 133, 221, 174, 193, 241, 36, 38,\n//                 179, 196, 107, 219, 185, 181, 253, 228, 47, 155, 42, 231, 73, 41, 78,\n//             ]),\n//             CompressedRistretto([\n//                 58, 255, 225, 197, 115, 208, 160, 143, 39, 197, 82, 69, 143, 235, 92, 170, 74, 40,\n//                 57, 11, 171, 227, 26, 185, 217, 207, 90, 185, 197, 190, 35, 60,\n//             ]),\n//             CompressedRistretto([\n//                 88, 43, 92, 118, 223, 136, 105, 145, 238, 186, 115, 8, 214, 112, 153, 253, 38, 108,\n//                 205, 230, 157, 130, 11, 66, 101, 85, 253, 110, 110, 14, 148, 112,\n//             ]),\n//         ];\n//         for i in 0..16 {\n//             let r_0 = FieldElement::from_bytes(&bytes[i]);\n//             let Q = RistrettoPoint::elligator_ristretto_flavor(&r_0);\n//             assert_eq!(Q.compress(), encoded_images[i]);\n//         }",
      "is_libsignal": false,
      "caller_count": 14,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#from_slice().",
      "display_name": "from_slice",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#from_slice().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn from_slice(bytes: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        bytes.try_into().map(CompressedRistretto)\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#ConditionallySelectable#conditional_select().",
      "display_name": "conditional_select",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#ConditionallySelectable#conditional_select().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn conditional_select(\n        a: &RistrettoPoint,\n        b: &RistrettoPoint,\n        choice: Choice,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::conditional_select(&a.0, &b.0, choice))\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "display_name": "batch_invert",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    ///\n    /// # Errors\n    ///\n    /// Returns [`TryFromSliceError`] if the input `bytes` slice does not have\n    /// a length of 32.\n    pub fn from_slice(bytes: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        bytes.try_into().map(CompressedRistretto)\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_times_pow2_mod_is_id().",
      "display_name": "u8_times_pow2_mod_is_id",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_times_pow2_mod_is_id().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/pow_lemmas.rs",
      "file_name": "pow_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "pub proof fn u8_times_pow2_mod_is_id(a: u8, k: nat, s: nat)\n    requires\n        k + 8 <= s,\n    ensures\n        (pow2(k) * a) as nat % pow2(s) == pow2(k) * a,\n{\n    assert(pow2(k) * a < pow2(k + 8)) by {\n        pow2_mul_u8(a, k);\n    }\n    if (k + 8 < s) {\n        assert(pow2(k + 8) < pow2(s)) by {\n            lemma_pow2_strictly_increases(k + 8, s);\n        }\n    }\n    assert(pow2(s) > 0) by {\n        lemma_pow2_pos(s);\n    }\n\n    assert((pow2(k) * a) as nat % pow2(s) == pow2(k) * a) by {\n        lemma_small_mod((pow2(k) * a) as nat, pow2(s));\n    }\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"EdwardsPoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?},\\n\\tT: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z, &self.T\n        )\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "display_name": "load8_at_spec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 17,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c2_0_val().",
      "display_name": "c2_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c2_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "display_name": "from",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "            fn from(P: &'a RistrettoPoint) -> BatchCompressState {\n                let XX = P.0.X.square();\n                let YY = P.0.Y.square();\n                let ZZ = P.0.Z.square();\n                let dTT = &P.0.T.square() * &constants::EDWARDS_D;\n\n                let e = &P.0.X * &(&P.0.Y + &P.0.Y); // = 2*X*Y\n                let f = &ZZ + &dTT;                  // = Z^2 + d*T^2\n                let g = &YY + &XX;                   // = Y^2 - a*X^2\n                let h = &ZZ - &dTT;                  // = Z^2 - d*T^2\n\n                let eg = &e * &g;\n                let fh = &f * &h;\n\n                BatchCompressState{ e, f, g, h, eg, fh }\n            }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_neg().",
      "display_name": "field_neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/curve_specs.rs",
      "relative_path": "src/curve_specs.rs",
      "file_name": "curve_specs.rs",
      "parent_folder": "src",
      "body": "    z != 0 &&\n    // The affine coordinates (X/Z, Y/Z) must be on the curve\n    on_edwards_curve(field_mul(x, field_inv(z)), field_mul(y, field_inv(z)))\n        &&\n    // Extended coordinate must satisfy T = X*Y/Z\n    t == field_mul(field_mul(x, y), field_inv(z))\n}\n\n/// Returns the abstract affine coordinates (x, y) of this point.\npub open spec fn affine_coords(point: crate::edwards::EdwardsPoint) -> (nat, nat) {\n    let x_abs = field_element(&point.X);\n    let y_abs = field_element(&point.Y);\n    let z_abs = field_element(&point.Z);\n    let z_inv = field_inv(z_abs);\n    (field_mul(x_abs, z_inv), field_mul(y_abs, z_inv))\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/montgomery_radix().",
      "display_name": "montgomery_radix",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/montgomery_radix().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "use rand_core::RngCore;\n\n#[cfg(any(test, feature = \"rand_core\"))]\nuse rand_core::CryptoRngCore;\n// From a conflict:\n//use rand_core::{CryptoRng, RngCore};\n",
      "is_libsignal": false,
      "caller_count": 7,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/verify_invert_correct().",
      "display_name": "verify_invert_correct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/verify_invert_correct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "proof fn verify_invert_correct(\n    x: Scalar52,\n)\n//     requires to_scalar(&x.limbs) != 0\n//    ensures (to_scalar(&x.limbs) * invert_spec(&x.limbs)) % group_order() == 1\n{\n    assume(false);\n\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/five_limbs_to_nat_aux().",
      "display_name": "five_limbs_to_nat_aux",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/five_limbs_to_nat_aux().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "}\n\npub proof fn lemma_52_52(x: u64, y: u64)\n    requires\n        x < (1u64 << 52),\n        y < (1u64 << 52),\n    ensures\n        (x as u128) * (y as u128) < (1u128 << 104),\n{\n    assert(1u128 << 52 == 1u64 << 52) by (bit_vector);\n    calc! {\n        (<)\n        (x as u128) * (y as u128); (<=) {\n            if x > 0 {\n                lemma_mul_strict_inequality(y as int, (1u128 << 52) as int, x as int);\n                assert(x * y < x * (1u128 << 52));\n            } else {\n                assert((0 as u128) * (y as u128) == 0);\n            }\n        }\n        (x as u128) * (1u128 << 52); (<) {\n            lemma_mul_strict_inequality(x as int, (1u128 << 52) as int, (1u128 << 52) as int);\n        }\n        (1u128 << 52) * (1u128 << 52);\n    }\n    assert((1u128 << 52) * (1u128 << 52) == (1u128 << 104)) by (compute);\n}",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/BasepointTable#create().",
      "display_name": "create",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/BasepointTable#create().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/traits.rs",
      "relative_path": "src/traits.rs",
      "file_name": "traits.rs",
      "parent_folder": "src",
      "body": "    fn create(basepoint: &Self::Point) -> Self;\n\n    /// Retrieve the original basepoint from this table.\n    fn basepoint(&self) -> Self::Point;\n\n    /// Multiply a `scalar` by this precomputed basepoint table, in constant time.\n    fn mul_base(&self, scalar: &Scalar) -> Self::Point;\n\n    /// Multiply `clamp_integer(bytes)` by this precomputed basepoint table, in constant time. For\n    /// a description of clamping, see [`clamp_integer`].\n    fn mul_base_clamped(&self, bytes: [u8; 32]) -> Self::Point {\n        // Basepoint multiplication is defined for all values of `bytes` up to and including\n        // 2^255 - 1. The limit comes from the fact that scalar.as_radix_16() doesn't work for\n        // most scalars larger than 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        self.mul_base(&s)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow2_plus_one().",
      "display_name": "lemma_pow2_plus_one",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow2_plus_one().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/reduce_lemmas.rs",
      "file_name": "reduce_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "    shifted_lt(limbs[3], 51);\n    shifted_lt(limbs[4], 51);\n\n    // \\A i. limbs[i] & mask51 < 2^51\n    masked_lt_51(limbs[0]);\n    masked_lt_51(limbs[1]);\n    masked_lt_51(limbs[2]);\n    masked_lt_51(limbs[3]);\n    masked_lt_51(limbs[4]);\n\n    // Since 19 < 2^5 and (limbs[4] >> 51) < 2^13, their product is less than 2^18\n    assert((limbs[4] >> 51) * 19 < (1u64 << 18) as nat) by {\n        assert(19 < (1u64 << 5)) by (bit_vector);\n        shift_is_pow2(5);\n        shift_is_pow2(13);\n        shift_is_pow2(18);\n        lemma_pow2_adds(13, 5);\n        // If (limbs[4] >> 51) < 2^13 and 19 < 2^5 then their product is less than 2^18\n        mul_lt((limbs[4] >> 51) as nat, (1u64 << 13) as nat, 19nat, (1u64 << 5) as nat);\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "display_name": "test_elligator_inv",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    fn test_elligator_inv() {\n        let mut rng = rand::thread_rng();\n\n        for i in 0..100 {\n            let mut fe_bytes = [0u8; 32];\n\n            if i == 0 {\n                // Test for first corner-case: fe = 0\n                fe_bytes = [0u8; 32];\n            } else if i == 1 {\n                // Test for second corner-case: fe = +sqrt(i*d)\n                fe_bytes = [\n                    168, 27, 92, 74, 203, 42, 48, 117, 170, 109, 234, 14, 45, 169, 188, 205, 21,\n                    110, 235, 115, 153, 84, 52, 117, 151, 235, 123, 244, 88, 85, 179, 5,\n                ];\n            } else {\n                // For the rest, just generate a random field element to test.\n                rng.fill_bytes(&mut fe_bytes);\n            }\n            fe_bytes[0] &= 254; // positive\n            fe_bytes[31] &= 127; // < 2^255-19\n            let fe = FieldElement::from_bytes(&fe_bytes);\n\n            let pt = RistrettoPoint::elligator_ristretto_flavor(&fe);\n            for pt2 in &pt.xcoset4() {\n                let (mask, fes) = RistrettoPoint(*pt2).elligator_ristretto_flavor_inverse();\n\n                let mut found = false;\n                for (j, fe_j) in fes.iter().enumerate() {\n                    if mask & (1 << j) != 0 {\n                        assert_eq!(RistrettoPoint::elligator_ristretto_flavor(fe_j), pt);\n                        if *fe_j == fe {\n                            found = true;\n                        }\n                    }\n                }\n                assert!(found);\n            }\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from8().",
      "display_name": "seq_from8",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from8().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub open spec fn seq_from8(b: &[u8; 8]) -> Seq<u8> {\n    Seq::new(8, |i: int| b[i])\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Debug#fmt().",
      "display_name": "fmt",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Debug#fmt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
      "relative_path": "src/backend/serial/curve_models/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "curve_models",
      "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"ProjectiveNielsPoint{{\\n\\tY_plus_X: {:?},\\n\\tY_minus_X: {:?},\\n\\tZ: {:?},\\n\\tT2d: {:?}\\n}}\",\n               &self.Y_plus_X, &self.Y_minus_X, &self.Z, &self.T2d)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_sum().",
      "display_name": "pow2_sum",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_sum().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "display_name": "lemma_fundamental_div_mod",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 26,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#invert().",
      "display_name": "invert",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#invert().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    pub fn invert(&self) -> (result: Scalar)\n        requires\n            is_canonical_scalar(self),\n        ensures\n    // Result is the multiplicative inverse: result * self ≡ 1 (mod group_order)\n\n            (scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1,\n            is_canonical_scalar(\n                &result,\n            ),\n    // VERIFICATION NOTE: is this true and/or necessary?\n    // Result is canonical\n    // scalar_to_nat(&result) < group_order(),\n    // result.bytes[31] <= 127,\n\n    {\n        let unpacked = self.unpack();\n        let inv_unpacked = unpacked.invert();\n        let result = inv_unpacked.pack();\n        assert((scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1);\n        assume(is_canonical_scalar(&result));\n        result\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#ConstantTimeEq#ct_eq().",
      "display_name": "ct_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#ConstantTimeEq#ct_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn ct_eq(&self, other: &CompressedRistretto) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_div_and_mod_51().",
      "display_name": "lemma_div_and_mod_51",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_div_and_mod_51().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub_new().",
      "display_name": "sub_new",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub_new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub fn sub_new(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n        requires\n            limbs_bounded(a),\n            limbs_bounded(b),\n            -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order(),\n        ensures\n            to_nat(&s.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int),\n    {\n        assume(false);  // TODO: complete the proof\n        let mut difference = Scalar52::ZERO;\n        let mask = (1u64 << 52) - 1;\n\n        // a - b\n        let mut borrow: u64 = 0;\n        for i in 0..5 {\n            assume(false);\n            borrow = a.limbs[i].wrapping_sub(b.limbs[i] + (borrow >> 63));\n            difference[i] = borrow & mask;\n        }\n\n        // conditionally add l if the difference is negative\n        difference.conditional_add_l(Choice::from((borrow >> 63) as u8));\n        difference\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#ConstantTimeEq#ct_eq().",
      "display_name": "ct_eq",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#ConstantTimeEq#ct_eq().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/montgomery.rs",
      "relative_path": "src/montgomery.rs",
      "file_name": "montgomery.rs",
      "parent_folder": "src",
      "body": "    fn ct_eq(&self, other: &MontgomeryPoint) -> Choice {\n        let self_fe = FieldElement::from_bytes(&self.0);\n        let other_fe = FieldElement::from_bytes(&other.0);\n\n        self_fe.ct_eq(&other_fe)\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_value().",
      "display_name": "ct_option_value",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_value().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "use rand_core::RngCore;\n\n#[cfg(any(test, feature = \"rand_core\"))]\nuse rand_core::CryptoRngCore;\n// From a conflict:\n//use rand_core::{CryptoRng, RngCore};\n",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "display_name": "square_internal",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "body": "    pub(crate) fn square_internal(a: &Scalar52) -> (z: [u128; 9])\n        requires\n            limbs_bounded(a),\n        ensures\n            slice128_to_nat(&z) == to_nat(&a.limbs) * to_nat(&a.limbs),\n    {\n        proof { lemma_square_internal_no_overflow() }\n\n        let mut z = [0u128;9];\n        z[0] = m(a.limbs[0], a.limbs[0]);\n        z[1] = m(a.limbs[0], a.limbs[1]) * 2;\n        z[2] = m(a.limbs[0], a.limbs[2]) * 2 + m(a.limbs[1], a.limbs[1]);\n        z[3] = m(a.limbs[0], a.limbs[3]) * 2 + m(a.limbs[1], a.limbs[2]) * 2;\n        z[4] = m(a.limbs[0], a.limbs[4]) * 2 + m(a.limbs[1], a.limbs[3]) * 2 + m(\n            a.limbs[2],\n            a.limbs[2],\n        );\n        z[5] = m(a.limbs[1], a.limbs[4]) * 2 + m(a.limbs[2], a.limbs[3]) * 2;\n        z[6] = m(a.limbs[2], a.limbs[4]) * 2 + m(a.limbs[3], a.limbs[3]);\n        z[7] = m(a.limbs[3], a.limbs[4]) * 2;\n        z[8] = m(a.limbs[4], a.limbs[4]);\n\n        proof {\n            lemma_square_internal_correct(&a.limbs, &z);\n        }\n\n        z\n    }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/Mul#mul().",
      "display_name": "mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/Mul#mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn mul(self, basepoint_table: &'a RistrettoBasepointTable) -> RistrettoPoint {\n        RistrettoPoint(self * &basepoint_table.0)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Add#add().",
      "display_name": "add",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Add#add().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Neg#neg().",
      "display_name": "neg",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Neg#neg().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    fn neg(self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: -(&self.X),\n            Y: self.Y,\n            Z: self.Z,\n            T: -(&self.T),\n        }\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#unwrap().",
      "display_name": "unwrap",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#unwrap().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_carry_propagation_is_division().",
      "display_name": "lemma_reduction_carry_propagation_is_division",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_carry_propagation_is_division().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/to_bytes_reduction_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/to_bytes_reduction_lemmas.rs",
      "file_name": "to_bytes_reduction_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_reduction_carry_propagation_is_division(input_limbs: [u64; 5], q: u64, c4: u64)\n    requires\n        forall|i: int| 0 <= i < 5 ==> input_limbs[i] < (1u64 << 52),\n        q == 0 || q == 1,\n        c4 == ({\n            let l0 = (input_limbs[0] + 19 * q) as u64;\n            let l1 = (input_limbs[1] + (l0 >> 51)) as u64;\n            let l2 = (input_limbs[2] + (l1 >> 51)) as u64;\n            let l3 = (input_limbs[3] + (l2 >> 51)) as u64;\n            let l4 = (input_limbs[4] + (l3 >> 51)) as u64;\n            l4 >> 51\n        }),",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 11
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#hash_from_bytes().",
      "display_name": "hash_from_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#hash_from_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    pub fn hash_from_bytes<D>(input: &[u8]) -> RistrettoPoint\n    where\n        D: Digest<OutputSize = U64> + Default,\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        RistrettoPoint::from_hash(hash)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#new().",
      "display_name": "new",
      "symbol": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#new().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_unwrap().",
      "display_name": "ct_option_unwrap",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_unwrap().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "body": "pub fn ct_option_unwrap<T>(opt: CtOption<T>) -> (val: T)\n    requires\n        ct_option_has_value(opt),\n    ensures\n        val == ct_option_value(opt),\n{\n    opt.unwrap()\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_decompose().",
      "display_name": "lemma_decompose",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_decompose().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_decompose(a: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        a == (a >> 52) * pow2(52) + (a & mask),\n{\n    // First, establish that bit shifting is division by pow2(52)\n    broadcast use lemma_u64_shr_is_div;\n\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    lemma2_to64_rest();  // Establishes pow2(52) == 0x10000000000000\n    assert((1u64 << 52) == 0x10000000000000) by (bit_vector);\n    assert(pow2(52) == 0x10000000000000);\n    assert((1u64 << 52) as nat == pow2(52));\n\n    assert(a >> 52 == a / (1u64 << 52));\n\n    // Apply fundamental division theorem: a = q * d + r\n    lemma_fundamental_div_mod(a as int, pow2(52) as int);\n    let q = a as nat / pow2(52);\n    let r = a as nat % pow2(52);\n    assert(a as nat == q * pow2(52) + r);\n    assert(0 <= r < pow2(52));\n\n    // Now prove that (a & mask) == r\n    // mask is all 1s in the lower 52 bits\n    assert(mask == (1u64 << 52) - 1);\n\n    // Key insight: a & mask gives us the lower 52 bits, which is exactly a % pow2(52)\n    lemma_u64_low_bits_mask_is_mod(a, 52);\n    assert(a & mask == a % (1u64 << 52));\n    assert((a % (1u64 << 52)) as nat == a as nat % pow2(52));\n    assert((a & mask) as nat == r);\n\n    // Now show that a >> 52 == q\n    assert((a >> 52) as nat == a as nat / pow2(52));\n    assert((a >> 52) as nat == q);\n\n    // Combine everything\n    assert(a as nat == (a >> 52) as nat * pow2(52) + (a & mask) as nat);\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_wide_to_nat().",
      "display_name": "bytes_wide_to_nat",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_wide_to_nat().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "//! method.  In the case of the second example above, this would reduce the\n//! resultant scalar \\\\( \\mod \\ell \\\\), producing \\\\( 2 \\\\):\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let l_plus_two_bytes: [u8; 32] = [\n//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Scalar = Scalar::from_bytes_mod_order(l_plus_two_bytes);\n//!\n//! let two: Scalar = Scalar::ONE + Scalar::ONE;\n//!\n//! assert!(a == two);\n//! ```\n//!\n//! There is also a constructor that reduces a \\\\(512\\\\)-bit integer,\n//! [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! To construct a `Scalar` as the hash of some input data, use\n//! [`Scalar::hash_from_bytes`], which takes a buffer, or\n//! [`Scalar::from_hash`], which allows an IUF API.\n//!\n#![cfg_attr(feature = \"digest\", doc = \"```\")]\n#![cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n//! # fn main() {\n//! use sha2::{Digest, Sha512};\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! // Hashing a single byte slice\n//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_multiply_divide_lt().",
      "display_name": "lemma_multiply_divide_lt",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_multiply_divide_lt().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
      "file_name": "pow2_51_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#fold().",
      "display_name": "fold",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#fold().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_inv().",
      "display_name": "field_inv",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_inv().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/curve_specs.rs",
      "relative_path": "src/curve_specs.rs",
      "file_name": "curve_specs.rs",
      "parent_folder": "src",
      "body": "    let y_abs = field_element(&point.Y);\n    let z_abs = field_element(&point.Z);\n    let z_inv = field_inv(z_abs);\n    (field_mul(x_abs, z_inv), field_mul(y_abs, z_inv))\n}\n\n/// Spec: Check if a CompressedEdwardsY represents the identity point\n/// The identity point is (0, 1) in affine coordinates\n/// When compressed, this is represented as y=1 with sign bit 0\npub open spec fn is_compressed_identity(compressed: crate::edwards::CompressedEdwardsY) -> bool {\n    // Extract the y-coordinate (identity has y = 1)\n    field_element_from_bytes(&compressed.0) == 1\n        &&\n    // Sign bit should be 0 (since x = 0)\n    (compressed.0[31] >> 7) == 0\n}",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_add_no_overflow().",
      "display_name": "spec_add_no_overflow",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_add_no_overflow().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "\n#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\n#[allow(unused_imports)]\nuse vstd::arithmetic::div_mod::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::mul::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\n#[allow(unused_imports)]\nuse vstd::bits::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::bit_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::div_mod_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mask_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::mul_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::pow_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::common_verus::shift_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::as_nat_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::compute_q_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::field_core::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::from_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::limbs_to_bytes_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::load8_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::negate_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2_51_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::pow2k_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::reduce_lemmas::*;\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::field_lemmas::to_bytes_reduction_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n#[allow(unused_imports)]\nuse crate::field_specs::*;\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl Debug for FieldElement51 {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self)\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,\n    {\n        self.limbs.zeroize();\n    }\n}\n\n/* MANUALLY moved outside, named return value */\n\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i),\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n    (input[i] as u64) | ((input[i + 1] as u64) << 8) | ((input[i + 2] as u64) << 16) | ((input[i\n        + 3] as u64) << 24) | ((input[i + 4] as u64) << 32) | ((input[i + 5] as u64) << 40) | ((\n    input[i + 6] as u64) << 48) | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX,\n{\n    proof {\n        // if a <= a' and b <= b' then ab <= a'b'\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            spec_add_no_overflow(old(self), _rhs),\n        ensures\n            *self == spec_add_limbs(old(self), _rhs),\n            field_element(self) == spec_field_add(old(self), _rhs),\n    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic addition principles\n    open spec fn obeys_add_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of add\n    open spec fn add_req(self, rhs: &FieldElement51) -> bool {\n        spec_add_no_overflow(self, rhs)\n    }\n\n    // Postcondition of add - delegates to spec_add_limbs for consistency\n    open spec fn add_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_add_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn add(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_add_limbs(self, _rhs),\n            field_element(&output) == spec_field_add(self, _rhs),\n    {\n        let mut output = *self;\n        /* ORIGINAL CODE\n        output += _rhs;\n        */\n        /* MODIFIED CODE */\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> output.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> output.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            output.limbs[i] += _rhs.limbs[i];\n        }\n        /* </MODIFIED CODE> */\n        // Trigger the forall invariant\n        assert(output.limbs == [\n            (original_limbs[0] + _rhs.limbs[0]) as u64,\n            (original_limbs[1] + _rhs.limbs[1]) as u64,\n            (original_limbs[2] + _rhs.limbs[2]) as u64,\n            (original_limbs[3] + _rhs.limbs[3]) as u64,\n            (original_limbs[4] + _rhs.limbs[4]) as u64,\n        ]);\n        assume(field_element(&output) == (field_element(self) + field_element(_rhs)) % p());\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(\n        &mut self,\n        _rhs: &'a FieldElement51,\n    )\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        requires\n            limbs_bounded(old(self), 54) && limbs_bounded(_rhs, 54),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n            *self == spec_sub_limbs(old(self), _rhs),\n            field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)),\n    {\n        /* ORIGINAL CODE\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n        */\n        /* MODIFIED CODE */\n        let result = &*self - _rhs;\n        self.limbs = result.limbs;\n        proof {\n            // result satisfies sub_spec by the postcondition of sub\n            assert(result == spec_sub_limbs(old(self), _rhs));\n            // Therefore self.limbs equals spec_sub_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_sub_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == field_sub(field_element(old(self)), field_element(_rhs)));\n        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn sub(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            output == spec_sub_limbs(self, _rhs),\n            field_element(&output) == field_sub(field_element(self), field_element(_rhs)),\n    {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        //\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let output = FieldElement51::reduce(\n            [\n                (self.limbs[0] + 36028797018963664u64) - _rhs.limbs[0],\n                (self.limbs[1] + 36028797018963952u64) - _rhs.limbs[1],\n                (self.limbs[2] + 36028797018963952u64) - _rhs.limbs[2],\n                (self.limbs[3] + 36028797018963952u64) - _rhs.limbs[3],\n                (self.limbs[4] + 36028797018963952u64) - _rhs.limbs[4],\n            ],\n        );\n        assume(field_element(&output) == field_sub(field_element(self), field_element(_rhs)));\n        output\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        proof {\n            // PROOF BYPASS: Assume preconditions for Mul\n            // For Mul (self * rhs): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> _rhs.limbs[i] < (1u64 << 54));\n        }\n        let result = &*self * _rhs;\n        self.limbs = result.limbs;\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic multiplication principles\n    open spec fn obeys_mul_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of mul\n    open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < (1u64 << 54) && forall|i: int|\n                0 <= i < 5 ==> rhs.limbs[i] < (1u64 << 54)\n    }\n\n    // Postcondition of mul\n    open spec fn mul_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR mul RESULT\n        arbitrary()\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip]  // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_mul(field_element(self), field_element(_rhs)),\n    {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        // VERIFICATION NOTE: manually moved outside\n        // #[inline(always)]\n        // fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.limbs;\n        let b: &[u64; 5] = &_rhs.limbs;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        assume(false);  // PROOF BYPASS for arithmetic overflow\n        // Multiply to get 128-bit coefficients of output\n        let c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(\n            a[1],\n            b4_19,\n        );\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0], b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(\n            a[2],\n            b4_19,\n        );\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1], b[1]) + m(a[0], b[2]) + m(a[4], b3_19) + m(\n            a[3],\n            b4_19,\n        );\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2], b[1]) + m(a[1], b[2]) + m(a[0], b[3]) + m(\n            a[4],\n            b4_19,\n        );\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3], b[1]) + m(a[2], b[2]) + m(a[1], b[3]) + m(\n            a[0],\n            b[4],\n        );\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        #[cfg(not(verus_keep_ghost))]\n        {\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(b[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(b[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(b[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(b[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n            debug_assert!(b[4] < (1 << 54));\n        }\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined at module level\n        let mut out = [0u64;5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51 { limbs: out }\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &FieldElement51 {\n    // Does the implementation of this trait obey basic negation principles\n    // Set to false since we use arbitrary() as placeholder\n    open spec fn obeys_neg_spec() -> bool {\n        false\n    }\n\n    // Pre-condition of neg\n    open spec fn neg_req(self) -> bool {\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 51)\n    }\n\n    // Postcondition of neg\n    open spec fn neg_spec(self) -> FieldElement51 {\n        // VERIFICATION NOTE: WE DON'T PROVIDE A SPEC EXPRESSION FOR neg RESULT\n        arbitrary()\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n\n    fn neg(self) -> (output:\n        FieldElement51)/*  VERIFICATION NOTE:\n    - PROOF BYPASS\n    - REVIEW SPEC WHILE DOING THE PROOF\n    */\n\n        ensures\n            field_element(&output) == field_neg(field_element(self)),\n    {\n        let mut output = *self;\n        assume(forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 51));\n        output.negate();\n        assume(field_element(&output) == field_neg(field_element(self)));\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(a: &FieldElement51, b: &FieldElement51, choice: Choice) -> (result:\n        FieldElement51)\n        ensures\n    // If choice is false, return a\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == a.limbs[i]),\n            // If choice is true, return b\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] result.limbs[i] == b.limbs[i]),\n    {\n        FieldElement51 {\n            limbs: [\n                conditional_select_u64(&a.limbs[0], &b.limbs[0], choice),\n                conditional_select_u64(&a.limbs[1], &b.limbs[1], choice),\n                conditional_select_u64(&a.limbs[2], &b.limbs[2], choice),\n                conditional_select_u64(&a.limbs[3], &b.limbs[3], choice),\n                conditional_select_u64(&a.limbs[4], &b.limbs[4], choice),\n            ],\n        }\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, a and b remain unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(a).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(b).limbs[i]),\n            // If choice is true, a and b are swapped\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] a.limbs[i] == old(b).limbs[i]) && (forall|i: int|\n                0 <= i < 5 ==> #[trigger] b.limbs[i] == old(a).limbs[i]),\n    {\n        // Originally this was\n        // u64::conditional_swap(&mut a.limbs[0], &mut b.limbs[0], choice);\n        // But Verus doesn't support index for &mut\n        // Hence first do the indexing, then pass mut ref, then substitute back in\n        let mut a0 = a.limbs[0];\n        let mut b0 = b.limbs[0];\n        conditional_swap_u64(&mut a0, &mut b0, choice);\n        a.limbs[0] = a0;\n        b.limbs[0] = b0;\n\n        let mut a1 = a.limbs[1];\n        let mut b1 = b.limbs[1];\n        conditional_swap_u64(&mut a1, &mut b1, choice);\n        a.limbs[1] = a1;\n        b.limbs[1] = b1;\n\n        let mut a2 = a.limbs[2];\n        let mut b2 = b.limbs[2];\n        conditional_swap_u64(&mut a2, &mut b2, choice);\n        a.limbs[2] = a2;\n        b.limbs[2] = b2;\n\n        let mut a3 = a.limbs[3];\n        let mut b3 = b.limbs[3];\n        conditional_swap_u64(&mut a3, &mut b3, choice);\n        a.limbs[3] = a3;\n        b.limbs[3] = b3;\n\n        let mut a4 = a.limbs[4];\n        let mut b4 = b.limbs[4];\n        conditional_swap_u64(&mut a4, &mut b4, choice);\n        a.limbs[4] = a4;\n        b.limbs[4] = b4;\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n        ensures\n    // If choice is false, self remains unchanged\n\n            !choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n            // If choice is true, self is assigned from other\n            choice_is_true(choice) ==> (forall|i: int|\n                0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n    {\n        let mut self0 = self.limbs[0];\n        conditional_assign_u64(&mut self0, &other.limbs[0], choice);\n        self.limbs[0] = self0;\n\n        let mut self1 = self.limbs[1];\n        conditional_assign_u64(&mut self1, &other.limbs[1], choice);\n        self.limbs[1] = self1;\n\n        let mut self2 = self.limbs[2];\n        conditional_assign_u64(&mut self2, &other.limbs[2], choice);\n        self.limbs[2] = self2;\n\n        let mut self3 = self.limbs[3];\n        conditional_assign_u64(&mut self3, &other.limbs[3], choice);\n        self.limbs[3] = self3;\n\n        let mut self4 = self.limbs[4];\n        conditional_assign_u64(&mut self4, &other.limbs[4], choice);\n        self.limbs[4] = self4;\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from2().",
      "display_name": "seq_from2",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from2().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub open spec fn seq_from2(b: &[u8; 2]) -> Seq<u8> {\n    Seq::new(2, |i: int| b[i])\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "display_name": "from_bytes_wide",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "#[allow(unused_imports)]\nuse crate::backend::serial::u64::scalar_lemmas::*;\n\n#[allow(unused_imports)]\nuse crate::backend::serial::u64::subtle_assumes::*;\n\n#[allow(unused_imports)]\nuse crate::core_assumes::*;\n\n#[allow(unused_imports)]\nuse crate::scalar_specs::*;\n\n#[cfg(feature = \"digest\")]\n#[allow(unused_imports)]\nuse digest::Digest;\n\nverus! {\n\n/*** <VERIFICATION NOTE> Focus on u64; removed all other backend types </VERIFICATION NOTE> ***/\ntype UnpackedScalar = backend::serial::u64::scalar::Scalar52;\n\n/// The `Scalar` struct holds an element of \\\\(\\mathbb Z / \\ell\\mathbb Z \\\\).\n#[allow(clippy::derived_hash_with_manual_eq)]\n#[derive(Copy, Clone, Hash)]\npub struct Scalar {\n    /// `bytes` is a little-endian byte encoding of an integer representing a scalar modulo the\n    /// group order.\n    ///\n    /// # Invariant #1\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255}\\\\). That is, the most\n    /// significant bit of `bytes[31]` is 0.\n    ///\n    /// This is required for `EdwardsPoint` variable- and fixed-base multiplication, because most\n    /// integers above 2^255 are unrepresentable in our radix-16 NAF (see [`Self::as_radix_16`]).\n    /// The invariant is also required because our `MontgomeryPoint` multiplication assumes the MSB\n    /// is 0 (see `MontgomeryPoint::mul`).\n    ///\n    /// # Invariant #2 (weak)\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255} - 19 \\\\), i.e., it represents\n    /// a canonical representative of an element of \\\\( \\mathbb Z / \\ell\\mathbb Z \\\\). This is\n    /// stronger than invariant #1. It also sometimes has to be broken.\n    ///\n    /// This invariant is deliberately broken in the implementation of `EdwardsPoint::{mul_clamped,\n    /// mul_base_clamped}`, `MontgomeryPoint::{mul_clamped, mul_base_clamped}`, and\n    /// `BasepointTable::mul_base_clamped`. This is not an issue though. As mentioned above,\n    /// scalar-point multiplication is defined for any choice of `bytes` that satisfies invariant\n    /// #1. Since clamping guarantees invariant #1 is satisfied, these operations are well defined.\n    ///\n    /// Note: Scalar-point mult is the _only_ thing you can do safely with an unreduced scalar.\n    /// Scalar-scalar addition and subtraction are NOT correct when using unreduced scalars.\n    /// Multiplication is correct, but this is only due to a quirk of our implementation, and not\n    /// guaranteed to hold in general in the future.\n    ///\n    /// Note: It is not possible to construct an unreduced `Scalar` from the public API unless the\n    /// `legacy_compatibility` is enabled (thus making `Scalar::from_bits` public). Thus, for all\n    /// public non-legacy uses, invariant #2\n    /// always holds.\n    ///\n    /* <VERIFICATION NOTE>\n    Changed from pub(crate) to pub\n    </VERIFICATION NOTE> */\n    pub bytes: [u8; 32],/* <ORIGINAL CODE>\n    pub(crate) bytes: [u8; 32],\n    </ORIGINAL CODE> */\n}\n\n// This is a dummy function that we call from signal\n// to test that verus functions in libsignal know\n// about verus functions in curve-dalek\npub open spec fn is_a_scalar(s: Scalar) -> bool {\n    true\n}\n\nimpl Scalar {\n    /// Construct a `Scalar` by reducing a 256-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    // VERIFICATION NOTE: VERIFIED\n    pub fn from_bytes_mod_order(bytes: [u8; 32]) -> (result: Scalar)\n        ensures\n    // Result is equivalent to input modulo the group order\n\n            bytes_to_nat(&result.bytes) % group_order() == bytes_to_nat(&bytes) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        // Temporarily allow s_unreduced.bytes > 2^255 ...\n        let s_unreduced = Scalar { bytes };\n\n        // Then reduce mod the group order and return the reduced representative.\n        let s = s_unreduced.reduce();\n        /*** <VERIFICATION NOTE> We omit debug asserts from verification  </VERIFICATION NOTE> ***/\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }\n\n    /// Construct a `Scalar` by reducing a 512-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    // VERIFICATION NOTE: VERIFIED\n    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == bytes_wide_to_nat(input) % group_order(),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }\n\n    /// Attempt to construct a `Scalar` from a canonical byte representation.\n    ///\n    /// # Return\n    ///\n    /// - `Some(s)`, where `s` is the `Scalar` corresponding to `bytes`,\n    ///   if `bytes` is a canonical byte representation modulo the group order \\\\( \\ell \\\\);\n    /// - `None` if `bytes` is not a canonical byte representation.\n    /*\n    <VERIFICATION NOTE>\n      - Refactored to use wrapper functions instead of trait functions for ct_eq and ct_option_new\n      - Has proof bypass\n    </VERIFICATION NOTE> */\n    pub fn from_canonical_bytes(bytes: [u8; 32]) -> (result: CtOption<Scalar>)\n        ensures\n            bytes_to_nat(&bytes) < group_order() ==> ct_option_has_value(result),\n            bytes_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result),\n            ct_option_has_value(result) ==> bytes_to_nat(&ct_option_value(result).bytes)\n                % group_order() == bytes_to_nat(&bytes) % group_order(),\n    {\n        /* <ORIGINAL CODE>\n          let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let high_byte_shifted = bytes[31] >> 7;\n        let high_bit_unset = ct_eq_u8(&high_byte_shifted, &0);\n        /* </MODIFIED CODE> */\n\n        let candidate = Scalar { bytes };\n        let is_canonical = candidate.is_canonical();\n\n        /* <ORIGINAL CODE>\n          CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n          </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let condition = choice_and(high_bit_unset, is_canonical);\n        let result = ct_option_new(candidate, condition);\n        /* </MODIFIED CODE> */\n\n        // VERIFICATION NOTE: PROOF BYPASS\n        assume(bytes_to_nat(&bytes) < group_order() ==> ct_option_has_value(result));\n        assume(bytes_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result));\n        assume(ct_option_has_value(result) ==> bytes_to_nat(&ct_option_value(result).bytes)\n            % group_order() == bytes_to_nat(&bytes) % group_order());\n\n        result\n    }\n\n    /// Construct a `Scalar` from the low 255 bits of a 256-bit integer. This breaks the invariant\n    /// that scalars are always reduced. Scalar-scalar arithmetic, i.e., addition, subtraction,\n    /// multiplication, **does not work** on scalars produced from this function. You may only use\n    /// the output of this function for `EdwardsPoint::mul`, `MontgomeryPoint::mul`, and\n    /// `EdwardsPoint::vartime_double_scalar_mul_basepoint`. **Do not use this function** unless\n    /// you absolutely have to.\n    /* <VERIFICATION NOTE>\n        -This is not in default features and not in our current target list ==> spec omitted for now\n    </VERIFICATION NOTE> */\n    #[cfg(feature = \"legacy_compatibility\")]\n    #[deprecated(\n        since = \"4.0.0\",\n        note = \"This constructor outputs scalars with undefined scalar-scalar arithmetic. See docs.\"\n    )]\n    pub const fn from_bits(bytes: [u8; 32]) -> Scalar {\n        let mut s = Scalar { bytes };\n        // Ensure invariant #1 holds. That is, make s < 2^255 by masking the high bit.\n        s.bytes[31] &= 0b0111_1111;\n\n        s\n    }\n}\n\nimpl Eq for Scalar {\n\n}\n\nimpl PartialEq for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS (problem with traits)\n    fn eq(&self, other: &Self) -> (result: bool)\n        ensures\n            result == (&self.bytes == &other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Choice::into\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let result = self.ct_eq(other).into();\n         </ORIGINAL CODE> */\n        let choice = self.ct_eq(other);\n        assert(choice_is_true(choice) == (self.bytes == other.bytes));\n        let result = choice_into(choice);\n        assert(result == choice_is_true(choice));\n        assert(result == (self.bytes == other.bytes));\n\n        // VERIFICATION NOTE: vstd's external trait specification check cannot be satisfied\n        // vstd expects obeys_eq_spec() and eq_spec() from PartialEqSpecImpl trait,\n        // but that trait is not publicly exported, so we bypass with assume(false)\n        // while maintaining our own custom ensures clause above\n        assume(false);\n\n        result\n    }\n}\n\nimpl ConstantTimeEq for Scalar {\n    fn ct_eq(&self, other: &Self) -> (result: Choice)\n        ensures\n            choice_is_true(result) == (self.bytes == other.bytes),\n    {\n        /* <VERIFICATION NOTE>\n         Use wrapper function for Verus compatibility instead of direct subtle call\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         self.bytes.ct_eq(&other.bytes)\n         </ORIGINAL CODE> */\n        ct_eq_bytes32(&self.bytes, &other.bytes)\n    }\n}\n\nimpl Index<usize> for Scalar {\n    type Output = u8;\n\n    /// Index the bytes of the representative for this `Scalar`.  Mutation is not permitted.\n    fn index(&self, _index: usize) -> (result: &u8)\n        requires\n            _index < 32,\n        ensures\n            result == &self.bytes[_index as int],\n    {\n        &(self.bytes[_index])\n    }\n}\n\nimpl Debug for Scalar {\n    /* VERIFICATION NOTE: we don't cover debugging */\n    #[verifier::external_body]\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar{{\\n\\tbytes: {:?},\\n}}\", &self.bytes)\n    }\n}\n\nimpl<'a> MulAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    fn mul_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n            is_canonical_scalar(self),\n    {\n        /* <ORIGINAL CODE>\n         *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n        /* <VERIFICATION NOTE>\n         In the modified code, we store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&old(self).bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        *self = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&self.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n    }\n}\n\ndefine_mul_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::MulSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_mul_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn mul_req(self, rhs: &Scalar) -> bool {\n        true  // No preconditions\n\n    }\n\n    open spec fn mul_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'b> Mul<&'b Scalar> for &Scalar {\n    type Output = Scalar;\n\n    // VERIFICATION NOTE: VERIFIED\n    fn mul(self, _rhs: &'b Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order(),\n    {\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n        let result_unpacked = UnpackedScalar::mul(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                * to_nat(&rhs_unpacked.limbs)) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                * bytes_to_nat(&_rhs.bytes)) % group_order());\n        }\n        assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n            * bytes_to_nat(&_rhs.bytes)) % group_order());\n        /* </MODIFIED CODE> */\n        /* <ORIGINAL CODE>\n         let result = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n         </ORIGINAL CODE> */\n\n        result\n    }\n}\n\ndefine_mul_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::AddSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_add_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn add_req(self, rhs: &Scalar) -> bool {\n        true  // No preconditions yet\n\n    }\n\n    open spec fn add_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'a> Add<&'a Scalar> for &Scalar {\n    type Output = Scalar;\n\n    /* <VERIFICATION NOTE>\n    PROOF BYPASS; may need to add preconditions to spec\n    </VERIFICATION NOTE> */\n    #[allow(non_snake_case)]\n    fn add(self, _rhs: &'a Scalar) -> (result: Scalar)\n        ensures\n            bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(&_rhs.bytes))\n                % group_order(),\n    {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        /* <VERIFICATION NOTE>\n         Store unpacked values explicitly for asserts\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::add requires inputs < group_order()\n        // By Scalar invariant #2, scalars should be canonical\n        // However, we cannot add requires clauses to trait implementations,\n        // so we assume this property holds\n        proof {\n            assume(to_nat(&self_unpacked.limbs) < group_order());\n            assume(to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::add(&self_unpacked, &rhs_unpacked);\n        proof {\n            assert(to_nat(&result_unpacked.limbs) == (to_nat(&self_unpacked.limbs) + to_nat(\n                &rhs_unpacked.limbs,\n            )) % group_order());\n            assert(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) == to_nat(&result_unpacked.limbs));\n            assert(bytes_to_nat(&result.bytes) == (bytes_to_nat(&self.bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order());\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }\n}\n\ndefine_add_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> AddAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    #[allow(clippy::op_ref)]\n    fn add_assign(&mut self, _rhs: &'a Scalar)\n        ensures\n            bytes_to_nat(&self.bytes) == (bytes_to_nat(&old(self).bytes) + bytes_to_nat(\n                &_rhs.bytes,\n            )) % group_order(),\n    {\n        *self = &*self + _rhs;\n    }\n}\n\ndefine_add_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&Scalar> for &Scalar {\n    open spec fn obeys_sub_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn sub_req(self, rhs: &Scalar) -> bool {\n        is_canonical_scalar(self) && is_canonical_scalar(rhs)\n    }\n\n    open spec fn sub_spec(self, rhs: &Scalar) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl<'b> Sub<&'b Scalar> for &Scalar {\n    type Output = Scalar;\n\n    // VERIFICATION NOTE: PROOF BYPASS (problems with traits and preconditions)\n    // PRECONDITION is_canonical_scalar(self) && is_canonical_scalar(_rhs)\n    #[allow(non_snake_case)]\n    fn sub(self, _rhs: &'b Scalar) -> (result:\n        Scalar)/* VERIFICATION NOTE: preconditions are added to the SpecImpl above\n    requires\n      is_canonical_scalar(self),\n      is_canonical_scalar(_rhs),\n    */\n\n        ensures\n            bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        /* <ORIGINAL CODE>\n         UnpackedScalar::sub(&self.unpack(), &_rhs.unpack()).pack()\n         </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        let self_unpacked = self.unpack();\n        let rhs_unpacked = _rhs.unpack();\n        proof {\n            assert(to_nat(&self_unpacked.limbs) == bytes_to_nat(&self.bytes));\n            assert(to_nat(&rhs_unpacked.limbs) == bytes_to_nat(&_rhs.bytes));\n            assert(limbs_bounded(&self_unpacked));\n            assert(limbs_bounded(&rhs_unpacked));\n        }\n\n        // UnpackedScalar::sub requires: -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()\n        proof {\n            assume(-group_order() <= to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs));\n            assume(to_nat(&self_unpacked.limbs) - to_nat(&rhs_unpacked.limbs) < group_order());\n        }\n\n        let result_unpacked = UnpackedScalar::sub(&self_unpacked, &rhs_unpacked);\n        proof {\n            // Postconditions from sub - need to strengthen, review connections\n            assume(to_nat(&result_unpacked.limbs) % group_order() == (to_nat(&self_unpacked.limbs)\n                - to_nat(&rhs_unpacked.limbs)) % (group_order() as int));\n            assume(limbs_bounded(&result_unpacked));\n        }\n\n        let result = result_unpacked.pack();\n        proof {\n            assert(bytes_to_nat(&result.bytes) % group_order() == to_nat(&result_unpacked.limbs)\n                % group_order());\n            assert(bytes_to_nat(&result.bytes) % group_order() == (bytes_to_nat(&self.bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int));\n        }\n        /* </MODIFIED CODE> */\n\n        result\n    }\n}\n\ndefine_sub_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> SubAssign<&'a Scalar> for Scalar {\n    // VERIFICATION NOTE: VERIFIED\n    #[allow(clippy::op_ref)]\n    fn sub_assign(&mut self, _rhs: &'a Scalar)\n        requires\n            is_canonical_scalar(old(self)),\n            is_canonical_scalar(_rhs),\n        ensures\n            bytes_to_nat(&self.bytes) % group_order() == (bytes_to_nat(&old(self).bytes)\n                - bytes_to_nat(&_rhs.bytes)) % (group_order() as int),\n    {\n        *self = &*self - _rhs;\n    }\n}\n\ndefine_sub_assign_variants!(LHS = Scalar, RHS = Scalar);\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for &Scalar {\n    open spec fn obeys_neg_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn neg_req(self) -> bool {\n        true  // No preconditions - scalars are canonical by invariant\n\n    }\n\n    open spec fn neg_spec(self) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl Neg for &Scalar {\n    type Output = Scalar;\n\n    #[allow(non_snake_case)]\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        /* <ORIGINAL CODE>\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> */\n        proof {\n            // Preconditions for mul_internal and sub\n            assume(limbs_bounded(&constants::R));\n            assume(limbs_bounded(&UnpackedScalar::ZERO));\n        }\n\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n\n        proof {\n            assume(limbs_bounded(&self_mod_l));\n            // sub requires: -group_order() <= 0 - to_nat(&self_mod_l.limbs) < group_order()\n            assume(-group_order() <= to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(\n                &self_mod_l.limbs,\n            ));\n            assume(to_nat(&UnpackedScalar::ZERO.limbs) - to_nat(&self_mod_l.limbs) < group_order());\n        }\n\n        let result = UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack();\n        proof {\n            // TODO: Prove that -self + self == 0 (mod group_order)\n            assume((scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0);\n        }\n\n        /* </MODIFIED CODE> */\n        result\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::NegSpecImpl for Scalar {\n    open spec fn obeys_neg_spec() -> bool {\n        false  // Set to false since we use ensures clause instead of concrete spec\n\n    }\n\n    open spec fn neg_req(self) -> bool {\n        true  // No specific preconditions - scalars are canonical by invariant\n\n    }\n\n    open spec fn neg_spec(self) -> Scalar {\n        arbitrary()  // Placeholder - actual spec is in ensures clause\n\n    }\n}\n\nimpl Neg for Scalar {\n    type Output = Scalar;\n\n    fn neg(self) -> (result: Scalar)\n        ensures\n            (scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0,\n    {\n        let result = (&self).neg();\n        proof {\n            assume((scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0);\n        }\n        result\n    }/* <ORIGINAL CODE>\n    fn neg(self) -> Scalar {\n        -&self\n    }\n    </ORIGINAL CODE> */\n\n}\n\nimpl ConditionallySelectable for Scalar {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> (Self) {\n        let mut bytes = [0u8;32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            /* <VERIFICATION NOTE>\n            Use wrapper function for Verus compatibility instead of direct subtle call\n            </VERIFICATION NOTE> */\n            /* <ORIGINAL CODE>\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n            </ORIGINAL CODE> */\n            /* <MODIFIED CODE> */\n            bytes[i] = select_u8(&a.bytes[i], &b.bytes[i], choice);\n            /* </MODIFIED CODE> */\n        }\n        Scalar { bytes }\n    }\n}\n\n/* <VERIFICATION NOTE>\n Trait implementations for Product and Sum declared as external_body since they use iterators which are not supported by Verus.\n</VERIFICATION NOTE> */\n\nimpl<T> Product<T> for Scalar where T: Borrow<Scalar> {\n    /* <ORIGINAL CODE>\n    fn product<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ONE, |acc, item| acc * item.borrow())\n    }\n    </ORIGINAL CODE> */\n    /* <VERIFICATION NOTE>\n     Added verifier::external_body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    /* <MODIFIED CODE> - FOR EVENTUAL VERIFICATION*/\n    fn product<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified product_of_slice function\n        Scalar::product_of_slice(&scalars)\n    }  /* </MODIFIED CODE> */\n\n}\n\nimpl<T> Sum<T> for Scalar where T: Borrow<Scalar> {\n    #[verifier::external_body]\n    fn sum<I>(iter: I) -> Self where I: Iterator<Item = T> {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }/* <MODIFIED CODE> - if needed in for verification in the future\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        // Collect iterator into a Vec, then convert via Borrow to get &[Scalar]\n        let items: Vec<T> = iter.collect();\n\n        // Convert to Vec<Scalar> via borrow\n        let scalars: Vec<Scalar> = items.iter().map(|item| *item.borrow()).collect();\n\n        // Use the verified sum_of_slice function\n        Scalar::sum_of_slice(&scalars)\n    }\n     </MODIFIED CODE> */\n\n}\n\nimpl Default for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn default() -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == 0 as nat,\n    {\n        let result = Scalar::ZERO;\n        assume(scalar_to_nat(&result) == 0 as nat);\n        result\n    }\n}\n\nimpl From<u8> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    fn from(x: u8) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        let mut s_bytes = [0u8;32];\n        s_bytes[0] = x;\n\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u16> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u16) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u16_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u32> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u32) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u32_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        let result = Scalar { bytes: s_bytes };\n        /* </MODIFIED CODE> */\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u64> for Scalar {\n    /// Construct a scalar from the given `u64`.\n    ///\n    /// # Inputs\n    ///\n    /// An `u64` to convert to a `Scalar`.\n    ///\n    /// # Returns\n    ///\n    /// A `Scalar` corresponding to the input `u64`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let fourtytwo = Scalar::from(42u64);\n    /// let six = Scalar::from(6u64);\n    /// let seven = Scalar::from(7u64);\n    ///\n    /// assert!(fourtytwo == six * seven);\n    /// ```\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u64) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u64_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\nimpl From<u128> for Scalar {\n    // VERIFICATION NOTE: PROOF BYPASS\n    #[allow(clippy::manual_memcpy)]\n    fn from(x: u128) -> (result: Scalar)\n        ensures\n            scalar_to_nat(&result) == x as nat,\n    {\n        /* <ORIGINAL CODE>\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        </ORIGINAL CODE> */\n        /* <MODIFIED CODE> Verus doesn't support copy_from_slice and to_le_bytes */\n        let mut s_bytes = [0u8;32];\n        let x_bytes = crate::core_assumes::u128_to_le_bytes(x);\n        for i in 0..x_bytes.len() {\n            s_bytes[i] = x_bytes[i];\n        }\n        /* </MODIFIED CODE> */\n        let result = Scalar { bytes: s_bytes };\n        proof {\n            assume(scalar_to_nat(&result) == x as nat);\n        }\n        result\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for Scalar {\n    /* <VERIFICATION NOTE>\n    External body annotation\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    fn zeroize(&mut self) {\n        self.bytes.zeroize();\n    }\n}\n\nimpl Scalar {\n    /// The scalar \\\\( 0 \\\\).\n    // pub const ZERO: Self = Self { bytes: [0u8; 32] };\n    /* <VERIFICATION NOTE>\n    Changed to explicit initialization\n    </VERIFICATION NOTE> */\n    /* <ORIGINAL CODE>\n    pub const ZERO: Self = Self { bytes: [0u8; 32] };\n    </ORIGINAL CODE> */\n    pub const ZERO: Scalar = Scalar {\n        bytes: [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n        ],\n    };\n\n    /// The scalar \\\\( 1 \\\\).\n    pub const ONE: Self = Self {\n        bytes: [\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n        ],\n    };\n\n    /* <VERIFICATION NOTE>\n     Verification of random method postponed - requires rand_core feature to be enabled.\n    </VERIFICATION NOTE> */\n    #[cfg(any(test, feature = \"rand_core\"))]\n    /// Return a `Scalar` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `CryptoRngCore`\n    ///   (i.e. `CryptoRng` + `RngCore`) interface.\n    ///\n    /// # Returns\n    ///\n    /// A random scalar within \\\\(\\mathbb{Z} / \\ell\\mathbb{Z}\\\\).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # fn main() {\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// use rand_core::OsRng;\n    ///\n    /// let mut csprng = OsRng;\n    /// let a: Scalar = Scalar::random(&mut csprng);\n    /// # }\n    /* <VERIFICATION NOTE>\n     No verifier::external_body annotation but it is NOT verified\n    </VERIFICATION NOTE> */\n    pub fn random<R: CryptoRngCore + ?Sized>(rng: &mut R) -> (result: Self)\n        ensures\n            is_random_scalar(&result),\n            is_canonical_scalar(&result),\n    {\n        let mut scalar_bytes = [0u8;64];\n        rng.fill_bytes(&mut scalar_bytes);\n        Scalar::from_bytes_mod_order_wide(&scalar_bytes)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Hash a slice of bytes into a scalar using a specified hash function.\n    ///\n    /// This function hashes the input using the specified `Digest` type and then reduces\n    /// the result modulo the group order to produce a scalar.\n    ///\n    /// Convenience wrapper around `from_hash`.\n    ///\n    /// # Example\n    ///\n    #[cfg_attr(feature = \"digest\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// use sha2::Sha512;\n    /// # fn main() {\n    /// let msg = \"To really appreciate architecture, you may even need to commit a murder\";\n    /// let s = Scalar::hash_from_bytes::<Sha512>(msg.as_bytes());\n    /// # }\n    /// ```\n    /* <VERIFICATION NOTE>\n     Marked as external_body due to complexity of Digest trait.\n     For Verus verification, use hash_from_bytes_verus instead.\n    </VERIFICATION NOTE> */\n    #[verifier::external_body]\n    pub fn hash_from_bytes<D>(input: &[u8]) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64> + Default,\n\n        ensures\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        Scalar::from_hash(hash)\n    }\n\n    /// Verus-compatible version of hash_from_bytes that uses SHA-512.\n    ///\n    /// This function is designed for Verus verification and directly computes\n    /// a SHA-512 hash. For regular code with generic hash functions, use `hash_from_bytes` instead.\n    ///\n    /// # Inputs\n    ///\n    /// * `input`: a byte slice to hash\n    ///\n    /// # Returns\n    ///\n    /// A scalar reduced modulo the group order\n    pub fn hash_from_bytes_verus(input: &[u8]) -> (result: Scalar)\n        ensures\n            is_random_bytes(input) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        use crate::core_assumes as assumes;\n        let hash_bytes: [u8; 64] = assumes::sha512_hash_bytes(input);\n        Scalar::from_hash_verus(hash_bytes)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Construct a scalar from a 64-byte (512-bit) hash output.\n    ///\n    /// This reduces the hash output modulo the group order.\n    /// Typically used after calling `finalize()` on a SHA-512 hasher.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// use sha2::{Digest, Sha512};\n    ///\n    /// # fn main() {\n    /// let mut h = Sha512::new();\n    /// h.update(b\"To really appreciate architecture, you may even need to commit a murder.\");\n    /// h.update(b\"While the programs used for The Manhattan Transcripts are of the most extreme\");\n    /// h.update(b\"nature, they also parallel the most common formula plot: the archetype of\");\n    /// h.update(b\"murder. Other phantasms were occasionally used to underline the fact that\");\n    /// h.update(b\"perhaps all architecture, rather than being about functional standards, is\");\n    /// h.update(b\"about love and death.\");\n    ///\n    /// let hash_bytes: [u8; 64] = h.finalize().into();\n    /// let s = Scalar::from_hash(hash_bytes);\n    ///\n    /// println!(\"{:?}\", s.to_bytes());\n    /// assert_eq!(\n    ///     s.to_bytes(),\n    ///     [  21,  88, 208, 252,  63, 122, 210, 152,\n    ///       154,  38,  15,  23,  16, 167,  80, 150,\n    ///       192, 221,  77, 226,  62,  25, 224, 148,\n    ///       239,  48, 176,  10, 185,  69, 168,  11, ],\n    /// );\n    /// # }\n    /// ```\n    /* <VERIFICATION NOTE>\n     Marked as external_body due to GenericArray having private fields.\n     For Verus verification, see from_hash_verus below.\n    </VERIFICATION NOTE> */\n    #[cfg(feature = \"digest\")]\n    #[verifier::external_body]\n    pub fn from_hash<D>(hash: D) -> (result: Scalar) where\n        D: digest::Digest<OutputSize = digest::generic_array::typenum::U64>,\n\n        ensures\n    //is_random_digest(&hash) ==> is_random_scalar(&result),\n    // Result satisfies Scalar invariants #1 and #2\n\n            is_canonical_scalar(&result),\n    {\n        let mut output = [0u8;64];\n        output.copy_from_slice(hash.finalize().as_slice());\n        Scalar::from_bytes_mod_order_wide(&output)\n    }\n\n    /// Verus-compatible version of from_hash that takes pre-finalized hash bytes.\n    ///\n    /// This function is designed for Verus verification and takes a byte array directly\n    /// instead of a generic Digest type. For regular code, use `from_hash` instead.\n    ///\n    /// # Inputs\n    ///\n    /// * `hash_bytes`: a 64-byte array representing the output of a hash function\n    ///\n    /// # Returns\n    ///\n    /// A scalar reduced modulo the group order\n    pub fn from_hash_verus(hash_bytes: [u8; 64]) -> (result: Scalar)\n        ensures\n            is_random_bytes(&hash_bytes) ==> is_random_scalar(&result),\n            // Result satisfies Scalar invariants #1 and #2\n            is_canonical_scalar(&result),\n    {\n        let result = Scalar::from_bytes_mod_order_wide(&hash_bytes);\n        assume(false);\n        result\n    }\n\n    /// Convert this `Scalar` to its underlying sequence of bytes.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.to_bytes() == [0u8; 32]);\n    /// ```\n    pub const fn to_bytes(&self) -> (result: [u8; 32])\n        ensures\n            result == self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        self.bytes\n    }\n\n    /// View the little-endian byte encoding of the integer representing this Scalar.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.as_bytes() == &[0u8; 32]);\n    /// ```\n    pub const fn as_bytes(&self) -> (result: &[u8; 32])\n        ensures\n            result == &self.bytes,\n            scalar_to_nat(self) == bytes_to_nat(&result),\n    {\n        &self.bytes\n    }\n}\n\nimpl Scalar {\n    /// Given a nonzero `Scalar`, compute its multiplicative inverse.\n    ///\n    /// # Warning\n    ///\n    /// `self` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Returns\n    ///\n    /// The multiplicative inverse of the this `Scalar`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // x = 2238329342913194256032495932344128051776374960164957527413114840482143558222\n    /// let X: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x4e, 0x5a, 0xb4, 0x34, 0x5d, 0x47, 0x08, 0x84,\n    ///         0x59, 0x13, 0xb4, 0x64, 0x1b, 0xc2, 0x7d, 0x52,\n    ///         0x52, 0xa5, 0x85, 0x10, 0x1b, 0xcc, 0x42, 0x44,\n    ///         0xd4, 0x49, 0xf4, 0xa8, 0x79, 0xd9, 0xf2, 0x04,\n    ///     ]);\n    /// // 1/x = 6859937278830797291664592131120606308688036382723378951768035303146619657244\n    /// let XINV: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x1c, 0xdc, 0x17, 0xfc, 0xe0, 0xe9, 0xa5, 0xbb,\n    ///         0xd9, 0x24, 0x7e, 0x56, 0xbb, 0x01, 0x63, 0x47,\n    ///         0xbb, 0xba, 0x31, 0xed, 0xd5, 0xa9, 0xbb, 0x96,\n    ///         0xd5, 0x0b, 0xcd, 0x7a, 0x3f, 0x96, 0x2a, 0x0f,\n    ///     ]);\n    ///\n    /// let inv_X: Scalar = X.invert();\n    /// assert!(XINV == inv_X);\n    /// let should_be_one: Scalar = &inv_X * &X;\n    /// assert!(should_be_one == Scalar::ONE);\n    /// ```\n    // VERIFICATION NOTE: VERIFIED\n    pub fn invert(&self) -> (result: Scalar)\n        requires\n            is_canonical_scalar(self),\n        ensures\n    // Result is the multiplicative inverse: result * self ≡ 1 (mod group_order)\n\n            (scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1,\n            is_canonical_scalar(\n                &result,\n            ),\n    // VERIFICATION NOTE: is this true and/or necessary?\n    // Result is canonical\n    // scalar_to_nat(&result) < group_order(),\n    // result.bytes[31] <= 127,\n\n    {\n        let unpacked = self.unpack();\n        let inv_unpacked = unpacked.invert();\n        let result = inv_unpacked.pack();\n        assert((scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1);\n        assume(is_canonical_scalar(&result));\n        result\n    }\n\n    /// Given a slice of nonzero (possibly secret) `Scalar`s,\n    /// compute their inverses in a batch.\n    ///\n    /// # Return\n    ///\n    /// Each element of `inputs` is replaced by its inverse.\n    ///\n    /// The product of all inverses is returned.\n    ///\n    /// # Warning\n    ///\n    /// All input `Scalars` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// # fn main() {\n    /// let mut scalars = [\n    ///     Scalar::from(3u64),\n    ///     Scalar::from(5u64),\n    ///     Scalar::from(7u64),\n    ///     Scalar::from(11u64),\n    /// ];\n    ///\n    /// let allinv = Scalar::batch_invert(&mut scalars);\n    ///\n    /// assert_eq!(allinv, Scalar::from(3*5*7*11u64).invert());\n    /// assert_eq!(scalars[0], Scalar::from(3u64).invert());\n    /// assert_eq!(scalars[1], Scalar::from(5u64).invert());\n    /// assert_eq!(scalars[2], Scalar::from(7u64).invert());\n    /// assert_eq!(scalars[3], Scalar::from(11u64).invert());\n    /// # }\n    /// ```\n    #[cfg(feature = \"alloc\")]\n    // Theo: Verus doesn't like the zeroize in this function. I think the long-term\n    // solution is to use assume_specification to tell Verus what zeroize does.\n    // In the short-term, I've just told verus to ignore the body.\n    // (SB update: alternative is to exclude just the zeroize call, as below)\n    pub fn batch_invert(inputs: &mut [Scalar]) -> (result:\n        Scalar)/* <VERIFICATION NOTE>\n     Refactored for Verus: Index loops instead of iterators, manual Vec construction, ..\n    </VERIFICATION NOTE> */\n\n        ensures\n    // Result is the modular inverse of the product of all original inputs\n\n            is_inverse_of_nat(&result, product_of_scalars(old(inputs)@)),\n            // Each input is replaced with its inverse\n            forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ),\n    {\n        // This code is essentially identical to the FieldElement\n        // implementation, and is documented there.  Unfortunately,\n        // it's not easy to write it generically, since here we want\n        // to use `UnpackedScalar`s internally, and `Scalar`s\n        // externally, but there's no corresponding distinction for\n        // field elements.\n        let n = inputs.len();\n        let one_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(limbs_bounded(&one_unpacked));\n        }\n\n        let one: UnpackedScalar = one_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&one));\n        }\n\n        /* <VERIFICATION NOTE>\n         Build vec manually instead of vec![one; n] for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         let mut scratch = vec![one; n];\n         </ORIGINAL CODE> */\n        let mut scratch = Vec::new();\n        for _ in 0..n {\n            scratch.push(one);\n        }\n\n        // Keep an accumulator of all of the previous products\n        let acc_unpacked = Scalar::ONE.unpack();\n\n        proof {\n            assume(scratch.len() == n);\n            assume(limbs_bounded(&acc_unpacked));\n        }\n\n        let mut acc = acc_unpacked.as_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        /* <VERIFICATION NOTE>\n         Rewritten with index loop instead of .zip() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n         for (input, scratch) in inputs.iter_mut().zip(scratch.iter_mut()) {\n             *scratch = acc;\n        //     // Avoid unnecessary Montgomery multiplication in second pass by\n        //     // keeping inputs in Montgomery form\n             let tmp = input.unpack().as_montgomery();\n             *input = tmp.pack();\n             acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n         }\n        </ORIGINAL CODE> */\n        for i in 0..n\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                limbs_bounded(&acc),\n        {\n            scratch[i] = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = input_unpacked.as_montgomery();\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n\n            proof {\n                assume(limbs_bounded(&acc));\n            }\n        }\n\n        proof {\n            // Assert that all scratch elements have bounded limbs\n            assume(forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]));\n        }\n\n        // acc is nonzero iff all inputs are nonzero\n        #[cfg(not(verus_keep_ghost))]\n        debug_assert!(acc.pack() != Scalar::ZERO);\n\n        // Compute the inverse of all products\n        // ORIGINAL CODE: acc = acc.montgomery_invert().from_montgomery();\n        acc = acc.montgomery_invert();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        acc = acc.from_montgomery();\n\n        proof {\n            assume(limbs_bounded(&acc));\n        }\n\n        // We need to return the product of all inverses later\n        let ret = acc.pack();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        /* <VERIFICATION NOTE>\n         Manual reverse loop instead of .rev() for Verus compatibility\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.iter().rev()) {\n             let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n             *input = UnpackedScalar::montgomery_mul(&acc, scratch).pack();\n             acc = tmp;\n         }\n        </ORIGINAL CODE> */\n        let mut i: usize = n;\n        while i > 0\n            invariant\n                scratch.len() == n,\n                n == inputs.len(),\n                i <= n,\n                limbs_bounded(&acc),\n                forall|j: int| 0 <= j < scratch.len() ==> #[trigger] limbs_bounded(&scratch[j]),\n            decreases i,\n        {\n            i -= 1;\n            let input_unpacked = inputs[i].unpack();\n\n            proof {\n                assume(limbs_bounded(&input_unpacked));\n            }\n\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input_unpacked);\n\n            proof {\n                assume(limbs_bounded(&tmp));\n            }\n\n            inputs[i] = UnpackedScalar::montgomery_mul(&acc, &scratch[i]).pack();\n            acc = tmp;\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        #[cfg(not(verus_keep_ghost))]\n        Zeroize::zeroize(&mut scratch);\n\n        proof {\n            // Assume the postconditions\n            assume(is_inverse_of_nat(&ret, product_of_scalars(old(inputs)@)));\n            assume(forall|i: int|\n                0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                    &(#[trigger] old(inputs)[i]),\n                    &(#[trigger] inputs[i]),\n                ));\n        }\n\n        ret\n    }\n}\n\n#[cfg(feature = \"serde\")]\nuse serde::de::Visitor;\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[cfg(feature = \"serde\")]\n/// Visitor for deserializing a Scalar from a sequence of 32 bytes.\n///\n/* VERIFICATION NOTE:\n- We don't cover serde feature yet\n- The ScalarVisitor struct is defined at module level rather than inside the\n`Deserialize::deserialize` since Verus doesn't support nested types\n</VERIFICATION NOTE> */\nstruct ScalarVisitor;\n\n#[cfg(feature = \"serde\")]\nimpl<'de> Visitor<'de> for ScalarVisitor {\n    type Value = Scalar;\n\n    #[verifier::external_body]\n    fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        {\n            formatter.write_str(\n                \"a sequence of 32 bytes whose little-endian interpretation is less than the \\\n                        basepoint order ℓ\",\n            )\n        }\n    }\n\n    #[verifier::external_body]\n    fn visit_seq<A>(self, mut seq: A) -> Result<Scalar, A::Error> where\n        A: serde::de::SeqAccess<'de>,\n     {\n        let mut bytes = [0u8;32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            bytes[i] = seq.next_element()?.ok_or_else(\n                || serde::de::Error::invalid_length(i, &\"expected 32 bytes\"),\n            )?;\n        }\n        Option::from(Scalar::from_canonical_bytes(bytes)).ok_or_else(\n            || serde::de::Error::custom(\"scalar was not canonically encoded\"),\n        )\n    }\n}\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl Serialize for Scalar {\n    #[verifier::external_body]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl<'de> Deserialize<'de> for Scalar {\n    #[verifier::external_body]\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error> where D: Deserializer<'de> {\n        /* VERIFICATION NOTE:\n        Originally struct ScalarVisitor defined here, but moved up to the top of the file\n        </VERIFICATION NOTE> */\n        deserializer.deserialize_tuple(32, ScalarVisitor)\n    }\n}\n\n} // verus!",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pre_reduce_limbs().",
      "display_name": "pre_reduce_limbs",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pre_reduce_limbs().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/field_core.rs",
      "file_name": "field_core.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn pre_reduce_limbs(limbs: [u64; 5]) -> [u64; 5] {\n    let r = [\n        (sixteen_p_vec[0] - limbs[0]) as u64,\n        (sixteen_p_vec[1] - limbs[1]) as u64,\n        (sixteen_p_vec[2] - limbs[2]) as u64,\n        (sixteen_p_vec[3] - limbs[3]) as u64,\n        (sixteen_p_vec[4] - limbs[4]) as u64,\n    ];\n    r\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "display_name": "lemma_limb2_contribution_correctness_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub proof fn lemma_limb2_contribution_correctness_52(limbs: [u64; 5], bytes: [u8; 32])\n    requires\n        limbs[2] < (1u64 << 52),\n        bytes_match_limbs_packing_52(limbs, bytes),\n    ensures\n        limb2_byte_contribution_52(limbs, bytes) == (limbs[2] as nat) * pow2(104),\n{\n    // Proof following docs_22_oct/lemma_limb2_contribution_52_proof.md\n    lemma2_to64();\n    shift_is_pow2(52);\n\n    // === STEP 1: Define the Split ===\n    let l2_low = limbs[2] as nat % pow2(48);  // Low 48 bits in bytes 13-18\n    let l2_high = limbs[2] as nat / pow2(48);  // High 4 bits in byte 19\n\n    // === STEP 2: Bound the High Part ===\n    lemma_div_bound(limbs[2] as nat, 48, 52);\n    assert(l2_high < pow2(4));\n    lemma_small_mod(l2_high, 16);\n    assert(l2_high % 16 == l2_high);\n\n    // === STEP 3: Reconstruction Identity ===\n    lemma_pow2_pos(48);\n    lemma_fundamental_div_mod(limbs[2] as int, pow2(48) as int);\n    assert(pow2(48) * l2_high == l2_high * pow2(48)) by {\n        lemma_mul_is_commutative(pow2(48) as int, l2_high as int);\n    }\n    assert(limbs[2] as nat == l2_low + l2_high * pow2(48));\n\n    // === STEP 4: Byte Reconstruction for Low 48 Bits ===\n    shr_zero_is_id(limbs[2]);\n    lemma_byte_from_limb_shift_52(limbs[2], 0, bytes[13]);\n    lemma_byte_from_limb_shift_52(limbs[2], 8, bytes[14]);\n    lemma_byte_from_limb_shift_52(limbs[2], 16, bytes[15]);\n    lemma_byte_from_limb_shift_52(limbs[2], 24, bytes[16]);\n    lemma_byte_from_limb_shift_52(limbs[2], 32, bytes[17]);\n    lemma_byte_from_limb_shift_52(limbs[2], 40, bytes[18]);\n\n    // Byte extractions commute with modulo for positions below 48 bits\n    lemma_mod_bound(l2_low as int, pow2(48) as int);\n    lemma_byte_extraction_commutes_with_mod(limbs[2] as nat, 0, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[2] as nat, 1, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[2] as nat, 2, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[2] as nat, 3, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[2] as nat, 4, 48);\n    lemma_byte_extraction_commutes_with_mod(limbs[2] as nat, 5, 48);\n\n    // 6-byte reconstruction lemma gives us the sum\n    lemma_6_bytes_reconstruct(\n        l2_low,\n        bytes[13],\n        bytes[14],\n        bytes[15],\n        bytes[16],\n        bytes[17],\n        bytes[18],\n    );\n\n    let bytes_at_offset_0 = bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8)\n        + bytes[15] as nat * pow2(16) + bytes[16] as nat * pow2(24) + bytes[17] as nat * pow2(32)\n        + bytes[18] as nat * pow2(40);\n\n    assert(bytes_at_offset_0 == l2_low);\n\n    // === STEP 5: Position Adjustment ===\n\n    // Multiply reconstruction identity by pow2(104)\n    assert((l2_low + l2_high * pow2(48)) * pow2(104) == limbs[2] as nat * pow2(104));\n\n    // Distribute\n    assert((l2_low + l2_high * pow2(48)) * pow2(104) == l2_low * pow2(104) + (l2_high * pow2(48))\n        * pow2(104)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(104) as int,\n            l2_low as int,\n            (l2_high * pow2(48)) as int,\n        );\n    }\n\n    // Simplify high term\n    lemma_pow2_adds(48, 104);\n    assert((l2_high * pow2(48)) * pow2(104) == l2_high * pow2(152)) by {\n        lemma_mul_is_associative(l2_high as int, pow2(48) as int, pow2(104) as int);\n    }\n\n    // Now we have: limbs[2] * 2^104 = l2_low * 2^104 + l2_high * 2^152\n\n    // === STEP 6: Expand the Low Part ===\n    // Multiply bytes_at_offset_0 by pow2(104)\n    assert(bytes_at_offset_0 * pow2(104) == l2_low * pow2(104));\n\n    // Distribute pow2(104) into each byte term\n    assert(bytes_at_offset_0 * pow2(104) == bytes[13] as nat * pow2(0) * pow2(104)\n        + bytes[14] as nat * pow2(8) * pow2(104) + bytes[15] as nat * pow2(16) * pow2(104)\n        + bytes[16] as nat * pow2(24) * pow2(104) + bytes[17] as nat * pow2(32) * pow2(104)\n        + bytes[18] as nat * pow2(40) * pow2(104)) by {\n        lemma_mul_is_distributive_add_other_way(\n            pow2(104) as int,\n            (bytes[13] as nat * pow2(0)) as int,\n            (bytes[14] as nat * pow2(8)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(104) as int,\n            (bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8)) as int,\n            (bytes[15] as nat * pow2(16)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(104) as int,\n            (bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8) + bytes[15] as nat * pow2(\n                16,\n            )) as int,\n            (bytes[16] as nat * pow2(24)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(104) as int,\n            (bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8) + bytes[15] as nat * pow2(16)\n                + bytes[16] as nat * pow2(24)) as int,\n            (bytes[17] as nat * pow2(32)) as int,\n        );\n        lemma_mul_is_distributive_add_other_way(\n            pow2(104) as int,\n            (bytes[13] as nat * pow2(0) + bytes[14] as nat * pow2(8) + bytes[15] as nat * pow2(16)\n                + bytes[16] as nat * pow2(24) + bytes[17] as nat * pow2(32)) as int,\n            (bytes[18] as nat * pow2(40)) as int,\n        );\n\n        // Apply associativity: (byte * pow2(k)) * pow2(104) = byte * (pow2(k) * pow2(104))\n        lemma_mul_is_associative(bytes[13] as int, pow2(0) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[14] as int, pow2(8) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[15] as int, pow2(16) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[16] as int, pow2(24) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[17] as int, pow2(32) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[18] as int, pow2(40) as int, pow2(104) as int);\n    }\n\n    assert(bytes_at_offset_0 * pow2(104) == bytes[13] as nat * pow2(104) + bytes[14] as nat * pow2(\n        112,\n    ) + bytes[15] as nat * pow2(120) + bytes[16] as nat * pow2(128) + bytes[17] as nat * pow2(136)\n        + bytes[18] as nat * pow2(144)) by {\n        lemma_mul_is_associative(bytes[13] as int, pow2(0) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[14] as int, pow2(8) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[15] as int, pow2(16) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[16] as int, pow2(24) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[17] as int, pow2(32) as int, pow2(104) as int);\n        lemma_mul_is_associative(bytes[18] as int, pow2(40) as int, pow2(104) as int);\n        lemma_pow2_adds(0, 104);\n        lemma_pow2_adds(8, 104);\n        lemma_pow2_adds(16, 104);\n        lemma_pow2_adds(24, 104);\n        lemma_pow2_adds(32, 104);\n        lemma_pow2_adds(40, 104);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 18
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_basics_3().",
      "display_name": "lemma_mul_basics_3",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_basics_3().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/from_bytes_lemmas.rs",
      "file_name": "from_bytes_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_from_le_bytes().",
      "display_name": "u32_from_le_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_from_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/core_assumes.rs",
      "relative_path": "src/core_assumes.rs",
      "file_name": "core_assumes.rs",
      "parent_folder": "src",
      "body": "pub fn u32_from_le_bytes(bytes: [u8; 4]) -> (x: u32)\n    ensures\n        x as nat == bytes_seq_to_nat(seq_from4(&bytes)),\n{\n    u32::from_le_bytes(bytes)\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "display_name": "as_extended",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "use serde::{Deserialize, Deserializer, Serialize, Serializer};\n",
      "is_libsignal": false,
      "caller_count": 11,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 Choice#From#from().",
      "display_name": "from",
      "symbol": "rust-analyzer cargo subtle 2.6.1 Choice#From#from().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 6,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base_clamped().",
      "display_name": "mul_base_clamped",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base_clamped().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "    pub fn mul_base_clamped(bytes: [u8; 32]) -> Self {\n        // See reasoning in Self::mul_clamped why it is OK to make an unreduced Scalar here. We\n        // note that fixed-base multiplication is also defined for all values of `bytes` less than\n        // 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        Self::mul_base(&s)\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "display_name": "sqrt_ratio_i",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "        impl<'de> Visitor<'de> for CompressedRistrettoVisitor {\n            type Value = CompressedRistretto;\n\n            fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                formatter.write_str(\"32 bytes of data\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<CompressedRistretto, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n                Ok(CompressedRistretto(bytes))\n            }\n        }",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 12
    },
    {
      "id": "rust-analyzer cargo generic-array 0.14.9 GenericArray#as_slice().",
      "display_name": "as_slice",
      "symbol": "rust-analyzer cargo generic-array 0.14.9 GenericArray#as_slice().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/clamp_integer().",
      "display_name": "clamp_integer",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/clamp_integer().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "pub const fn clamp_integer(bytes: [u8; 32]) -> (result: [u8; 32])\n    ensures\n// Result is a valid clamped integer for X25519\n\n        is_clamped_integer(&result),\n        // All bytes except 0 and 31 remain unchanged\n        forall|i: int| 1 <= i < 31 ==> #[trigger] result[i] == bytes[i],\n        // Low byte preserves bits 3-7\n        result[0] & 0b1111_1000 == bytes[0] & 0b1111_1000,\n        // High byte preserves bits 0-5\n        result[31] & 0b0011_1111 == bytes[31] & 0b0011_1111,\n{\n    let mut result = bytes;\n\n    // Clear low 3 bits: result[0] = bytes[0] & 0b1111_1000\n    result[0] &= 0b1111_1000;\n\n    // Clear bit 7 (MSB): result[31] = result[31] & 0b0111_1111\n    result[31] &= 0b0111_1111;\n\n    // Set bit 6: result[31] = result[31] | 0b0100_0000\n    result[31] |= 0b0100_0000;\n\n    proof {\n        // The bitwise operations above produce a clamped integer\n        assume(is_clamped_integer(&result));\n        // Bits 3-7 of byte 0 are preserved\n        assume(result[0] & 0b1111_1000 == bytes[0] & 0b1111_1000);\n        // Bits 0-5 of byte 31 are preserved\n        assume(result[31] & 0b0011_1111 == bytes[31] & 0b0011_1111);\n    }\n\n    result\n}",
      "is_libsignal": false,
      "caller_count": 5,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo subtle 2.6.1 Choice#BitOr#bitor().",
      "display_name": "bitor",
      "symbol": "rust-analyzer cargo subtle 2.6.1 Choice#BitOr#bitor().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
      "relative_path": "src/backend/serial/u64/subtle_assumes.rs",
      "file_name": "subtle_assumes.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb4().",
      "display_name": "load8_limb4",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb4().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn load8_limb4(input: &[u8])\n    requires\n        24 + 7 < input.len(),\n    ensures\n        ((load8_at_spec(input, 24) as u64) >> 12) & mask51 == (input[25] as nat / pow2(4)) + (\n        input[26] * pow2((2 * 8 - 12) as nat)) + (input[27] * pow2((3 * 8 - 12) as nat)) + (\n        input[28] * pow2((4 * 8 - 12) as nat)) + (input[29] * pow2((5 * 8 - 12) as nat)) + (\n        input[30] * pow2((6 * 8 - 12) as nat)) + ((input[31] as nat % pow2(7)) * pow2(\n            (7 * 8 - 12) as nat,\n        )),\n{\n    let i = 24;\n    let k = 12;\n\n    let j_div = 2;\n    let j_id = 7;\n    let j_shift = 8;\n\n    load8_limb_X(input, i, k, j_div, j_id, j_shift);\n\n    // Sanity check\n    assert((load8_at_spec(input, i) as u64 >> k) & mask51 == (((input[i + 0] * pow2(0 * 8)) as u64)\n        / (pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 1] * pow2(1 * 8)) as u64) / (\n    pow2(k as nat) as u64)) % (pow2(51) as u64) + (((input[i + 2] * pow2(2 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 3] * pow2(3 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 4] * pow2(4 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 5] * pow2(5 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 6] * pow2(6 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64) + (((input[i + 7] * pow2(7 * 8)) as u64) / (pow2(\n        k as nat,\n    ) as u64)) % (pow2(51) as u64));\n\n    // First term too small, swallowed by div\n    assert(input[24] as nat / pow2(12) == 0) by {\n        assert(input[24] < pow2(8) < pow2(12)) by {\n            assert(input[24] < pow2(8)) by {\n                u8_lt_pow2_8(input[24]);\n            }\n            assert(pow2(8) < pow2(12)) by {\n                lemma_pow2_strictly_increases(8, 12);\n            }\n        }\n\n        lemma_basic_div(input[24] as int, pow2(12) as int);\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_square_mod_p().",
      "display_name": "is_square_mod_p",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_square_mod_p().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field_specs.rs",
      "relative_path": "src/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "src",
      "body": "pub open spec fn is_square_mod_p(a: nat) -> bool {\n    exists|y: nat| (#[trigger] (y * y) % p()) == (a % p())\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Identity#identity().",
      "display_name": "identity",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Identity#identity().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "body": "    fn identity() -> CompressedRistretto {\n        CompressedRistretto([0u8; 32])\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/low_bits_mask().",
      "display_name": "low_bits_mask",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/low_bits_mask().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "is_libsignal": false,
      "caller_count": 9,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb3_byte_contribution_52().",
      "display_name": "limb3_byte_contribution_52",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb3_byte_contribution_52().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "file_name": "scalar_to_bytes_lemmas.rs",
      "parent_folder": "scalar_byte_lemmas",
      "body": "pub open spec fn limb3_byte_contribution_52(limbs: [u64; 5], bytes: [u8; 32]) -> nat {\n    // Byte 19 high 4 bits (limbs[3]'s bits 0-3)\n    ((limbs[3] as nat % pow2(4)) * 16) * pow2(19 * 8) + bytes[20] as nat * pow2(20 * 8)\n        + bytes[21] as nat * pow2(21 * 8) + bytes[22] as nat * pow2(22 * 8) + bytes[23] as nat\n        * pow2(23 * 8) + bytes[24] as nat * pow2(24 * 8) + bytes[25] as nat * pow2(25 * 8)\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_loop1_invariant().",
      "display_name": "lemma_sub_loop1_invariant",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_loop1_invariant().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_sub_loop1_invariant(\n    difference: Scalar52,\n    borrow: u64,\n    i: usize,\n    a: &Scalar52,\n    b: &Scalar52,\n    old_borrow: u64,\n    mask: u64,\n    difference_loop1_start: Scalar52,\n)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> difference.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) == seq_u64_to_nat(difference_loop1_start.limbs@.subrange(0, i as int)) - (old_borrow\n            >> 63) * pow2((52 * (i) as nat)),\n        difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(\n            0,\n            i as int,\n        ),\n        difference.limbs[i as int] == borrow & mask,\n        borrow == a.limbs[i as int].wrapping_sub((b.limbs[i as int] + (old_borrow >> 63)) as u64),\n    ensures\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n            (52 * (i + 1) as nat),\n        ) == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i + 1),\n        ),\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] * pow2(52 * i as nat) - (\n        seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] * pow2(52 * i as nat)); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(\n            b.limbs@.subrange(0, i as int),\n        ) + (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            assert(difference_loop1_start.limbs@.subrange(0, i as int)\n                == difference.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) - (old_borrow >> 63) * pow2(\n            52 * i as nat,\n        ) + (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n            - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n            assert(borrow == a.limbs[i as int].wrapping_sub(\n                (b.limbs[i as int] + (old_borrow >> 63)) as u64,\n            ));\n            assert(difference.limbs[i as int] == borrow & mask);\n            // Expand wrapping sub\n            if a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) < 0 {\n                assert(borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52)) by {\n                    assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    assert(b.limbs[i as int] <= (1u64 << 52) - 1);\n                    assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                        >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                    assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 <= 1u64 << 52);\n                    assert(borrow >= (a.limbs[i as int] - (1u64 << 52)\n                        + 0x1_0000_0000_0000_0000) as u64);\n                };\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n                        - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                            >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow\n                        - 0x1_0000_0000_0000_0000) * pow2(52 * i as nat); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((borrow >> 52)\n                        * pow2(52) + difference.limbs[i as int] - 0x1_0000_0000_0000_0000) * pow2(\n                        52 * i as nat,\n                    ); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                            broadcast use lemma_pow2_adds;\n\n                        };\n                        assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n                        broadcast use lemma_mul_is_distributive_sub_other_way;\n\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow\n                            >> 52) as nat * pow2(52 * (i + 1) as nat)) by {\n                            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                            lemma_mul_is_associative(\n                                (borrow >> 52) as int,\n                                pow2(52) as int,\n                                pow2(52 * i as nat) as int,\n                            );\n                        };\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) + difference.limbs[i as int] * pow2(52 * i as nat) - 0x1_0000_0000_0000_0000\n                        * pow2(52 * i as nat); {\n                        lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) - 0x1_0000_0000_0000_0000 * pow2(52 * i as nat); {\n                        assert(borrow >> 52 == (1u64 << 12) - 1) by (bit_vector)\n                            requires\n                                borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52),\n                        ;\n                        assert(0x1_0000_0000_0000_0000 * pow2(52 * i as nat) == (1u64 << 12) * pow2(\n                            52 * (i + 1) as nat,\n                        )) by {\n                            lemma2_to64();\n                            assert(0x1_0000_0000_0000_0000 == pow2(64));\n                            assert(1u64 << 12 == pow2(12)) by (compute);\n                            lemma_pow2_adds(64, 52 * i as nat);\n                            lemma_pow2_adds(12, 52 * (i + 1) as nat);\n                            assert(64 + 52 * i as nat == 12 + 52 * (i + 1) as nat);\n                        }\n                        lemma_mul_is_distributive_sub_other_way(\n                            pow2(52 * (i + 1) as nat) as int,\n                            (1u64 << 12) - 1,\n                            (1u64 << 12) as int,\n                        );\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) + (-1) * pow2(\n                        52 * (i + 1) as nat,\n                    ); {\n                        assert(borrow >> 63 == 1) by (bit_vector)\n                            requires\n                                borrow >= 0x1_0000_0000_0000_0000 - (1u64 << 52),\n                        ;\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n                        (52 * (i + 1) as nat),\n                    );\n                }\n            } else {\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (a.limbs[i as int]\n                        - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                            >> 63)) as u64)) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow) * pow2(\n                        52 * i as nat,\n                    ); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((borrow >> 52)\n                        * pow2(52) + difference.limbs[i as int]) * pow2(52 * i as nat); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {\n                            broadcast use lemma_pow2_adds;\n\n                        };\n                        assert(52 + 52 * i as nat == 52 * (i + 1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow\n                            >> 52) as nat * pow2(52 * (i + 1) as nat)) by {\n                            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i + 1) as nat));\n                            lemma_mul_is_associative(\n                                (borrow >> 52) as int,\n                                pow2(52) as int,\n                                pow2(52 * i as nat) as int,\n                            );\n                        };\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow >> 52) * pow2(\n                        52 * (i + 1) as nat,\n                    ) + difference.limbs[i as int] * pow2(52 * i as nat); {\n                        lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                        assert(borrow < 1u64 << 52) by {\n                            assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow\n                                >> 63)) as u64)) as u64);\n                            assert(a.limbs[i as int] < (1u64 << 52));\n                            assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 >= 0);\n                        }\n                        assert(borrow >> 52 == 0) by (bit_vector)\n                            requires\n                                borrow < 1u64 << 52,\n                        ;\n                        assert(borrow >> 63 == 0) by (bit_vector)\n                            requires\n                                borrow < 1u64 << 52,\n                        ;\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n                        (52 * (i + 1) as nat),\n                    );\n                }\n            }\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2(\n            (52 * (i + 1) as nat),\n        );\n    }\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_spec_fits_u64().",
      "display_name": "load8_at_spec_fits_u64",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_spec_fits_u64().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "        assume(forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52))\n    }\n}\n\n#[cfg(verus_keep_ghost)]\nimpl vstd::std_specs::ops::SubSpecImpl<&FieldElement51> for &FieldElement51 {\n    // Does the implementation of this trait obey basic subtraction principles\n    open spec fn obeys_sub_spec() -> bool {\n        true\n    }\n\n    // Pre-condition of sub - delegates to spec_sub_limbs_bounded for consistency\n    open spec fn sub_req(self, rhs: &FieldElement51) -> bool {\n        limbs_bounded(self, 54) && limbs_bounded(rhs, 54)\n    }\n\n    // Postcondition of sub - delegates to spec_sub_limbs for consistency\n    open spec fn sub_spec(self, rhs: &FieldElement51) -> FieldElement51 {\n        spec_sub_limbs(self, rhs)\n    }\n}",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_setup().",
      "display_name": "lemma_carry_propagation_setup",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_setup().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/compute_q_lemmas.rs",
      "file_name": "compute_q_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn lemma_carry_propagation_setup()\n    ensures\n        (1u64 << 51) == pow2(51),\n        (1u64 << 52) == pow2(52),\n        pow2(52) == 2 * pow2(51),\n        19 < pow2(51),\n        3 * pow2(51) <= u64::MAX,\n{\n    lemma2_to64();\n    shift_is_pow2(51);\n    shift_is_pow2(52);\n    lemma_pow2_pos(51);\n\n    assert(pow2(52) == 2 * pow2(51)) by {\n        lemma_pow2_adds(1, 51);\n    }\n\n    assert(19 < pow2(51)) by {\n        lemma_pow2_strictly_increases(5, 51);\n    }\n\n    assert(3 * pow2(51) <= u64::MAX) by {\n        lemma2_to64_rest();\n    }\n}",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec_is_bounded().",
      "display_name": "load8_at_plus_version_rec_is_bounded",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec_is_bounded().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub proof fn load8_at_plus_version_rec_is_bounded(input: &[u8], i: usize, k: nat)\n    requires\n        k <= 7,\n    ensures\n        load8_at_plus_version_rec(input, i, k) < pow2(8 * (k + 1)),\n    decreases k,\n{\n    assert(u8::MAX < pow2(8)) by {\n        lemma2_to64();\n    }\n\n    if (k == 0) {\n        // just needs the the pre-if assert\n    } else {\n        // k > 0\n        // Let f(k) := load8_at_plus_version_rec(input, i, k)\n        // IH: f(k - 1) < pow2(8 * k)\n        assert(load8_at_plus_version_rec(input, i, (k - 1) as nat) < pow2(8 * k)) by {\n            load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n        }\n\n        let c = (input[i + k] as u64);\n        assert(c < pow2(8));\n\n        // f(k) = f(k - 1) + c * pow2(8 * k)\n        assert(c << (8 * k) == c * pow2(8 * k)) by {\n            assert((input[i + k] as u64) * pow2(8 * k) <= u64::MAX) by {\n                assert(u64::MAX == pow2(64) - 1) by {\n                    lemma2_to64_rest();\n                }\n                assert(c * pow2(8 * k) < pow2(64)) by {\n                    assert(c * pow2(8 * k) < pow2(8) * pow2(8 * k)) by {\n                        lemma_mul_strict_inequality(c as int, pow2(8) as int, pow2(8 * k) as int);\n                    }\n                    assert(pow2(8) * pow2(8 * k) <= pow2(64)) by {\n                        assert(pow2(8 * k) <= pow2(56)) by {\n                            if (k < 7) {\n                                lemma_pow2_strictly_increases(8 * k, 56);\n                            }\n                        }\n                        lemma_pow2_pos(8);\n                        lemma_mul_inequality(pow2(8 * k) as int, pow2(56) as int, pow2(8) as int);\n                        lemma_pow2_adds(8, 56);\n                    }\n                }\n            }\n            lemma_u64_shl_is_mul(c, (8 * k) as u64);\n        }\n\n        // f(k - 1) < 1 * 2^(8k)\n        // c <= 2^8 - 1\n        // f(k -1) + c * 2^8k < 2^8 * 2^8k = 2^(8 * (k + 1))\n\n        assert(load8_at_plus_version_rec(input, i, k) < pow2(8 * k) + c * pow2(8 * k));\n\n        assert(pow2(8 * k) + c * pow2(8 * k) <= pow2(8 * (k + 1))) by {\n            // x + c * x == c ( x + 1 )\n            assert(pow2(8 * k) + c * pow2(8 * k) == pow2(8 * k) * (c + 1)) by {\n                lemma_mul_is_distributive_add(pow2(8 * k) as int, c as int, 1);\n            }\n            assert(c + 1 <= pow2(8));\n\n            assert(pow2(8 * k) * (c + 1) <= pow2(8 * (k + 1))) by {\n                lemma_mul_inequality((c + 1) as int, pow2(8) as int, pow2(8 * k) as int);\n                lemma_pow2_adds(8, 8 * k);\n                lemma_mul_is_distributive_add(8, 1, k as int);\n            }\n        }\n    }\n}",
      "is_libsignal": false,
      "caller_count": 4,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/has_inv_mod_p().",
      "display_name": "has_inv_mod_p",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/has_inv_mod_p().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field_specs.rs",
      "relative_path": "src/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "src",
      "body": "pub open spec fn has_inv_mod_p(v: nat) -> bool {\n    v % p() != 0 && exists|w: nat| (#[trigger] (v * w) % p()) == 1\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_inv_witness().",
      "display_name": "is_inv_witness",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_inv_witness().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/field_specs.rs",
      "relative_path": "src/field_specs.rs",
      "file_name": "field_specs.rs",
      "parent_folder": "src",
      "body": "pub open spec fn is_inv_witness(v: nat, w: nat) -> bool {\n    ((v % p()) * (w % p())) % p() == 1\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 1
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core default/Default#default().",
      "display_name": "default",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core default/Default#default().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/ristretto.rs",
      "relative_path": "src/ristretto.rs",
      "file_name": "ristretto.rs",
      "parent_folder": "src",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq_lib/Seq#map().",
      "display_name": "map",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq_lib/Seq#map().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/wrapping_mul().",
      "display_name": "wrapping_mul",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/wrapping_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar.rs",
      "relative_path": "src/backend/serial/u64/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "u64",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "display_name": "optional_mixed_multiscalar_mul",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/mod.rs",
      "relative_path": "src/backend/mod.rs",
      "file_name": "mod.rs",
      "parent_folder": "backend",
      "body": "    // #[cfg(all(curve25519_dalek_backend = \"simd\", nightly))]\n    // Avx512,\n    Serial,\n}\n\n#[inline]\nfn get_selected_backend() -> BackendKind {\n    // #[cfg(all(curve25519_dalek_backend = \"simd\", nightly))]\n    // {\n    //     cpufeatures::new!(cpuid_avx512, \"avx512ifma\", \"avx512vl\");\n    //     let token_avx512: cpuid_avx512::InitToken = cpuid_avx512::init();\n    //     if token_avx512.get() {\n    //         return BackendKind::Avx512;\n    //     }\n    // }\n\n    // #[cfg(curve25519_dalek_backend = \"simd\")]\n    // {\n    //     cpufeatures::new!(cpuid_avx2, \"avx2\");\n    //     let token_avx2: cpuid_avx2::InitToken = cpuid_avx2::init();\n    //     if token_avx2.get() {\n    //         return BackendKind::Avx2;\n    //     }\n    // }\n\n    BackendKind::Serial\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 10
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#sum_of_slice().",
      "display_name": "sum_of_slice",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#sum_of_slice().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar_helpers.rs",
      "relative_path": "src/scalar_helpers.rs",
      "file_name": "scalar_helpers.rs",
      "parent_folder": "src",
      "body": "    pub fn sum_of_slice(scalars: &[Scalar]) -> (result: Scalar)\n        ensures\n    // Result is a valid scalar (bytes represent a value < group_order)\n\n            scalar_to_nat(&result) < group_order(),\n            // Result represents the sum of all scalars in the slice (mod group_order)\n            scalar_congruent_nat(&result, sum_of_scalars(scalars@)),\n    {\n        let n = scalars.len();\n        let mut acc = Scalar::ZERO;\n\n        proof {\n            // Assume properties of Scalar::ZERO\n            assume(scalar_to_nat(&acc) < group_order());\n            assume(scalar_to_nat(&acc) == 0);\n            assume(scalar_congruent_nat(&acc, sum_of_scalars(scalars@.subrange(0, 0))));\n        }\n\n        for i in 0..n\n            invariant\n                n == scalars.len(),\n                scalar_to_nat(&acc) < group_order(),\n                // acc represents the sum of scalars[0..i]\n                scalar_congruent_nat(&acc, sum_of_scalars(scalars@.subrange(0, i as int))),\n        {\n            proof {\n                // Assume preconditions for addition are satisfied\n                assume(false);\n            }\n            acc = &acc + &scalars[i];\n\n            proof {\n                // Assume the result maintains the invariant\n                assume(scalar_to_nat(&acc) < group_order());\n                assume(scalar_congruent_nat(\n                    &acc,\n                    sum_of_scalars(scalars@.subrange(0, (i + 1) as int)),\n                ));\n            }\n        }\n\n        proof {\n            // At this point, acc is the sum of all scalars\n            assert(scalars@.subrange(0, n as int) =~= scalars@);\n        }\n\n        acc\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 5
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/edwards_identity_affine().",
      "display_name": "edwards_identity_affine",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/edwards_identity_affine().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/curve_specs.rs",
      "relative_path": "src/curve_specs.rs",
      "file_name": "curve_specs.rs",
      "parent_folder": "src",
      "body": "pub open spec fn edwards_identity_affine() -> (nat, nat) {\n    (0, 1)\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_add_mod_noop().",
      "display_name": "lemma_add_mod_noop",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_add_mod_noop().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/div_mod_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/div_mod_lemmas.rs",
      "file_name": "div_mod_lemmas.rs",
      "parent_folder": "common_verus",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/pow2_MUL_div_Mod_u8_t51_cond().",
      "display_name": "pow2_MUL_div_Mod_u8_t51_cond",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/pow2_MUL_div_Mod_u8_t51_cond().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "relative_path": "src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
      "file_name": "load8_lemmas.rs",
      "parent_folder": "field_lemmas",
      "body": "pub open spec fn pow2_MUL_div_Mod_u8_t51_cond(k: nat, j: nat) -> bool {\n    (k <= j * 8) && (j * 8 - k <= 51)\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/lemma_low_bits_mask_unfold().",
      "display_name": "lemma_low_bits_mask_unfold",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/lemma_low_bits_mask_unfold().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/mask_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/mask_lemmas.rs",
      "file_name": "mask_lemmas.rs",
      "parent_folder": "common_verus",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "display_name": "elligator_encode",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/edwards.rs",
      "relative_path": "src/edwards.rs",
      "file_name": "edwards.rs",
      "parent_folder": "src",
      "body": "            assert(!is_valid_y_coordinate(field_element_from_bytes(&self.0)));\n            let result = None;\n            result\n        }\n    }\n}\n\nmod decompress {\n    use super::*;\n\n    #[rustfmt::skip]  // keep alignment of explanatory comments\n    pub(super) fn step_1(repr: &CompressedEdwardsY) -> (result: (\n        Choice,\n        FieldElement,\n        FieldElement,\n        FieldElement,\n    ))  // Result components: (is_valid, X, Y, Z)// VERIFICATION NOTE: PROOF BYPASSFORMATTER_NOT_INLINE_MARKER\n        ensures\n    // The returned Y field element matches the one extracted from the compressed representation\n\n            field_element(&result.2) == field_element_from_bytes(&repr.0),\n            // The returned Z field element is 1\n            field_element(&result.3) == 1,\n            // The choice is true iff the Y is valid and (X, Y) is on the curve\n            choice_is_true(result.0) <==> is_valid_y_coordinate(field_element(&result.2)),\n            choice_is_true(result.0) ==> on_edwards_curve(\n                field_element(&result.1),\n                field_element(&result.2),\n            ),\n    {\n        let Y = FieldElement::from_bytes(repr.as_bytes());\n        assert(field_element_from_bytes(&repr.0) == field_element(&Y));\n        let Z = FieldElement::ONE;\n        proof {\n            assume(forall|i: int| 0 <= i < 5 ==> Y.limbs[i] < 1u64 << 54);\n        }\n        let YY = Y.square();\n\n        /* <VERIFICATION NOTE>\n        Assume preconditions for field operations with *SpecImpl traits.\n        </VERIFICATION NOTE> */\n        proof {\n            // For Sub (YY - Z): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> YY.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> Z.limbs[i] < (1u64 << 54));\n\n            // For Mul (YY * EDWARDS_D): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> constants::EDWARDS_D.limbs[i] < (1u64 << 54));\n        }\n        let u = &YY - &Z;  // u =  y²-1\n        let yy_times_d = &YY * &constants::EDWARDS_D;\n        proof {\n            // For Add (yy_times_d + Z): requires no overflow\n            assume(forall|i: int|\n                0 <= i < 5 ==> #[trigger] (yy_times_d.limbs[i] + Z.limbs[i]) <= u64::MAX);\n        }\n        let v = &yy_times_d + &Z;  // v = dy²+1\n\n        let (is_valid_y_coord, X) = FieldElement::sqrt_ratio_i(&u, &v);\n\n        proof {\n            // Assume postconditions that depend on sqrt_ratio_i behavior\n            assume(field_element(&Z) == 1);\n            // Note: Using <==> (bi-implication) to match the postcondition exactly\n            assume(choice_is_true(is_valid_y_coord) <==> is_valid_y_coordinate(field_element(&Y)));\n            assume(choice_is_true(is_valid_y_coord) ==> on_edwards_curve(\n                field_element(&X),\n                field_element(&Y),\n            ));\n        }\n        (is_valid_y_coord, X, Y, Z)\n    }\n\n    #[rustfmt::skip]\n    pub(super) fn step_2(\n        repr: &CompressedEdwardsY,\n        mut X: FieldElement,\n        Y: FieldElement,\n        Z: FieldElement,\n    ) -> (result: EdwardsPoint)\n    // VERIFICATION NOTE: PROOF BYPASS\n\n        ensures\n            field_element(&result.X)\n                ==\n            // If the sign bit is 1, negate the X field element\n            if (repr.0[31] >> 7) == 1 {\n                field_neg(field_element(&X))\n            } else {\n                field_element(&X)\n            },\n            // Y and Z are unchanged\n            field_element(&result.Y) == field_element(&Y),\n            field_element(&result.Z) == field_element(&Z),\n            // X is conditionally negated based on the sign bit\n            // T = X * Y (after conditional negation)\n            field_element(&result.T) == field_mul(\n                field_element(&result.X),\n                field_element(&result.Y),\n            ),\n    {\n        // FieldElement::sqrt_ratio_i always returns the nonnegative square root,\n        // so we negate according to the supplied sign bit.\n        let compressed_sign_bit = Choice::from(repr.as_bytes()[31] >> 7);\n\n        /* <VERIFICATION NOTE>\n         Using conditional_negate_field wrapper and assuming preconditions for trait operations.\n        </VERIFICATION NOTE> */\n        /* <ORIGINAL CODE>\n        X.conditional_negate(compressed_sign_bit);\n        </ORIGINAL CODE> */\n        let ghost original_X = X;\n        conditional_negate_field(&mut X, compressed_sign_bit);\n\n        proof {\n            // For Mul (X * Y): requires limbs < 2^54\n            assume(forall|i: int| 0 <= i < 5 ==> X.limbs[i] < (1u64 << 54));\n            assume(forall|i: int| 0 <= i < 5 ==> Y.limbs[i] < (1u64 << 54));\n\n            // Assume conditional_negate_field behaves correctly\n            assume(field_element(&X) == if choice_is_true(compressed_sign_bit) {\n                field_neg(field_element(&original_X))\n            } else {\n                field_element(&original_X)\n            });\n        }\n\n        let result = EdwardsPoint { X, Y, Z, T: &X * &Y };\n\n        proof {\n            // Assume multiplication produces correct field_mul result\n            assume(field_element(&result.T) == field_mul(\n                field_element(&result.X),\n                field_element(&result.Y),\n            ));\n        }\n\n        result\n    }\n\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 7
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Index#index().",
      "display_name": "index",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Index#index().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "    fn index(&self, _index: usize) -> (result: &u8)\n        requires\n            _index < 32,\n        ensures\n            result == &self.bytes[_index as int],\n    {\n        &(self.bytes[_index])\n    }",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_multiples_vanish().",
      "display_name": "lemma_div_multiples_vanish",
      "symbol": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_multiples_vanish().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/shift_lemmas.rs",
      "file_name": "shift_lemmas.rs",
      "parent_folder": "common_verus",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_carry_and_sum_bounds().",
      "display_name": "lemma_add_carry_and_sum_bounds",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_carry_and_sum_bounds().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_add_carry_and_sum_bounds(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) < 2,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 4
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/reconstruct_radix_2w().",
      "display_name": "reconstruct_radix_2w",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/reconstruct_radix_2w().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "#[cfg(any(test, feature = \"rand_core\"))]\nuse rand_core::CryptoRngCore;\n// From a conflict:\n//use rand_core::{CryptoRng, RngCore};\n",
      "is_libsignal": false,
      "caller_count": 2,
      "callee_count": 2
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec().",
      "display_name": "plus_version_is_spec",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "    {\n        let ghost original_limbs = self.limbs;\n        for i in 0..5\n            invariant\n                forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> self.limbs[j] == original_limbs[j] + _rhs.limbs[j],\n                forall|j: int| #![auto] i <= j < 5 ==> self.limbs[j] == original_limbs[j],\n                forall|j: int|\n                    0 <= j < 5 ==> #[trigger] original_limbs[j] + _rhs.limbs[j] <= u64::MAX,\n        {\n            // Trigger the forall\n            assert(original_limbs[i as int] + _rhs.limbs[i as int] <= u64::MAX);\n            self.limbs[i] += _rhs.limbs[i];\n        }\n        proof {\n            // After loop, all limbs are the sum: self.limbs[i] == original_limbs[i] + _rhs.limbs[i]\n            // This means self.limbs equals spec_add_limbs(old(self), _rhs).limbs\n            assert(self.limbs =~= spec_add_limbs(old(self), _rhs).limbs);\n        }\n        assume(field_element(self) == (field_element(old(self)) + field_element(_rhs)) % p());\n    }",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 9
    },
    {
      "id": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core map/adapters/iter/Map#Iterator#fold().",
      "display_name": "fold",
      "symbol": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core map/adapters/iter/Map#Iterator#fold().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
      "relative_path": "src/backend/serial/scalar_mul/pippenger.rs",
      "file_name": "pippenger.rs",
      "parent_folder": "scalar_mul",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_from_le_bytes().",
      "display_name": "u64_from_le_bytes",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_from_le_bytes().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/scalar.rs",
      "relative_path": "src/scalar.rs",
      "file_name": "scalar.rs",
      "parent_folder": "src",
      "body": "use group::ff::{Field, FromUniformBytes, PrimeField};\n#[cfg(feature = \"group-bits\")]",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 3
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mul_internal_correct().",
      "display_name": "lemma_mul_internal_correct",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mul_internal_correct().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
      "relative_path": "src/backend/serial/u64/scalar_lemmas.rs",
      "file_name": "scalar_lemmas.rs",
      "parent_folder": "u64",
      "body": "pub proof fn lemma_mul_internal_correct(a: &[u64; 5], b: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        forall|i: int| 0 <= i < 5 ==> b[i] < (1u64 << 52),\n        z[0] == (a[0] * b[0]),\n        z[1] == (a[0] * b[1]) + (a[1] * b[0]),\n        z[2] == (a[0] * b[2]) + (a[1] * b[1]) + (a[2] * b[0]),\n        z[3] == (a[0] * b[3]) + (a[1] * b[2]) + (a[2] * b[1]) + (a[3] * b[0]),\n        z[4] == (a[0] * b[4]) + (a[1] * b[3]) + (a[2] * b[2]) + (a[3] * b[1]) + (a[4] * b[0]),\n        z[5] == (a[1] * b[4]) + (a[2] * b[3]) + (a[3] * b[2]) + (a[4] * b[1]),\n        z[6] == (a[2] * b[4]) + (a[3] * b[3]) + (a[4] * b[2]),\n        z[7] == (a[3] * b[4]) + (a[4] * b[3]),\n        z[8] == (a[4] * b[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(b),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*b) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n    lemma_five_limbs_equals_to_nat(&b);\n}",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 8
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_encode().",
      "display_name": "lizard_encode",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_encode().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/lizard/lizard_ristretto.rs",
      "relative_path": "src/lizard/lizard_ristretto.rs",
      "file_name": "lizard_ristretto.rs",
      "parent_folder": "lizard",
      "body": "    pub fn lizard_encode<D: Digest>(data: &[u8; 16]) -> RistrettoPoint\n    where\n        D: Digest<OutputSize = U32>,\n    {\n        let mut fe_bytes: [u8; 32] = Default::default();\n\n        let digest = D::digest(data);\n        fe_bytes[0..32].copy_from_slice(digest.as_slice());\n        fe_bytes[8..24].copy_from_slice(data);\n        fe_bytes[0] &= 254; // make positive since Elligator on r and -r is the same\n        fe_bytes[31] &= 63;\n        let fe = FieldElement::from_bytes(&fe_bytes);\n        RistrettoPoint::elligator_ristretto_flavor(&fe)\n    }",
      "is_libsignal": false,
      "caller_count": 1,
      "callee_count": 6
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c1_0_val().",
      "display_name": "c1_0_val",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c1_0_val().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/field.rs",
      "relative_path": "src/backend/serial/u64/field.rs",
      "file_name": "field.rs",
      "parent_folder": "u64",
      "body": "/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).",
      "is_libsignal": false,
      "caller_count": 3,
      "callee_count": 0
    },
    {
      "id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/main().",
      "display_name": "main",
      "symbol": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/main().",
      "full_path": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs",
      "relative_path": "src/backend/serial/u64/common_verus/mul_lemmas.rs",
      "file_name": "mul_lemmas.rs",
      "parent_folder": "common_verus",
      "body": "fn main() {\n}",
      "is_libsignal": false,
      "caller_count": 0,
      "callee_count": 0
    }
  ],
  "links": [
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#to_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#to_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_extraction_commutes_with_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/bytes_match_limbs_packing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_from_limb_shift().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb2_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#zip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_byte_from_limb_shift_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb0_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/bytes_match_limbs_packing_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_extraction_commutes_with_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_bytes32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_sign_bit().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_sign_bit().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_le_max64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/lemma_reorder_mul().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_single_stage_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_bounded_shr_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_single_stage_division().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_single_stage_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_setup().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/bit_arrange().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/reduce_with_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/carry_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c4_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_rr_limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_to_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_to_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_to_le_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/to_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/load8_at().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_versions_equivalent().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/load8_at().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/load8_at().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/load8_at().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/rec_version_is_exec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Zeroize#zeroize().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_swap_u64().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_swap().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_swap_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from16().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq/Seq#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_v0_and_reorder().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_v0_and_reorder().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_5_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb2_byte_contribution_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_empty_seq_as_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/low_bits_masks_fit_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_basics_4().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_le_max64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_ver_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_times_pow2_fits_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod_lemma().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#to_montgomery().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb0_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb2_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat_32_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb1_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb3_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/bytes_match_limbs_packing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb4_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_geometric_series_radix51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_geometric_series_radix51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_geometric_series_radix51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_geometric_series_radix51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_basics().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_geometric_series_radix51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_geometric_series_radix51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_geometric_series_radix51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#PartialEq#eq().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/bits_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/bits_to_nat_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV_MOD().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_multiply_divide_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV_MOD().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV_MOD().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV_MOD().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV_MOD().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV_MOD().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV_MOD().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#from_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#to_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#decompress().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#unwrap().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_encode().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#unwrap().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/low_bits_masks_fit_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_strictly_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_by_multiple().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_strictly_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_by_multiple_is_strongly_ordered().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#optional_mixed_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_edwards().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_cast_then_mod_51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_cast_then_mod_51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#bits_le_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/bits_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#bits_le_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#bits_le_verus().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_affine_niels().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_u8().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#is_torsion_free().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/IsIdentity#is_identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core map/adapters/iter/Map#Iterator#fold().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#cmp().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#expect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#size_hint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#by_ref().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core map/adapters/iter/Map#Iterator#next().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#zip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#to_radix_2w_size_hint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_seq_u64_to_nat_subrange_extend().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_seq_u64_to_nat_subrange_extend().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_seq_u64_to_nat_subrange_extend().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_seq_u64_to_nat_subrange_extend().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq_lib/Seq#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_MOD_u8().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_MOD().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_MOD_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_MOD_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_bytes32().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_bytes32().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_cofactor().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_pow_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_compressed_identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/clamp_integer().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#is_small_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_cofactor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#is_small_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/IsIdentity#is_identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/reduce_with_q_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_unmasked_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb3().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb3().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb3().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/a2_0_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c2_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_of_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_multiples_vanish_fancy().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_of_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_of_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_1().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_to_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_to_le_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/to_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_to_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#non_adjacent_form().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#non_adjacent_form().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_from_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#non_adjacent_form().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/wrapping_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#non_adjacent_form().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_valid_naf().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#non_adjacent_form().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_div_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_by_multiple().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_by_multiple_is_strongly_ordered().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_all_carries_bounded_by_3().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_all_carries_bounded_by_3().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_all_carries_bounded_by_3().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_bounded_shr_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_all_carries_bounded_by_3().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_setup().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb0().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_7_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_pow_a_pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_mod_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_from_limb_shift().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_extraction_commutes_with_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/bytes_match_limbs_packing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb0_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core impls/cmp/Ord#cmp().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#non_adjacent_form().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Sum#sum().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#fold().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Sum#sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_chunk_extraction_commutes_with_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_chunk_extraction_commutes_with_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_chunk_extraction_commutes_with_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_chunk_extraction_commutes_with_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_chunk_extraction_commutes_with_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from4().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq/Seq#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_MOD().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_MOD().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_MOD().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_MOD().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_MOD().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb0_byte_contribution_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_nonincreasing().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_nonincreasing().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_shr_le_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#ConditionallySelectable#conditional_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/differential_add_and_double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_swap().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#as_affine().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Hash#hash().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core array/Hash#hash().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Hash#hash().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Hash#hash().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_inv_axiom().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_inv_axiom().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ValidityCheck#is_valid().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#ValidityCheck#is_valid().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ValidityCheck#is_valid().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_mod_sum_factor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_squared().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_squared().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_squared().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_squared().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_5_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_v0_and_reorder().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_si_vi_and_reorder().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_squared().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#TryFrom#try_from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#from_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c1_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c1_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c1_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_carry_bounded_after_mask().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_carry_bounded_after_mask().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_carry_bounded_after_mask().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_strict_inequality_converse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_carry_bounded_after_mask().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/l51_bit_mask_lt().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/l51_bit_mask_lt().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_versions_equivalent().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_versions_equivalent().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/bit_or_is_plus().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_versions_equivalent().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_or_version_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_versions_equivalent().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_versions_equivalent().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_nonincreasing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_versions_equivalent().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec_is_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash().",
      "target": "rust-analyzer cargo generic-array 0.14.9 GenericArray#as_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/copy_from_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#finalize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_modular_bit_partitioning().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_modular_bit_partitioning().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_modular_bit_partitioning().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_modular_bit_partitioning().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_modular_bit_partitioning().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_pow2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_pow2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_pow2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_pow2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_truncate_middle().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_div_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_div_bound().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_strictly_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_div_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01234().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_pow_a_pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01234().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb4().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01234().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_mod_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01234().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_7_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01234().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01234().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_0123().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01234().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/copy_from_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#expect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#finalize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_by_cofactor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#to_edwards().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#update().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#nonspec_map_to_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_sub_limbs().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_add_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_twice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_wide_to_nat_rec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/vartime_double_base_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/get_selected_backend().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/vartime_double_base_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 vartime_double_base/scalar_mul/serial/backend/mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/a1_0_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c1_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/lemma_neg_no_underflow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/negate_proof().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_si_vi_and_reorder().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_quad_prod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_si_vi_and_reorder().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_5_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_si_vi_and_reorder().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#from_uniform_bytes_single_elligator().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#from_uniform_bytes_single_elligator().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_edwards_point().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_sign_bit().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_y_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_add_no_overflow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_add_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#AddAssign#add_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_unmasked_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_compute_q().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_shr_le_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/sum_of_scalars().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/sum_of_scalars().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq/Seq#skip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/sum_of_scalars().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_loop2_invariant().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_old_carry().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_loop2_invariant().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_loop2_invariant().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_affine_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_select_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/lemma_neg_no_underflow().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/lemma_neg_no_underflow().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/lemma_neg_no_underflow().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/lemma_neg_no_underflow().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/all_neg_limbs_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_carry_bounded_after_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_scalar_subtract_no_overflow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix_51_partial_geometric_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix_51_partial_geometric_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix_51_partial_geometric_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix_51_partial_geometric_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_fits_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_fits_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec_is_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_fits_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_uniform_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/copy_from_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_uniform_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_uniform_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c3_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c3_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c3_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c2_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/a3_0_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c3_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_correct_after_loops().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_l_equals_group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_correct_after_loops().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_correct_after_loops().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_correct_after_loops().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_correct_after_loops().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_correct_after_loops().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_bound_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_correct_after_loops().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_correct_after_loops().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_field_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_field_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mul_internal_correct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/m().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mul_internal_no_overflow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_012().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_012().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_012().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_pow_a_pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_012().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_8_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_012().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_mod_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_012().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_012().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/bit_or_is_plus().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_by_multiple_is_strongly_ordered().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_by_multiple().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_u8_cast_is_mod_256().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_le_max64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_is_ordered_by_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_into().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_into().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb3_byte_contribution().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Neg#neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_boundary_byte_combines().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/bytes_match_limbs_packing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb0_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb3_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb1_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb4_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb2_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat_32_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Zeroize#zeroize().",
      "target": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_from_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_from_le_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/from_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_from_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from16().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb4_byte_contribution().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Debug#fmt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Debug#fmt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Debug#fmt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#coset4().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_five_limbs_equals_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_pow252().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/five_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_l_equals_group_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/VartimeEdwardsPrecomputation#VartimePrecomputedMultiscalarMul#new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_two_factoring_51().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_two_factoring().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_two_factoring_51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_01234().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat_32_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb3_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/five_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb0_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb0_contribution_correctness_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb1_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb2_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/bytes_match_limbs_packing_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb4_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/bit_or_is_plus().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_strictly_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_u8_cast_is_mod_256().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_mul_le_implies_div_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_modular_bit_partitioning().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_boundary_byte_combines_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_seq_to_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq/Seq#skip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_seq_to_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow22501().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec_lemma().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec_lemma().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec_lemma().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec_lemma().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec_lemma().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec_lemma().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec_lemma().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_valid_radix_16().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_valid_radix_2w().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_base().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_le_max64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_base().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_spec_fits_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_base().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_base().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/l51_bit_mask_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_mul_sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_mul_sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_mul_sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_mul_sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_square_internal_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_square_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_nine_limbs_equals_slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_square_internal_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_square_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/nine_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_square_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_five_limbs_equals_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_square_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_square_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/five_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_square_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/lemma_as_nat_sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/lemma_as_nat_sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/lemma_as_nat_sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod_lemma().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod_lemma().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/div_pow2_preserves_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod_lemma().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod_lemma().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod_lemma().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod_lemma().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_basic_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_shift_mod_lemma().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shifted_lt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_u64_max_shifting().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shifted_lt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_shr_le_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shifted_lt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Zeroize#zeroize().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_0123().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_0123().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_mod_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_0123().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_7_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_0123().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_012().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_0123().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_0123().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_pow_a_pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat_0123().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb3().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MultiscalarMul#multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_bytes32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/lemma_m().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_remainder_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_multiples_vanish_fancy().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_direct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_expansion().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_boundaries().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_decomposition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_decomposition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_bytes_to_nat_rec_equals_bytes_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat_32_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_bytes_to_nat_rec_equals_bytes_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_bytes_to_nat_rec_equals_bytes_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_bytes_to_nat_rec_equals_bytes_to_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_bytes_to_nat_rec_equals_bytes_to_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_bound_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_general_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_bound_scalar().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_bound_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_bound_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/IsIdentity#is_identity().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/IsIdentity#is_identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/IsIdentity#is_identity().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/variable_base_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/masked_lt_51().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/l51_bit_mask_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/masked_lt_51().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/masked_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_and().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_and().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#BitAnd#bitand().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb1().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_shr_51_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_shr_51_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_negate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pre_reduce_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_shr_le_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_u64_max_shifting().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/masked_lt_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow2_plus_one().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_strict_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb1_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/bytes_match_limbs_packing_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_byte_from_limb_shift_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Zeroize#zeroize().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_or().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#BitOr#bitor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_or().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_boundaries().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shifted_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_boundaries().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/masked_lt_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_edwards_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_edwards_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_edwards_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_edwards_point().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_compressed_identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/product_of_fields().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/product_of_fields().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq/Seq#skip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/product_of_fields().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/on_edwards_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/on_edwards_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/on_edwards_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/on_edwards_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/on_edwards_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/on_edwards_curve().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c0_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c0_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_pow252().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_pow252().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_pow252().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_negate_field().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/VartimeEdwardsPrecomputation#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#optional_mixed_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c3_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c4_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c2_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_mul_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_cast_then_mod_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c2_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_squared().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c3_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_shr_51_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c4_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/lemma_reorder_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/term_product_bounds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_0_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/lemma_pow1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/masked_lt_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_div_and_mod_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_shift_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow_nat_is_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c0_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/l51_bit_mask_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c1_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c1_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_mod_diff_factor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mul_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow2_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/m().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable8#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#new().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#new().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_sqrt_ratio().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_sqrt_ratio_times_i().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Neg#neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#to_jacobi_quartic_ristretto().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#to_jacobi_quartic_ristretto().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#to_jacobi_quartic_ristretto().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#to_jacobi_quartic_ristretto().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#zip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/m().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_sqrt_ratio().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_sqrt_ratio().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb0().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb0().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb0().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb0().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb0().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_basics_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb0().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_basics_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_div2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_5_bytes_reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/bot_half().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/top_half().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_valid_radix_16().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/reconstruct_radix_16().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectiveNielsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat_32_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_shift_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_shift_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c1_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_shift_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c3_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_shift_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c2_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_shift_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c4_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_shift_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_0_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_shift_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_shr_51_fits_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_add_then_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_multiply_divide_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_add_then_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_add_then_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_add_then_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_subtracts().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_add_then_shift().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_mixed_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core empty/sources/iter/empty().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_congruent_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_congruent_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c4_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c3_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c4_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c4_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_limbs5().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_limbs5().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_mod_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_mod_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_mod_u8().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_remainder_bound().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_remainder_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_remainder_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_remainder_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb1_byte_contribution_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_inverse_field_of_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_inverse_field_of_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_4_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_4_terms().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_3_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_4_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow_nat_is_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_strict_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mul_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_k().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_left_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_general_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_general_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_general_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq_lib/Seq#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_general_bound().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_general_bound().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_general_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_general_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_general_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_general_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_stage_division_theorem().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_direct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_setup().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_single_stage_division().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_is_division().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_all_carries_bounded_by_3().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/words_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/words_to_nat_gen_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_to_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_to_le_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/to_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_to_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from4().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#update().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core default/Default#default().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_from_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_from_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_from_le_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/from_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limbs_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limbs_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat_32_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limbs_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/bytes_match_limbs_packing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limbs_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limbs_to_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_sum_equals_limb_sum().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Sum#sum().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#fold().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Sum#sum().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat_rec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_select_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_select_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#elligator_ristretto_flavor_inverse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core array/Default#default().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#unwrap_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/copy_from_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#digest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#enumerate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_decode().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_five_limbs_equals_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_bytes_to_nat_rec_equals_bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#Zeroize#zeroize().",
      "target": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/sha512_hash_bytes().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#update().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/sha512_hash_bytes().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/sha512_hash_bytes().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#finalize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/sha512_hash_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/sha512_hash_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Zeroize#zeroize().",
      "target": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_bits_be().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/Mul#mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/Mul#mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#skip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#bits_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_decomposition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat_32_u8_rec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_sub_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#SubAssign#sub_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/LookupTable#select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c2_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c2_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c2_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c1_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_lizard_encode_helper().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/product_of_scalars().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq/Seq#skip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/product_of_scalars().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/product_of_scalars().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#decompress().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#decompress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/ristretto/step_1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_shr_51_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_shr_51_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_shr_51_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_is_ordered().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_sub_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_assign_u64().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_assign_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow2_square().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/lemma_pow_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow2_square().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow2_square().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow2_square().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_unfold().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_Mod_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_Mod_u8().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_Mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_Mod_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#MulAssign#mul_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_extraction_commutes_with_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_extraction_commutes_with_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_chunk_extraction_commutes_with_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_extraction_commutes_with_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/masked_lt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/masked_lt().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/masked_lt().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/masked_lt().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/masked_lt().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_shl_le_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_shl_le_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_by_multiple().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#decode_253_bits().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#elligator_ristretto_flavor_inverse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#decode_253_bits().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/BasepointTable#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/clamp_integer().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_pow2_260_greater_than_2_group_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_pow252().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_pow2_260_greater_than_2_group_order().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_pow2_260_greater_than_2_group_order().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_pow2_260_greater_than_2_group_order().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_pow2_260_greater_than_2_group_order().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb1_byte_contribution().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/a0_0_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#PartialEq#eq().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_valid_radix_2w().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_from_bytes().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat_32_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#ConditionallySelectable#conditional_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_nine_limbs_equals_slice128_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_nine_limbs_equals_slice128_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/nine_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#vartime_double_scalar_mul_basepoint().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/vartime_double_base_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#is_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#is_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#is_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#is_canonical().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb4_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb1_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat_32_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb0_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb2_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_boundary_byte_combines_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/bytes_match_limbs_packing_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_sum_equals_byte_nat_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb3_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#random().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#random().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#random().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/variable_base_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/get_selected_backend().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/variable_base_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 variable_base/scalar_mul/serial/backend/mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_carry_propagation_is_division().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_carry_out_equals_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_strictly_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Zeroize#zeroize().",
      "target": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoBasepointTable#basepoint().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#basepoint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_two_factoring_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_div_and_mod_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_basic_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_boundaries().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/l51_bit_mask_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_and().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#is_canonical().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_value().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_has_value().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_canonical_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_expansion().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_expansion().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_expansion().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_expansion().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_radix51_telescoping_expansion().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_6_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_6_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_6_terms().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_5_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/clamp_integer().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_base().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_swap().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_swap().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_swap_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_u8().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_u8().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/get_selected_backend().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/low_bits_masks_fit_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/low_bits_mask_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/low_bits_masks_fit_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/low_bits_masks_fit_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/lemma_low_bits_mask_values().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_assign_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/square_multiply().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_u64_max_shifting().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/words_to_nat_gen_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_from_montgomery_limbs_conversion().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_five_limbs_equals_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_from_montgomery_limbs_conversion().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/nine_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_from_montgomery_limbs_conversion().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_from_montgomery_limbs_conversion().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_from_montgomery_limbs_conversion().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_from_montgomery_limbs_conversion().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_nine_limbs_equals_slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Mul#mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/m().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_nondecreasing().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_nondecreasing().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_nondecreasing().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_shl_le_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_nondecreasing().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_nondecreasing().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_nondecreasing().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_nondecreasing().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_nondecreasing().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_nondecreasing().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/slice128_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#mul_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/clamp_integer().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_u64_to_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq_lib/Seq#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_u64_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#expect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimePrecomputedMultiscalarMul#vartime_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/negate_proof().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/negate_proof().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/lemma_as_nat_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/negate_proof().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/negate_proof().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/negate_proof().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/all_neg_limbs_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/negate_proof().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/negate_proof().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/negate_proof().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_shr_le_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/negate_proof().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/lemma_neg_no_underflow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/negate_proof().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/negate_proof().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/negate_proof().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pre_reduce_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/negate_proof().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/u64/serial/backend/negate_proof().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb4_byte_contribution_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_five_limbs_equals_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_as_bytes_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_bytes_to_nat_rec_equals_bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_two_factoring().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_two_factoring().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_two_factoring().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#Zeroize#zeroize().",
      "target": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#Zeroize#zeroize().",
      "target": "rust-analyzer cargo zeroize 1.8.2 Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_mul_le_implies_div_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_is_ordered().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_mul_le_implies_div_le().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_by_multiple().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/reconstruct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq/Seq#skip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_sqrt_ratio_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_sqrt_ratio_times_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Zeroize#zeroize().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#by_ref().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#MultiscalarMul#multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#size_hint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/words_to_nat_gen_u32().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#PartialEq#eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#PartialEq#eq().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/Into#into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select_u8().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select_u8().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Sum#sum().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#fold().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/rec_version_is_exec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_or_version_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/on_edwards_curve().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_y_coordinate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#Identity#identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_hash().",
      "target": "rust-analyzer cargo generic-array 0.14.9 GenericArray#as_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_hash().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/copy_from_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_hash().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_uniform_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_hash().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#finalize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_bytes32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_to_le_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/to_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_to_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_to_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from16().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_five_limbs_equals_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_five_limbs_equals_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/five_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/as_nat_32_mod_255().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/as_nat_32_mod_255().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/as_nat_32_mod_255().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/as_nat_32_mod_255().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_lt_pow2_8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/as_nat_32_mod_255().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_sum().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/as_nat_32_mod_255().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat_32_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/as_nat_32_mod_255().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/as_nat_32_mod_255().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/as_nat_32_mod_255().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_sum_bounds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/as_nat_32_mod_255().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/as_nat_32_mod_255().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_basics_3().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_from_limb_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_from_limb_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_from_limb_shift().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_u8_cast_is_mod_256().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_extraction_commutes_with_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/bytes_match_limbs_packing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_5_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_from_limb_shift().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb3_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/AffineNielsPoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Product#product().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Product#product().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Product#product().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#Product#product().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#product_of_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/differential_add_and_double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_eq_bytes32().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#compress().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#unwrap_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_8_terms().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_7_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_8_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_8_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_from_montgomery_limbs_conversion().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_pow_a_pow().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_pow_a_pow().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_pow_a_pow().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_pow_a_pow().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_pow_a_pow().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_some().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_has_value().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_some().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_some().",
      "target": "rust-analyzer cargo subtle 2.6.1 CtOption#is_some().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_mod_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/pow2_MUL_div_mod_u8_t51_cond().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_MOD_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/pow2_mul_DIV_MOD_u8_t51_cond().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/pow2_MUL_div_Mod_u8_t51_cond().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_base().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV_MOD_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_Mod_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/pow2_MUL_div_MOD_u8_t51_cond().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_le_max64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb1_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_extraction_commutes_with_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/bytes_match_limbs_packing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_5_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_from_limb_shift().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb1_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#expect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "target": "rust-analyzer cargo std https://github.com/rust-lang/rust/library/std env/var().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "target": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc string/ToString#to_string().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#as_deref().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 is_capable_simd().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "target": "rust-analyzer cargo rustc_version 0.4.1 version_meta().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 main().",
      "target": "rust-analyzer cargo rustc_version 0.4.1 version().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_ver_div_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_ver_div_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_ver_div_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_le_max64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_ver_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_ver_div_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_ver_div_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec_is_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_ver_div_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_fits_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_ver_div_mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_times_pow2_fits_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_inverse_field().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_inverse_field().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_edwards_identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_basics_3().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_sum_bounds().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_general().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_sum_bounds().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_sum().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_Mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_Mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div_Mod().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#as_affine().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/ProjectivePoint#as_affine().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_shr_le_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_shr_le_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_is_ordered().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_shr_le_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/a4_0_val().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c4_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_shr_le_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_strictly_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_telescoping().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/l51_bit_mask_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/masked_lt_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_div_and_mod_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/reduce_with_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_carry_out_equals_q().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_mod_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_mod_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_mod_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_mod_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_mod_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_mod_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/assemble_mod_div().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pow255_gt_19().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pow255_gt_19().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pow255_gt_19().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_negate_field().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits_warning().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits().",
      "target": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc string/String#AsRef#as_ref().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 deterministic/determine_curve25519_dalek_bits().",
      "target": "rust-analyzer cargo std https://github.com/rust-lang/rust/library/std env/var().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#by_ref().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#size_hint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_optional_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/pippenger_optional_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/read_le_u64_into().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/read_le_u64_into().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_from_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/read_le_u64_into().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_telescoping().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_telescoping().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_telescoping().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_telescoping().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_telescoping().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_telescoping().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_telescoping().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_telescoping().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Default#default().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#ValidityCheck#is_valid().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_verus/u64/serial/backend/sum_bounds().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_verus/u64/serial/backend/seq_sum().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_verus/u64/serial/backend/sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_verus/u64/serial/backend/sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_verus/u64/serial/backend/sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_verus/u64/serial/backend/sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_strictly_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_verus/u64/serial/backend/sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_bounded_shr_51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_bounded_shr_51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_bounded_shr_51().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_strictly_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_bounded_shr_51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#encode_253_bits().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#encode_253_bits().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#encode_253_bits().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_7_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_7_terms().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_6_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_7_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_3_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_3_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_y_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_y_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_y_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_neg().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_y_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_y_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_y_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_valid_y_coordinate().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/montgomery_radix().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#part1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#part2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/m().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/reconstruct_radix_2w().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_valid_radix_2w().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_valid_radix_16().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_from_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/reconstruct_radix_16().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_2w().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#as_radix_16().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 straus/scalar_mul/serial/backend/Straus#MultiscalarMul#multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/straus_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/get_selected_backend().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Identity#identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_compressed_identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#Identity#identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#elligator_ristretto_flavor_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#to_jacobi_quartic_ristretto().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#elligator_ristretto_flavor_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#elligator_ristretto_flavor_inverse().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#elligator_ristretto_flavor_inverse().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#dual().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/words_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_stage_division_theorem().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_stage_division_theorem().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_stage_division_theorem().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_stage_division_theorem().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_sub_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_l_value_properties().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_loop_invariant().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_carry_and_sum_bounds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_sum_simplify().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_l_equals_group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_loop_bounds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#new().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/VartimeRistrettoPrecomputation#VartimePrecomputedMultiscalarMul#new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_inverse_of_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_montgomery().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_inverse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#as_montgomery().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo zeroize 1.8.2 Vec#Zeroize#zeroize().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/product_of_scalars().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#montgomery_invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#push().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#batch_invert().",
      "target": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/m().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_52_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_div_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_div_decomposition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_mod_decomposition().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_div_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_equality_converse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_div_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_div_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/sum_div_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_quad_prod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mod_cancel().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_add_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mod_cancel().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mod_cancel().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_lt().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_strict_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_lt().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_nonzero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/get_selected_backend().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/VartimePrecomputedStraus#new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_constants/lizard/test_lizard_constants().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_constants/lizard/test_lizard_constants().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_constants/lizard/test_lizard_constants().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_valid_naf().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_by_multiple().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_5_terms().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_4_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_5_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_5_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/affine_coords().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/affine_coords().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_inv().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/affine_coords().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/CompressedEdwardsY#from_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/try_into_32_bytes_array().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/nine_limbs_to_nat_aux().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_new().",
      "target": "rust-analyzer cargo subtle 2.6.1 CtOption#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/div_pow2_preserves_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/div_pow2_preserves_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_by_multiple().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/div_pow2_preserves_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_by_multiple_is_strongly_ordered().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/div_pow2_preserves_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/div_pow2_preserves_decomposition().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_MUL_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/div_pow2_preserves_decomposition().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_carry_bounded_after_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_borrow_and_mask_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_scalar_subtract_no_overflow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/wrapping_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_correct_after_loops().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_loop2_invariant().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_loop1_invariant().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#mul_internal().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoBasepointTable#create().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsBasepointTable#BasepointTable#create().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_le_max64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_le_max64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_le_max64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_byte_from_limb_shift_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_byte_from_limb_shift_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#TryFrom#try_from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#from_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow_nat_is_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow_nat_is_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow_nat_is_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow_nat_is_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/lemma0_pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow_nat_is_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/lemma_pow_positive().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_none().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_none().",
      "target": "rust-analyzer cargo subtle 2.6.1 CtOption#is_none().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_is_none().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_has_value().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_inverse_of_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_inverse_of_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_wide_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_bytes_mod_order_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_and_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_and_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_and_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_and_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_and_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_and_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_and_mod().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_compute_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_all_carries_bounded_by_3().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_compute_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_compute_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_compute_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_is_binary().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_compute_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_biconditional().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_compute_q().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb0_byte_contribution().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_0_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c2_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_0_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c4_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_0_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c1_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_0_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c0_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_0_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c3_0_val().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/c_i_0_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/term_product_bounds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_is_binary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_is_binary().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_is_binary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_is_division().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_is_binary().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_is_binary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_strictly_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_is_binary().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_is_binary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_is_binary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_is_binary().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_is_binary().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_from_limb_shift().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/bytes_match_limbs_packing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb4_byte_contribution().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_as_nat_bound_from_51bit_limbs().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_as_nat_bound_from_51bit_limbs().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_geometric_sum_5_terms().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_as_nat_bound_from_51bit_limbs().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_mul_upper_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_as_nat_bound_from_51bit_limbs().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_as_nat_bound_from_51bit_limbs().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_as_nat_bound_from_51bit_limbs().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_as_nat_bound_from_51bit_limbs().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_as_nat_bound_from_51bit_limbs().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_lt_pow2_8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_lt_pow2_8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_spec_fits_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/from_bytes_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat_32_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/load8_at().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/u64/serial/backend/as_nat_32_mod_255().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/reconstruct_radix_16().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/reconstruct_radix_2w().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV_MOD_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV_MOD_u8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV_MOD_u8().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_DIV_MOD().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#part1().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/wrapping_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#part1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/m().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_square_of().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_square_of().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#random().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_uniform_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#product_of_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_congruent_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#product_of_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/product_of_scalars().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#product_of_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#product_of_slice().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#product_of_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/lemma_shr_le_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_q_arr().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries1().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_biconditional().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_strictly_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_biconditional().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_biconditional().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_biconditional().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_biconditional().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/pow255_gt_19().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_biconditional().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_biconditional().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_biconditional().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_biconditional().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_q_biconditional().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_not().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#Not#not().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_not().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invsqrt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 jacobi_quartic/lizard/JacobiPoint#elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/left_right_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/left_right_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/left_right_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_multiples_vanish().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/left_right_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/left_right_shift().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/low_bits_mask_increases().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/lemma_low_bits_mask_unfold().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/low_bits_mask_increases().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/low_bits_mask_increases().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/lemma_low_bits_mask_values().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_verus/u64/serial/backend/low_bits_mask_increases().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/lemma_low_bits_mask_div2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_geometric_sum_5_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_geometric_sum_5_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_geometric_sum_5_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_geometric_sum_5_terms().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimeMultiscalarMul#vartime_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimeMultiscalarMul#vartime_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimeMultiscalarMul#optional_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 traits/VartimeMultiscalarMul#vartime_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core option/Option#expect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/pippenger_optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pippenger/scalar_mul/serial/backend/Pippenger#VartimeMultiscalarMul#optional_multiscalar_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/pippenger_optional_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 backend/get_selected_backend().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_basic_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_nonincreasing().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 bits/low_bits_mask().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/mask_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/left_right_shift().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/bit_or_is_plus().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_le_max64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_multiply_divide_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/bitwise_or_l_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_decreases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shl_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/bitwise_or_r_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_verus/u64/serial/backend/lemma_bitops_lifted().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_k().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 as_nat_lemmas/field_lemmas/u64/serial/backend/as_nat_k().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_mod_sum_factor().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_add_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_mod_sum_factor().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_mod_sum_factor().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_twice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#bits_le().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_affine_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#as_projective_niels().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_sum_simplify().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_pow2_260_greater_than_2_group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_sum_simplify().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_sum_simplify().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_sum_simplify().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_sum_simplify().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_sum_simplify().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_sum_simplify().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_mul_upper_bound().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/bytes_match_limbs_packing_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_byte_from_limb_shift_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_denominator().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb3_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb3_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#from_hash_verus().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/sha512_hash_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#hash_from_bytes_verus().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/is_random_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/term_product_bounds().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/lemma_m().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/u64/serial/backend/term_product_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#From#from().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u16_to_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_to_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_to_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u128_to_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#vartime_double_scalar_mul_basepoint().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#vartime_double_scalar_mul_basepoint().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat_32_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/u64/serial/backend/as_bytes_boundaries2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/bit_arrange().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/reduce_with_q_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_limbs_to_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_to_bytes_reduction().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/u64/serial/backend/lemma_reduce_bound_2p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_compute_q().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/spec_reduce().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Sub#sub().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_to_nat().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_mod_diff_factor().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_sub_mod_noop().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_mod_diff_factor().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_mod_diff_factor().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_twice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_times_pow2_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_times_pow2_fits_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_times_pow2_fits_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_times_pow2_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_times_pow2_fits_u64().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/limb2_byte_contribution().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_byte_from_limb_shift_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/bytes_match_limbs_packing_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb4_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb4_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_specs/is_identity().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_loop_invariant().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_loop_invariant().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_loop_invariant().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_q_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/compute_q_arr().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_general().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_general().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_verus/u64/serial/backend/mul_le().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_general().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_general().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_general().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_general().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/bits_to_nat_rec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#pow2k().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power/arithmetic/pow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#from_slice().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/TryInto#try_into().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#from_slice().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core result/Result#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#ConditionallySelectable#conditional_select().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo subtle 2.6.1 From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_inverse_field().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#push().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_zero().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_not().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_times_pow2_mod_is_id().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_times_pow2_mod_is_id().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_times_pow2_mod_is_id().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_times_pow2_mod_is_id().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_times_pow2_mod_is_id().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_mul_u8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Debug#fmt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_1().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Debug#fmt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 decompress/edwards/step_2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#Debug#fmt().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#zip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#efgh().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#batch_invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 BatchCompressState#From#from().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_neg().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/montgomery_radix().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/five_limbs_to_nat_aux().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow2_plus_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow2_plus_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow2_plus_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow2_plus_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_basics_3().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_pow2_plus_one().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#enumerate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#elligator_ristretto_flavor_inverse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "target": "rust-analyzer cargo rand 0.8.5 thread/rngs/ThreadRng#RngCore#fill_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#xcoset4().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/iter().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 test/lizard_ristretto/lizard/test_elligator_inv().",
      "target": "rust-analyzer cargo rand 0.8.5 thread/rngs/thread_rng().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from8().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq/Seq#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/pow2_sum().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#unpack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#pack().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_canonical_scalar().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar#invert().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/Scalar52#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/CompressedRistretto#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_div_and_mod_51().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_div_and_mod_51().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/l51_bit_mask_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_div_and_mod_51().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_verus/u64/serial/backend/lemma_div_and_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub_new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub_new().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/wrapping_sub().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub_new().",
      "target": "rust-analyzer cargo subtle 2.6.1 Choice#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub_new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#conditional_add_l().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub_new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#sub_new().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/MontgomeryPoint#ConstantTimeEq#ct_eq().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_square_internal_correct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_square_internal_no_overflow().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/m().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#square_internal().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_add_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/spec_field_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/Add#add().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_div_multiples_vanish_fancy().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/masked_lt_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_as_nat_bound_from_51bit_limbs().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/l51_bit_mask_lt().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/u64/serial/backend/lemma_div_and_mod_51().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_telescoping().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/u64/serial/backend/lemma_reduction_carry_propagation_is_division().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#hash_from_bytes().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#update().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#hash_from_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#from_hash().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#hash_from_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core default/Default#default().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_unwrap().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_has_value().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_unwrap().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_unwrap().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_value().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/ct_option_unwrap().",
      "target": "rust-analyzer cargo subtle 2.6.1 CtOption#unwrap().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_decompose().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_decompose().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_decompose().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_decompose().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_decompose().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_wide_to_nat().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_wide_to_nat_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_inv().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from2().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq/Seq#new().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#montgomery_mul().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_wide_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/u64/serial/backend/Scalar52#from_bytes_wide().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_small_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shr_zero_is_id().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_byte_extraction_commutes_with_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb2_byte_contribution_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/lemma_div_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_commutative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_byte_from_limb_shift_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/bytes_match_limbs_packing_52().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/u64/serial/backend/lemma_6_bytes_reconstruct().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_mod_bound().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/lemma_limb2_contribution_correctness_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_from_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from4().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_from_le_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/from_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u32_from_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards/EdwardsPoint#mul_base_clamped().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/clamp_integer().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_assign().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_or().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_sqrt_ratio().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#pow_p58().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/negate_field().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/choice_is_true().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#is_negative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/field_element_as_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 subtle_assumes/u64/serial/backend/conditional_negate_field().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_sqrt_ratio_times_i().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#ConstantTimeEq#ct_eq().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar/clamp_integer().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/is_clamped_integer().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb4().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb4().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb4().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_verus/u64/serial/backend/u8_lt_pow2_8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb4().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb_X().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb4().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_limb4().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_basic_div().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_square_mod_p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/u64/serial/backend/limb3_byte_contribution_52().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_loop1_invariant().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/limbs_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_loop1_invariant().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/seq_u64_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_sub_loop1_invariant().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_spec_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_spec_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_spec_fits_u64().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_plus_fits_u64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_setup().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_setup().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_setup().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_setup().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_setup().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_setup().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/u64/serial/backend/lemma_carry_propagation_setup().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_strict_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_strictly_increases().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec_is_bounded().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/has_inv_mod_p().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/is_inv_witness().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/p().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo alloc https://github.com/rust-lang/rust/library/alloc vec/Vec#len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#as_extended().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#collect().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/CompletedPoint#as_projective().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 window/NafLookupTable5#From#from().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#map().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#Identity#identity().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 curve_models/serial/backend/ProjectivePoint#double().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus#VartimePrecomputedMultiscalarMul#optional_mixed_multiscalar_mul().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core iterator/traits/iter/Iterator#rev().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#sum_of_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_congruent_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#sum_of_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/scalar_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#sum_of_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/sum_of_scalars().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#sum_of_slice().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/len().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_helpers/Scalar#sum_of_slice().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/group_order().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#as_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#sqrt_ratio_i().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/FieldElement51#invert().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#ConditionallySelectable#conditional_select().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "target": "rust-analyzer cargo subtle 2.6.1 ConditionallyNegatable#conditional_negate().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery/elligator_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#square().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_carry_and_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_pos().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_carry_and_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_strict_inequality_converse().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_carry_and_sum_bounds().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_verus/u64/serial/backend/shift_is_pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_add_carry_and_sum_bounds().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/reconstruct_radix_2w().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/reconstruct_radix_2w().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 seq/Seq#skip().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_inequality().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_distributive_add().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec_lemma().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/load8_at_plus_version_rec_is_bounded().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/pow2().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma2_to64_rest().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/u64/serial/backend/plus_version_is_spec().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field_core/field_lemmas/u64/serial/backend/load8_at_spec().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_from_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/bytes_seq_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_from_le_bytes().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/seq_from8().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 core_assumes/u64_from_le_bytes().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core num/from_le_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mul_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/nine_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mul_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_five_limbs_equals_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mul_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mul_internal_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 mul/arithmetic/lemma_mul_is_associative().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mul_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/five_limbs_to_nat_aux().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mul_internal_correct().",
      "target": "rust-analyzer cargo vstd 0.0.0-2025-08-12-1837 power2/arithmetic/lemma_pow2_adds().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mul_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_nine_limbs_equals_slice128_to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/u64/serial/backend/lemma_mul_internal_correct().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/u64/serial/backend/to_nat().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 field/u64/serial/backend/FieldElement51#from_bytes().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_encode().",
      "target": "rust-analyzer cargo curve25519-dalek 4.1.3 ristretto/RistrettoPoint#elligator_ristretto_flavor().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_encode().",
      "target": "rust-analyzer cargo generic-array 0.14.9 GenericArray#as_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_encode().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core array/Default#default().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_encode().",
      "target": "rust-analyzer cargo core https://github.com/rust-lang/rust/library/core slice/copy_from_slice().",
      "type": "calls"
    },
    {
      "source": "rust-analyzer cargo curve25519-dalek 4.1.3 lizard_ristretto/lizard/RistrettoPoint#lizard_encode().",
      "target": "rust-analyzer cargo digest 0.10.7 digest/Digest#digest().",
      "type": "calls"
    }
  ],
  "metadata": {
    "total_nodes": 787,
    "total_edges": 2233,
    "project_root": "file:///home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek",
    "generated_at": "2025-11-05T10:59:48.058355787+00:00"
  }
}