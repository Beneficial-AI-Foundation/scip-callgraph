#!/usr/bin/env python3
"""
Find curve25519-dalek functions that are called by libsignal.

This script analyzes the SCIP-based call graph (graph.json) to identify which
curve25519-dalek cryptographic functions are directly called by libsignal code.
It also correlates these functions with their Verus specifications from specs.json.

HOW IT WORKS:
1. Loads graph.json which contains nodes (functions) and edges (call relationships)
   generated by rust-analyzer's SCIP indexer from the combined libsignal + dalek workspace.

2. For each curve25519-dalek node, checks if it has "dependents" (callers) that are
   marked as is_libsignal=True. This identifies dalek functions called by libsignal.

3. Handles trait method resolution: when rust-analyzer records a call to a trait
   method (e.g., traits.rs::identity), the script maps it to the concrete
   implementation (e.g., ristretto.rs::identity) when available.

4. Loads specs.json (from verus-analyzer) to find Verus specifications (requires/
   ensures clauses) for each function. Uses SCIP ID conversion and fuzzy matching
   by (function_name, file_path) to correlate rust-analyzer IDs with verus-analyzer IDs.

5. Generates output in various formats (text, JSON, CSV, Markdown) with GitHub links
   to both the dalek-lite source and the libsignal caller locations.

INPUT FILES:
- web/public/graph.json: SCIP call graph from rust-analyzer
- specs.json: Verus specifications from verus-analyzer
- atoms.json: Additional atom data (optional, for legacy compatibility)

OUTPUT:
- Markdown report with functions grouped by specs availability
- Tables linking dalek functions to their libsignal callers
- Expandable sections showing Verus pre/postconditions

Usage:
    python scripts/find_dalek_called_by_signal.py          # text output
    python scripts/find_dalek_called_by_signal.py json     # JSON output
    python scripts/find_dalek_called_by_signal.py csv      # CSV output
    python scripts/find_dalek_called_by_signal.py md       # Markdown file
    python scripts/find_dalek_called_by_signal.py md out.md  # Custom filename
    python scripts/find_dalek_called_by_signal.py focus    # Focus set JSON for web UI
    python scripts/find_dalek_called_by_signal.py focus out.json  # Custom filename
"""

import json
import csv
import sys
from collections import defaultdict
from datetime import datetime
from pathlib import Path

# Resolve paths relative to project root
SCRIPT_DIR = Path(__file__).parent
PROJECT_ROOT = SCRIPT_DIR.parent
DATA_DIR = PROJECT_ROOT / 'data' / 'for_find_dalek_called_by_signal_script'
DEFAULT_GRAPH_PATH = DATA_DIR / 'graph.json'
DEFAULT_ATOMS_PATH = DATA_DIR / 'atoms.json'
DEFAULT_SPECS_PATH = DATA_DIR / 'specs.json'

# GitHub repo base URLs
LIBSIGNAL_GITHUB_BASE = "https://github.com/signalapp/libsignal/blob/main"
DALEK_LITE_GITHUB_BASE = "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main"

def make_libsignal_link(relative_path: str, line: int) -> str:
    """Create a GitHub link to a specific file and line in libsignal."""
    return f"{LIBSIGNAL_GITHUB_BASE}/{relative_path}#L{line}"

def make_dalek_lite_link(relative_path: str, line: int) -> str:
    """Create a GitHub link to a specific file and line in dalek-lite."""
    return f"{DALEK_LITE_GITHUB_BASE}/{relative_path}#L{line}"

# Keep old name for backward compatibility
def make_github_link(relative_path: str, line: int) -> str:
    """Create a GitHub link to a specific file and line."""
    return make_libsignal_link(relative_path, line)


import re

def rust_analyzer_to_verus_analyzer(ra_id: str) -> list:
    """
    Convert rust-analyzer SCIP ID format to possible verus-analyzer formats.
    
    rust-analyzer (graph.json):  #impl<ReturnType>#[SelfType]method()
    verus-analyzer (atoms.json): #SelfType<ReturnType>#method()
    
    Returns a list of possible matches since the conversion isn't always 1:1.
    """
    results = [ra_id]  # Original is always a candidate
    
    # Pattern 1: #impl<ReturnType>#[SelfType]method()
    # -> #SelfType<ReturnType>#method()
    pattern1 = r'#impl<([^>]+)>#\[([^\]]+)\](\w+\(\))'
    def replacer1(match):
        return_type = match.group(1)
        self_type = match.group(2)
        method = match.group(3)
        return f'#{self_type}<{return_type}>#{method}'
    converted1 = re.sub(pattern1, replacer1, ra_id)
    if converted1 != ra_id:
        results.append(converted1)
    
    # Pattern 2: impl<Type>#[SelfType]method() (no leading &)
    # -> SelfType<Type>#method()
    pattern2 = r'impl<([^>]+)>#\[([^\]]+)\](\w+\(\))'
    def replacer2(match):
        type_param = match.group(1)
        self_type = match.group(2)
        method = match.group(3)
        return f'{self_type}<{type_param}>#{method}'
    converted2 = re.sub(pattern2, replacer2, ra_id)
    if converted2 != ra_id and converted2 not in results:
        results.append(converted2)
    
    return results


def load_atoms_and_specs(atoms_path=None, specs_path=None):
    """Load atoms.json and specs.json files."""
    if atoms_path is None:
        atoms_path = DEFAULT_ATOMS_PATH
    if specs_path is None:
        specs_path = DEFAULT_SPECS_PATH
    
    atoms = {}
    specs = {}
    
    if Path(atoms_path).exists():
        with open(atoms_path, 'r') as f:
            atoms = json.load(f)
    
    if Path(specs_path).exists():
        with open(specs_path, 'r') as f:
            specs = json.load(f)
    
    return atoms, specs


def build_atoms_index(atoms):
    """Build an index of atoms by (display_name, code_path) for fuzzy matching."""
    atoms_by_name_file = {}
    for atom_id, atom_data in atoms.items():
        name = atom_data.get('display-name')
        file = atom_data.get('code-path', '')
        key = (name, file)
        if key not in atoms_by_name_file:
            atoms_by_name_file[key] = []
        atoms_by_name_file[key].append(atom_id)
    return atoms_by_name_file


def find_atoms_id(ra_id: str, display_name: str, relative_path: str, 
                  atoms: dict, atoms_by_name_file: dict) -> str:
    """
    Find the matching atoms.json ID for a rust-analyzer ID.
    Uses ID conversion first, then falls back to name+file matching.
    """
    atoms_set = set(atoms.keys())
    
    # Try direct ID conversion
    candidates = rust_analyzer_to_verus_analyzer(ra_id)
    for candidate in candidates:
        if candidate in atoms_set:
            return candidate
    
    # Fallback to fuzzy match by name+file
    file = relative_path
    if not file.startswith('curve25519-dalek/'):
        file = 'curve25519-dalek/' + file if file else ''
    
    key = (display_name, file)
    if key in atoms_by_name_file:
        # Return the first match
        return atoms_by_name_file[key][0]
    
    return None


def build_specs_index(specs: dict) -> dict:
    """Build an index of specs by (name, file) for fuzzy matching."""
    specs_by_name_file = {}
    for spec_id, spec_data in specs.items():
        name = spec_data.get('name')
        file = spec_data.get('file', '')
        key = (name, file)
        if key not in specs_by_name_file:
            specs_by_name_file[key] = []
        specs_by_name_file[key].append((spec_id, spec_data))
    return specs_by_name_file


def find_spec_for_function(ra_id: str, display_name: str, relative_path: str, 
                           specs: dict, specs_by_name_file: dict) -> dict:
    """
    Find the spec for a function directly from specs.json.
    
    Returns a dict with spec_id, file, start_line, requires_text, ensures_text
    or None if not found.
    """
    specs_set = set(specs.keys())
    
    # Normalize path
    file = relative_path
    if not file.startswith('curve25519-dalek/'):
        file = 'curve25519-dalek/' + file if file else ''
    
    # Try direct ID conversion and lookup in specs
    candidates = rust_analyzer_to_verus_analyzer(ra_id)
    for candidate in candidates:
        if candidate in specs_set:
            spec_data = specs[candidate]
            if spec_data.get('requires_text') or spec_data.get('ensures_text'):
                return {
                    'spec_id': candidate,
                    'file': spec_data.get('file', ''),
                    'start_line': spec_data.get('start_line'),
                    'requires_text': spec_data.get('requires_text'),
                    'ensures_text': spec_data.get('ensures_text')
                }
    
    # Fallback to fuzzy match by name+file
    key = (display_name, file)
    if key in specs_by_name_file:
        for spec_id, spec_data in specs_by_name_file[key]:
            if spec_data.get('requires_text') or spec_data.get('ensures_text'):
                return {
                    'spec_id': spec_id,
                    'file': spec_data.get('file', ''),
                    'start_line': spec_data.get('start_line'),
                    'requires_text': spec_data.get('requires_text'),
                    'ensures_text': spec_data.get('ensures_text')
                }
    
    return None


def get_specs_for_function(atoms_id: str, atoms: dict, specs: dict) -> dict:
    """
    DEPRECATED: Get preconditions and postconditions for a function from atoms.json.
    Use find_spec_for_function() instead for direct specs.json lookup.
    """
    result = {'preconditions': [], 'postconditions': []}
    
    if not atoms_id or atoms_id not in atoms:
        return result
    
    atom_data = atoms[atoms_id]
    code_path = atom_data.get('code-path', '')
    deps_with_loc = atom_data.get('dependencies-with-locations', [])
    
    for dep in deps_with_loc:
        location = dep.get('location')
        spec_id = dep.get('scip-name')
        line = dep.get('line')
        
        if location not in ('precondition', 'postcondition'):
            continue
        
        spec_data = specs.get(spec_id, {})
        
        if location == 'precondition':
            text = spec_data.get('requires_text', '')
            if text:
                result['preconditions'].append({
                    'spec_id': spec_id,
                    'line': line,
                    'file': code_path,
                    'text': text
                })
        elif location == 'postcondition':
            text = spec_data.get('ensures_text', '')
            if text:
                result['postconditions'].append({
                    'spec_id': spec_id,
                    'line': line,
                    'file': code_path,
                    'text': text
                })
    
    return result


def get_dalek_functions_called_by_signal(graph_path=None):
    """Find all curve25519-dalek functions called by libsignal."""
    if graph_path is None:
        graph_path = DEFAULT_GRAPH_PATH
    
    with open(graph_path, 'r') as f:
        data = json.load(f)
    
    nodes = data['nodes']
    node_by_id = {n['id']: n for n in nodes}
    
    result_map = {}
    
    # First pass: build a map of function names to their non-trait implementations
    # This helps us find concrete implementations when SCIP records a trait method call
    impl_by_func_name = {}
    for node in nodes:
        node_id = node['id']
        if 'curve25519-dalek' not in node_id:
            continue
        relative_path = node.get('relative_path', '')
        display_name = node.get('display_name', '')
        # Only record non-trait implementations from src/ (not benches/, tests/, etc.)
        if ('traits.rs' not in relative_path and 
            'benches/' not in relative_path and
            '/test/' not in node_id and
            display_name):
            key = display_name
            if key not in impl_by_func_name:
                impl_by_func_name[key] = []
            impl_by_func_name[key].append({
                'id': node_id,
                'path': relative_path,
                'node': node
            })
    
    # Serialization functions to exclude (serde traits, not relevant for crypto analysis)
    EXCLUDED_FUNCTIONS = {'serialize', 'deserialize'}
    
    for node in nodes:
        node_id = node['id']
        
        if 'curve25519-dalek' not in node_id:
            continue
        
        relative_path = node.get('relative_path', '')
        display_name = node.get('display_name', '')
        
        # Skip serialization functions
        if display_name in EXCLUDED_FUNCTIONS:
            continue
        
        # For trait methods, try to find a concrete implementation
        is_trait_method = 'traits.rs' in relative_path
        actual_path = relative_path
        
        if is_trait_method and display_name in impl_by_func_name:
            # Use the first concrete implementation we find
            # Prefer ristretto.rs or edwards.rs as they're the main types
            impls = impl_by_func_name[display_name]
            preferred = None
            for impl in impls:
                if 'ristretto.rs' in impl['path'] or 'edwards.rs' in impl['path']:
                    preferred = impl
                    break
            if preferred:
                actual_path = preferred['path']
            elif impls:
                actual_path = impls[0]['path']
        
        dependents = node.get('dependents', [])
        
        for dep_id in dependents:
            if 'curve25519-dalek' not in dep_id:
                dep_node = node_by_id.get(dep_id, {})
                if dep_node.get('is_libsignal', False):
                    caller_path = dep_node.get('relative_path', '')
                    caller_line = dep_node.get('start_line', 0)
                    caller_name = dep_node.get('display_name', '')
                    
                    result_map[node_id] = {
                        'dalek_function': display_name,
                        'dalek_path': actual_path,  # Use mapped implementation path for trait methods
                        'is_trait_method': is_trait_method,
                        'original_path': relative_path,  # Keep original for reference
                        'caller_id': dep_id,
                        'caller_name': caller_name,
                        'caller_path': caller_path,
                        'caller_line': caller_line,
                        'github_link': make_github_link(caller_path, caller_line)
                    }
                    break
    
    return result_map

def output_markdown(result_map, output_file=None, include_specs=True):
    """Generate a nicely formatted markdown file."""
    if output_file is None:
        output_file = PROJECT_ROOT / 'curve25519_dalek_functions_called_by_libsignal.md'
    
    # Load specs if needed
    specs = {}
    specs_by_name_file = {}
    functions_with_specs = []
    functions_without_specs = []
    
    if include_specs:
        _, specs = load_atoms_and_specs()
        if specs:
            specs_by_name_file = build_specs_index(specs)
            
            # Find specs for each function
            with open(DEFAULT_GRAPH_PATH, 'r') as f:
                graph_data = json.load(f)
            node_by_id = {n['id']: n for n in graph_data['nodes']}
            
            # Track seen (name, file) to avoid duplicates
            seen_with_specs = set()
            seen_without_specs = set()
            
            for ra_id, info in result_map.items():
                node = node_by_id.get(ra_id, {})
                display_name = node.get('display_name', info['dalek_function'])
                # Use the mapped path (which maps trait methods to their implementations)
                relative_path = info['dalek_path']
                
                # Normalize path
                file = relative_path
                if not file.startswith('curve25519-dalek/'):
                    file = 'curve25519-dalek/' + file if file else ''
                
                # Skip duplicates (same function name + file)
                key = (display_name, file)
                
                spec_info = find_spec_for_function(ra_id, display_name, relative_path, specs, specs_by_name_file)
                if spec_info:
                    if key not in seen_with_specs:
                        seen_with_specs.add(key)
                        functions_with_specs.append({
                            'ra_id': ra_id,
                            'spec_id': spec_info['spec_id'],
                            'display_name': display_name,
                            'file': file,
                            'start_line': spec_info['start_line'],
                            'requires_text': spec_info['requires_text'],
                            'ensures_text': spec_info['ensures_text']
                        })
                else:
                    # Function without spec text - still try to find line number from specs.json
                    if key not in seen_without_specs and key not in seen_with_specs:
                        seen_without_specs.add(key)
                        
                        # Try to get line number from specs.json (even without spec text)
                        start_line = None
                        
                        # First try to match by SCIP ID conversion (most accurate)
                        candidates = rust_analyzer_to_verus_analyzer(ra_id)
                        for candidate in candidates:
                            if candidate in specs:
                                start_line = specs[candidate].get('start_line')
                                if start_line:
                                    break
                        
                        # If not found by ID, look up by (name, file) in specs
                        if not start_line:
                            lookup_key = (display_name, file)
                            if lookup_key in specs_by_name_file:
                                for spec_id, spec_data in specs_by_name_file[lookup_key]:
                                    start_line = spec_data.get('start_line')
                                    if start_line:
                                        break
                        
                        # If still not found, try all specs entries for this name
                        if not start_line:
                            for spec_id, spec_data in specs.items():
                                if spec_data.get('name') == display_name:
                                    spec_file = spec_data.get('file', '')
                                    # Match if file paths end the same way
                                    if file.endswith(spec_file) or spec_file.endswith(file.replace('curve25519-dalek/', '')):
                                        start_line = spec_data.get('start_line')
                                        if start_line:
                                            break
                        
                        # Fall back to node's start_line or default to 1
                        if not start_line:
                            start_line = node.get('start_line', 1)
                        
                        functions_without_specs.append({
                            'ra_id': ra_id,
                            'display_name': display_name,
                            'file': file,
                            'start_line': start_line
                        })
    
    # Group by dalek source file
    by_dalek_file = defaultdict(list)
    for dalek_id, info in result_map.items():
        by_dalek_file[info['dalek_path']].append((dalek_id, info))
    
    # Group by signal caller file  
    by_signal_file = defaultdict(list)
    for dalek_id, info in result_map.items():
        by_signal_file[info['caller_path']].append((dalek_id, info))
    
    lines = []
    lines.append("# curve25519-dalek Functions Called by libsignal")
    lines.append("")
    lines.append(f"> Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    lines.append("")
    lines.append(f"**Total:** {len(result_map)} curve25519-dalek functions are called by libsignal")
    lines.append("")
    lines.append("> **Note:** This analysis excludes serialization functions (`serialize`, `deserialize`) and benchmark code, as they are not relevant for cryptographic verification.")
    lines.append("")

    # Summary table
    lines.append("## Summary")
    lines.append("")
    lines.append("| curve25519-dalek Source File | # Functions Used |")
    lines.append("|------------------------------|------------------|")
    for dalek_file in sorted(by_dalek_file.keys()):
        count = len(by_dalek_file[dalek_file])
        short_name = dalek_file.replace('curve25519-dalek/', '')
        lines.append(f"| `{short_name}` | {count} |")
    lines.append("")
    
    # Quick reference table
    lines.append("## Quick Reference")
    lines.append("")
    lines.append("| Function | curve25519-dalek Location | Example libsignal Caller |")
    lines.append("|----------|---------------------------|--------------------------|")
    for dalek_id, info in sorted(result_map.items(), key=lambda x: x[1]['dalek_function']):
        func = info['dalek_function']
        dalek_short = info['dalek_path'].replace('curve25519-dalek/', '')
        caller_link = f"[`{info['caller_name']}`]({info['github_link']})"
        lines.append(f"| `{func}` | `{dalek_short}` | {caller_link} |")
    lines.append("")
    
    # Functions with Specs subsection
    if functions_with_specs:
        lines.append("### Functions with Verus Specifications")
        lines.append("")
        lines.append(f"**{len(functions_with_specs)}** functions have Verus specifications (requires/ensures clauses):")
        lines.append("")
        
        for func_spec in sorted(functions_with_specs, key=lambda x: (x['file'], x['display_name'])):
            name = func_spec['display_name']
            file_short = func_spec['file'].replace('curve25519-dalek/', '')
            start_line = func_spec.get('start_line', 1)
            link = make_dalek_lite_link(func_spec['file'], start_line)
            
            # Use details/summary for expandable specs
            lines.append(f"<details>")
            lines.append(f"<summary><code>{name}</code> (<a href=\"{link}\">{file_short}:{start_line}</a>)</summary>")
            lines.append("")
            
            # Format precondition (requires)
            requires = func_spec.get('requires_text')
            if requires:
                lines.append("```rust")
                lines.append(requires.strip())
                lines.append("```")
                lines.append("")
            
            # Format postcondition (ensures)
            ensures = func_spec.get('ensures_text')
            if ensures:
                lines.append("```rust")
                lines.append(ensures.strip())
                lines.append("```")
                lines.append("")
            
            lines.append("</details>")
            lines.append("")
    
    # Functions without Specs subsection
    if functions_without_specs:
        lines.append("### Functions without Verus Specifications")
        lines.append("")
        lines.append(f"**{len(functions_without_specs)}** functions do not yet have Verus specifications:")
        lines.append("")
        lines.append("| Function | Source Location |")
        lines.append("|----------|-----------------|")
        
        for func in sorted(functions_without_specs, key=lambda x: (x['file'], x['display_name'])):
            name = func['display_name']
            file_short = func['file'].replace('curve25519-dalek/', '')
            start_line = func.get('start_line', 1)
            link = make_dalek_lite_link(func['file'], start_line)
            lines.append(f"| `{name}` | [{file_short}:{start_line}]({link}) |")
        
        lines.append("")
    
    # Detailed sections by dalek file
    lines.append("## Details by curve25519-dalek Source File")
    lines.append("")
    
    for dalek_file in sorted(by_dalek_file.keys()):
        short_name = dalek_file.replace('curve25519-dalek/', '')
        lines.append(f"### `{short_name}`")
        lines.append("")
        
        items = sorted(by_dalek_file[dalek_file], key=lambda x: x[1]['dalek_function'])
        for dalek_id, info in items:
            lines.append(f"#### `{info['dalek_function']}`")
            lines.append("")
            lines.append(f"- **Called by:** [`{info['caller_name']}`]({info['github_link']})")
            lines.append(f"- **Caller location:** `{info['caller_path']}:{info['caller_line']}`")
            lines.append(f"- **Full SCIP ID:** `{dalek_id}`")
            lines.append("")
    
    # Section by signal caller area
    lines.append("## Details by libsignal Caller Area")
    lines.append("")
    
    # Group callers by top-level directory
    by_signal_area = defaultdict(list)
    for dalek_id, info in result_map.items():
        # Extract area like "rust/zkgroup", "rust/core", etc.
        parts = info['caller_path'].split('/')
        if len(parts) >= 2:
            area = '/'.join(parts[:2])
        else:
            area = info['caller_path']
        by_signal_area[area].append((dalek_id, info))
    
    for area in sorted(by_signal_area.keys()):
        lines.append(f"### `{area}`")
        lines.append("")
        items = sorted(by_signal_area[area], key=lambda x: x[1]['dalek_function'])
        
        lines.append("| curve25519-dalek Function | Caller | Link |")
        lines.append("|---------------------------|--------|------|")
        for dalek_id, info in items:
            lines.append(f"| `{info['dalek_function']}` | `{info['caller_name']}` | [View]({info['github_link']}) |")
        lines.append("")
    
    content = '\n'.join(lines)
    
    with open(output_file, 'w') as f:
        f.write(content)
    
    print(f"Markdown file written to: {output_file}")
    return output_file

def output_focus_json(result_map, output_file=None):
    """Generate a focus set JSON file for the web UI.
    
    This file can be loaded by the web UI via the ?focus= URL parameter
    to show only these entry-point functions in the graph visualization.
    
    Includes both SCIP node IDs (for exact matching) and display_name +
    relative_path pairs (for fuzzy matching across different analyzers,
    since rust-analyzer and verus-analyzer produce different SCIP IDs
    for the same function).
    """
    if output_file is None:
        output_file = PROJECT_ROOT / 'web' / 'public' / 'focus_dalek_entrypoints.json'
    
    # Build focus_functions list with name+path for analyzer-agnostic matching
    # Use a set to deduplicate (same function may appear via multiple SCIP IDs)
    seen = set()
    focus_functions = []
    for ra_id, info in sorted(result_map.items(), key=lambda x: x[1]['dalek_function']):
        name = info['dalek_function']
        path = info['dalek_path']
        key = (name, path)
        if key not in seen:
            seen.add(key)
            focus_functions.append({
                'display_name': name,
                'relative_path': path,
            })
    
    focus_data = {
        'focus_nodes': sorted(result_map.keys()),
        'focus_functions': focus_functions,
        'metadata': {
            'description': 'curve25519-dalek functions called by libsignal',
            'generated_at': datetime.now().isoformat(),
            'total': len(result_map),
            'unique_functions': len(focus_functions),
        }
    }
    
    with open(output_file, 'w') as f:
        json.dump(focus_data, f, indent=2)
    
    print(f"Focus set JSON written to: {output_file}")
    print(f"  Contains {len(result_map)} node IDs, {len(focus_functions)} unique functions")
    print(f"  Load in UI with: ?focus=focus_dalek_entrypoints.json")
    return output_file


def main():
    result_map = get_dalek_functions_called_by_signal()
    
    output_format = sys.argv[1] if len(sys.argv) > 1 else 'text'
    output_file = sys.argv[2] if len(sys.argv) > 2 else None
    
    if output_format == 'json':
        print(json.dumps(result_map, indent=2))
    elif output_format == 'csv':
        writer = csv.writer(sys.stdout)
        writer.writerow(['dalek_function_id', 'dalek_function', 'dalek_path', 
                        'caller_id', 'caller_name', 'caller_path', 'caller_line', 'github_link'])
        for dalek_id, info in sorted(result_map.items(), key=lambda x: x[1]['dalek_function']):
            writer.writerow([
                dalek_id,
                info['dalek_function'],
                info['dalek_path'],
                info['caller_id'],
                info['caller_name'],
                info['caller_path'],
                info['caller_line'],
                info['github_link']
            ])
    elif output_format == 'md':
        output_markdown(result_map, output_file)
    elif output_format == 'focus':
        output_focus_json(result_map, output_file)
    else:  # text (default)
        print(f"Found {len(result_map)} curve25519-dalek functions called by libsignal:\n")
        
        for dalek_id, info in sorted(result_map.items(), key=lambda x: x[1]['dalek_function']):
            print(f"curve25519-dalek function: {info['dalek_function']}")
            print(f"  Dalek path: {info['dalek_path']}")
            print(f"  Dalek ID: {dalek_id}")
            print(f"  Called by: {info['caller_name']}")
            print(f"  Caller path: {info['caller_path']}:{info['caller_line']}")
            print(f"  GitHub: {info['github_link']}")
            print()

if __name__ == '__main__':
    main()

