# Reusable workflow for generating enriched call graphs from Rust/Verus projects
# 
# Usage in your project (minimal - github_url is auto-detected):
#   jobs:
#     callgraph:
#       uses: Beneficial-AI-Foundation/scip-callgraph/.github/workflows/generate-callgraph.yml@main
#
# Specify a Verus version (recommended for reproducibility):
#   jobs:
#     callgraph:
#       uses: Beneficial-AI-Foundation/scip-callgraph/.github/workflows/generate-callgraph.yml@main
#       with:
#         verus_version: '0.2025.11.23.41c5885'
#
# For non-Verus projects, use rust-analyzer instead:
#   jobs:
#     callgraph:
#       uses: Beneficial-AI-Foundation/scip-callgraph/.github/workflows/generate-callgraph.yml@main
#       with:
#         use_rust_analyzer: true
#         skip_verification: true
#
# Override github_url if needed (e.g., for forks pointing to upstream):
#   jobs:
#     callgraph:
#       uses: Beneficial-AI-Foundation/scip-callgraph/.github/workflows/generate-callgraph.yml@main
#       with:
#         github_url: https://github.com/upstream-org/upstream-repo
#
name: Generate Call Graph

on:
  workflow_call:
    inputs:
      project_path:
        description: 'Path to the Verus project (relative to repo root)'
        required: false
        default: '.'
        type: string
      github_url:
        description: 'GitHub repository URL for source code links (auto-detected if not provided)'
        required: false
        default: ''
        type: string
      github_path_prefix:
        description: 'Path prefix for source files (e.g., "curve25519-dalek" if repo has subdirectory)'
        required: false
        default: ''
        type: string
      package:
        description: 'Cargo package name (for workspaces)'
        required: false
        default: ''
        type: string
      skip_verification:
        description: 'Skip Verus verification step'
        required: false
        default: false
        type: boolean
      skip_similar_lemmas:
        description: 'Skip similar lemmas enrichment'
        required: false
        default: false
        type: boolean
      deploy_mode:
        description: 'Deployment mode: "subpath" (for existing sites) or "standalone" (full site)'
        required: false
        default: 'standalone'
        type: string
      subpath:
        description: 'Subpath for deployment (only used when deploy_mode is "subpath")'
        required: false
        default: 'callgraph'
        type: string
      use_rust_analyzer:
        description: 'Use rust-analyzer instead of verus-analyzer for SCIP generation'
        required: false
        default: false
        type: boolean
      verus_version:
        description: 'Verus release version (e.g., "0.2025.11.23.41c5885"). If not provided, installs the latest release.'
        required: false
        default: ''
        type: string

jobs:
  build:
    name: Build Call Graph
    runs-on: ubuntu-latest
    
    outputs:
      artifact_name: callgraph-viewer
    
    steps:
      - name: Checkout calling repository
        uses: actions/checkout@v4
        with:
          path: project

      - name: Checkout scip-callgraph
        uses: actions/checkout@v4
        with:
          repository: Beneficial-AI-Foundation/scip-callgraph
          path: scip-callgraph
          submodules: recursive

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@1.91.0

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Python and uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Install verus-analyzer
        if: ${{ !inputs.use_rust_analyzer }}
        run: |
          # Using direct URL to avoid GitHub API rate limits
          wget -q "https://github.com/verus-lang/verus-analyzer/releases/latest/download/verus-analyzer-x86_64-unknown-linux-gnu.gz" -O verus-analyzer.gz
          gunzip verus-analyzer.gz
          chmod +x verus-analyzer
          sudo mv verus-analyzer /usr/local/bin/
          verus-analyzer --version

      - name: Install rust-analyzer
        if: ${{ inputs.use_rust_analyzer }}
        run: |
          # Download latest standalone rust-analyzer for better SCIP symbol generation
          # (rustup version may be older and miss operator overload resolution)
          # Using direct URL to avoid GitHub API rate limits
          wget -q "https://github.com/rust-lang/rust-analyzer/releases/latest/download/rust-analyzer-x86_64-unknown-linux-gnu.gz" -O rust-analyzer.gz
          gunzip rust-analyzer.gz
          chmod +x rust-analyzer
          sudo mv rust-analyzer /usr/local/bin/
          # Use full path to avoid rustup proxy interception
          /usr/local/bin/rust-analyzer --version

      - name: Install Verus (for verification)
        if: ${{ !inputs.skip_verification }}
        env:
          VERUS_VERSION: ${{ inputs.verus_version }}
        run: |
          if [ -n "$VERUS_VERSION" ]; then
            echo "Installing specified Verus version: $VERUS_VERSION"
            RELEASE_TAG="release/$VERUS_VERSION"
          else
            echo "No Verus version specified, fetching latest release..."
            RELEASE_TAG=$(curl -s https://api.github.com/repos/verus-lang/verus/releases/latest | jq -r '.tag_name')
            # Extract version from tag (e.g., "release/0.2025.11.23.41c5885" -> "0.2025.11.23.41c5885")
            VERUS_VERSION="${RELEASE_TAG#release/}"
            echo "Latest Verus version: $VERUS_VERSION"
          fi
          
          # URL-encode the release tag (replace / with %2F)
          ENCODED_TAG=$(echo "$RELEASE_TAG" | sed 's|/|%2F|g')
          DOWNLOAD_URL="https://github.com/verus-lang/verus/releases/download/${ENCODED_TAG}/verus-${VERUS_VERSION}-x86-linux.zip"
          
          echo "Downloading from: $DOWNLOAD_URL"
          wget "$DOWNLOAD_URL" -O verus.zip
          unzip verus.zip
          mv verus-x86-linux ~/.cargo/bin
          cd ~/.cargo/bin
          ln -s verus-x86-linux/cargo-verus
          echo "Verus $VERUS_VERSION installed successfully"

      - name: Install scip CLI
        run: |
          # Using direct URL to avoid GitHub API rate limits
          wget -q "https://github.com/sourcegraph/scip/releases/latest/download/scip-linux-amd64.tar.gz" -O scip-linux.tar.gz
          tar -xzf scip-linux.tar.gz
          chmod +x scip
          sudo mv scip /usr/local/bin/
          scip --version

      - name: Build scip-callgraph pipeline
        working-directory: scip-callgraph
        run: cargo build --release --bin pipeline

      - name: Setup Python environment for similar lemmas
        if: ${{ !inputs.skip_similar_lemmas }}
        working-directory: scip-callgraph
        run: |
          uv sync --extra enrich
          cd external/verus_lemma_finder && uv tool run maturin develop --release && cd ../..

      # Step 1: Generate SCIP index
      - name: Generate SCIP index
        working-directory: project/${{ inputs.project_path }}
        env:
          USE_RUST_ANALYZER: ${{ inputs.use_rust_analyzer }}
        run: |
          if [ "$USE_RUST_ANALYZER" = "true" ]; then
            # Use full path to avoid rustup proxy interception
            ANALYZER="/usr/local/bin/rust-analyzer"
          else
            ANALYZER="/usr/local/bin/verus-analyzer"
          fi
          echo "Generating SCIP index using $ANALYZER..."
          $ANALYZER scip .
          echo "Converting SCIP to JSON..."
          scip print --json index.scip > index.scip.json
          echo "âœ“ SCIP JSON generated"
          ls -la index.scip*

      # Step 2: Run the pipeline
      - name: Run call graph pipeline
        env:
          PROJECT_PATH: ${{ github.workspace }}/project/${{ inputs.project_path }}
          SCIP_JSON: ${{ github.workspace }}/project/${{ inputs.project_path }}/index.scip.json
          OUTPUT_PATH: ${{ github.workspace }}/scip-callgraph/web/public/graph.json
          # Auto-detect github_url from context if not explicitly provided
          GITHUB_URL: ${{ inputs.github_url || format('{0}/{1}', github.server_url, github.repository) }}
          SKIP_VERIFICATION: ${{ inputs.skip_verification }}
          SKIP_SIMILAR_LEMMAS: ${{ inputs.skip_similar_lemmas }}
          PACKAGE: ${{ inputs.package }}
          USE_RUST_ANALYZER: ${{ inputs.use_rust_analyzer }}
        working-directory: scip-callgraph
        run: |
          ARGS="--use-cached-scip"
          
          # github_url is always set (either from input or auto-detected)
          ARGS="$ARGS --github-url $GITHUB_URL"
          echo "Using GitHub URL: $GITHUB_URL"
          
          if [ "$SKIP_VERIFICATION" = "true" ]; then
            ARGS="$ARGS --skip-verification"
          fi
          
          if [ "$SKIP_SIMILAR_LEMMAS" = "true" ]; then
            ARGS="$ARGS --skip-similar-lemmas"
          fi
          
          if [ -n "$PACKAGE" ]; then
            ARGS="$ARGS --package $PACKAGE"
          fi
          
          if [ "$USE_RUST_ANALYZER" = "true" ]; then
            ARGS="$ARGS --use-rust-analyzer"
          fi
          
          echo "Running pipeline with: $ARGS"
          ./target/release/pipeline "$PROJECT_PATH" $ARGS

      # Step 3: Build web viewer
      - name: Build web viewer
        working-directory: scip-callgraph/web
        env:
          # Auto-detect github_url if not explicitly provided (same as pipeline step)
          VITE_GITHUB_URL: ${{ inputs.github_url || format('{0}/{1}', github.server_url, github.repository) }}
          VITE_GITHUB_PATH_PREFIX: ${{ inputs.github_path_prefix }}
        run: |
          npm ci
          
          # Set base path for deployment
          if [ "${{ inputs.deploy_mode }}" = "subpath" ]; then
            echo "Building for subpath: /${{ inputs.subpath }}/"
            npx vite build --base=/${{ inputs.subpath }}/
          else
            # Extract repo name from auto-detected github_url for standalone deployment
            # e.g., https://github.com/org/repo -> /repo/
            REPO_NAME=$(echo "$VITE_GITHUB_URL" | sed 's|.*/||')
            echo "Building for standalone deployment: /${REPO_NAME}/"
            npx vite build --base=/${REPO_NAME}/
          fi

      # Step 4: Prepare artifact
      - name: Prepare deployment artifact
        run: |
          mkdir -p artifact
          cp -r scip-callgraph/web/dist/* artifact/
          # Ensure graph.json is in the artifact
          cp scip-callgraph/web/public/graph.json artifact/
          
          echo "Artifact contents:"
          ls -la artifact/

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: callgraph-viewer
          path: artifact
          retention-days: 7

      # For standalone mode, also upload as pages artifact
      # NOTE: Only upload when NOT in subpath mode to avoid duplicate artifacts
      # when the calling workflow handles its own Pages deployment
      - name: Upload Pages artifact (standalone mode)
        if: inputs.deploy_mode != 'subpath'
        uses: actions/upload-pages-artifact@v3
        with:
          path: artifact

  # Deploy job for standalone mode (full GitHub Pages site)
  deploy-standalone:
    name: Deploy (Standalone)
    if: inputs.deploy_mode != 'subpath'
    needs: build
    runs-on: ubuntu-latest
    
    permissions:
      pages: write
      id-token: write
    
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

